{"prompt": "class ObjectBuffer\n{\n    // // // Config constants\n\n    /**\n     * Also: let's expand by doubling up until 64k chunks (which is 16k entries for\n     * 32-bit machines)\n     */\n    private final static int SMALL_CHUNK = (1 << 14);\n\n    /**\n     * Let's limit maximum size of chunks we use; helps avoid excessive allocation\n     * overhead for huge data sets.\n     * For now, let's limit to quarter million entries, 1 meg chunks for 32-bit\n     * machines.\n     */\n    private final static int MAX_CHUNK = (1 << 18);\n\n    // // // Data storage\n\n    private LinkedNode<Object[]> _head;\n\n    private LinkedNode<Object[]> _tail;\n\n    /**\n     * Number of total buffered entries in this buffer, counting all instances\n     * within linked list formed by following {@link #_head}.\n     */\n    private int _size;\n\n    // // // Simple reuse\n\n    /**\n     * Reusable Object array, stored here after buffer has been released having\n     * been used previously.\n     */\n    private Object[] _freeBuffer;\n\n    /*\n    /**********************************************************\n    /* Construction\n    /**********************************************************\n     */\n\n    public ObjectBuffer() { }\n\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    /**\n     * Method called to start buffering process. Will ensure that the buffer\n     * is empty, and then return an object array to start chunking content on\n     */\n    public Object[] resetAndStart()\n    {\n        _reset();\n        if (_freeBuffer == null) {\n            return (_freeBuffer = new Object[12]);\n        }\n        return _freeBuffer;\n    }\n\n    /**\n     * @since 2.9\n     */\n    public Object[] resetAndStart(Object[] base, int count)\n    {\n        _reset();\n        if ((_freeBuffer == null) || (_freeBuffer.length < count)) {\n            _freeBuffer = new Object[Math.max(12, count)];\n        }\n        System.arraycopy(base, 0, _freeBuffer, 0, count);\n        return _freeBuffer;\n    }\n\n    /**\n     * Method called to add a full Object array as a chunk buffered within\n     * this buffer, and to obtain a new array to fill. Caller is not to use\n     * the array it gives; but to use the returned array for continued\n     * buffering.\n     *\n     * @param fullChunk Completed chunk that the caller is requesting\n     *   to append to this buffer. It is generally chunk that was\n     *   returned by an earlier call to {@link #resetAndStart} or\n     *   {@link #appendCompletedChunk} (although this is not required or\n     *   enforced)\n     *\n     * @return New chunk buffer for caller to fill\n     */\n    public Object[] appendCompletedChunk(Object[] fullChunk)\n    {", "metadata": {"defects4j_task_id": "1f3076894b33e198d2809f8acf7b15eddd0edb31f21ade4bcc16c5478a7a94e3", "task_id": "FasterXML_jackson-databind/32", "ground_truth": "\n        LinkedNode<Object[]> next = new LinkedNode<Object[]>(fullChunk, null);\n        if (_head == null) { // first chunk\n            _head = _tail = next;\n        } else { // have something already\n            _tail.linkNext(next);\n            _tail = next;\n        }\n        int len = fullChunk.length;\n        _size += len;\n        // double the size for small chunks\n        if (len < SMALL_CHUNK) {\n            len += len;\n        } else if (len < MAX_CHUNK) { // but by +25% for larger (to limit overhead)\n            len += (len >> 2);\n        }\n        return new Object[len];\n    ", "fpath_tuple": ["FasterXML_jackson-databind", "jackson-databind", "src", "main", "java", "com", "fasterxml", "jackson", "databind", "util", "ObjectBuffer.java"], "context_start_lineno": 0, "function_name": "appendCompletedChunk", "left_context": "class ObjectBuffer\n{\n    // // // Config constants\n\n    /**\n     * Also: let's expand by doubling up until 64k chunks (which is 16k entries for\n     * 32-bit machines)\n     */\n    private final static int SMALL_CHUNK = (1 << 14);\n\n    /**\n     * Let's limit maximum size of chunks we use; helps avoid excessive allocation\n     * overhead for huge data sets.\n     * For now, let's limit to quarter million entries, 1 meg chunks for 32-bit\n     * machines.\n     */\n    private final static int MAX_CHUNK = (1 << 18);\n\n    // // // Data storage\n\n    private LinkedNode<Object[]> _head;\n\n    private LinkedNode<Object[]> _tail;\n\n    /**\n     * Number of total buffered entries in this buffer, counting all instances\n     * within linked list formed by following {@link #_head}.\n     */\n    private int _size;\n\n    // // // Simple reuse\n\n    /**\n     * Reusable Object array, stored here after buffer has been released having\n     * been used previously.\n     */\n    private Object[] _freeBuffer;\n\n    /*\n    /**********************************************************\n    /* Construction\n    /**********************************************************\n     */\n\n    public ObjectBuffer() { }\n\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    /**\n     * Method called to start buffering process. Will ensure that the buffer\n     * is empty, and then return an object array to start chunking content on\n     */\n    public Object[] resetAndStart()\n    {\n        _reset();\n        if (_freeBuffer == null) {\n            return (_freeBuffer = new Object[12]);\n        }\n        return _freeBuffer;\n    }\n\n    /**\n     * @since 2.9\n     */\n    public Object[] resetAndStart(Object[] base, int count)\n    {\n        _reset();\n        if ((_freeBuffer == null) || (_freeBuffer.length < count)) {\n            _freeBuffer = new Object[Math.max(12, count)];\n        }\n        System.arraycopy(base, 0, _freeBuffer, 0, count);\n        return _freeBuffer;\n    }\n\n    /**\n     * Method called to add a full Object array as a chunk buffered within\n     * this buffer, and to obtain a new array to fill. Caller is not to use\n     * the array it gives; but to use the returned array for continued\n     * buffering.\n     *\n     * @param fullChunk Completed chunk that the caller is requesting\n     *   to append to this buffer. It is generally chunk that was\n     *   returned by an earlier call to {@link #resetAndStart} or\n     *   {@link #appendCompletedChunk} (although this is not required or\n     *   enforced)\n     *\n     * @return New chunk buffer for caller to fill\n     */\n    public Object[] appendCompletedChunk(Object[] fullChunk)\n    {", "right_context": "}\n\n    /**\n     * Method called to indicate that the buffering process is now\n     * complete; and to construct a combined exactly-sized result\n     * array. Additionally the buffer itself will be reset to\n     * reduce memory retention.\n     *<p>\n     * Resulting array will be of generic <code>Object[]</code> type:\n     * if a typed array is needed, use the method with additional\n     * type argument.\n     */\n    public Object[] completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries)\n    {\n        int totalSize = lastChunkEntries + _size;\n        Object[] result = new Object[totalSize];\n        _copyTo(result, totalSize, lastChunk, lastChunkEntries);\n        _reset();\n        return result;\n    }\n\n    /**\n     * Type-safe alternative to\n     * {@link #completeAndClearBuffer(Object[], int)}, to allow\n     * for constructing explicitly typed result array.\n     *\n     * @param componentType Type of elements included in the buffer. Will be\n     *   used for constructing the result array.\n     */\n    public <T> T[] completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, Class<T> componentType)\n    {\n       int totalSize = lastChunkEntries + _size;\n \t   @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) Array.newInstance(componentType, totalSize);\n        _copyTo(result, totalSize, lastChunk, lastChunkEntries);\n        _reset();\n        return result;\n    }\n\n    public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList)\n    {\n        for (LinkedNode<Object[]> n = _head; n != null; n = n.next()) {\n            Object[] curr = n.value();\n            for (int i = 0, len = curr.length; i < len; ++i) {\n                resultList.add(curr[i]);\n            }\n        }\n        // and then the last one\n        for (int i = 0; i < lastChunkEntries; ++i) {\n            resultList.add(lastChunk[i]);\n        }\n        _reset();\n    }\n    \n    /**\n     * Helper method that can be used to check how much free capacity\n     * will this instance start with. Can be used to choose the best\n     * instance to reuse, based on size of reusable object chunk\n     * buffer holds reference to.\n     */\n    public int initialCapacity() {\n        return (_freeBuffer == null) ? 0 : _freeBuffer.length;\n    }\n\n    /**\n     * Method that can be used to check how many Objects have been buffered\n     * within this buffer.\n     */\n    public int bufferedSize() { return _size; }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected void _reset()\n    {\n        // can we reuse the last (and thereby biggest) array for next time?\n        if (_tail != null) {\n            _freeBuffer = _tail.value();\n        }\n        // either way, must discard current contents\n        _head = _tail = null;\n        _size = 0;\n    }\n\n    protected final void _copyTo(Object resultArray, int totalSize,\n            Object[] lastChunk, int lastChunkEntries)\n    {\n        int ptr = 0;\n\n        for (LinkedNode<Object[]> n = _head; n != null; n = n.next()) {\n            Object[] curr = n.value();\n            int len = curr.length;\n            System.arraycopy(curr, 0, resultArray, ptr, len);\n            ptr += len;\n        }\n        System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries);\n        ptr += lastChunkEntries;\n\n        // sanity check (could have failed earlier due to out-of-bounds, too)\n        if (ptr != totalSize) {\n            throw new IllegalStateException(\"Should have gotten \"+totalSize+\" entries, got \"+ptr);\n        }\n    }\n}", "class_name": "ObjectBuffer", "return_type": "Object[]", "parameters": [{"type": "Object[]", "name": "fullChunk"}]}}
{"prompt": "class PiePlot extends Plot implements Selectable, Cloneable,\n        Serializable {\n\n    /**\n     * Returns the interior gap, measured as a percentage of the available\n     * drawing space.\n     *\n     * @return The gap (as a percentage of the available drawing space).\n     *\n     * @see #setInteriorGap(double)\n     */\n    public double getInteriorGap() {\n        return this.interiorGap;\n    }\n\n    /**\n     * Sets the interior gap and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  This controls the space between the edges of the\n     * pie plot and the plot area itself (the region where the section labels\n     * appear).\n     *\n     * @param percent  the gap (as a percentage of the available drawing space).\n     *\n     * @see #getInteriorGap()\n     */\n    public void setInteriorGap(double percent) {\n\n        if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {\n            throw new IllegalArgumentException(\n                \"Invalid 'percent' (\" + percent + \") argument.\");\n        }\n\n        if (this.interiorGap != percent) {\n            this.interiorGap = percent;\n            fireChangeEvent();\n        }\n\n    }\n\n    /**\n     * Returns a flag indicating whether the pie chart is circular, or\n     * stretched into an elliptical shape.\n     *\n     * @return A flag indicating whether the pie chart is circular.\n     *\n     * @see #setCircular(boolean)\n     */\n    public boolean isCircular() {\n        return this.circular;\n    }\n\n    /**\n     * A flag indicating whether the pie chart is circular, or stretched into\n     * an elliptical shape.\n     *\n     * @param flag  the new value.\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean flag) {\n        setCircular(flag, true);\n    }\n\n    /**\n     * Sets the circular attribute and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param circular  the new value of the flag.\n     * @param notify  notify listeners?\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean circular, boolean notify) {\n        this.circular = circular;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the flag that controls whether <code>null</code> values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public boolean getIgnoreNullValues() {\n        return this.ignoreNullValues;\n    }\n\n    /**\n     * Sets a flag that controls whether <code>null</code> values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  At\n     * present, this only affects whether or not the key is presented in the\n     * legend.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreNullValues()\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public void setIgnoreNullValues(boolean flag) {\n        this.ignoreNullValues = flag;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether zero values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public boolean getIgnoreZeroValues() {\n        return this.ignoreZeroValues;\n    }\n\n    /**\n     * Sets a flag that controls whether zero values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  This\n     * only affects whether or not a label appears for the non-visible\n     * pie section.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreZeroValues()\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public void setIgnoreZeroValues(boolean flag) {\n        this.ignoreZeroValues = flag;\n        fireChangeEvent();\n    }\n\n    //// SECTION PAINT ////////////////////////////////////////////////////////\n\n    /**\n     * Returns the paint for the specified section.  This is equivalent to\n     * <code>lookupSectionPaint(section, getAutoPopulateSectionPaint())</code>.\n     *\n     * @param key  the section key.\n     * @param selected  is the section selected?\n     *\n     * @return The paint for the specified section.\n     *\n     * @since 1.2.0\n     *\n     * @see #lookupSectionPaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected) {\n        Paint result = null;\n        if (selected) {\n            result = this.selectedItemAttributes.lookupSectionPaint(key);\n        }\n        if (result == null) {\n            result = lookupSectionPaint(key, selected,\n                    getAutoPopulateSectionPaint());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the paint for the specified section.  The lookup involves these\n     * steps:\n     * <ul>\n     * <li>if {@link #getSectionPaint(Comparable)} is non-<code>null</code>\n     *         return it;</li>\n     * <li>if {@link #getSectionPaint(Comparable)} is <code>null</code> but\n     *         <code>autoPopulate</code> is <code>true</code>, attempt to fetch\n     *         a new paint from the drawing supplier\n     *         ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionPaint()}.\n     * </ul>\n     *\n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier\n     *     is used to auto-populate the section paint settings.\n     *\n     * @return The paint.\n     *\n     * @since 1.2.0\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected, \n            boolean autoPopulate) {\n\n        if (selected) {\n          //  return Color.WHITE;\n        }\n        Paint result = null;\n\n        // is a paint defined for the specified key\n        result = this.sectionPaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n\n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextPaint();\n                this.sectionPaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionPaint;\n            }\n        }\n        else {\n            result = this.baseSectionPaint;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a key for the specified section.  If there is no such section\n     * in the dataset, we generate a key.  This is to provide some backward\n     * compatibility for the (now deprecated) methods that get/set attributes\n     * based on section indices.  The preferred way of doing this now is to\n     * link the attributes directly to the section key (there are new methods\n     * for this, starting from version 1.0.3).\n     *\n     * @param section  the section index.\n     *\n     * @return The key.\n     *\n     * @since 1.0.3\n     */\n    protected Comparable getSectionKey(int section) {", "metadata": {"defects4j_task_id": "cc8f907557109ee35b048274c78d08e61cfb8579560cb8b9aef4fd0503453e42", "task_id": "FasterXML_jackson-databind/166", "ground_truth": "\n            // can only occur for floating-point numbers\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object value = _currentObject();\n                if (value instanceof Double) {\n                    Double v = (Double) value;\n                    return v.isNaN() || v.isInfinite();\n                }\n                if (value instanceof Float) {\n                    Float v = (Float) value;\n                    return v.isNaN() || v.isInfinite();\n                }\n            }\n            return false;\n        ", "fpath_tuple": ["FasterXML_jackson-databind", "jackson-databind", "src", "main", "java", "com", "fasterxml", "jackson", "databind", "util", "TokenBuffer.java"], "context_start_lineno": 0, "function_name": "isNaN", "left_context": "class PiePlot extends Plot implements Selectable, Cloneable,\n        Serializable {\n\n    /**\n     * Returns the interior gap, measured as a percentage of the available\n     * drawing space.\n     *\n     * @return The gap (as a percentage of the available drawing space).\n     *\n     * @see #setInteriorGap(double)\n     */\n    public double getInteriorGap() {\n        return this.interiorGap;\n    }\n\n    /**\n     * Sets the interior gap and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  This controls the space between the edges of the\n     * pie plot and the plot area itself (the region where the section labels\n     * appear).\n     *\n     * @param percent  the gap (as a percentage of the available drawing space).\n     *\n     * @see #getInteriorGap()\n     */\n    public void setInteriorGap(double percent) {\n\n        if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {\n            throw new IllegalArgumentException(\n                \"Invalid 'percent' (\" + percent + \") argument.\");\n        }\n\n        if (this.interiorGap != percent) {\n            this.interiorGap = percent;\n            fireChangeEvent();\n        }\n\n    }\n\n    /**\n     * Returns a flag indicating whether the pie chart is circular, or\n     * stretched into an elliptical shape.\n     *\n     * @return A flag indicating whether the pie chart is circular.\n     *\n     * @see #setCircular(boolean)\n     */\n    public boolean isCircular() {\n        return this.circular;\n    }\n\n    /**\n     * A flag indicating whether the pie chart is circular, or stretched into\n     * an elliptical shape.\n     *\n     * @param flag  the new value.\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean flag) {\n        setCircular(flag, true);\n    }\n\n    /**\n     * Sets the circular attribute and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param circular  the new value of the flag.\n     * @param notify  notify listeners?\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean circular, boolean notify) {\n        this.circular = circular;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the flag that controls whether <code>null</code> values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public boolean getIgnoreNullValues() {\n        return this.ignoreNullValues;\n    }\n\n    /**\n     * Sets a flag that controls whether <code>null</code> values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  At\n     * present, this only affects whether or not the key is presented in the\n     * legend.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreNullValues()\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public void setIgnoreNullValues(boolean flag) {\n        this.ignoreNullValues = flag;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether zero values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public boolean getIgnoreZeroValues() {\n        return this.ignoreZeroValues;\n    }\n\n    /**\n     * Sets a flag that controls whether zero values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  This\n     * only affects whether or not a label appears for the non-visible\n     * pie section.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreZeroValues()\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public void setIgnoreZeroValues(boolean flag) {\n        this.ignoreZeroValues = flag;\n        fireChangeEvent();\n    }\n\n    //// SECTION PAINT ////////////////////////////////////////////////////////\n\n    /**\n     * Returns the paint for the specified section.  This is equivalent to\n     * <code>lookupSectionPaint(section, getAutoPopulateSectionPaint())</code>.\n     *\n     * @param key  the section key.\n     * @param selected  is the section selected?\n     *\n     * @return The paint for the specified section.\n     *\n     * @since 1.2.0\n     *\n     * @see #lookupSectionPaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected) {\n        Paint result = null;\n        if (selected) {\n            result = this.selectedItemAttributes.lookupSectionPaint(key);\n        }\n        if (result == null) {\n            result = lookupSectionPaint(key, selected,\n                    getAutoPopulateSectionPaint());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the paint for the specified section.  The lookup involves these\n     * steps:\n     * <ul>\n     * <li>if {@link #getSectionPaint(Comparable)} is non-<code>null</code>\n     *         return it;</li>\n     * <li>if {@link #getSectionPaint(Comparable)} is <code>null</code> but\n     *         <code>autoPopulate</code> is <code>true</code>, attempt to fetch\n     *         a new paint from the drawing supplier\n     *         ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionPaint()}.\n     * </ul>\n     *\n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier\n     *     is used to auto-populate the section paint settings.\n     *\n     * @return The paint.\n     *\n     * @since 1.2.0\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected, \n            boolean autoPopulate) {\n\n        if (selected) {\n          //  return Color.WHITE;\n        }\n        Paint result = null;\n\n        // is a paint defined for the specified key\n        result = this.sectionPaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n\n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextPaint();\n                this.sectionPaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionPaint;\n            }\n        }\n        else {\n            result = this.baseSectionPaint;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a key for the specified section.  If there is no such section\n     * in the dataset, we generate a key.  This is to provide some backward\n     * compatibility for the (now deprecated) methods that get/set attributes\n     * based on section indices.  The preferred way of doing this now is to\n     * link the attributes directly to the section key (there are new methods\n     * for this, starting from version 1.0.3).\n     *\n     * @param section  the section index.\n     *\n     * @return The key.\n     *\n     * @since 1.0.3\n     */\n    protected Comparable getSectionKey(int section) {", "right_context": "}\n}", "class_name": "TokenBuffer", "return_type": "boolean", "parameters": []}}
{"prompt": "class SimpleModule\n    extends com.fasterxml.jackson.databind.Module\n    implements java.io.Serializable\n{\n    protected SimpleSerializers _keySerializers = null;\n    protected SimpleKeyDeserializers _keyDeserializers = null;\n\n    /**\n     * Lazily-constructed resolver used for storing mappings from\n     * abstract classes to more specific implementing classes\n     * (which may be abstract or concrete)\n     */\n    protected SimpleAbstractTypeResolver _abstractTypes = null;\n\n    /**\n     * Lazily-constructed resolver used for storing mappings from\n     * abstract classes to more specific implementing classes\n     * (which may be abstract or concrete)\n     */\n    protected SimpleValueInstantiators _valueInstantiators = null;\n\n    /**\n     * @since 2.2\n     */\n    protected BeanDeserializerModifier _deserializerModifier = null;\n\n    /**\n     * @since 2.2\n     */\n    protected BeanSerializerModifier _serializerModifier = null;\n\n    /**\n     * Lazily-constructed map that contains mix-in definitions, indexed\n     * by target class, value being mix-in to apply.\n     */\n    protected HashMap<Class<?>, Class<?>> _mixins = null;\n    \n    /**\n     * Set of subtypes to register, if any.\n     */\n    protected LinkedHashSet<NamedType> _subtypes = null;\n\n    /**\n     * @since 2.3\n     */\n    protected PropertyNamingStrategy _namingStrategy = null;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle: creation\n    /**********************************************************\n     */\n\n    /**\n     * Constructors that should only be used for non-reusable\n     * convenience modules used by app code: \"real\" modules should\n     * use actual name and version number information.\n     */\n    public SimpleModule() {\n        // can't chain when making reference to 'this'\n        // note: generate different name for direct instantiation, sub-classing\n        _name = (getClass() == SimpleModule.class) ?\n                \"SimpleModule-\"+System.identityHashCode(this)\n                : getClass().getName();\n        _version = Version.unknownVersion();\n    }\n    \n    /**\n     * Convenience constructor that will default version to\n     * {@link Version#unknownVersion()}.\n     */\n    public SimpleModule(String name) {\n        this(name, Version.unknownVersion());\n    }\n\n    /**\n     * Convenience constructor that will use specified Version,\n     * including name from {@link Version#getArtifactId()}\n     */\n    public SimpleModule(Version version) {\n        _name = version.getArtifactId();\n        _version = version;\n    }\n    \n    /**\n     * Constructor to use for actual reusable modules.\n     * ObjectMapper may use name as identifier to notice attempts\n     * for multiple registrations of the same module (although it\n     * does not have to).\n     * \n     * @param name Unique name of the module\n     * @param version Version of the module\n     */\n    public SimpleModule(String name, Version version) {\n        _name = name;\n        _version = version;\n    }\n\n    /**\n     * @since 2.1\n     */\n    public SimpleModule(String name, Version version,\n            Map<Class<?>,JsonDeserializer<?>> deserializers) {\n        this(name, version, deserializers, null);\n    }\n\n    /**\n     * @since 2.1\n     */\n    public SimpleModule(String name, Version version,\n            List<JsonSerializer<?>> serializers) {\n        this(name, version, null, serializers);\n    }\n    \n    /**\n     * @since 2.1\n     */\n    public SimpleModule(String name, Version version,\n            Map<Class<?>,JsonDeserializer<?>> deserializers,\n            List<JsonSerializer<?>> serializers)\n    {\n        _name = name;\n        _version = version;\n        if (deserializers != null) {\n            _deserializers = new SimpleDeserializers(deserializers);\n        }\n        if (serializers != null) {\n            _serializers = new SimpleSerializers(serializers);\n        }\n    }\n\n    /**\n     * Since instances are likely to be custom, implementation returns\n     * <code>null</code> if (but only if!) this class is directly instantiated;\n     * but class name (default impl) for sub-classes.\n     */\n    @Override\n    public Object getTypeId() {\n        if (getClass() == SimpleModule.class) {\n            return null;\n        }\n        return super.getTypeId();\n    }\n    \n    /*\n    /**********************************************************\n    /* Simple setters to allow overriding\n    /**********************************************************\n     */\n\n    /**\n     * Resets all currently configured serializers.\n     */\n    public void setSerializers(SimpleSerializers s) {\n        _serializers = s;\n    }\n\n    /**\n     * Resets all currently configured deserializers.\n     */\n    public void setDeserializers(SimpleDeserializers d) {\n        _deserializers = d;\n    }\n\n    /**\n     * Resets all currently configured key serializers.\n     */\n    public void setKeySerializers(SimpleSerializers ks) {\n        _keySerializers = ks;\n    }\n\n    /**\n     * Resets all currently configured key deserializers.\n     */\n    public void setKeyDeserializers(SimpleKeyDeserializers kd) {\n        _keyDeserializers = kd;\n    }\n\n    /**\n     * Resets currently configured abstract type mappings\n     */\n    public void setAbstractTypes(SimpleAbstractTypeResolver atr) {\n        _abstractTypes = atr;        \n    }\n\n    /**\n     * Resets all currently configured value instantiators\n     */\n    public void setValueInstantiators(SimpleValueInstantiators svi) {\n        _valueInstantiators = svi;\n    }\n\n    /**\n     * @since 2.2\n     */\n    public SimpleModule setDeserializerModifier(BeanDeserializerModifier mod) {\n        _deserializerModifier = mod;\n        return this;\n    }\n\n    /**\n     * @since 2.2\n     */\n    public SimpleModule setSerializerModifier(BeanSerializerModifier mod) {\n        _serializerModifier = mod;\n        return this;\n    }\n\n    /**\n     * @since 2.3\n     */\n    protected SimpleModule setNamingStrategy(PropertyNamingStrategy naming) {\n        _namingStrategy = naming;\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration methods, adding serializers\n    /**********************************************************\n     */\n\n    /**\n     * Method for adding serializer to handle type that the serializer claims to handle\n     * (see {@link JsonSerializer#handledType()}).\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.\n     */\n    public SimpleModule addSerializer(JsonSerializer<?> ser)\n    {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(ser);\n        return this;\n    }\n\n    /**\n     * Method for adding serializer to handle values of specific type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.\n     */\n    public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n    {", "metadata": {"defects4j_task_id": "00d7c6b6a6994c27e69876288bc2ce39cc52e82cc0f70764ee5f6568c56ab343", "task_id": "FasterXML_jackson-databind/0", "ground_truth": "\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    ", "fpath_tuple": ["FasterXML_jackson-databind", "jackson-databind", "src", "main", "java", "com", "fasterxml", "jackson", "databind", "module", "SimpleModule.java"], "context_start_lineno": 0, "function_name": "addSerializer", "left_context": "class SimpleModule\n    extends com.fasterxml.jackson.databind.Module\n    implements java.io.Serializable\n{\n    protected SimpleSerializers _keySerializers = null;\n    protected SimpleKeyDeserializers _keyDeserializers = null;\n\n    /**\n     * Lazily-constructed resolver used for storing mappings from\n     * abstract classes to more specific implementing classes\n     * (which may be abstract or concrete)\n     */\n    protected SimpleAbstractTypeResolver _abstractTypes = null;\n\n    /**\n     * Lazily-constructed resolver used for storing mappings from\n     * abstract classes to more specific implementing classes\n     * (which may be abstract or concrete)\n     */\n    protected SimpleValueInstantiators _valueInstantiators = null;\n\n    /**\n     * @since 2.2\n     */\n    protected BeanDeserializerModifier _deserializerModifier = null;\n\n    /**\n     * @since 2.2\n     */\n    protected BeanSerializerModifier _serializerModifier = null;\n\n    /**\n     * Lazily-constructed map that contains mix-in definitions, indexed\n     * by target class, value being mix-in to apply.\n     */\n    protected HashMap<Class<?>, Class<?>> _mixins = null;\n    \n    /**\n     * Set of subtypes to register, if any.\n     */\n    protected LinkedHashSet<NamedType> _subtypes = null;\n\n    /**\n     * @since 2.3\n     */\n    protected PropertyNamingStrategy _namingStrategy = null;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle: creation\n    /**********************************************************\n     */\n\n    /**\n     * Constructors that should only be used for non-reusable\n     * convenience modules used by app code: \"real\" modules should\n     * use actual name and version number information.\n     */\n    public SimpleModule() {\n        // can't chain when making reference to 'this'\n        // note: generate different name for direct instantiation, sub-classing\n        _name = (getClass() == SimpleModule.class) ?\n                \"SimpleModule-\"+System.identityHashCode(this)\n                : getClass().getName();\n        _version = Version.unknownVersion();\n    }\n    \n    /**\n     * Convenience constructor that will default version to\n     * {@link Version#unknownVersion()}.\n     */\n    public SimpleModule(String name) {\n        this(name, Version.unknownVersion());\n    }\n\n    /**\n     * Convenience constructor that will use specified Version,\n     * including name from {@link Version#getArtifactId()}\n     */\n    public SimpleModule(Version version) {\n        _name = version.getArtifactId();\n        _version = version;\n    }\n    \n    /**\n     * Constructor to use for actual reusable modules.\n     * ObjectMapper may use name as identifier to notice attempts\n     * for multiple registrations of the same module (although it\n     * does not have to).\n     * \n     * @param name Unique name of the module\n     * @param version Version of the module\n     */\n    public SimpleModule(String name, Version version) {\n        _name = name;\n        _version = version;\n    }\n\n    /**\n     * @since 2.1\n     */\n    public SimpleModule(String name, Version version,\n            Map<Class<?>,JsonDeserializer<?>> deserializers) {\n        this(name, version, deserializers, null);\n    }\n\n    /**\n     * @since 2.1\n     */\n    public SimpleModule(String name, Version version,\n            List<JsonSerializer<?>> serializers) {\n        this(name, version, null, serializers);\n    }\n    \n    /**\n     * @since 2.1\n     */\n    public SimpleModule(String name, Version version,\n            Map<Class<?>,JsonDeserializer<?>> deserializers,\n            List<JsonSerializer<?>> serializers)\n    {\n        _name = name;\n        _version = version;\n        if (deserializers != null) {\n            _deserializers = new SimpleDeserializers(deserializers);\n        }\n        if (serializers != null) {\n            _serializers = new SimpleSerializers(serializers);\n        }\n    }\n\n    /**\n     * Since instances are likely to be custom, implementation returns\n     * <code>null</code> if (but only if!) this class is directly instantiated;\n     * but class name (default impl) for sub-classes.\n     */\n    @Override\n    public Object getTypeId() {\n        if (getClass() == SimpleModule.class) {\n            return null;\n        }\n        return super.getTypeId();\n    }\n    \n    /*\n    /**********************************************************\n    /* Simple setters to allow overriding\n    /**********************************************************\n     */\n\n    /**\n     * Resets all currently configured serializers.\n     */\n    public void setSerializers(SimpleSerializers s) {\n        _serializers = s;\n    }\n\n    /**\n     * Resets all currently configured deserializers.\n     */\n    public void setDeserializers(SimpleDeserializers d) {\n        _deserializers = d;\n    }\n\n    /**\n     * Resets all currently configured key serializers.\n     */\n    public void setKeySerializers(SimpleSerializers ks) {\n        _keySerializers = ks;\n    }\n\n    /**\n     * Resets all currently configured key deserializers.\n     */\n    public void setKeyDeserializers(SimpleKeyDeserializers kd) {\n        _keyDeserializers = kd;\n    }\n\n    /**\n     * Resets currently configured abstract type mappings\n     */\n    public void setAbstractTypes(SimpleAbstractTypeResolver atr) {\n        _abstractTypes = atr;        \n    }\n\n    /**\n     * Resets all currently configured value instantiators\n     */\n    public void setValueInstantiators(SimpleValueInstantiators svi) {\n        _valueInstantiators = svi;\n    }\n\n    /**\n     * @since 2.2\n     */\n    public SimpleModule setDeserializerModifier(BeanDeserializerModifier mod) {\n        _deserializerModifier = mod;\n        return this;\n    }\n\n    /**\n     * @since 2.2\n     */\n    public SimpleModule setSerializerModifier(BeanSerializerModifier mod) {\n        _serializerModifier = mod;\n        return this;\n    }\n\n    /**\n     * @since 2.3\n     */\n    protected SimpleModule setNamingStrategy(PropertyNamingStrategy naming) {\n        _namingStrategy = naming;\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Configuration methods, adding serializers\n    /**********************************************************\n     */\n\n    /**\n     * Method for adding serializer to handle type that the serializer claims to handle\n     * (see {@link JsonSerializer#handledType()}).\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.\n     */\n    public SimpleModule addSerializer(JsonSerializer<?> ser)\n    {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(ser);\n        return this;\n    }\n\n    /**\n     * Method for adding serializer to handle values of specific type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.\n     */\n    public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n    {", "right_context": "}\n}", "class_name": "SimpleModule", "return_type": "SimpleModule", "parameters": [{"type": "Class<? extends T>", "name": "type"}, {"type": "JsonSerializer<T>", "name": "ser"}]}}
{"prompt": "class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    /* TODOs for future versions:\n     * \n     * For 2.9?\n     *\n     * - New method in JsonDeserializer (deserializeNext()) to allow use of more\n     *   efficient 'nextXxx()' method `JsonParser` provides.\n     *\n     * Also: need to ensure efficient impl of those methods for Smile, CBOR\n     * at least (in addition to JSON)\n     */\n\n    @Override\n    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n        return new BeanDeserializer(this, oir);\n    }\n\n    @Override\n    public BeanDeserializer withIgnorableProperties(Set<String> ignorableProps) {\n        return new BeanDeserializer(this, ignorableProps);\n    }\n\n    @Override\n    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n        return new BeanDeserializer(this, props);\n    }\n\n    @Override\n    protected BeanDeserializerBase asArrayDeserializer() {\n        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        return new BeanAsArrayDeserializer(this, props);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializer implementation\n    /**********************************************************\n     */\n\n    /**\n     * Main deserialization method for bean-based objects (POJOs).\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // common case first\n        if (p.isExpectedStartObjectToken()) {\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, p.nextToken());\n            }\n            // 23-Sep-2015, tatu: This is wrong at some many levels, but for now... it is\n            //    what it is, including \"expected behavior\".\n            p.nextToken();\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        }\n        return _deserializeOther(p, ctxt, p.getCurrentToken());\n    }\n\n    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n            JsonToken t) throws IOException\n    {\n        // and then others, generally requiring use of @JsonCreator\n        if (t != null) {\n            switch (t) {\n            case VALUE_STRING:\n                return deserializeFromString(p, ctxt);\n            case VALUE_NUMBER_INT:\n                return deserializeFromNumber(p, ctxt);\n            case VALUE_NUMBER_FLOAT:\n                return deserializeFromDouble(p, ctxt);\n            case VALUE_EMBEDDED_OBJECT:\n                return deserializeFromEmbedded(p, ctxt);\n            case VALUE_TRUE:\n            case VALUE_FALSE:\n                return deserializeFromBoolean(p, ctxt);\n            case VALUE_NULL:\n                return deserializeFromNull(p, ctxt);\n            case START_ARRAY:\n                // these only work if there's a (delegating) creator...\n                return deserializeFromArray(p, ctxt);\n            case FIELD_NAME:\n            case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n                if (_vanillaProcessing) {\n                    return vanillaDeserialize(p, ctxt, t);\n                }\n                if (_objectIdReader != null) {\n                    return deserializeWithObjectId(p, ctxt);\n                }\n                return deserializeFromObject(p, ctxt);\n            default:\n            }\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    @Deprecated // since 2.8; remove unless getting used\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }\n\n    /**\n     * Secondary deserialization method, called in cases where POJO\n     * instance is created as part of deserialization, potentially\n     * after collecting some or all of the properties to set.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean) throws IOException\n    {\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, bean);\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.getCurrentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************\n     */\n\n    /**\n     * Streamlined version that is only used when no \"special\"\n     * features are enabled.\n     */\n    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n    {", "metadata": {"defects4j_task_id": "1aa652f1d449f7e02ab8efe6f2798c3af7fbdc76dd7578051a2a95dcb2fdde8f", "task_id": "FasterXML_jackson-databind/30", "ground_truth": "\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    ", "fpath_tuple": ["FasterXML_jackson-databind", "jackson-databind", "src", "main", "java", "com", "fasterxml", "jackson", "databind", "deser", "BeanDeserializer.java"], "context_start_lineno": 0, "function_name": "vanillaDeserialize", "left_context": "class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    /* TODOs for future versions:\n     * \n     * For 2.9?\n     *\n     * - New method in JsonDeserializer (deserializeNext()) to allow use of more\n     *   efficient 'nextXxx()' method `JsonParser` provides.\n     *\n     * Also: need to ensure efficient impl of those methods for Smile, CBOR\n     * at least (in addition to JSON)\n     */\n\n    @Override\n    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n        return new BeanDeserializer(this, oir);\n    }\n\n    @Override\n    public BeanDeserializer withIgnorableProperties(Set<String> ignorableProps) {\n        return new BeanDeserializer(this, ignorableProps);\n    }\n\n    @Override\n    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n        return new BeanDeserializer(this, props);\n    }\n\n    @Override\n    protected BeanDeserializerBase asArrayDeserializer() {\n        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        return new BeanAsArrayDeserializer(this, props);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializer implementation\n    /**********************************************************\n     */\n\n    /**\n     * Main deserialization method for bean-based objects (POJOs).\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // common case first\n        if (p.isExpectedStartObjectToken()) {\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, p.nextToken());\n            }\n            // 23-Sep-2015, tatu: This is wrong at some many levels, but for now... it is\n            //    what it is, including \"expected behavior\".\n            p.nextToken();\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        }\n        return _deserializeOther(p, ctxt, p.getCurrentToken());\n    }\n\n    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n            JsonToken t) throws IOException\n    {\n        // and then others, generally requiring use of @JsonCreator\n        if (t != null) {\n            switch (t) {\n            case VALUE_STRING:\n                return deserializeFromString(p, ctxt);\n            case VALUE_NUMBER_INT:\n                return deserializeFromNumber(p, ctxt);\n            case VALUE_NUMBER_FLOAT:\n                return deserializeFromDouble(p, ctxt);\n            case VALUE_EMBEDDED_OBJECT:\n                return deserializeFromEmbedded(p, ctxt);\n            case VALUE_TRUE:\n            case VALUE_FALSE:\n                return deserializeFromBoolean(p, ctxt);\n            case VALUE_NULL:\n                return deserializeFromNull(p, ctxt);\n            case START_ARRAY:\n                // these only work if there's a (delegating) creator...\n                return deserializeFromArray(p, ctxt);\n            case FIELD_NAME:\n            case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n                if (_vanillaProcessing) {\n                    return vanillaDeserialize(p, ctxt, t);\n                }\n                if (_objectIdReader != null) {\n                    return deserializeWithObjectId(p, ctxt);\n                }\n                return deserializeFromObject(p, ctxt);\n            default:\n            }\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    @Deprecated // since 2.8; remove unless getting used\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }\n\n    /**\n     * Secondary deserialization method, called in cases where POJO\n     * instance is created as part of deserialization, potentially\n     * after collecting some or all of the properties to set.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean) throws IOException\n    {\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, bean);\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.getCurrentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************\n     */\n\n    /**\n     * Streamlined version that is only used when no \"special\"\n     * features are enabled.\n     */\n    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n    {", "right_context": "}\n}", "class_name": "BeanDeserializer", "return_type": "Object", "parameters": [{"type": "JsonParser", "name": "p"}, {"type": "DeserializationContext", "name": "ctxt"}, {"type": "JsonToken", "name": "t"}]}}
{"prompt": "class TypeFactory\n    implements java.io.Serializable\n{\n    /**\n     * Method that can be used to construct \"raw\" Collection type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level factory methods\n    /**********************************************************\n     */\n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        JavaType kt, vt;\n\n        // 28-May-2015, tatu: Properties are special, as per [databind#810]; fake \"correct\" parameter sig\n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            // ok to have no types (\"raw\")\n            switch (typeParams.size()) {\n            case 0: // acceptable?\n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": cannot determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": cannot determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": cannot determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    /**\n     * Factory method to call when no special {@link JavaType} is needed,\n     * no generic parameters are passed. Default implementation may check\n     * pre-constructed values for \"well-known\" types, but if none found\n     * will simply call {@link #_newSimpleType}\n     *\n     * @since 2.7\n     */\n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    /**\n     * Factory method that is to create a new {@link SimpleType} with no\n     * checks whatsoever. Default implementation calls the single argument\n     * constructor of {@link SimpleType}.\n     *\n     * @since 2.7\n     */\n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        /* 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.\n         *    This may have been due to potential mutability of the instance; but that\n         *    should not be issue any more, and creation is somewhat wasteful. So let's\n         *    try reusing singleton/flyweight instance.\n         */\n        return CORE_TYPE_OBJECT;\n    }\n\n    /**\n     * Helper method called to see if requested, non-generic-parameterized\n     * type is one of common, \"well-known\" types, instances of which are\n     * pre-constructed and do not need dynamic caching.\n     *\n     * @since 2.7\n     */\n    protected JavaType _findWellKnownSimple(Class<?> clz) {", "metadata": {"defects4j_task_id": "5fee39b2c366005a4e0dc00102882915daa8037d96c81f31359614af0a91fae7", "task_id": "FasterXML_jackson-databind/82", "ground_truth": "\n        if (clz.isPrimitive()) {\n            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;\n            if (clz == CLS_INT) return CORE_TYPE_INT;\n            if (clz == CLS_LONG) return CORE_TYPE_LONG;\n        } else {\n            if (clz == CLS_STRING) return CORE_TYPE_STRING;\n            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7\n        }\n        return null;\n    ", "fpath_tuple": ["FasterXML_jackson-databind", "jackson-databind", "src", "main", "java", "com", "fasterxml", "jackson", "databind", "type", "TypeFactory.java"], "context_start_lineno": 0, "function_name": "_findWellKnownSimple", "left_context": "class TypeFactory\n    implements java.io.Serializable\n{\n    /**\n     * Method that can be used to construct \"raw\" Collection type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return constructCollectionType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return constructCollectionLikeType(collectionClass, unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return constructMapType(mapClass, unknownType(), unknownType());\n    }\n\n    /**\n     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *</pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return constructMapLikeType(mapClass, unknownType(), unknownType());\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level factory methods\n    /**********************************************************\n     */\n\n    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        JavaType kt, vt;\n\n        // 28-May-2015, tatu: Properties are special, as per [databind#810]; fake \"correct\" parameter sig\n        if (rawClass == Properties.class) {\n            kt = vt = CORE_TYPE_STRING;\n        } else {\n            List<JavaType> typeParams = bindings.getTypeParameters();\n            // ok to have no types (\"raw\")\n            switch (typeParams.size()) {\n            case 0: // acceptable?\n                kt = vt = _unknownType();\n                break;\n            case 2:\n                kt = typeParams.get(0);\n                vt = typeParams.get(1);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": cannot determine type parameters\");\n            }\n        }\n        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);\n    }\n\n    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": cannot determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        List<JavaType> typeParams = bindings.getTypeParameters();\n        // ok to have no types (\"raw\")\n        JavaType ct;\n        if (typeParams.isEmpty()) {\n            ct = _unknownType();\n        } else if (typeParams.size() == 1) {\n            ct = typeParams.get(0);\n        } else {\n            throw new IllegalArgumentException(\"Strange Reference type \"+rawClass.getName()+\": cannot determine type parameters\");\n        }\n        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);\n    }\n\n    /**\n     * Factory method to call when no special {@link JavaType} is needed,\n     * no generic parameters are passed. Default implementation may check\n     * pre-constructed values for \"well-known\" types, but if none found\n     * will simply call {@link #_newSimpleType}\n     *\n     * @since 2.7\n     */\n    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        if (bindings.isEmpty()) {\n            JavaType result = _findWellKnownSimple(raw);\n            if (result != null) {\n                return result;\n            }\n        }\n        return _newSimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    /**\n     * Factory method that is to create a new {@link SimpleType} with no\n     * checks whatsoever. Default implementation calls the single argument\n     * constructor of {@link SimpleType}.\n     *\n     * @since 2.7\n     */\n    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        return new SimpleType(raw, bindings, superClass, superInterfaces);\n    }\n\n    protected JavaType _unknownType() {\n        /* 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.\n         *    This may have been due to potential mutability of the instance; but that\n         *    should not be issue any more, and creation is somewhat wasteful. So let's\n         *    try reusing singleton/flyweight instance.\n         */\n        return CORE_TYPE_OBJECT;\n    }\n\n    /**\n     * Helper method called to see if requested, non-generic-parameterized\n     * type is one of common, \"well-known\" types, instances of which are\n     * pre-constructed and do not need dynamic caching.\n     *\n     * @since 2.7\n     */\n    protected JavaType _findWellKnownSimple(Class<?> clz) {", "right_context": "}\n}", "class_name": "TypeFactory", "return_type": "JavaType", "parameters": [{"type": "Class<?>", "name": "clz"}]}}
{"prompt": "class JFreeChart implements Drawable,\n                                   TitleChangeListener,\n                                   PlotChangeListener,\n                                   Serializable,\n                                   Cloneable {\n\n    /**\n     * Returns the collection of rendering hints for the chart.\n     *\n     * @return The rendering hints for the chart (never <code>null</code>).\n     *\n     * @see #setRenderingHints(RenderingHints)\n     */\n    public RenderingHints getRenderingHints() {\n        return this.renderingHints;\n    }\n\n    /**\n     * Sets the rendering hints for the chart.  These will be added (using the\n     * Graphics2D.addRenderingHints() method) near the start of the\n     * JFreeChart.draw() method.\n     *\n     * @param renderingHints  the rendering hints (<code>null</code> not\n     *                        permitted).\n     *\n     * @see #getRenderingHints()\n     */\n    public void setRenderingHints(RenderingHints renderingHints) {\n        if (renderingHints == null) {\n            throw new NullPointerException(\"RenderingHints given are null\");\n        }\n        this.renderingHints = renderingHints;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a border is drawn around the\n     * outside of the chart.\n     *\n     * @return A boolean.\n     *\n     * @see #setBorderVisible(boolean)\n     */\n    public boolean isBorderVisible() {\n        return this.borderVisible;\n    }\n\n    /**\n     * Sets a flag that controls whether or not a border is drawn around the\n     * outside of the chart.\n     *\n     * @param visible  the flag.\n     *\n     * @see #isBorderVisible()\n     */\n    public void setBorderVisible(boolean visible) {\n        this.borderVisible = visible;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns the stroke used to draw the chart border (if visible).\n     *\n     * @return The border stroke.\n     *\n     * @see #setBorderStroke(Stroke)\n     */\n    public Stroke getBorderStroke() {\n        return this.borderStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the chart border (if visible).\n     *\n     * @param stroke  the stroke.\n     *\n     * @see #getBorderStroke()\n     */\n    public void setBorderStroke(Stroke stroke) {\n        this.borderStroke = stroke;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns the paint used to draw the chart border (if visible).\n     *\n     * @return The border paint.\n     *\n     * @see #setBorderPaint(Paint)\n     */\n    public Paint getBorderPaint() {\n        return this.borderPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the chart border (if visible).\n     *\n     * @param paint  the paint.\n     *\n     * @see #getBorderPaint()\n     */\n    public void setBorderPaint(Paint paint) {\n        this.borderPaint = paint;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns the padding between the chart border and the chart drawing area.\n     *\n     * @return The padding (never <code>null</code>).\n     *\n     * @see #setPadding(RectangleInsets)\n     */\n    public RectangleInsets getPadding() {\n        return this.padding;\n    }\n\n    /**\n     * Sets the padding between the chart border and the chart drawing area,\n     * and sends a {@link ChartChangeEvent} to all registered listeners.\n     *\n     * @param padding  the padding (<code>null</code> not permitted).\n     *\n     * @see #getPadding()\n     */\n    public void setPadding(RectangleInsets padding) {\n        if (padding == null) {\n            throw new IllegalArgumentException(\"Null 'padding' argument.\");\n        }\n        this.padding = padding;\n        notifyListeners(new ChartChangeEvent(this));\n    }\n\n    /**\n     * Returns the main chart title.  Very often a chart will have just one\n     * title, so we make this case simple by providing accessor methods for\n     * the main title.  However, multiple titles are supported - see the\n     * {@link #addSubtitle(Title)} method.\n     *\n     * @return The chart title (possibly <code>null</code>).\n     *\n     * @see #setTitle(TextTitle)\n     */\n    public TextTitle getTitle() {\n        return this.title;\n    }\n\n    /**\n     * Sets the main title for the chart and sends a {@link ChartChangeEvent}\n     * to all registered listeners.  If you do not want a title for the\n     * chart, set it to <code>null</code>.  If you want more than one title on\n     * a chart, use the {@link #addSubtitle(Title)} method.\n     *\n     * @param title  the title (<code>null</code> permitted).\n     *\n     * @see #getTitle()\n     */\n    public void setTitle(TextTitle title) {\n        if (this.title != null) {\n            this.title.removeChangeListener(this);\n        }\n        this.title = title;\n        if (title != null) {\n            title.addChangeListener(this);\n        }\n        fireChartChanged();\n    }\n\n    /**\n     * Sets the chart title and sends a {@link ChartChangeEvent} to all\n     * registered listeners.  This is a convenience method that ends up calling\n     * the {@link #setTitle(TextTitle)} method.  If there is an existing title,\n     * its text is updated, otherwise a new title using the default font is\n     * added to the chart.  If <code>text</code> is <code>null</code> the chart\n     * title is set to <code>null</code>.\n     *\n     * @param text  the title text (<code>null</code> permitted).\n     *\n     * @see #getTitle()\n     */\n    public void setTitle(String text) {\n        if (text != null) {\n            if (this.title == null) {\n                setTitle(new TextTitle(text, JFreeChart.DEFAULT_TITLE_FONT));\n            }\n            else {\n                this.title.setText(text);\n            }\n        }\n        else {\n            setTitle((TextTitle) null);\n        }\n    }\n\n    /**\n     * Adds a legend to the plot and sends a {@link ChartChangeEvent} to all\n     * registered listeners.\n     *\n     * @param legend  the legend (<code>null</code> not permitted).\n     *\n     * @see #removeLegend()\n     */\n    public void addLegend(LegendTitle legend) {\n        addSubtitle(legend);\n    }\n\n    /**\n     * Returns the legend for the chart, if there is one.  Note that a chart\n     * can have more than one legend - this method returns the first.\n     *\n     * @return The legend (possibly <code>null</code>).\n     *\n     * @see #getLegend(int)\n     */\n    public LegendTitle getLegend() {\n        return getLegend(0);\n    }\n\n    /**\n     * Returns the nth legend for a chart, or <code>null</code>.\n     *\n     * @param index  the legend index (zero-based).\n     *\n     * @return The legend (possibly <code>null</code>).\n     *\n     * @see #addLegend(LegendTitle)\n     */\n    public LegendTitle getLegend(int index) {", "metadata": {"defects4j_task_id": "6e3e154b9904f4d30d5b17be0b3e922f354952b7dbad2fb5e98eda74cbe70eed", "task_id": "jfree_jfreechart/93", "ground_truth": "\n        int seen = 0;\n        Iterator iterator = this.subtitles.iterator();\n        while (iterator.hasNext()) {\n            Title subtitle = (Title) iterator.next();\n            if (subtitle instanceof LegendTitle) {\n                if (seen == index) {\n                    return (LegendTitle) subtitle;\n                }\n                else {\n                    seen++;\n                }\n            }\n        }\n        return null;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "JFreeChart.java"], "context_start_lineno": 0, "function_name": "getLegend", "left_context": "class JFreeChart implements Drawable,\n                                   TitleChangeListener,\n                                   PlotChangeListener,\n                                   Serializable,\n                                   Cloneable {\n\n    /**\n     * Returns the collection of rendering hints for the chart.\n     *\n     * @return The rendering hints for the chart (never <code>null</code>).\n     *\n     * @see #setRenderingHints(RenderingHints)\n     */\n    public RenderingHints getRenderingHints() {\n        return this.renderingHints;\n    }\n\n    /**\n     * Sets the rendering hints for the chart.  These will be added (using the\n     * Graphics2D.addRenderingHints() method) near the start of the\n     * JFreeChart.draw() method.\n     *\n     * @param renderingHints  the rendering hints (<code>null</code> not\n     *                        permitted).\n     *\n     * @see #getRenderingHints()\n     */\n    public void setRenderingHints(RenderingHints renderingHints) {\n        if (renderingHints == null) {\n            throw new NullPointerException(\"RenderingHints given are null\");\n        }\n        this.renderingHints = renderingHints;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a border is drawn around the\n     * outside of the chart.\n     *\n     * @return A boolean.\n     *\n     * @see #setBorderVisible(boolean)\n     */\n    public boolean isBorderVisible() {\n        return this.borderVisible;\n    }\n\n    /**\n     * Sets a flag that controls whether or not a border is drawn around the\n     * outside of the chart.\n     *\n     * @param visible  the flag.\n     *\n     * @see #isBorderVisible()\n     */\n    public void setBorderVisible(boolean visible) {\n        this.borderVisible = visible;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns the stroke used to draw the chart border (if visible).\n     *\n     * @return The border stroke.\n     *\n     * @see #setBorderStroke(Stroke)\n     */\n    public Stroke getBorderStroke() {\n        return this.borderStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the chart border (if visible).\n     *\n     * @param stroke  the stroke.\n     *\n     * @see #getBorderStroke()\n     */\n    public void setBorderStroke(Stroke stroke) {\n        this.borderStroke = stroke;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns the paint used to draw the chart border (if visible).\n     *\n     * @return The border paint.\n     *\n     * @see #setBorderPaint(Paint)\n     */\n    public Paint getBorderPaint() {\n        return this.borderPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the chart border (if visible).\n     *\n     * @param paint  the paint.\n     *\n     * @see #getBorderPaint()\n     */\n    public void setBorderPaint(Paint paint) {\n        this.borderPaint = paint;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns the padding between the chart border and the chart drawing area.\n     *\n     * @return The padding (never <code>null</code>).\n     *\n     * @see #setPadding(RectangleInsets)\n     */\n    public RectangleInsets getPadding() {\n        return this.padding;\n    }\n\n    /**\n     * Sets the padding between the chart border and the chart drawing area,\n     * and sends a {@link ChartChangeEvent} to all registered listeners.\n     *\n     * @param padding  the padding (<code>null</code> not permitted).\n     *\n     * @see #getPadding()\n     */\n    public void setPadding(RectangleInsets padding) {\n        if (padding == null) {\n            throw new IllegalArgumentException(\"Null 'padding' argument.\");\n        }\n        this.padding = padding;\n        notifyListeners(new ChartChangeEvent(this));\n    }\n\n    /**\n     * Returns the main chart title.  Very often a chart will have just one\n     * title, so we make this case simple by providing accessor methods for\n     * the main title.  However, multiple titles are supported - see the\n     * {@link #addSubtitle(Title)} method.\n     *\n     * @return The chart title (possibly <code>null</code>).\n     *\n     * @see #setTitle(TextTitle)\n     */\n    public TextTitle getTitle() {\n        return this.title;\n    }\n\n    /**\n     * Sets the main title for the chart and sends a {@link ChartChangeEvent}\n     * to all registered listeners.  If you do not want a title for the\n     * chart, set it to <code>null</code>.  If you want more than one title on\n     * a chart, use the {@link #addSubtitle(Title)} method.\n     *\n     * @param title  the title (<code>null</code> permitted).\n     *\n     * @see #getTitle()\n     */\n    public void setTitle(TextTitle title) {\n        if (this.title != null) {\n            this.title.removeChangeListener(this);\n        }\n        this.title = title;\n        if (title != null) {\n            title.addChangeListener(this);\n        }\n        fireChartChanged();\n    }\n\n    /**\n     * Sets the chart title and sends a {@link ChartChangeEvent} to all\n     * registered listeners.  This is a convenience method that ends up calling\n     * the {@link #setTitle(TextTitle)} method.  If there is an existing title,\n     * its text is updated, otherwise a new title using the default font is\n     * added to the chart.  If <code>text</code> is <code>null</code> the chart\n     * title is set to <code>null</code>.\n     *\n     * @param text  the title text (<code>null</code> permitted).\n     *\n     * @see #getTitle()\n     */\n    public void setTitle(String text) {\n        if (text != null) {\n            if (this.title == null) {\n                setTitle(new TextTitle(text, JFreeChart.DEFAULT_TITLE_FONT));\n            }\n            else {\n                this.title.setText(text);\n            }\n        }\n        else {\n            setTitle((TextTitle) null);\n        }\n    }\n\n    /**\n     * Adds a legend to the plot and sends a {@link ChartChangeEvent} to all\n     * registered listeners.\n     *\n     * @param legend  the legend (<code>null</code> not permitted).\n     *\n     * @see #removeLegend()\n     */\n    public void addLegend(LegendTitle legend) {\n        addSubtitle(legend);\n    }\n\n    /**\n     * Returns the legend for the chart, if there is one.  Note that a chart\n     * can have more than one legend - this method returns the first.\n     *\n     * @return The legend (possibly <code>null</code>).\n     *\n     * @see #getLegend(int)\n     */\n    public LegendTitle getLegend() {\n        return getLegend(0);\n    }\n\n    /**\n     * Returns the nth legend for a chart, or <code>null</code>.\n     *\n     * @param index  the legend index (zero-based).\n     *\n     * @return The legend (possibly <code>null</code>).\n     *\n     * @see #addLegend(LegendTitle)\n     */\n    public LegendTitle getLegend(int index) {", "right_context": "}\n\n}", "class_name": "JFreeChart", "return_type": "LegendTitle", "parameters": [{"type": "int", "name": "index"}]}}
{"prompt": "class CustomXYURLGenerator implements XYURLGenerator, Cloneable,\n        PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -8565933356596551832L;\n\n    /** Storage for the URLs. */\n    private ArrayList urlSeries = new ArrayList();\n\n    /**\n     * Default constructor.\n     */\n    public CustomXYURLGenerator() {\n        super();\n    }\n\n    /**\n     * Returns the number of URL lists stored by the renderer.\n     *\n     * @return The list count.\n     */\n    public int getListCount() {\n        return this.urlSeries.size();\n    }\n\n    /**\n     * Returns the number of URLs in a given list.\n     *\n     * @param list  the list index (zero based).\n     *\n     * @return The URL count.\n     */\n    public int getURLCount(int list) {\n        int result = 0;\n        List urls = (List) this.urlSeries.get(list);\n        if (urls != null) {\n            result = urls.size();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the URL for an item.\n     *\n     * @param series  the series index.\n     * @param item  the item index.\n     *\n     * @return The URL (possibly <code>null</code>).\n     */\n    public String getURL(int series, int item) {", "metadata": {"defects4j_task_id": "8c7d4d039a3da2525050b44229c2096383951be7454ad9bb5da426fd1bdd605e", "task_id": "jfree_jfreechart/115", "ground_truth": "\n        String result = null;\n        if (series < getListCount()) {\n            List urls = (List) this.urlSeries.get(series);\n            if (urls != null) {\n                if (item < urls.size()) {\n                    result = (String) urls.get(item);\n                }\n            }\n        }\n        return result;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "urls", "CustomXYURLGenerator.java"], "context_start_lineno": 0, "function_name": "getURL", "left_context": "class CustomXYURLGenerator implements XYURLGenerator, Cloneable,\n        PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -8565933356596551832L;\n\n    /** Storage for the URLs. */\n    private ArrayList urlSeries = new ArrayList();\n\n    /**\n     * Default constructor.\n     */\n    public CustomXYURLGenerator() {\n        super();\n    }\n\n    /**\n     * Returns the number of URL lists stored by the renderer.\n     *\n     * @return The list count.\n     */\n    public int getListCount() {\n        return this.urlSeries.size();\n    }\n\n    /**\n     * Returns the number of URLs in a given list.\n     *\n     * @param list  the list index (zero based).\n     *\n     * @return The URL count.\n     */\n    public int getURLCount(int list) {\n        int result = 0;\n        List urls = (List) this.urlSeries.get(list);\n        if (urls != null) {\n            result = urls.size();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the URL for an item.\n     *\n     * @param series  the series index.\n     * @param item  the item index.\n     *\n     * @return The URL (possibly <code>null</code>).\n     */\n    public String getURL(int series, int item) {", "right_context": "}\n\n    /**\n     * Generates a URL.\n     *\n     * @param dataset  the dataset.\n     * @param series  the series (zero-based index).\n     * @param item  the item (zero-based index).\n     *\n     * @return A string containing the URL (possibly <code>null</code>).\n     */\n    public String generateURL(XYDataset dataset, int series, int item) {\n        return getURL(series, item);\n    }\n\n    /**\n     * Adds a list of URLs.\n     *\n     * @param urls  the list of URLs (<code>null</code> permitted, the list\n     *     is copied).\n     */\n    public void addURLSeries(List urls) {\n        List listToAdd = null;\n        if (urls != null) {\n            listToAdd = new java.util.ArrayList(urls);\n        }\n        this.urlSeries.add(listToAdd);\n    }\n\n    /**\n     * Tests this generator for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CustomXYURLGenerator)) {\n            return false;\n        }\n        CustomXYURLGenerator that = (CustomXYURLGenerator) obj;\n        int listCount = getListCount();\n        if (listCount != that.getListCount()) {\n            return false;\n        }\n\n        for (int series = 0; series < listCount; series++) {\n            int urlCount = getURLCount(series);\n            if (urlCount != that.getURLCount(series)) {\n                return false;\n            }\n\n            for (int item = 0; item < urlCount; item++) {\n                String u1 = getURL(series, item);\n                String u2 = that.getURL(series, item);\n                if (u1 != null) {\n                    if (!u1.equals(u2)) {\n                        return false;\n                    }\n                }\n                else {\n                    if (u2 != null) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n\n    }\n\n    /**\n     * Returns a new generator that is a copy of, and independent from, this\n     * generator.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if there is a problem with cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        CustomXYURLGenerator clone = (CustomXYURLGenerator) super.clone();\n        clone.urlSeries = new java.util.ArrayList(this.urlSeries);\n        return clone;\n    }\n\n}", "class_name": "CustomXYURLGenerator", "return_type": "String", "parameters": [{"type": "int", "name": "series"}, {"type": "int", "name": "item"}]}}
{"prompt": "class HashUtilities {\n\n    /**\n     * Returns a hash code for a <code>Paint</code> instance.  If\n     * <code>p</code> is <code>null</code>, this method returns zero.\n     *\n     * @param p  the paint (<code>null</code> permitted).\n     *\n     * @return The hash code.\n     */\n    public static int hashCodeForPaint(Paint p) {\n        if (p == null) {\n            return 0;\n        }\n        int result = 0;\n        // handle GradientPaint as a special case\n        if (p instanceof GradientPaint) {\n            GradientPaint gp = (GradientPaint) p;\n            result = 193;\n            result = 37 * result + gp.getColor1().hashCode();\n            result = 37 * result + gp.getPoint1().hashCode();\n            result = 37 * result + gp.getColor2().hashCode();\n            result = 37 * result + gp.getPoint2().hashCode();\n        }\n        else {\n            // we assume that all other Paint instances implement equals() and\n            // hashCode()...of course that might not be true, but what can we\n            // do about it?\n            result = p.hashCode();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a hash code for a <code>double[]</code> instance.  If the array\n     * is <code>null</code>, this method returns zero.\n     *\n     * @param a  the array (<code>null</code> permitted).\n     *\n     * @return The hash code.\n     */\n    public static int hashCodeForDoubleArray(double[] a) {", "metadata": {"defects4j_task_id": "9fcbddb84a8ee34daef23d5280694f6b4891f3a091d27ab9ef8d23de86e2c84a", "task_id": "jfree_jfreechart/130", "ground_truth": "\n        if (a == null) {\n            return 0;\n        }\n        int result = 193;\n        long temp;\n        for (int i = 0; i < a.length; i++) {\n            temp = Double.doubleToLongBits(a[i]);\n            result = 29 * result + (int) (temp ^ (temp >>> 32));\n        }\n        return result;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "util", "HashUtilities.java"], "context_start_lineno": 0, "function_name": "hashCodeForDoubleArray", "left_context": "class HashUtilities {\n\n    /**\n     * Returns a hash code for a <code>Paint</code> instance.  If\n     * <code>p</code> is <code>null</code>, this method returns zero.\n     *\n     * @param p  the paint (<code>null</code> permitted).\n     *\n     * @return The hash code.\n     */\n    public static int hashCodeForPaint(Paint p) {\n        if (p == null) {\n            return 0;\n        }\n        int result = 0;\n        // handle GradientPaint as a special case\n        if (p instanceof GradientPaint) {\n            GradientPaint gp = (GradientPaint) p;\n            result = 193;\n            result = 37 * result + gp.getColor1().hashCode();\n            result = 37 * result + gp.getPoint1().hashCode();\n            result = 37 * result + gp.getColor2().hashCode();\n            result = 37 * result + gp.getPoint2().hashCode();\n        }\n        else {\n            // we assume that all other Paint instances implement equals() and\n            // hashCode()...of course that might not be true, but what can we\n            // do about it?\n            result = p.hashCode();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a hash code for a <code>double[]</code> instance.  If the array\n     * is <code>null</code>, this method returns zero.\n     *\n     * @param a  the array (<code>null</code> permitted).\n     *\n     * @return The hash code.\n     */\n    public static int hashCodeForDoubleArray(double[] a) {", "right_context": "}\n\n    /**\n     * Returns a hash value based on a seed value and the value of a boolean\n     * primitive.\n     *\n     * @param pre  the seed value.\n     * @param b  the boolean value.\n     *\n     * @return A hash value.\n     *\n     * @since 1.0.7\n     */\n    public static int hashCode(int pre, boolean b) {\n        return 37 * pre + (b ? 0 : 1);\n    }\n\n    /**\n     * Returns a hash value based on a seed value and the value of an int\n     * primitive.\n     *\n     * @param pre  the seed value.\n     * @param i  the int value.\n     *\n     * @return A hash value.\n     *\n     * @since 1.0.8\n     */\n    public static int hashCode(int pre, int i) {\n        return 37 * pre + i;\n    }\n\n    /**\n     * Returns a hash value based on a seed value and the value of a double\n     * primitive.\n     *\n     * @param pre  the seed value.\n     * @param d  the double value.\n     *\n     * @return A hash value.\n     *\n     * @since 1.0.7\n     */\n    public static int hashCode(int pre, double d) {\n        long l = Double.doubleToLongBits(d);\n        return 37 * pre + (int) (l ^ (l >>> 32));\n    }\n\n    /**\n     * Returns a hash value based on a seed value and a paint instance.\n     *\n     * @param pre  the seed value.\n     * @param p  the paint (<code>null</code> permitted).\n     *\n     * @return A hash value.\n     *\n     * @since 1.0.7\n     */\n    public static int hashCode(int pre, Paint p) {\n        return 37 * pre + hashCodeForPaint(p);\n    }\n\n    /**\n     * Returns a hash value based on a seed value and a stroke instance.\n     *\n     * @param pre  the seed value.\n     * @param s  the stroke (<code>null</code> permitted).\n     *\n     * @return A hash value.\n     *\n     * @since 1.0.7\n     */\n    public static int hashCode(int pre, Stroke s) {\n        int h = (s != null ? s.hashCode() : 0);\n        return 37 * pre + h;\n    }\n\n    /**\n     * Returns a hash value based on a seed value and a string instance.\n     *\n     * @param pre  the seed value.\n     * @param s  the string (<code>null</code> permitted).\n     *\n     * @return A hash value.\n     *\n     * @since 1.0.7\n     */\n    public static int hashCode(int pre, String s) {\n        int h = (s != null ? s.hashCode() : 0);\n        return 37 * pre + h;\n    }\n\n    /**\n     * Returns a hash value based on a seed value and a <code>Comparable</code>\n     * instance.\n     *\n     * @param pre  the seed value.\n     * @param c  the comparable (<code>null</code> permitted).\n     *\n     * @return A hash value.\n     *\n     * @since 1.0.7\n     */\n    public static int hashCode(int pre, Comparable c) {\n        int h = (c != null ? c.hashCode() : 0);\n        return 37 * pre + h;\n    }\n\n    /**\n     * Returns a hash value based on a seed value and an <code>Object</code>\n     * instance.\n     *\n     * @param pre  the seed value.\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A hash value.\n     *\n     * @since 1.0.8\n     */\n    public static int hashCode(int pre, Object obj) {\n        int h = (obj != null ? obj.hashCode() : 0);\n        return 37 * pre + h;\n    }\n\n}", "class_name": "HashUtilities", "return_type": "int", "parameters": [{"type": "double[]", "name": "a"}]}}
{"prompt": "class ChartPanel extends JPanel implements ChartChangeListener,\n        ChartProgressListener, ActionListener, MouseListener,\n        MouseMotionListener, OverlayChangeListener, RenderingSource,\n        Printable, Serializable {\n\n    /**\n     * Add an overlay to the panel.\n     *\n     * @param overlay  the overlay (<code>null</code> not permitted).\n     *\n     * @since 1.0.13\n     */\n    public void addOverlay(Overlay overlay) {\n        if (overlay == null) {\n            throw new IllegalArgumentException(\"Null 'overlay' argument.\");\n        }\n        this.overlays.add(overlay);\n        overlay.addChangeListener(this);\n        repaint();\n    }\n\n    /**\n     * Removes an overlay from the panel.\n     *\n     * @param overlay  the overlay to remove (<code>null</code> not permitted).\n     *\n     * @since 1.0.13\n     */\n    public void removeOverlay(Overlay overlay) {\n        if (overlay == null) {\n            throw new IllegalArgumentException(\"Null 'overlay' argument.\");\n        }\n        boolean removed = this.overlays.remove(overlay);\n        if (removed) {\n            overlay.removeChangeListener(this);\n            repaint();\n        }\n    }\n\n    /**\n     * Handles a change to an overlay by repainting the panel.\n     *\n     * @param event  the event.\n     *\n     * @since 1.0.13\n     */\n    public void overlayChanged(OverlayChangeEvent event) {\n        repaint();\n    }\n\n    /**\n     * Returns the value of the <code>useBuffer</code> flag as set in the\n     * constructor.\n     *\n     * @return A boolean.\n     *\n     * @since 1.2.0\n     */\n    public boolean getUseBuffer() {\n        return this.useBuffer;\n    }\n\n    /**\n     * Returns the orientation of the plot in the panel.\n     *\n     * @return The orientation of the plot.\n     *\n     * @since 1.2.0\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Adds a mouse handler.\n     *\n     * @param handler  the handler (<code>null</code> not permitted).\n     *\n     * @see #removeMouseHandler(org.jfree.chart.panel.AbstractMouseHandler)\n     *\n     * @since 1.2.0\n     */\n    public void addMouseHandler(AbstractMouseHandler handler) {\n        if (handler == null) {\n            throw new IllegalArgumentException(\"Null 'handler' argument.\");\n        }\n        this.availableMouseHandlers.add(handler);\n    }\n\n    /**\n     * Removes a mouse handler.\n     *\n     * @param handler  the handler (<code>null</code> not permitted).\n     *\n     * @return A boolean.\n     *\n     * @see #addMouseHandler(org.jfree.chart.panel.AbstractMouseHandler)\n     *\n     * @since 1.2.0\n     */\n    public boolean removeMouseHandler(AbstractMouseHandler handler) {\n        if (handler == null) {\n            throw new IllegalArgumentException(\"Null 'handler' argument.\");\n        }\n        return this.availableMouseHandlers.remove(handler);\n    }\n\n    /**\n     * Clears the 'liveMouseHandler' field.  Each handler is responsible for\n     * calling this method when they have finished handling mouse events.\n     *\n     * @since 1.2.0\n     */\n    public void clearLiveMouseHandler() {\n        this.liveMouseHandler = null;\n    }\n\n    /**\n     * Returns the zoom handler.\n     *\n     * @return The zoom handler.\n     *\n     * @since 1.2.0\n     */\n    public ZoomHandler getZoomHandler() {\n        return this.zoomHandler;\n    }\n\n    /**\n     * Returns the zoom rectangle.\n     *\n     * @return The zoom rectangle (possibly <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    public Rectangle2D getZoomRectangle() {\n        return this.zoomRectangle;\n    }\n\n    /**\n     * Sets the zoom rectangle for the panel.\n     *\n     * @param rect  the rectangle (<code>null</code> permitted).\n     *\n     * @since 1.2.0\n     */\n    public void setZoomRectangle(Rectangle2D rect) {\n        this.zoomRectangle = rect;\n    }\n\n    /**\n     * Switches the display of tooltips for the panel on or off.  Note that\n     * tooltips can only be displayed if the chart has been configured to\n     * generate tooltip items.\n     *\n     * @param flag  <code>true</code> to enable tooltips, <code>false</code> to\n     *              disable tooltips.\n     */\n    public void setDisplayToolTips(boolean flag) {\n        if (flag) {\n            ToolTipManager.sharedInstance().registerComponent(this);\n        }\n        else {\n            ToolTipManager.sharedInstance().unregisterComponent(this);\n        }\n    }\n\n    /**\n     * Returns a string for the tooltip.\n     *\n     * @param e  the mouse event.\n     *\n     * @return A tool tip or <code>null</code> if no tooltip is available.\n     */\n    public String getToolTipText(MouseEvent e) {\n\n        String result = null;\n        if (this.info != null) {\n            EntityCollection entities = this.info.getEntityCollection();\n            if (entities != null) {\n                Insets insets = getInsets();\n                ChartEntity entity = entities.getEntity(\n                        (int) ((e.getX() - insets.left) / this.scaleX),\n                        (int) ((e.getY() - insets.top) / this.scaleY));\n                if (entity != null) {\n                    result = entity.getToolTipText();\n                }\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location.\n     */\n    public Point translateJava2DToScreen(Point2D java2DPoint) {\n        Insets insets = getInsets();\n        int x = (int) (java2DPoint.getX() * this.scaleX + insets.left);\n        int y = (int) (java2DPoint.getY() * this.scaleY + insets.top);\n        return new Point(x, y);\n    }\n\n    /**\n     * Translates a panel (component) location to a Java2D point.\n     *\n     * @param screenPoint  the screen location (<code>null</code> not\n     *                     permitted).\n     *\n     * @return The Java2D coordinates.\n     */\n    public Point2D translateScreenToJava2D(Point screenPoint) {", "metadata": {"defects4j_task_id": "2ed3b966732334bae4f913db91d3f7326784792b6b10779d3c893bf74f980433", "task_id": "jfree_jfreechart/40", "ground_truth": "\n        Insets insets = getInsets();\n        double x = (screenPoint.getX() - insets.left) / this.scaleX;\n        double y = (screenPoint.getY() - insets.top) / this.scaleY;\n        return new Point2D.Double(x, y);\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "ChartPanel.java"], "context_start_lineno": 0, "function_name": "translateScreenToJava2D", "left_context": "class ChartPanel extends JPanel implements ChartChangeListener,\n        ChartProgressListener, ActionListener, MouseListener,\n        MouseMotionListener, OverlayChangeListener, RenderingSource,\n        Printable, Serializable {\n\n    /**\n     * Add an overlay to the panel.\n     *\n     * @param overlay  the overlay (<code>null</code> not permitted).\n     *\n     * @since 1.0.13\n     */\n    public void addOverlay(Overlay overlay) {\n        if (overlay == null) {\n            throw new IllegalArgumentException(\"Null 'overlay' argument.\");\n        }\n        this.overlays.add(overlay);\n        overlay.addChangeListener(this);\n        repaint();\n    }\n\n    /**\n     * Removes an overlay from the panel.\n     *\n     * @param overlay  the overlay to remove (<code>null</code> not permitted).\n     *\n     * @since 1.0.13\n     */\n    public void removeOverlay(Overlay overlay) {\n        if (overlay == null) {\n            throw new IllegalArgumentException(\"Null 'overlay' argument.\");\n        }\n        boolean removed = this.overlays.remove(overlay);\n        if (removed) {\n            overlay.removeChangeListener(this);\n            repaint();\n        }\n    }\n\n    /**\n     * Handles a change to an overlay by repainting the panel.\n     *\n     * @param event  the event.\n     *\n     * @since 1.0.13\n     */\n    public void overlayChanged(OverlayChangeEvent event) {\n        repaint();\n    }\n\n    /**\n     * Returns the value of the <code>useBuffer</code> flag as set in the\n     * constructor.\n     *\n     * @return A boolean.\n     *\n     * @since 1.2.0\n     */\n    public boolean getUseBuffer() {\n        return this.useBuffer;\n    }\n\n    /**\n     * Returns the orientation of the plot in the panel.\n     *\n     * @return The orientation of the plot.\n     *\n     * @since 1.2.0\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Adds a mouse handler.\n     *\n     * @param handler  the handler (<code>null</code> not permitted).\n     *\n     * @see #removeMouseHandler(org.jfree.chart.panel.AbstractMouseHandler)\n     *\n     * @since 1.2.0\n     */\n    public void addMouseHandler(AbstractMouseHandler handler) {\n        if (handler == null) {\n            throw new IllegalArgumentException(\"Null 'handler' argument.\");\n        }\n        this.availableMouseHandlers.add(handler);\n    }\n\n    /**\n     * Removes a mouse handler.\n     *\n     * @param handler  the handler (<code>null</code> not permitted).\n     *\n     * @return A boolean.\n     *\n     * @see #addMouseHandler(org.jfree.chart.panel.AbstractMouseHandler)\n     *\n     * @since 1.2.0\n     */\n    public boolean removeMouseHandler(AbstractMouseHandler handler) {\n        if (handler == null) {\n            throw new IllegalArgumentException(\"Null 'handler' argument.\");\n        }\n        return this.availableMouseHandlers.remove(handler);\n    }\n\n    /**\n     * Clears the 'liveMouseHandler' field.  Each handler is responsible for\n     * calling this method when they have finished handling mouse events.\n     *\n     * @since 1.2.0\n     */\n    public void clearLiveMouseHandler() {\n        this.liveMouseHandler = null;\n    }\n\n    /**\n     * Returns the zoom handler.\n     *\n     * @return The zoom handler.\n     *\n     * @since 1.2.0\n     */\n    public ZoomHandler getZoomHandler() {\n        return this.zoomHandler;\n    }\n\n    /**\n     * Returns the zoom rectangle.\n     *\n     * @return The zoom rectangle (possibly <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    public Rectangle2D getZoomRectangle() {\n        return this.zoomRectangle;\n    }\n\n    /**\n     * Sets the zoom rectangle for the panel.\n     *\n     * @param rect  the rectangle (<code>null</code> permitted).\n     *\n     * @since 1.2.0\n     */\n    public void setZoomRectangle(Rectangle2D rect) {\n        this.zoomRectangle = rect;\n    }\n\n    /**\n     * Switches the display of tooltips for the panel on or off.  Note that\n     * tooltips can only be displayed if the chart has been configured to\n     * generate tooltip items.\n     *\n     * @param flag  <code>true</code> to enable tooltips, <code>false</code> to\n     *              disable tooltips.\n     */\n    public void setDisplayToolTips(boolean flag) {\n        if (flag) {\n            ToolTipManager.sharedInstance().registerComponent(this);\n        }\n        else {\n            ToolTipManager.sharedInstance().unregisterComponent(this);\n        }\n    }\n\n    /**\n     * Returns a string for the tooltip.\n     *\n     * @param e  the mouse event.\n     *\n     * @return A tool tip or <code>null</code> if no tooltip is available.\n     */\n    public String getToolTipText(MouseEvent e) {\n\n        String result = null;\n        if (this.info != null) {\n            EntityCollection entities = this.info.getEntityCollection();\n            if (entities != null) {\n                Insets insets = getInsets();\n                ChartEntity entity = entities.getEntity(\n                        (int) ((e.getX() - insets.left) / this.scaleX),\n                        (int) ((e.getY() - insets.top) / this.scaleY));\n                if (entity != null) {\n                    result = entity.getToolTipText();\n                }\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location.\n     */\n    public Point translateJava2DToScreen(Point2D java2DPoint) {\n        Insets insets = getInsets();\n        int x = (int) (java2DPoint.getX() * this.scaleX + insets.left);\n        int y = (int) (java2DPoint.getY() * this.scaleY + insets.top);\n        return new Point(x, y);\n    }\n\n    /**\n     * Translates a panel (component) location to a Java2D point.\n     *\n     * @param screenPoint  the screen location (<code>null</code> not\n     *                     permitted).\n     *\n     * @return The Java2D coordinates.\n     */\n    public Point2D translateScreenToJava2D(Point screenPoint) {", "right_context": "}\n\n}", "class_name": "ChartPanel", "return_type": "Point2D", "parameters": [{"type": "Point", "name": "screenPoint"}]}}
{"prompt": "class CategoryAxis extends Axis implements Cloneable, Serializable {\n\n    /**\n     * A utility method for determining the height of a text block.\n     *\n     * @param block  the text block.\n     * @param position  the label position.\n     * @param g2  the graphics device.\n     *\n     * @return The height.\n     */\n    protected double calculateTextBlockHeight(TextBlock block,\n                                              CategoryLabelPosition position,\n                                              Graphics2D g2) {\n\n        RectangleInsets insets = getTickLabelInsets();\n        Size2D size = block.calculateDimensions(g2);\n        Rectangle2D box = new Rectangle2D.Double(0.0, 0.0, size.getWidth(),\n                size.getHeight());\n        Shape rotatedBox = ShapeUtilities.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double h = rotatedBox.getBounds2D().getHeight()\n                   + insets.getTop() + insets.getBottom();\n        return h;\n\n    }\n\n    /**\n     * Creates a clone of the axis.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the axis does\n     *         not support cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        CategoryAxis clone = (CategoryAxis) super.clone();\n        clone.tickLabelFontMap = new HashMap(this.tickLabelFontMap);\n        clone.tickLabelPaintMap = new HashMap(this.tickLabelPaintMap);\n        clone.categoryLabelToolTips = new HashMap(this.categoryLabelToolTips);\n        return clone;\n    }\n\n    /**\n     * Tests this axis for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryAxis)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        CategoryAxis that = (CategoryAxis) obj;\n        if (that.lowerMargin != this.lowerMargin) {\n            return false;\n        }\n        if (that.upperMargin != this.upperMargin) {\n            return false;\n        }\n        if (that.categoryMargin != this.categoryMargin) {\n            return false;\n        }\n        if (that.maximumCategoryLabelWidthRatio\n                != this.maximumCategoryLabelWidthRatio) {\n            return false;\n        }\n        if (that.categoryLabelPositionOffset\n                != this.categoryLabelPositionOffset) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(that.categoryLabelPositions,\n                this.categoryLabelPositions)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(that.categoryLabelToolTips,\n                this.categoryLabelToolTips)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.tickLabelFontMap,\n                that.tickLabelFontMap)) {\n            return false;\n        }\n        if (!equalPaintMaps(this.tickLabelPaintMap, that.tickLabelPaintMap)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        if (getLabel() != null) {\n            return getLabel().hashCode();\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        writePaintMap(this.tickLabelPaintMap, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.tickLabelPaintMap = readPaintMap(stream);\n    }\n\n    /**\n     * Reads a <code>Map</code> of (<code>Comparable</code>, <code>Paint</code>)\n     * elements from a stream.\n     *\n     * @param in  the input stream.\n     *\n     * @return The map.\n     *\n     * @throws IOException\n     * @throws ClassNotFoundException\n     *\n     * @see #writePaintMap(Map, ObjectOutputStream)\n     */\n    private Map readPaintMap(ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        boolean isNull = in.readBoolean();\n        if (isNull) {\n            return null;\n        }\n        Map result = new HashMap();\n        int count = in.readInt();\n        for (int i = 0; i < count; i++) {\n            Comparable category = (Comparable) in.readObject();\n            Paint paint = SerialUtilities.readPaint(in);\n            result.put(category, paint);\n        }\n        return result;\n    }\n\n    /**\n     * Writes a map of (<code>Comparable</code>, <code>Paint</code>)\n     * elements to a stream.\n     *\n     * @param map  the map (<code>null</code> permitted).\n     *\n     * @param out\n     * @throws IOException\n     *\n     * @see #readPaintMap(ObjectInputStream)\n     */\n    private void writePaintMap(Map map, ObjectOutputStream out)\n            throws IOException {\n        if (map == null) {\n            out.writeBoolean(true);\n        }\n        else {\n            out.writeBoolean(false);\n            Set keys = map.keySet();\n            int count = keys.size();\n            out.writeInt(count);\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Comparable key = (Comparable) iterator.next();\n                out.writeObject(key);\n                SerialUtilities.writePaint((Paint) map.get(key), out);\n            }\n        }\n    }\n\n    /**\n     * Tests two maps containing (<code>Comparable</code>, <code>Paint</code>)\n     * elements for equality.\n     *\n     * @param map1  the first map (<code>null</code> not permitted).\n     * @param map2  the second map (<code>null</code> not permitted).\n     *\n     * @return A boolean.\n     */\n    private boolean equalPaintMaps(Map map1, Map map2) {", "metadata": {"defects4j_task_id": "af8b3e65b9ca0d5b8073927bd330ed2d58af9f773ba3726c3931a87f6d024196", "task_id": "jfree_jfreechart/149", "ground_truth": "\n        if (map1.size() != map2.size()) {\n            return false;\n        }\n        Set entries = map1.entrySet();\n        Iterator iterator = entries.iterator();\n        while (iterator.hasNext()) {\n            Map.Entry entry = (Map.Entry) iterator.next();\n            Paint p1 = (Paint) entry.getValue();\n            Paint p2 = (Paint) map2.get(entry.getKey());\n            if (!PaintUtilities.equal(p1, p2)) {\n                return false;\n            }\n        }\n        return true;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "axis", "CategoryAxis.java"], "context_start_lineno": 0, "function_name": "equalPaintMaps", "left_context": "class CategoryAxis extends Axis implements Cloneable, Serializable {\n\n    /**\n     * A utility method for determining the height of a text block.\n     *\n     * @param block  the text block.\n     * @param position  the label position.\n     * @param g2  the graphics device.\n     *\n     * @return The height.\n     */\n    protected double calculateTextBlockHeight(TextBlock block,\n                                              CategoryLabelPosition position,\n                                              Graphics2D g2) {\n\n        RectangleInsets insets = getTickLabelInsets();\n        Size2D size = block.calculateDimensions(g2);\n        Rectangle2D box = new Rectangle2D.Double(0.0, 0.0, size.getWidth(),\n                size.getHeight());\n        Shape rotatedBox = ShapeUtilities.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double h = rotatedBox.getBounds2D().getHeight()\n                   + insets.getTop() + insets.getBottom();\n        return h;\n\n    }\n\n    /**\n     * Creates a clone of the axis.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the axis does\n     *         not support cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        CategoryAxis clone = (CategoryAxis) super.clone();\n        clone.tickLabelFontMap = new HashMap(this.tickLabelFontMap);\n        clone.tickLabelPaintMap = new HashMap(this.tickLabelPaintMap);\n        clone.categoryLabelToolTips = new HashMap(this.categoryLabelToolTips);\n        return clone;\n    }\n\n    /**\n     * Tests this axis for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryAxis)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        CategoryAxis that = (CategoryAxis) obj;\n        if (that.lowerMargin != this.lowerMargin) {\n            return false;\n        }\n        if (that.upperMargin != this.upperMargin) {\n            return false;\n        }\n        if (that.categoryMargin != this.categoryMargin) {\n            return false;\n        }\n        if (that.maximumCategoryLabelWidthRatio\n                != this.maximumCategoryLabelWidthRatio) {\n            return false;\n        }\n        if (that.categoryLabelPositionOffset\n                != this.categoryLabelPositionOffset) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(that.categoryLabelPositions,\n                this.categoryLabelPositions)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(that.categoryLabelToolTips,\n                this.categoryLabelToolTips)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.tickLabelFontMap,\n                that.tickLabelFontMap)) {\n            return false;\n        }\n        if (!equalPaintMaps(this.tickLabelPaintMap, that.tickLabelPaintMap)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        if (getLabel() != null) {\n            return getLabel().hashCode();\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        writePaintMap(this.tickLabelPaintMap, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.tickLabelPaintMap = readPaintMap(stream);\n    }\n\n    /**\n     * Reads a <code>Map</code> of (<code>Comparable</code>, <code>Paint</code>)\n     * elements from a stream.\n     *\n     * @param in  the input stream.\n     *\n     * @return The map.\n     *\n     * @throws IOException\n     * @throws ClassNotFoundException\n     *\n     * @see #writePaintMap(Map, ObjectOutputStream)\n     */\n    private Map readPaintMap(ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        boolean isNull = in.readBoolean();\n        if (isNull) {\n            return null;\n        }\n        Map result = new HashMap();\n        int count = in.readInt();\n        for (int i = 0; i < count; i++) {\n            Comparable category = (Comparable) in.readObject();\n            Paint paint = SerialUtilities.readPaint(in);\n            result.put(category, paint);\n        }\n        return result;\n    }\n\n    /**\n     * Writes a map of (<code>Comparable</code>, <code>Paint</code>)\n     * elements to a stream.\n     *\n     * @param map  the map (<code>null</code> permitted).\n     *\n     * @param out\n     * @throws IOException\n     *\n     * @see #readPaintMap(ObjectInputStream)\n     */\n    private void writePaintMap(Map map, ObjectOutputStream out)\n            throws IOException {\n        if (map == null) {\n            out.writeBoolean(true);\n        }\n        else {\n            out.writeBoolean(false);\n            Set keys = map.keySet();\n            int count = keys.size();\n            out.writeInt(count);\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Comparable key = (Comparable) iterator.next();\n                out.writeObject(key);\n                SerialUtilities.writePaint((Paint) map.get(key), out);\n            }\n        }\n    }\n\n    /**\n     * Tests two maps containing (<code>Comparable</code>, <code>Paint</code>)\n     * elements for equality.\n     *\n     * @param map1  the first map (<code>null</code> not permitted).\n     * @param map2  the second map (<code>null</code> not permitted).\n     *\n     * @return A boolean.\n     */\n    private boolean equalPaintMaps(Map map1, Map map2) {", "right_context": "}}\n\n}", "class_name": "CategoryAxis", "return_type": "boolean", "parameters": [{"type": "Map", "name": "map1"}, {"type": "Map", "name": "map2"}]}}
{"prompt": "class LogarithmicAxis extends NumberAxis {\n\n    /**\n     * Returns the 'strictValuesFlag' flag; if true and 'allowNegativesFlag'\n     * is false then this axis will throw a runtime exception if any of its\n     * values are less than or equal to zero; if false then the axis will\n     * adjust for values less than or equal to zero as needed.\n     *\n     * @return <code>true</code> if strict enforcement is enabled.\n     */\n    public boolean getStrictValuesFlag() {\n        return this.strictValuesFlag;\n    }\n\n    /**\n     * Sets the 'expTickLabelsFlag' flag.  If the 'log10TickLabelsFlag'\n     * is false then this will set whether or not \"1e#\"-style tick labels\n     * are used.  The default is to use regular numeric tick labels.\n     *\n     * @param flgVal true for \"1e#\"-style tick labels, false for\n     * log10 or regular numeric tick labels.\n     */\n    public void setExpTickLabelsFlag(boolean flgVal) {\n        this.expTickLabelsFlag = flgVal;\n        setupNumberFmtObj();             //setup number formatter obj\n    }\n\n    /**\n     * Returns the 'expTickLabelsFlag' flag.\n     *\n     * @return <code>true</code> for \"1e#\"-style tick labels,\n     *         <code>false</code> for log10 or regular numeric tick labels.\n     */\n    public boolean getExpTickLabelsFlag() {\n      return this.expTickLabelsFlag;\n    }\n\n    /**\n     * Sets the 'log10TickLabelsFlag' flag.  The default value is false.\n     *\n     * @param flag true for \"10^n\"-style tick labels, false for \"1e#\"-style\n     * or regular numeric tick labels.\n     */\n    public void setLog10TickLabelsFlag(boolean flag) {\n        this.log10TickLabelsFlag = flag;\n    }\n\n    /**\n     * Returns the 'log10TickLabelsFlag' flag.\n     *\n     * @return <code>true</code> for \"10^n\"-style tick labels,\n     *         <code>false</code> for \"1e#\"-style or regular numeric tick\n     *         labels.\n     */\n    public boolean getLog10TickLabelsFlag() {\n        return this.log10TickLabelsFlag;\n    }\n\n    /**\n     * Sets the 'autoRangeNextLogFlag' flag.  This determines whether or\n     * not the 'autoAdjustRange()' method will select the next \"10^n\"\n     * values when determining the upper and lower bounds.  The default\n     * value is false.\n     *\n     * @param flag <code>true</code> to make the 'autoAdjustRange()'\n     * method select the next \"10^n\" values, <code>false</code> to not.\n     */\n    public void setAutoRangeNextLogFlag(boolean flag) {\n        this.autoRangeNextLogFlag = flag;\n    }\n\n    /**\n     * Returns the 'autoRangeNextLogFlag' flag.\n     *\n     * @return <code>true</code> if the 'autoAdjustRange()' method will\n     * select the next \"10^n\" values, <code>false</code> if not.\n     */\n    public boolean getAutoRangeNextLogFlag() {\n        return this.autoRangeNextLogFlag;\n    }\n\n    /**\n     * Overridden version that calls original and then sets up flag for\n     * log axis processing.\n     *\n     * @param range  the new range.\n     */\n    public void setRange(Range range) {\n        super.setRange(range);      // call parent method\n        setupSmallLogFlag();        // setup flag based on bounds values\n    }\n\n    /**\n     * Sets up flag for log axis processing.  Set true if negative values\n     * not allowed and the lower bound is between 0 and 10.\n     */\n    protected void setupSmallLogFlag() {\n        // set flag true if negative values not allowed and the\n        // lower bound is between 0 and 10:\n        double lowerVal = getRange().getLowerBound();\n        this.smallLogFlag = (!this.allowNegativesFlag && lowerVal < 10.0\n                && lowerVal > 0.0);\n    }\n\n    /**\n     * Sets up the number formatter object according to the\n     * 'expTickLabelsFlag' flag.\n     */\n    protected void setupNumberFmtObj() {\n        if (this.numberFormatterObj instanceof DecimalFormat) {\n            //setup for \"1e#\"-style tick labels or regular\n            // numeric tick labels, depending on flag:\n            ((DecimalFormat) this.numberFormatterObj).applyPattern(\n                    this.expTickLabelsFlag ? \"0E0\" : \"0.###\");\n        }\n    }\n\n    /**\n     * Returns the log10 value, depending on if values between 0 and\n     * 1 are being plotted.  If negative values are not allowed and\n     * the lower bound is between 0 and 10 then a normal log is\n     * returned; otherwise the returned value is adjusted if the\n     * given value is less than 10.\n     *\n     * @param val the value.\n     *\n     * @return log<sub>10</sub>(val).\n     *\n     * @see #switchedPow10(double)\n     */\n    protected double switchedLog10(double val) {\n        return this.smallLogFlag ? Math.log(val)\n                / LOG10_VALUE : adjustedLog10(val);\n    }\n\n    /**\n     * Returns a power of 10, depending on if values between 0 and\n     * 1 are being plotted.  If negative values are not allowed and\n     * the lower bound is between 0 and 10 then a normal power is\n     * returned; otherwise the returned value is adjusted if the\n     * given value is less than 1.\n     *\n     * @param val the value.\n     *\n     * @return 10<sup>val</sup>.\n     *\n     * @since 1.0.5\n     * @see #switchedLog10(double)\n     */\n    public double switchedPow10(double val) {\n        return this.smallLogFlag ? Math.pow(10.0, val) : adjustedPow10(val);\n    }\n\n    /**\n     * Returns an adjusted log10 value for graphing purposes.  The first\n     * adjustment is that negative values are changed to positive during\n     * the calculations, and then the answer is negated at the end.  The\n     * second is that, for values less than 10, an increasingly large\n     * (0 to 1) scaling factor is added such that at 0 the value is\n     * adjusted to 1, resulting in a returned result of 0.\n     *\n     * @param val  value for which log10 should be calculated.\n     *\n     * @return An adjusted log<sub>10</sub>(val).\n     *\n     * @see #adjustedPow10(double)\n     */\n    public double adjustedLog10(double val) {", "metadata": {"defects4j_task_id": "31d6ff7bc1a61f922aa17944de9ebf3284748b0565cc0000af203b2299e89a27", "task_id": "jfree_jfreechart/44", "ground_truth": "\n        boolean negFlag = (val < 0.0);\n        if (negFlag) {\n            val = -val;          // if negative then set flag and make positive\n        }\n        if (val < 10.0) {                // if < 10 then\n            val += (10.0 - val) / 10.0;  //increase so 0 translates to 0\n        }\n        //return value; negate if original value was negative:\n        double res = Math.log(val) / LOG10_VALUE;\n        return negFlag ? (-res) : res;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "axis", "LogarithmicAxis.java"], "context_start_lineno": 0, "function_name": "adjustedLog10", "left_context": "class LogarithmicAxis extends NumberAxis {\n\n    /**\n     * Returns the 'strictValuesFlag' flag; if true and 'allowNegativesFlag'\n     * is false then this axis will throw a runtime exception if any of its\n     * values are less than or equal to zero; if false then the axis will\n     * adjust for values less than or equal to zero as needed.\n     *\n     * @return <code>true</code> if strict enforcement is enabled.\n     */\n    public boolean getStrictValuesFlag() {\n        return this.strictValuesFlag;\n    }\n\n    /**\n     * Sets the 'expTickLabelsFlag' flag.  If the 'log10TickLabelsFlag'\n     * is false then this will set whether or not \"1e#\"-style tick labels\n     * are used.  The default is to use regular numeric tick labels.\n     *\n     * @param flgVal true for \"1e#\"-style tick labels, false for\n     * log10 or regular numeric tick labels.\n     */\n    public void setExpTickLabelsFlag(boolean flgVal) {\n        this.expTickLabelsFlag = flgVal;\n        setupNumberFmtObj();             //setup number formatter obj\n    }\n\n    /**\n     * Returns the 'expTickLabelsFlag' flag.\n     *\n     * @return <code>true</code> for \"1e#\"-style tick labels,\n     *         <code>false</code> for log10 or regular numeric tick labels.\n     */\n    public boolean getExpTickLabelsFlag() {\n      return this.expTickLabelsFlag;\n    }\n\n    /**\n     * Sets the 'log10TickLabelsFlag' flag.  The default value is false.\n     *\n     * @param flag true for \"10^n\"-style tick labels, false for \"1e#\"-style\n     * or regular numeric tick labels.\n     */\n    public void setLog10TickLabelsFlag(boolean flag) {\n        this.log10TickLabelsFlag = flag;\n    }\n\n    /**\n     * Returns the 'log10TickLabelsFlag' flag.\n     *\n     * @return <code>true</code> for \"10^n\"-style tick labels,\n     *         <code>false</code> for \"1e#\"-style or regular numeric tick\n     *         labels.\n     */\n    public boolean getLog10TickLabelsFlag() {\n        return this.log10TickLabelsFlag;\n    }\n\n    /**\n     * Sets the 'autoRangeNextLogFlag' flag.  This determines whether or\n     * not the 'autoAdjustRange()' method will select the next \"10^n\"\n     * values when determining the upper and lower bounds.  The default\n     * value is false.\n     *\n     * @param flag <code>true</code> to make the 'autoAdjustRange()'\n     * method select the next \"10^n\" values, <code>false</code> to not.\n     */\n    public void setAutoRangeNextLogFlag(boolean flag) {\n        this.autoRangeNextLogFlag = flag;\n    }\n\n    /**\n     * Returns the 'autoRangeNextLogFlag' flag.\n     *\n     * @return <code>true</code> if the 'autoAdjustRange()' method will\n     * select the next \"10^n\" values, <code>false</code> if not.\n     */\n    public boolean getAutoRangeNextLogFlag() {\n        return this.autoRangeNextLogFlag;\n    }\n\n    /**\n     * Overridden version that calls original and then sets up flag for\n     * log axis processing.\n     *\n     * @param range  the new range.\n     */\n    public void setRange(Range range) {\n        super.setRange(range);      // call parent method\n        setupSmallLogFlag();        // setup flag based on bounds values\n    }\n\n    /**\n     * Sets up flag for log axis processing.  Set true if negative values\n     * not allowed and the lower bound is between 0 and 10.\n     */\n    protected void setupSmallLogFlag() {\n        // set flag true if negative values not allowed and the\n        // lower bound is between 0 and 10:\n        double lowerVal = getRange().getLowerBound();\n        this.smallLogFlag = (!this.allowNegativesFlag && lowerVal < 10.0\n                && lowerVal > 0.0);\n    }\n\n    /**\n     * Sets up the number formatter object according to the\n     * 'expTickLabelsFlag' flag.\n     */\n    protected void setupNumberFmtObj() {\n        if (this.numberFormatterObj instanceof DecimalFormat) {\n            //setup for \"1e#\"-style tick labels or regular\n            // numeric tick labels, depending on flag:\n            ((DecimalFormat) this.numberFormatterObj).applyPattern(\n                    this.expTickLabelsFlag ? \"0E0\" : \"0.###\");\n        }\n    }\n\n    /**\n     * Returns the log10 value, depending on if values between 0 and\n     * 1 are being plotted.  If negative values are not allowed and\n     * the lower bound is between 0 and 10 then a normal log is\n     * returned; otherwise the returned value is adjusted if the\n     * given value is less than 10.\n     *\n     * @param val the value.\n     *\n     * @return log<sub>10</sub>(val).\n     *\n     * @see #switchedPow10(double)\n     */\n    protected double switchedLog10(double val) {\n        return this.smallLogFlag ? Math.log(val)\n                / LOG10_VALUE : adjustedLog10(val);\n    }\n\n    /**\n     * Returns a power of 10, depending on if values between 0 and\n     * 1 are being plotted.  If negative values are not allowed and\n     * the lower bound is between 0 and 10 then a normal power is\n     * returned; otherwise the returned value is adjusted if the\n     * given value is less than 1.\n     *\n     * @param val the value.\n     *\n     * @return 10<sup>val</sup>.\n     *\n     * @since 1.0.5\n     * @see #switchedLog10(double)\n     */\n    public double switchedPow10(double val) {\n        return this.smallLogFlag ? Math.pow(10.0, val) : adjustedPow10(val);\n    }\n\n    /**\n     * Returns an adjusted log10 value for graphing purposes.  The first\n     * adjustment is that negative values are changed to positive during\n     * the calculations, and then the answer is negated at the end.  The\n     * second is that, for values less than 10, an increasingly large\n     * (0 to 1) scaling factor is added such that at 0 the value is\n     * adjusted to 1, resulting in a returned result of 0.\n     *\n     * @param val  value for which log10 should be calculated.\n     *\n     * @return An adjusted log<sub>10</sub>(val).\n     *\n     * @see #adjustedPow10(double)\n     */\n    public double adjustedLog10(double val) {", "right_context": "}\n\n}", "class_name": "LogarithmicAxis", "return_type": "double", "parameters": [{"type": "double", "name": "val"}]}}
{"prompt": "class SegmentedTimeline implements Timeline, Cloneable, Serializable {\n\n    /**\n     * Private internal class to represent a range of segments. This class is\n     * mainly used to store in one object a range of exception segments. This\n     * optimizes certain timelines that use a small segment size (like an\n     * intraday timeline) allowing them to express a day exception as one\n     * SegmentRange instead of multi Segments.\n     */\n    protected class SegmentRange extends Segment {\n\n        /** The number of segments in the range. */\n        private long segmentCount;\n\n        /**\n         * Creates a SegmentRange between a start and end domain values.\n         *\n         * @param fromMillisecond  start of the range\n         * @param toMillisecond  end of the range\n         */\n        public SegmentRange(long fromMillisecond, long toMillisecond) {\n\n            Segment start = getSegment(fromMillisecond);\n            Segment end = getSegment(toMillisecond);\n//            if (start.getSegmentStart() != fromMillisecond\n//                || end.getSegmentEnd() != toMillisecond) {\n//                throw new IllegalArgumentException(\"Invalid Segment Range [\"\n//                    + fromMillisecond + \",\" + toMillisecond + \"]\");\n//            }\n\n            this.millisecond = fromMillisecond;\n            this.segmentNumber = calculateSegmentNumber(fromMillisecond);\n            this.segmentStart = start.segmentStart;\n            this.segmentEnd = end.segmentEnd;\n            this.segmentCount\n                = (end.getSegmentNumber() - start.getSegmentNumber() + 1);\n        }\n\n        /**\n         * Returns the number of segments contained in this range.\n         *\n         * @return The segment count.\n         */\n        public long getSegmentCount() {\n            return this.segmentCount;\n        }\n\n        /**\n         * Returns a segment that is the intersection of this segment and the\n         * interval.\n         *\n         * @param from  the start of the interval.\n         * @param to  the end of the interval.\n         *\n         * @return The intersection.\n         */\n        public Segment intersect(long from, long to) {\n\n            // Segment fromSegment = getSegment(from);\n            // fromSegment.inc();\n            // Segment toSegment = getSegment(to);\n            // toSegment.dec();\n            long start = Math.max(from, this.segmentStart);\n            long end = Math.min(to, this.segmentEnd);\n            // long start = Math.max(\n            //     fromSegment.getSegmentStart(), this.segmentStart\n            // );\n            // long end = Math.min(toSegment.getSegmentEnd(), this.segmentEnd);\n            if (start <= end) {\n                return new SegmentRange(start, end);\n            }\n            else {\n                return null;\n            }\n        }\n\n        /**\n         * Returns true if all Segments of this SegmentRenge are an included\n         * segment and are not an exception.\n         *\n         * @return <code>true</code> or </code>false</code>.\n         */\n        public boolean inIncludeSegments() {", "metadata": {"defects4j_task_id": "6dfd3b90385b614acae377832569b9401e3fe468f880d4a34cc25841653b25a7", "task_id": "jfree_jfreechart/91", "ground_truth": "\n            for (Segment segment = getSegment(this.segmentStart);\n                segment.getSegmentStart() < this.segmentEnd;\n                segment.inc()) {\n                if (!segment.inIncludeSegments()) {\n                    return (false);\n                }\n            }\n            return true;\n        ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "axis", "SegmentedTimeline.java"], "context_start_lineno": 0, "function_name": "inIncludeSegments", "left_context": "class SegmentedTimeline implements Timeline, Cloneable, Serializable {\n\n    /**\n     * Private internal class to represent a range of segments. This class is\n     * mainly used to store in one object a range of exception segments. This\n     * optimizes certain timelines that use a small segment size (like an\n     * intraday timeline) allowing them to express a day exception as one\n     * SegmentRange instead of multi Segments.\n     */\n    protected class SegmentRange extends Segment {\n\n        /** The number of segments in the range. */\n        private long segmentCount;\n\n        /**\n         * Creates a SegmentRange between a start and end domain values.\n         *\n         * @param fromMillisecond  start of the range\n         * @param toMillisecond  end of the range\n         */\n        public SegmentRange(long fromMillisecond, long toMillisecond) {\n\n            Segment start = getSegment(fromMillisecond);\n            Segment end = getSegment(toMillisecond);\n//            if (start.getSegmentStart() != fromMillisecond\n//                || end.getSegmentEnd() != toMillisecond) {\n//                throw new IllegalArgumentException(\"Invalid Segment Range [\"\n//                    + fromMillisecond + \",\" + toMillisecond + \"]\");\n//            }\n\n            this.millisecond = fromMillisecond;\n            this.segmentNumber = calculateSegmentNumber(fromMillisecond);\n            this.segmentStart = start.segmentStart;\n            this.segmentEnd = end.segmentEnd;\n            this.segmentCount\n                = (end.getSegmentNumber() - start.getSegmentNumber() + 1);\n        }\n\n        /**\n         * Returns the number of segments contained in this range.\n         *\n         * @return The segment count.\n         */\n        public long getSegmentCount() {\n            return this.segmentCount;\n        }\n\n        /**\n         * Returns a segment that is the intersection of this segment and the\n         * interval.\n         *\n         * @param from  the start of the interval.\n         * @param to  the end of the interval.\n         *\n         * @return The intersection.\n         */\n        public Segment intersect(long from, long to) {\n\n            // Segment fromSegment = getSegment(from);\n            // fromSegment.inc();\n            // Segment toSegment = getSegment(to);\n            // toSegment.dec();\n            long start = Math.max(from, this.segmentStart);\n            long end = Math.min(to, this.segmentEnd);\n            // long start = Math.max(\n            //     fromSegment.getSegmentStart(), this.segmentStart\n            // );\n            // long end = Math.min(toSegment.getSegmentEnd(), this.segmentEnd);\n            if (start <= end) {\n                return new SegmentRange(start, end);\n            }\n            else {\n                return null;\n            }\n        }\n\n        /**\n         * Returns true if all Segments of this SegmentRenge are an included\n         * segment and are not an exception.\n         *\n         * @return <code>true</code> or </code>false</code>.\n         */\n        public boolean inIncludeSegments() {", "right_context": "}\n\n        /**\n         * Returns true if we are an excluded segment.\n         *\n         * @return <code>true</code> or </code>false</code>.\n         */\n        public boolean inExcludeSegments() {\n            for (Segment segment = getSegment(this.segmentStart);\n                segment.getSegmentStart() < this.segmentEnd;\n                segment.inc()) {\n                if (!segment.inExceptionSegments()) {\n                    return (false);\n                }\n            }\n            return true;\n        }\n\n        /**\n         * Not implemented for SegmentRange. Always throws\n         * IllegalArgumentException.\n         *\n         * @param n Number of segments to increment.\n         */\n        public void inc(long n) {\n            throw new IllegalArgumentException(\n                    \"Not implemented in SegmentRange\");\n        }\n\n    }\n\n\n}", "class_name": "SegmentedTimeline", "return_type": "boolean", "parameters": []}}
{"prompt": "class DateAxis extends ValueAxis implements Cloneable, Serializable {\n\n    /**\n     * Returns a {@link java.util.Date} corresponding to the specified position\n     * within a {@link RegularTimePeriod}.\n     *\n     * @param period  the period.\n     * @param position  the position (<code>null</code> not permitted).\n     *\n     * @return A date.\n     */\n    private Date calculateDateForPosition(RegularTimePeriod period,\n                                          DateTickMarkPosition position) {\n\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");\n        }\n        Date result = null;\n        if (position == DateTickMarkPosition.START) {\n            result = new Date(period.getFirstMillisecond());\n        }\n        else if (position == DateTickMarkPosition.MIDDLE) {\n            result = new Date(period.getMiddleMillisecond());\n        }\n        else if (position == DateTickMarkPosition.END) {\n            result = new Date(period.getLastMillisecond());\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the first \"standard\" date (based on the specified field and\n     * units).\n     *\n     * @param date  the reference date.\n     * @param unit  the date tick unit.\n     *\n     * @return The next \"standard\" date.\n     */\n    protected Date nextStandardDate(Date date, DateTickUnit unit) {", "metadata": {"defects4j_task_id": "58d50d13e8202b15982893a14f85d166773c21ab462b40966fa91e7a50c30f79", "task_id": "jfree_jfreechart/78", "ground_truth": "\n        Date previous = previousStandardDate(date, unit);\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(previous);\n        calendar.add(unit.getCalendarField(), unit.getMultiple());\n        return calendar.getTime();\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "axis", "DateAxis.java"], "context_start_lineno": 0, "function_name": "nextStandardDate", "left_context": "class DateAxis extends ValueAxis implements Cloneable, Serializable {\n\n    /**\n     * Returns a {@link java.util.Date} corresponding to the specified position\n     * within a {@link RegularTimePeriod}.\n     *\n     * @param period  the period.\n     * @param position  the position (<code>null</code> not permitted).\n     *\n     * @return A date.\n     */\n    private Date calculateDateForPosition(RegularTimePeriod period,\n                                          DateTickMarkPosition position) {\n\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");\n        }\n        Date result = null;\n        if (position == DateTickMarkPosition.START) {\n            result = new Date(period.getFirstMillisecond());\n        }\n        else if (position == DateTickMarkPosition.MIDDLE) {\n            result = new Date(period.getMiddleMillisecond());\n        }\n        else if (position == DateTickMarkPosition.END) {\n            result = new Date(period.getLastMillisecond());\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the first \"standard\" date (based on the specified field and\n     * units).\n     *\n     * @param date  the reference date.\n     * @param unit  the date tick unit.\n     *\n     * @return The next \"standard\" date.\n     */\n    protected Date nextStandardDate(Date date, DateTickUnit unit) {", "right_context": "}\n\n}", "class_name": "DateAxis", "return_type": "Date", "parameters": [{"type": "Date", "name": "date"}, {"type": "DateTickUnit", "name": "unit"}]}}
{"prompt": "class LogAxis extends ValueAxis {\n\n    /**\n     * Estimates the maximum width of the tick labels, assuming the specified\n     * tick unit is used.\n     * <P>\n     * Rather than computing the string bounds of every tick on the axis, we\n     * just look at two values: the lower bound and the upper bound for the\n     * axis.  These two values will usually be representative.\n     *\n     * @param g2  the graphics device.\n     * @param unit  the tick unit to use for calculation.\n     *\n     * @return The estimated maximum width of the tick labels.\n     *\n     * @since 1.0.7\n     */\n    protected double estimateMaximumTickLabelWidth(Graphics2D g2,\n                                                   TickUnit unit) {\n\n        RectangleInsets tickLabelInsets = getTickLabelInsets();\n        double result = tickLabelInsets.getLeft() + tickLabelInsets.getRight();\n\n        if (isVerticalTickLabels()) {\n            // all tick labels have the same width (equal to the height of the\n            // font)...\n            FontRenderContext frc = g2.getFontRenderContext();\n            LineMetrics lm = getTickLabelFont().getLineMetrics(\"0\", frc);\n            result += lm.getHeight();\n        }\n        else {\n            // look at lower and upper bounds...\n            FontMetrics fm = g2.getFontMetrics(getTickLabelFont());\n            Range range = getRange();\n            double lower = range.getLowerBound();\n            double upper = range.getUpperBound();\n            String lowerStr = \"\";\n            String upperStr = \"\";\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                lowerStr = formatter.format(lower);\n                upperStr = formatter.format(upper);\n            }\n            else {\n                lowerStr = unit.valueToString(lower);\n                upperStr = unit.valueToString(upper);\n            }\n            double w1 = fm.stringWidth(lowerStr);\n            double w2 = fm.stringWidth(upperStr);\n            result += Math.max(w1, w2);\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Zooms in on the current range.\n     *\n     * @param lowerPercent  the new lower bound.\n     * @param upperPercent  the new upper bound.\n     */\n    public void zoomRange(double lowerPercent, double upperPercent) {\n        Range range = getRange();\n        double start = range.getLowerBound();\n        double end = range.getUpperBound();\n        double log1 = calculateLog(start);\n        double log2 = calculateLog(end);\n        double length = log2 - log1;\n        Range adjusted = null;\n        if (isInverted()) {\n            double logA = log1 + length * (1 - upperPercent);\n            double logB = log1 + length * (1 - lowerPercent);\n            adjusted = new Range(calculateValue(logA), calculateValue(logB));\n        }\n        else {\n            double logA = log1 + length * lowerPercent;\n            double logB = log1 + length * upperPercent;\n            adjusted = new Range(calculateValue(logA), calculateValue(logB));\n        }\n        setRange(adjusted);\n    }\n\n    /**\n     * Slides the axis range by the specified percentage.\n     *\n     * @param percent  the percentage.\n     *\n     * @since 1.0.13\n     */\n    public void pan(double percent) {\n        Range range = getRange();\n        double lower = range.getLowerBound();\n        double upper = range.getUpperBound();\n        double log1 = calculateLog(lower);\n        double log2 = calculateLog(upper);\n        double length = log2 - log1;\n        double adj = length * percent;\n        log1 = log1 + adj;\n        log2 = log2 + adj;\n        setRange(calculateValue(log1), calculateValue(log2));\n    }\n\n    /**\n     * Creates a tick label for the specified value.  Note that this method\n     * was 'private' prior to version 1.0.10.\n     *\n     * @param value  the value.\n     *\n     * @return The label.\n     *\n     * @since 1.0.10\n     */\n    protected String createTickLabel(double value) {\n        if (this.numberFormatOverride != null) {\n            return this.numberFormatOverride.format(value);\n        }\n        else {\n            return this.tickUnit.valueToString(value);\n        }\n    }\n\n    /**\n     * Tests this axis for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof LogAxis)) {\n            return false;\n        }\n        LogAxis that = (LogAxis) obj;\n        if (this.base != that.base) {\n            return false;\n        }\n        if (this.smallestValue != that.smallestValue) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result = 193;\n        long temp = Double.doubleToLongBits(this.base);\n        result = 37 * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(this.smallestValue);\n        result = 37 * result + (int) (temp ^ (temp >>> 32));\n        if (this.numberFormatOverride != null) {\n            result = 37 * result + this.numberFormatOverride.hashCode();\n        }\n        result = 37 * result + this.tickUnit.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a collection of tick units for log (base 10) values.\n     * Uses a given Locale to create the DecimalFormats.\n     *\n     * @param locale the locale to use to represent Numbers.\n     *\n     * @return A collection of tick units for integer values.\n     *\n     * @since 1.0.7\n     */\n    public static TickUnitSource createLogTickUnits(Locale locale) {", "metadata": {"defects4j_task_id": "ff993d6805375a60c0a96f188a539fc9a1ac9e003b6c1ffeb94f145253b82a7a", "task_id": "jfree_jfreechart/209", "ground_truth": "\n        TickUnits units = new TickUnits();\n        NumberFormat numberFormat = new LogFormat();\n        units.add(new NumberTickUnit(0.05, numberFormat, 2));\n        units.add(new NumberTickUnit(0.1, numberFormat, 10));\n        units.add(new NumberTickUnit(0.2, numberFormat, 2));\n        units.add(new NumberTickUnit(0.5, numberFormat, 5));\n        units.add(new NumberTickUnit(1, numberFormat, 10));\n        units.add(new NumberTickUnit(2, numberFormat, 10));\n        units.add(new NumberTickUnit(3, numberFormat, 15));\n        units.add(new NumberTickUnit(4, numberFormat, 20));\n        units.add(new NumberTickUnit(5, numberFormat, 25));\n        units.add(new NumberTickUnit(6, numberFormat));\n        units.add(new NumberTickUnit(7, numberFormat));\n        units.add(new NumberTickUnit(8, numberFormat));\n        units.add(new NumberTickUnit(9, numberFormat));\n        units.add(new NumberTickUnit(10, numberFormat));\n        return units;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "axis", "LogAxis.java"], "context_start_lineno": 0, "function_name": "createLogTickUnits", "left_context": "class LogAxis extends ValueAxis {\n\n    /**\n     * Estimates the maximum width of the tick labels, assuming the specified\n     * tick unit is used.\n     * <P>\n     * Rather than computing the string bounds of every tick on the axis, we\n     * just look at two values: the lower bound and the upper bound for the\n     * axis.  These two values will usually be representative.\n     *\n     * @param g2  the graphics device.\n     * @param unit  the tick unit to use for calculation.\n     *\n     * @return The estimated maximum width of the tick labels.\n     *\n     * @since 1.0.7\n     */\n    protected double estimateMaximumTickLabelWidth(Graphics2D g2,\n                                                   TickUnit unit) {\n\n        RectangleInsets tickLabelInsets = getTickLabelInsets();\n        double result = tickLabelInsets.getLeft() + tickLabelInsets.getRight();\n\n        if (isVerticalTickLabels()) {\n            // all tick labels have the same width (equal to the height of the\n            // font)...\n            FontRenderContext frc = g2.getFontRenderContext();\n            LineMetrics lm = getTickLabelFont().getLineMetrics(\"0\", frc);\n            result += lm.getHeight();\n        }\n        else {\n            // look at lower and upper bounds...\n            FontMetrics fm = g2.getFontMetrics(getTickLabelFont());\n            Range range = getRange();\n            double lower = range.getLowerBound();\n            double upper = range.getUpperBound();\n            String lowerStr = \"\";\n            String upperStr = \"\";\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                lowerStr = formatter.format(lower);\n                upperStr = formatter.format(upper);\n            }\n            else {\n                lowerStr = unit.valueToString(lower);\n                upperStr = unit.valueToString(upper);\n            }\n            double w1 = fm.stringWidth(lowerStr);\n            double w2 = fm.stringWidth(upperStr);\n            result += Math.max(w1, w2);\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Zooms in on the current range.\n     *\n     * @param lowerPercent  the new lower bound.\n     * @param upperPercent  the new upper bound.\n     */\n    public void zoomRange(double lowerPercent, double upperPercent) {\n        Range range = getRange();\n        double start = range.getLowerBound();\n        double end = range.getUpperBound();\n        double log1 = calculateLog(start);\n        double log2 = calculateLog(end);\n        double length = log2 - log1;\n        Range adjusted = null;\n        if (isInverted()) {\n            double logA = log1 + length * (1 - upperPercent);\n            double logB = log1 + length * (1 - lowerPercent);\n            adjusted = new Range(calculateValue(logA), calculateValue(logB));\n        }\n        else {\n            double logA = log1 + length * lowerPercent;\n            double logB = log1 + length * upperPercent;\n            adjusted = new Range(calculateValue(logA), calculateValue(logB));\n        }\n        setRange(adjusted);\n    }\n\n    /**\n     * Slides the axis range by the specified percentage.\n     *\n     * @param percent  the percentage.\n     *\n     * @since 1.0.13\n     */\n    public void pan(double percent) {\n        Range range = getRange();\n        double lower = range.getLowerBound();\n        double upper = range.getUpperBound();\n        double log1 = calculateLog(lower);\n        double log2 = calculateLog(upper);\n        double length = log2 - log1;\n        double adj = length * percent;\n        log1 = log1 + adj;\n        log2 = log2 + adj;\n        setRange(calculateValue(log1), calculateValue(log2));\n    }\n\n    /**\n     * Creates a tick label for the specified value.  Note that this method\n     * was 'private' prior to version 1.0.10.\n     *\n     * @param value  the value.\n     *\n     * @return The label.\n     *\n     * @since 1.0.10\n     */\n    protected String createTickLabel(double value) {\n        if (this.numberFormatOverride != null) {\n            return this.numberFormatOverride.format(value);\n        }\n        else {\n            return this.tickUnit.valueToString(value);\n        }\n    }\n\n    /**\n     * Tests this axis for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof LogAxis)) {\n            return false;\n        }\n        LogAxis that = (LogAxis) obj;\n        if (this.base != that.base) {\n            return false;\n        }\n        if (this.smallestValue != that.smallestValue) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result = 193;\n        long temp = Double.doubleToLongBits(this.base);\n        result = 37 * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(this.smallestValue);\n        result = 37 * result + (int) (temp ^ (temp >>> 32));\n        if (this.numberFormatOverride != null) {\n            result = 37 * result + this.numberFormatOverride.hashCode();\n        }\n        result = 37 * result + this.tickUnit.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a collection of tick units for log (base 10) values.\n     * Uses a given Locale to create the DecimalFormats.\n     *\n     * @param locale the locale to use to represent Numbers.\n     *\n     * @return A collection of tick units for integer values.\n     *\n     * @since 1.0.7\n     */\n    public static TickUnitSource createLogTickUnits(Locale locale) {", "right_context": "}}\n\n}", "class_name": "LogAxis", "return_type": "TickUnitSource", "parameters": [{"type": "Locale", "name": "locale"}]}}
{"prompt": "class CombinedRangeCategoryPlot extends CategoryPlot\n        implements PlotChangeListener {\n\n    /**\n     * Calculates the space required for the axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The space required for the axes.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2,\n                                           Rectangle2D plotArea) {\n\n        AxisSpace space = new AxisSpace();\n        PlotOrientation orientation = getOrientation();\n\n        // work out the space required by the domain axis...\n        AxisSpace fixed = getFixedRangeAxisSpace();\n        if (fixed != null) {\n            if (orientation == PlotOrientation.VERTICAL) {\n                space.setLeft(fixed.getLeft());\n                space.setRight(fixed.getRight());\n            }\n            else if (orientation == PlotOrientation.HORIZONTAL) {\n                space.setTop(fixed.getTop());\n                space.setBottom(fixed.getBottom());\n            }\n        }\n        else {\n            ValueAxis valueAxis = getRangeAxis();\n            RectangleEdge valueEdge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), orientation);\n            if (valueAxis != null) {\n                space = valueAxis.reserveSpace(g2, this, plotArea, valueEdge,\n                        space);\n            }\n        }\n\n        Rectangle2D adjustedPlotArea = space.shrink(plotArea, null);\n        // work out the maximum height or width of the non-shared axes...\n        int n = this.subplots.size();\n        int totalWeight = 0;\n        for (int i = 0; i < n; i++) {\n            CategoryPlot sub = (CategoryPlot) this.subplots.get(i);\n            totalWeight += sub.getWeight();\n        }\n        // calculate plotAreas of all sub-plots, maximum vertical/horizontal\n        // axis width/height\n        this.subplotArea = new Rectangle2D[n];\n        double x = adjustedPlotArea.getX();\n        double y = adjustedPlotArea.getY();\n        double usableSize = 0.0;\n        if (orientation == PlotOrientation.VERTICAL) {\n            usableSize = adjustedPlotArea.getWidth() - this.gap * (n - 1);\n        }\n        else if (orientation == PlotOrientation.HORIZONTAL) {\n            usableSize = adjustedPlotArea.getHeight() - this.gap * (n - 1);\n        }\n\n        for (int i = 0; i < n; i++) {\n            CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n\n            // calculate sub-plot area\n            if (orientation == PlotOrientation.VERTICAL) {\n                double w = usableSize * plot.getWeight() / totalWeight;\n                this.subplotArea[i] = new Rectangle2D.Double(x, y, w,\n                        adjustedPlotArea.getHeight());\n                x = x + w + this.gap;\n            }\n            else if (orientation == PlotOrientation.HORIZONTAL) {\n                double h = usableSize * plot.getWeight() / totalWeight;\n                this.subplotArea[i] = new Rectangle2D.Double(x, y,\n                        adjustedPlotArea.getWidth(), h);\n                y = y + h + this.gap;\n            }\n\n            AxisSpace subSpace = plot.calculateDomainAxisSpace(g2,\n                    this.subplotArea[i], null);\n            space.ensureAtLeast(subSpace);\n\n        }\n\n        return space;\n    }\n\n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a\n     * printer).  Will perform all the placement calculations for each\n     * sub-plots and then tell these to draw themselves.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot (including axis labels)\n     *              should be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the parent state.\n     * @param info  collects information about the drawing (<code>null</code>\n     *              permitted).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo info) {\n\n        // set up info collection...\n        if (info != null) {\n            info.setPlotArea(area);\n        }\n\n        // adjust the drawing area for plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        // calculate the data area...\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n\n        // set the width and height of non-shared axis of all sub-plots\n        setFixedDomainAxisSpaceForSubplots(space);\n\n        // draw the shared axis\n        ValueAxis axis = getRangeAxis();\n        RectangleEdge rangeEdge = getRangeAxisEdge();\n        double cursor = RectangleEdge.coordinate(dataArea, rangeEdge);\n        AxisState state = axis.draw(g2, cursor, area, dataArea, rangeEdge,\n                info);\n        if (parentState == null) {\n            parentState = new PlotState();\n        }\n        parentState.getSharedAxisStates().put(axis, state);\n\n        // draw all the charts\n        for (int i = 0; i < this.subplots.size(); i++) {\n            CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n            PlotRenderingInfo subplotInfo = null;\n            if (info != null) {\n                subplotInfo = new PlotRenderingInfo(info.getOwner());\n                info.addSubplotInfo(subplotInfo);\n            }\n            Point2D subAnchor = null;\n            if (anchor != null && this.subplotArea[i].contains(anchor)) {\n                subAnchor = anchor;\n            }\n            plot.draw(g2, this.subplotArea[i], subAnchor, parentState,\n                    subplotInfo);\n        }\n\n        if (info != null) {\n            info.setDataArea(dataArea);\n        }\n\n    }\n\n    /**\n     * Sets the orientation for the plot (and all the subplots).\n     *\n     * @param orientation  the orientation.\n     */\n    public void setOrientation(PlotOrientation orientation) {\n\n        super.setOrientation(orientation);\n\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            plot.setOrientation(orientation);\n        }\n\n    }\n\n    /**\n     * Returns a range representing the extent of the data values in this plot\n     * (obtained from the subplots) that will be rendered against the specified\n     * axis.  NOTE: This method is intended for internal JFreeChart use, and\n     * is public only so that code in the axis classes can call it.  Since\n     * only the range axis is shared between subplots, the JFreeChart code\n     * will only call this method for the range values (although this is not\n     * checked/enforced).\n      *\n      * @param axis  the axis.\n      *\n      * @return The range.\n      */\n     public Range getDataRange(ValueAxis axis) {", "metadata": {"defects4j_task_id": "313ca002bf599bf0fdbce2f1c50bf77c71e5a291d4a69fc422d7ec57a1970a35", "task_id": "jfree_jfreechart/43", "ground_truth": "\n         Range result = null;\n         if (this.subplots != null) {\n             Iterator iterator = this.subplots.iterator();\n             while (iterator.hasNext()) {\n                 CategoryPlot subplot = (CategoryPlot) iterator.next();\n                 result = Range.combine(result, subplot.getDataRange(axis));\n             }\n         }\n         return result;\n     ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "plot", "CombinedRangeCategoryPlot.java"], "context_start_lineno": 0, "function_name": "getDataRange", "left_context": "class CombinedRangeCategoryPlot extends CategoryPlot\n        implements PlotChangeListener {\n\n    /**\n     * Calculates the space required for the axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The space required for the axes.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2,\n                                           Rectangle2D plotArea) {\n\n        AxisSpace space = new AxisSpace();\n        PlotOrientation orientation = getOrientation();\n\n        // work out the space required by the domain axis...\n        AxisSpace fixed = getFixedRangeAxisSpace();\n        if (fixed != null) {\n            if (orientation == PlotOrientation.VERTICAL) {\n                space.setLeft(fixed.getLeft());\n                space.setRight(fixed.getRight());\n            }\n            else if (orientation == PlotOrientation.HORIZONTAL) {\n                space.setTop(fixed.getTop());\n                space.setBottom(fixed.getBottom());\n            }\n        }\n        else {\n            ValueAxis valueAxis = getRangeAxis();\n            RectangleEdge valueEdge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), orientation);\n            if (valueAxis != null) {\n                space = valueAxis.reserveSpace(g2, this, plotArea, valueEdge,\n                        space);\n            }\n        }\n\n        Rectangle2D adjustedPlotArea = space.shrink(plotArea, null);\n        // work out the maximum height or width of the non-shared axes...\n        int n = this.subplots.size();\n        int totalWeight = 0;\n        for (int i = 0; i < n; i++) {\n            CategoryPlot sub = (CategoryPlot) this.subplots.get(i);\n            totalWeight += sub.getWeight();\n        }\n        // calculate plotAreas of all sub-plots, maximum vertical/horizontal\n        // axis width/height\n        this.subplotArea = new Rectangle2D[n];\n        double x = adjustedPlotArea.getX();\n        double y = adjustedPlotArea.getY();\n        double usableSize = 0.0;\n        if (orientation == PlotOrientation.VERTICAL) {\n            usableSize = adjustedPlotArea.getWidth() - this.gap * (n - 1);\n        }\n        else if (orientation == PlotOrientation.HORIZONTAL) {\n            usableSize = adjustedPlotArea.getHeight() - this.gap * (n - 1);\n        }\n\n        for (int i = 0; i < n; i++) {\n            CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n\n            // calculate sub-plot area\n            if (orientation == PlotOrientation.VERTICAL) {\n                double w = usableSize * plot.getWeight() / totalWeight;\n                this.subplotArea[i] = new Rectangle2D.Double(x, y, w,\n                        adjustedPlotArea.getHeight());\n                x = x + w + this.gap;\n            }\n            else if (orientation == PlotOrientation.HORIZONTAL) {\n                double h = usableSize * plot.getWeight() / totalWeight;\n                this.subplotArea[i] = new Rectangle2D.Double(x, y,\n                        adjustedPlotArea.getWidth(), h);\n                y = y + h + this.gap;\n            }\n\n            AxisSpace subSpace = plot.calculateDomainAxisSpace(g2,\n                    this.subplotArea[i], null);\n            space.ensureAtLeast(subSpace);\n\n        }\n\n        return space;\n    }\n\n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a\n     * printer).  Will perform all the placement calculations for each\n     * sub-plots and then tell these to draw themselves.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot (including axis labels)\n     *              should be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the parent state.\n     * @param info  collects information about the drawing (<code>null</code>\n     *              permitted).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo info) {\n\n        // set up info collection...\n        if (info != null) {\n            info.setPlotArea(area);\n        }\n\n        // adjust the drawing area for plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        // calculate the data area...\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n\n        // set the width and height of non-shared axis of all sub-plots\n        setFixedDomainAxisSpaceForSubplots(space);\n\n        // draw the shared axis\n        ValueAxis axis = getRangeAxis();\n        RectangleEdge rangeEdge = getRangeAxisEdge();\n        double cursor = RectangleEdge.coordinate(dataArea, rangeEdge);\n        AxisState state = axis.draw(g2, cursor, area, dataArea, rangeEdge,\n                info);\n        if (parentState == null) {\n            parentState = new PlotState();\n        }\n        parentState.getSharedAxisStates().put(axis, state);\n\n        // draw all the charts\n        for (int i = 0; i < this.subplots.size(); i++) {\n            CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n            PlotRenderingInfo subplotInfo = null;\n            if (info != null) {\n                subplotInfo = new PlotRenderingInfo(info.getOwner());\n                info.addSubplotInfo(subplotInfo);\n            }\n            Point2D subAnchor = null;\n            if (anchor != null && this.subplotArea[i].contains(anchor)) {\n                subAnchor = anchor;\n            }\n            plot.draw(g2, this.subplotArea[i], subAnchor, parentState,\n                    subplotInfo);\n        }\n\n        if (info != null) {\n            info.setDataArea(dataArea);\n        }\n\n    }\n\n    /**\n     * Sets the orientation for the plot (and all the subplots).\n     *\n     * @param orientation  the orientation.\n     */\n    public void setOrientation(PlotOrientation orientation) {\n\n        super.setOrientation(orientation);\n\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            plot.setOrientation(orientation);\n        }\n\n    }\n\n    /**\n     * Returns a range representing the extent of the data values in this plot\n     * (obtained from the subplots) that will be rendered against the specified\n     * axis.  NOTE: This method is intended for internal JFreeChart use, and\n     * is public only so that code in the axis classes can call it.  Since\n     * only the range axis is shared between subplots, the JFreeChart code\n     * will only call this method for the range values (although this is not\n     * checked/enforced).\n      *\n      * @param axis  the axis.\n      *\n      * @return The range.\n      */\n     public Range getDataRange(ValueAxis axis) {", "right_context": "}\n\n}", "class_name": "CombinedRangeCategoryPlot", "return_type": "Range", "parameters": [{"type": "ValueAxis", "name": "axis"}]}}
{"prompt": "class DefaultDrawingSupplier implements DrawingSupplier, Cloneable,\n        PublicCloneable, Serializable {\n\n    /**\n     * Returns the next paint in the sequence.\n     *\n     * @return The paint.\n     */\n    public Paint getNextPaint() {\n        Paint result\n            = this.paintSequence[this.paintIndex % this.paintSequence.length];\n        this.paintIndex++;\n        return result;\n    }\n\n    /**\n     * Returns the next outline paint in the sequence.\n     *\n     * @return The paint.\n     */\n    public Paint getNextOutlinePaint() {\n        Paint result = this.outlinePaintSequence[\n                this.outlinePaintIndex % this.outlinePaintSequence.length];\n        this.outlinePaintIndex++;\n        return result;\n    }\n\n    /**\n     * Returns the next fill paint in the sequence.\n     *\n     * @return The paint.\n     *\n     * @since 1.0.6\n     */\n    public Paint getNextFillPaint() {\n        Paint result = this.fillPaintSequence[this.fillPaintIndex\n                % this.fillPaintSequence.length];\n        this.fillPaintIndex++;\n        return result;\n    }\n\n    /**\n     * Returns the next stroke in the sequence.\n     *\n     * @return The stroke.\n     */\n    public Stroke getNextStroke() {\n        Stroke result = this.strokeSequence[\n                this.strokeIndex % this.strokeSequence.length];\n        this.strokeIndex++;\n        return result;\n    }\n\n    /**\n     * Returns the next outline stroke in the sequence.\n     *\n     * @return The stroke.\n     */\n    public Stroke getNextOutlineStroke() {\n        Stroke result = this.outlineStrokeSequence[\n                this.outlineStrokeIndex % this.outlineStrokeSequence.length];\n        this.outlineStrokeIndex++;\n        return result;\n    }\n\n    /**\n     * Returns the next shape in the sequence.\n     *\n     * @return The shape.\n     */\n    public Shape getNextShape() {\n        Shape result = this.shapeSequence[\n                this.shapeIndex % this.shapeSequence.length];\n        this.shapeIndex++;\n        return result;\n    }\n\n    /**\n     * Creates an array of standard shapes to display for the items in series\n     * on charts.\n     *\n     * @return The array of shapes.\n     */\n    public static Shape[] createStandardSeriesShapes() {\n\n        Shape[] result = new Shape[10];\n\n        double size = 6.0;\n        double delta = size / 2.0;\n        int[] xpoints = null;\n        int[] ypoints = null;\n\n        // square\n        result[0] = new Rectangle2D.Double(-delta, -delta, size, size);\n        // circle\n        result[1] = new Ellipse2D.Double(-delta, -delta, size, size);\n\n        // up-pointing triangle\n        xpoints = intArray(0.0, delta, -delta);\n        ypoints = intArray(-delta, delta, delta);\n        result[2] = new Polygon(xpoints, ypoints, 3);\n\n        // diamond\n        xpoints = intArray(0.0, delta, 0.0, -delta);\n        ypoints = intArray(-delta, 0.0, delta, 0.0);\n        result[3] = new Polygon(xpoints, ypoints, 4);\n\n        // horizontal rectangle\n        result[4] = new Rectangle2D.Double(-delta, -delta / 2, size, size / 2);\n\n        // down-pointing triangle\n        xpoints = intArray(-delta, +delta, 0.0);\n        ypoints = intArray(-delta, -delta, delta);\n        result[5] = new Polygon(xpoints, ypoints, 3);\n\n        // horizontal ellipse\n        result[6] = new Ellipse2D.Double(-delta, -delta / 2, size, size / 2);\n\n        // right-pointing triangle\n        xpoints = intArray(-delta, delta, -delta);\n        ypoints = intArray(-delta, 0.0, delta);\n        result[7] = new Polygon(xpoints, ypoints, 3);\n\n        // vertical rectangle\n        result[8] = new Rectangle2D.Double(-delta / 2, -delta, size / 2, size);\n\n        // left-pointing triangle\n        xpoints = intArray(-delta, delta, delta);\n        ypoints = intArray(0.0, -delta, +delta);\n        result[9] = new Polygon(xpoints, ypoints, 3);\n\n        return result;\n\n    }\n\n    /**\n     * Tests this object for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n\n        if (!(obj instanceof DefaultDrawingSupplier)) {\n            return false;\n        }\n\n        DefaultDrawingSupplier that = (DefaultDrawingSupplier) obj;\n\n        if (!Arrays.equals(this.paintSequence, that.paintSequence)) {\n            return false;\n        }\n        if (this.paintIndex != that.paintIndex) {\n            return false;\n        }\n        if (!Arrays.equals(this.outlinePaintSequence,\n                that.outlinePaintSequence)) {\n            return false;\n        }\n        if (this.outlinePaintIndex != that.outlinePaintIndex) {\n            return false;\n        }\n        if (!Arrays.equals(this.strokeSequence, that.strokeSequence)) {\n            return false;\n        }\n        if (this.strokeIndex != that.strokeIndex) {\n            return false;\n        }\n        if (!Arrays.equals(this.outlineStrokeSequence,\n                that.outlineStrokeSequence)) {\n            return false;\n        }\n        if (this.outlineStrokeIndex != that.outlineStrokeIndex) {\n            return false;\n        }\n        if (!equalShapes(this.shapeSequence, that.shapeSequence)) {\n            return false;\n        }\n        if (this.shapeIndex != that.shapeIndex) {\n            return false;\n        }\n        return true;\n\n    }\n\n    /**\n     * A utility method for testing the equality of two arrays of shapes.\n     *\n     * @param s1  the first array (<code>null</code> permitted).\n     * @param s2  the second array (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    private boolean equalShapes(Shape[] s1, Shape[] s2) {", "metadata": {"defects4j_task_id": "d16c483cb0ed6a904f7f2610e7f7516b06b71428192411fdc8813a7171819d9f", "task_id": "jfree_jfreechart/171", "ground_truth": "\n        if (s1 == null) {\n            return s2 == null;\n        }\n        if (s2 == null) {\n            return false;\n        }\n        if (s1.length != s2.length) {\n            return false;\n        }\n        for (int i = 0; i < s1.length; i++) {\n            if (!ShapeUtilities.equal(s1[i], s2[i])) {\n                return false;\n            }\n        }\n        return true;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "plot", "DefaultDrawingSupplier.java"], "context_start_lineno": 0, "function_name": "equalShapes", "left_context": "class DefaultDrawingSupplier implements DrawingSupplier, Cloneable,\n        PublicCloneable, Serializable {\n\n    /**\n     * Returns the next paint in the sequence.\n     *\n     * @return The paint.\n     */\n    public Paint getNextPaint() {\n        Paint result\n            = this.paintSequence[this.paintIndex % this.paintSequence.length];\n        this.paintIndex++;\n        return result;\n    }\n\n    /**\n     * Returns the next outline paint in the sequence.\n     *\n     * @return The paint.\n     */\n    public Paint getNextOutlinePaint() {\n        Paint result = this.outlinePaintSequence[\n                this.outlinePaintIndex % this.outlinePaintSequence.length];\n        this.outlinePaintIndex++;\n        return result;\n    }\n\n    /**\n     * Returns the next fill paint in the sequence.\n     *\n     * @return The paint.\n     *\n     * @since 1.0.6\n     */\n    public Paint getNextFillPaint() {\n        Paint result = this.fillPaintSequence[this.fillPaintIndex\n                % this.fillPaintSequence.length];\n        this.fillPaintIndex++;\n        return result;\n    }\n\n    /**\n     * Returns the next stroke in the sequence.\n     *\n     * @return The stroke.\n     */\n    public Stroke getNextStroke() {\n        Stroke result = this.strokeSequence[\n                this.strokeIndex % this.strokeSequence.length];\n        this.strokeIndex++;\n        return result;\n    }\n\n    /**\n     * Returns the next outline stroke in the sequence.\n     *\n     * @return The stroke.\n     */\n    public Stroke getNextOutlineStroke() {\n        Stroke result = this.outlineStrokeSequence[\n                this.outlineStrokeIndex % this.outlineStrokeSequence.length];\n        this.outlineStrokeIndex++;\n        return result;\n    }\n\n    /**\n     * Returns the next shape in the sequence.\n     *\n     * @return The shape.\n     */\n    public Shape getNextShape() {\n        Shape result = this.shapeSequence[\n                this.shapeIndex % this.shapeSequence.length];\n        this.shapeIndex++;\n        return result;\n    }\n\n    /**\n     * Creates an array of standard shapes to display for the items in series\n     * on charts.\n     *\n     * @return The array of shapes.\n     */\n    public static Shape[] createStandardSeriesShapes() {\n\n        Shape[] result = new Shape[10];\n\n        double size = 6.0;\n        double delta = size / 2.0;\n        int[] xpoints = null;\n        int[] ypoints = null;\n\n        // square\n        result[0] = new Rectangle2D.Double(-delta, -delta, size, size);\n        // circle\n        result[1] = new Ellipse2D.Double(-delta, -delta, size, size);\n\n        // up-pointing triangle\n        xpoints = intArray(0.0, delta, -delta);\n        ypoints = intArray(-delta, delta, delta);\n        result[2] = new Polygon(xpoints, ypoints, 3);\n\n        // diamond\n        xpoints = intArray(0.0, delta, 0.0, -delta);\n        ypoints = intArray(-delta, 0.0, delta, 0.0);\n        result[3] = new Polygon(xpoints, ypoints, 4);\n\n        // horizontal rectangle\n        result[4] = new Rectangle2D.Double(-delta, -delta / 2, size, size / 2);\n\n        // down-pointing triangle\n        xpoints = intArray(-delta, +delta, 0.0);\n        ypoints = intArray(-delta, -delta, delta);\n        result[5] = new Polygon(xpoints, ypoints, 3);\n\n        // horizontal ellipse\n        result[6] = new Ellipse2D.Double(-delta, -delta / 2, size, size / 2);\n\n        // right-pointing triangle\n        xpoints = intArray(-delta, delta, -delta);\n        ypoints = intArray(-delta, 0.0, delta);\n        result[7] = new Polygon(xpoints, ypoints, 3);\n\n        // vertical rectangle\n        result[8] = new Rectangle2D.Double(-delta / 2, -delta, size / 2, size);\n\n        // left-pointing triangle\n        xpoints = intArray(-delta, delta, delta);\n        ypoints = intArray(0.0, -delta, +delta);\n        result[9] = new Polygon(xpoints, ypoints, 3);\n\n        return result;\n\n    }\n\n    /**\n     * Tests this object for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n\n        if (!(obj instanceof DefaultDrawingSupplier)) {\n            return false;\n        }\n\n        DefaultDrawingSupplier that = (DefaultDrawingSupplier) obj;\n\n        if (!Arrays.equals(this.paintSequence, that.paintSequence)) {\n            return false;\n        }\n        if (this.paintIndex != that.paintIndex) {\n            return false;\n        }\n        if (!Arrays.equals(this.outlinePaintSequence,\n                that.outlinePaintSequence)) {\n            return false;\n        }\n        if (this.outlinePaintIndex != that.outlinePaintIndex) {\n            return false;\n        }\n        if (!Arrays.equals(this.strokeSequence, that.strokeSequence)) {\n            return false;\n        }\n        if (this.strokeIndex != that.strokeIndex) {\n            return false;\n        }\n        if (!Arrays.equals(this.outlineStrokeSequence,\n                that.outlineStrokeSequence)) {\n            return false;\n        }\n        if (this.outlineStrokeIndex != that.outlineStrokeIndex) {\n            return false;\n        }\n        if (!equalShapes(this.shapeSequence, that.shapeSequence)) {\n            return false;\n        }\n        if (this.shapeIndex != that.shapeIndex) {\n            return false;\n        }\n        return true;\n\n    }\n\n    /**\n     * A utility method for testing the equality of two arrays of shapes.\n     *\n     * @param s1  the first array (<code>null</code> permitted).\n     * @param s2  the second array (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    private boolean equalShapes(Shape[] s1, Shape[] s2) {", "right_context": "}\n}", "class_name": "DefaultDrawingSupplier", "return_type": "boolean", "parameters": [{"type": "Shape[]", "name": "s1"}, {"type": "Shape[]", "name": "s2"}]}}
{"prompt": "class CategoryPlot extends Plot implements ValueAxisPlot, Pannable,\n        Selectable, Zoomable, AnnotationChangeListener, RendererChangeListener,\n        Cloneable, PublicCloneable, Serializable {\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getDomainAxis()\n     */\n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n\n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axes  the axes (<code>null</code> not permitted).\n     *\n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     *\n     * @param axis  the axis (<code>null</code> not permitted).\n     *\n     * @return The axis index.\n     *\n     * @see #getDomainAxis(int)\n     * @see #getRangeAxisIndex(ValueAxis)\n     *\n     * @since 1.0.3\n     */\n    public int getDomainAxisIndex(CategoryAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        return this.domainAxes.indexOf(axis);\n    }\n\n    /**\n     * Returns the domain axis location for the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     *\n     * @see #getRangeAxisLocation()\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     *\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     *\n     * @see #getDomainAxisLocation()\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * @param notify  a flag that controls whether listeners are notified.\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     *\n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.5\n     *\n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain axis edge.  This is derived from the axis location\n     * and the plot orientation.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {", "metadata": {"defects4j_task_id": "c65e93ae3eb54f0f0812e0231fd992503a7b113314a5e62492d6cf555487fe24", "task_id": "jfree_jfreechart/160", "ground_truth": "\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "plot", "CategoryPlot.java"], "context_start_lineno": 0, "function_name": "getDomainAxisEdge", "left_context": "class CategoryPlot extends Plot implements ValueAxisPlot, Pannable,\n        Selectable, Zoomable, AnnotationChangeListener, RendererChangeListener,\n        Cloneable, PublicCloneable, Serializable {\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getDomainAxis()\n     */\n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n\n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axes  the axes (<code>null</code> not permitted).\n     *\n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     *\n     * @param axis  the axis (<code>null</code> not permitted).\n     *\n     * @return The axis index.\n     *\n     * @see #getDomainAxis(int)\n     * @see #getRangeAxisIndex(ValueAxis)\n     *\n     * @since 1.0.3\n     */\n    public int getDomainAxisIndex(CategoryAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        return this.domainAxes.indexOf(axis);\n    }\n\n    /**\n     * Returns the domain axis location for the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     *\n     * @see #getRangeAxisLocation()\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     *\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     *\n     * @see #getDomainAxisLocation()\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * @param notify  a flag that controls whether listeners are notified.\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     *\n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.5\n     *\n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain axis edge.  This is derived from the axis location\n     * and the plot orientation.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {", "right_context": "}\n}", "class_name": "CategoryPlot", "return_type": "RectangleEdge", "parameters": [{"type": "int", "name": "index"}]}}
{"prompt": "class CategoryPlot extends Plot implements ValueAxisPlot, Pannable,\n        Selectable, Zoomable, AnnotationChangeListener, RendererChangeListener,\n        Cloneable, PublicCloneable, Serializable {\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  if the cloning is not supported.\n     */\n    public Object clone() throws CloneNotSupportedException {\n\n        CategoryPlot clone = (CategoryPlot) super.clone();\n\n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations\n                = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxesMap = new TreeMap();\n        clone.datasetToDomainAxesMap.putAll(this.datasetToDomainAxesMap);\n        clone.datasetToRangeAxesMap = new TreeMap();\n        clone.datasetToRangeAxesMap.putAll(this.datasetToRangeAxesMap);\n\n        clone.renderers = (ObjectList) this.renderers.clone();\n        for (int i = 0; i < this.renderers.size(); i++) {\n            CategoryItemRenderer renderer2 = (CategoryItemRenderer)\n                    this.renderers.get(i);\n            if (renderer2 instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) renderer2;\n                CategoryItemRenderer rc = (CategoryItemRenderer) pc.clone();\n                clone.renderers.set(i, rc);\n                rc.setPlot(clone);\n                rc.addChangeListener(clone);\n            }\n        }\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n\n        clone.annotations = (List) ObjectUtilities.deepClone(this.annotations);\n        clone.foregroundDomainMarkers = cloneMarkerMap(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers = cloneMarkerMap(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers = cloneMarkerMap(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers = cloneMarkerMap(\n                this.backgroundRangeMarkers);\n        if (this.fixedLegendItems != null) {\n            clone.fixedLegendItems\n                    = (LegendItemCollection) this.fixedLegendItems.clone();\n        }\n        return clone;\n\n    }\n\n    /**\n     * A utility method to clone the marker maps.\n     *\n     * @param map  the map to clone.\n     *\n     * @return A clone of the map.\n     *\n     * @throws CloneNotSupportedException if there is some problem cloning the\n     *                                    map.\n     */\n    private Map cloneMarkerMap(Map map) throws CloneNotSupportedException {", "metadata": {"defects4j_task_id": "d7530491c0104a9e9c13d6c514381db574fa0fc38611f8f7fee9288f840e79f2", "task_id": "jfree_jfreechart/176", "ground_truth": "\n        Map clone = new HashMap();\n        Set keys = map.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Object key = iterator.next();\n            List entry = (List) map.get(key);\n            Object toAdd = ObjectUtilities.deepClone(entry);\n            clone.put(key, toAdd);\n        }\n        return clone;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "plot", "CategoryPlot.java"], "context_start_lineno": 0, "function_name": "cloneMarkerMap", "left_context": "class CategoryPlot extends Plot implements ValueAxisPlot, Pannable,\n        Selectable, Zoomable, AnnotationChangeListener, RendererChangeListener,\n        Cloneable, PublicCloneable, Serializable {\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  if the cloning is not supported.\n     */\n    public Object clone() throws CloneNotSupportedException {\n\n        CategoryPlot clone = (CategoryPlot) super.clone();\n\n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations\n                = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxesMap = new TreeMap();\n        clone.datasetToDomainAxesMap.putAll(this.datasetToDomainAxesMap);\n        clone.datasetToRangeAxesMap = new TreeMap();\n        clone.datasetToRangeAxesMap.putAll(this.datasetToRangeAxesMap);\n\n        clone.renderers = (ObjectList) this.renderers.clone();\n        for (int i = 0; i < this.renderers.size(); i++) {\n            CategoryItemRenderer renderer2 = (CategoryItemRenderer)\n                    this.renderers.get(i);\n            if (renderer2 instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) renderer2;\n                CategoryItemRenderer rc = (CategoryItemRenderer) pc.clone();\n                clone.renderers.set(i, rc);\n                rc.setPlot(clone);\n                rc.addChangeListener(clone);\n            }\n        }\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n\n        clone.annotations = (List) ObjectUtilities.deepClone(this.annotations);\n        clone.foregroundDomainMarkers = cloneMarkerMap(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers = cloneMarkerMap(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers = cloneMarkerMap(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers = cloneMarkerMap(\n                this.backgroundRangeMarkers);\n        if (this.fixedLegendItems != null) {\n            clone.fixedLegendItems\n                    = (LegendItemCollection) this.fixedLegendItems.clone();\n        }\n        return clone;\n\n    }\n\n    /**\n     * A utility method to clone the marker maps.\n     *\n     * @param map  the map to clone.\n     *\n     * @return A clone of the map.\n     *\n     * @throws CloneNotSupportedException if there is some problem cloning the\n     *                                    map.\n     */\n    private Map cloneMarkerMap(Map map) throws CloneNotSupportedException {", "right_context": "}\n}", "class_name": "CategoryPlot", "return_type": "Map", "parameters": [{"type": "Map", "name": "map"}]}}
{"prompt": "class PiePlot extends Plot implements Selectable, Cloneable,\n        Serializable {\n\n    /**\n     * Returns the interior gap, measured as a percentage of the available\n     * drawing space.\n     *\n     * @return The gap (as a percentage of the available drawing space).\n     *\n     * @see #setInteriorGap(double)\n     */\n    public double getInteriorGap() {\n        return this.interiorGap;\n    }\n\n    /**\n     * Sets the interior gap and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  This controls the space between the edges of the\n     * pie plot and the plot area itself (the region where the section labels\n     * appear).\n     *\n     * @param percent  the gap (as a percentage of the available drawing space).\n     *\n     * @see #getInteriorGap()\n     */\n    public void setInteriorGap(double percent) {\n\n        if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {\n            throw new IllegalArgumentException(\n                \"Invalid 'percent' (\" + percent + \") argument.\");\n        }\n\n        if (this.interiorGap != percent) {\n            this.interiorGap = percent;\n            fireChangeEvent();\n        }\n\n    }\n\n    /**\n     * Returns a flag indicating whether the pie chart is circular, or\n     * stretched into an elliptical shape.\n     *\n     * @return A flag indicating whether the pie chart is circular.\n     *\n     * @see #setCircular(boolean)\n     */\n    public boolean isCircular() {\n        return this.circular;\n    }\n\n    /**\n     * A flag indicating whether the pie chart is circular, or stretched into\n     * an elliptical shape.\n     *\n     * @param flag  the new value.\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean flag) {\n        setCircular(flag, true);\n    }\n\n    /**\n     * Sets the circular attribute and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param circular  the new value of the flag.\n     * @param notify  notify listeners?\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean circular, boolean notify) {\n        this.circular = circular;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the flag that controls whether <code>null</code> values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public boolean getIgnoreNullValues() {\n        return this.ignoreNullValues;\n    }\n\n    /**\n     * Sets a flag that controls whether <code>null</code> values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  At\n     * present, this only affects whether or not the key is presented in the\n     * legend.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreNullValues()\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public void setIgnoreNullValues(boolean flag) {\n        this.ignoreNullValues = flag;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether zero values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public boolean getIgnoreZeroValues() {\n        return this.ignoreZeroValues;\n    }\n\n    /**\n     * Sets a flag that controls whether zero values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  This\n     * only affects whether or not a label appears for the non-visible\n     * pie section.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreZeroValues()\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public void setIgnoreZeroValues(boolean flag) {\n        this.ignoreZeroValues = flag;\n        fireChangeEvent();\n    }\n\n    //// SECTION PAINT ////////////////////////////////////////////////////////\n\n    /**\n     * Returns the paint for the specified section.  This is equivalent to\n     * <code>lookupSectionPaint(section, getAutoPopulateSectionPaint())</code>.\n     *\n     * @param key  the section key.\n     * @param selected  is the section selected?\n     *\n     * @return The paint for the specified section.\n     *\n     * @since 1.2.0\n     *\n     * @see #lookupSectionPaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected) {\n        Paint result = null;\n        if (selected) {\n            result = this.selectedItemAttributes.lookupSectionPaint(key);\n        }\n        if (result == null) {\n            result = lookupSectionPaint(key, selected,\n                    getAutoPopulateSectionPaint());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the paint for the specified section.  The lookup involves these\n     * steps:\n     * <ul>\n     * <li>if {@link #getSectionPaint(Comparable)} is non-<code>null</code>\n     *         return it;</li>\n     * <li>if {@link #getSectionPaint(Comparable)} is <code>null</code> but\n     *         <code>autoPopulate</code> is <code>true</code>, attempt to fetch\n     *         a new paint from the drawing supplier\n     *         ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionPaint()}.\n     * </ul>\n     *\n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier\n     *     is used to auto-populate the section paint settings.\n     *\n     * @return The paint.\n     *\n     * @since 1.2.0\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected, \n            boolean autoPopulate) {\n\n        if (selected) {\n          //  return Color.WHITE;\n        }\n        Paint result = null;\n\n        // is a paint defined for the specified key\n        result = this.sectionPaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n\n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextPaint();\n                this.sectionPaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionPaint;\n            }\n        }\n        else {\n            result = this.baseSectionPaint;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a key for the specified section.  If there is no such section\n     * in the dataset, we generate a key.  This is to provide some backward\n     * compatibility for the (now deprecated) methods that get/set attributes\n     * based on section indices.  The preferred way of doing this now is to\n     * link the attributes directly to the section key (there are new methods\n     * for this, starting from version 1.0.3).\n     *\n     * @param section  the section index.\n     *\n     * @return The key.\n     *\n     * @since 1.0.3\n     */\n    protected Comparable getSectionKey(int section) {", "metadata": {"defects4j_task_id": "cc7b53b6a234d2b7f952bc7cf38c6206f4a7910491d8a0c414ed4600f17588c1", "task_id": "jfree_jfreechart/165", "ground_truth": "\n        Comparable key = null;\n        if (this.dataset != null) {\n            if (section >= 0 && section < this.dataset.getItemCount()) {\n                key = this.dataset.getKey(section);\n            }\n        }\n        if (key == null) {\n            key = new Integer(section);\n        }\n        return key;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "chart", "plot", "PiePlot.java"], "context_start_lineno": 0, "function_name": "getSectionKey", "left_context": "class PiePlot extends Plot implements Selectable, Cloneable,\n        Serializable {\n\n    /**\n     * Returns the interior gap, measured as a percentage of the available\n     * drawing space.\n     *\n     * @return The gap (as a percentage of the available drawing space).\n     *\n     * @see #setInteriorGap(double)\n     */\n    public double getInteriorGap() {\n        return this.interiorGap;\n    }\n\n    /**\n     * Sets the interior gap and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  This controls the space between the edges of the\n     * pie plot and the plot area itself (the region where the section labels\n     * appear).\n     *\n     * @param percent  the gap (as a percentage of the available drawing space).\n     *\n     * @see #getInteriorGap()\n     */\n    public void setInteriorGap(double percent) {\n\n        if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {\n            throw new IllegalArgumentException(\n                \"Invalid 'percent' (\" + percent + \") argument.\");\n        }\n\n        if (this.interiorGap != percent) {\n            this.interiorGap = percent;\n            fireChangeEvent();\n        }\n\n    }\n\n    /**\n     * Returns a flag indicating whether the pie chart is circular, or\n     * stretched into an elliptical shape.\n     *\n     * @return A flag indicating whether the pie chart is circular.\n     *\n     * @see #setCircular(boolean)\n     */\n    public boolean isCircular() {\n        return this.circular;\n    }\n\n    /**\n     * A flag indicating whether the pie chart is circular, or stretched into\n     * an elliptical shape.\n     *\n     * @param flag  the new value.\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean flag) {\n        setCircular(flag, true);\n    }\n\n    /**\n     * Sets the circular attribute and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param circular  the new value of the flag.\n     * @param notify  notify listeners?\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean circular, boolean notify) {\n        this.circular = circular;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the flag that controls whether <code>null</code> values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public boolean getIgnoreNullValues() {\n        return this.ignoreNullValues;\n    }\n\n    /**\n     * Sets a flag that controls whether <code>null</code> values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  At\n     * present, this only affects whether or not the key is presented in the\n     * legend.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreNullValues()\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public void setIgnoreNullValues(boolean flag) {\n        this.ignoreNullValues = flag;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether zero values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public boolean getIgnoreZeroValues() {\n        return this.ignoreZeroValues;\n    }\n\n    /**\n     * Sets a flag that controls whether zero values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  This\n     * only affects whether or not a label appears for the non-visible\n     * pie section.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreZeroValues()\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public void setIgnoreZeroValues(boolean flag) {\n        this.ignoreZeroValues = flag;\n        fireChangeEvent();\n    }\n\n    //// SECTION PAINT ////////////////////////////////////////////////////////\n\n    /**\n     * Returns the paint for the specified section.  This is equivalent to\n     * <code>lookupSectionPaint(section, getAutoPopulateSectionPaint())</code>.\n     *\n     * @param key  the section key.\n     * @param selected  is the section selected?\n     *\n     * @return The paint for the specified section.\n     *\n     * @since 1.2.0\n     *\n     * @see #lookupSectionPaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected) {\n        Paint result = null;\n        if (selected) {\n            result = this.selectedItemAttributes.lookupSectionPaint(key);\n        }\n        if (result == null) {\n            result = lookupSectionPaint(key, selected,\n                    getAutoPopulateSectionPaint());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the paint for the specified section.  The lookup involves these\n     * steps:\n     * <ul>\n     * <li>if {@link #getSectionPaint(Comparable)} is non-<code>null</code>\n     *         return it;</li>\n     * <li>if {@link #getSectionPaint(Comparable)} is <code>null</code> but\n     *         <code>autoPopulate</code> is <code>true</code>, attempt to fetch\n     *         a new paint from the drawing supplier\n     *         ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionPaint()}.\n     * </ul>\n     *\n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier\n     *     is used to auto-populate the section paint settings.\n     *\n     * @return The paint.\n     *\n     * @since 1.2.0\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected, \n            boolean autoPopulate) {\n\n        if (selected) {\n          //  return Color.WHITE;\n        }\n        Paint result = null;\n\n        // is a paint defined for the specified key\n        result = this.sectionPaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n\n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextPaint();\n                this.sectionPaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionPaint;\n            }\n        }\n        else {\n            result = this.baseSectionPaint;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a key for the specified section.  If there is no such section\n     * in the dataset, we generate a key.  This is to provide some backward\n     * compatibility for the (now deprecated) methods that get/set attributes\n     * based on section indices.  The preferred way of doing this now is to\n     * link the attributes directly to the section key (there are new methods\n     * for this, starting from version 1.0.3).\n     *\n     * @param section  the section index.\n     *\n     * @return The key.\n     *\n     * @since 1.0.3\n     */\n    protected Comparable getSectionKey(int section) {", "right_context": "}\n}", "class_name": "PiePlot", "return_type": "Comparable", "parameters": [{"type": "int", "name": "section"}]}}
{"prompt": "class DataUtilities {\n\n    /**\n     * Returns a clone of the specified array.\n     *\n     * @param source  the source array (<code>null</code> not permitted).\n     *\n     * @return A clone of the array.\n     *\n     * @since 1.0.13\n     */\n    public static double[][] clone(double[][] source) {\n        if (source == null) {\n            throw new IllegalArgumentException(\"Null 'source' argument.\");\n        }\n        double[][] clone = new double[source.length][];\n        for (int i = 0; i < source.length; i++) {\n            if (source[i] != null) {\n                double[] row = new double[source[i].length];\n                System.arraycopy(source[i], 0, row, 0, source[i].length);\n                clone[i] = row;\n            }\n        }\n        return clone;\n    }\n\n    /**\n     * Returns the total of the values in one column of the supplied data\n     * table.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     *\n     * @return The total of the values in the specified column.\n     */\n    public static double calculateColumnTotal(Values2D data, int column) {", "metadata": {"defects4j_task_id": "2c2800a85a93b596663075bc5db72448eb3cdeae72b5f6a71efa3acffe5abd1c", "task_id": "jfree_jfreechart/39", "ground_truth": "\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' argument.\");\n        }\n        double total = 0.0;\n        int rowCount = data.getRowCount();\n        for (int r = 0; r < rowCount; r++) {\n            Number n = data.getValue(r, column);\n            if (n != null) {\n                total += n.doubleValue();\n            }\n        }\n        return total;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "DataUtilities.java"], "context_start_lineno": 0, "function_name": "calculateColumnTotal", "left_context": "class DataUtilities {\n\n    /**\n     * Returns a clone of the specified array.\n     *\n     * @param source  the source array (<code>null</code> not permitted).\n     *\n     * @return A clone of the array.\n     *\n     * @since 1.0.13\n     */\n    public static double[][] clone(double[][] source) {\n        if (source == null) {\n            throw new IllegalArgumentException(\"Null 'source' argument.\");\n        }\n        double[][] clone = new double[source.length][];\n        for (int i = 0; i < source.length; i++) {\n            if (source[i] != null) {\n                double[] row = new double[source[i].length];\n                System.arraycopy(source[i], 0, row, 0, source[i].length);\n                clone[i] = row;\n            }\n        }\n        return clone;\n    }\n\n    /**\n     * Returns the total of the values in one column of the supplied data\n     * table.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     *\n     * @return The total of the values in the specified column.\n     */\n    public static double calculateColumnTotal(Values2D data, int column) {", "right_context": "}\n\n}", "class_name": "DataUtilities", "return_type": "double", "parameters": [{"type": "Values2D", "name": "data"}, {"type": "int", "name": "column"}]}}
{"prompt": "class DataUtilities {\n\n    /**\n     * Returns a clone of the specified array.\n     *\n     * @param source  the source array (<code>null</code> not permitted).\n     *\n     * @return A clone of the array.\n     *\n     * @since 1.0.13\n     */\n    public static double[][] clone(double[][] source) {\n        if (source == null) {\n            throw new IllegalArgumentException(\"Null 'source' argument.\");\n        }\n        double[][] clone = new double[source.length][];\n        for (int i = 0; i < source.length; i++) {\n            if (source[i] != null) {\n                double[] row = new double[source[i].length];\n                System.arraycopy(source[i], 0, row, 0, source[i].length);\n                clone[i] = row;\n            }\n        }\n        return clone;\n    }\n\n    /**\n     * Returns the total of the values in one column of the supplied data\n     * table.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     *\n     * @return The total of the values in the specified column.\n     */\n    public static double calculateColumnTotal(Values2D data, int column) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' argument.\");\n        }\n        double total = 0.0;\n        int rowCount = data.getRowCount();\n        for (int r = 0; r < rowCount; r++) {\n            Number n = data.getValue(r, column);\n            if (n != null) {\n                total += n.doubleValue();\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13\n     */\n     public static double calculateColumnTotal(Values2D data, int column,\n             int[] validRows) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' argument.\");\n        }\n        double total = 0.0;\n        int rowCount = data.getRowCount();\n        for (int v = 0; v < validRows.length; v++) {\n        \tint row = validRows[v];\n        \tif (row < rowCount) {\n\t            Number n = data.getValue(row, column);\n\t            if (n != null) {\n\t                total += n.doubleValue();\n\t            }\n        \t}\n        }\n        return total;\n    }\n\n    /**\n     * Returns the total of the values in one row of the supplied data\n     * table.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param row  the row index (zero-based).\n     *\n     * @return The total of the values in the specified row.\n     */\n    public static double calculateRowTotal(Values2D data, int row) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' argument.\");\n        }\n        double total = 0.0;\n        int columnCount = data.getColumnCount();\n        for (int c = 0; c < columnCount; c++) {\n            Number n = data.getValue(row, c);\n            if (n != null) {\n                total += n.doubleValue();\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Returns the total of the values in one row of the supplied data\n     * table by taking only the column numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param row  the row index (zero-based).\n     * @param validCols the array with valid cols (zero-based).\n     *\n     * @return The total of the valid values in the specified row.\n     *\n     * @since 1.0.13\n     */\n     public static double calculateRowTotal(Values2D data, int row,\n             int[] validCols) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' argument.\");\n        }\n        double total = 0.0;\n        int colCount = data.getColumnCount();\n        for (int v = 0; v < validCols.length; v++) {\n        \tint col = validCols[v];\n        \tif (col < colCount) {\n\t            Number n = data.getValue(row, col);\n\t            if (n != null) {\n\t                total += n.doubleValue();\n\t            }\n        \t}\n        }\n        return total;\n    }\n\n    /**\n     * Constructs an array of <code>Number</code> objects from an array of\n     * <code>double</code> primitives.\n     *\n     * @param data  the data (<code>null</code> not permitted).\n     *\n     * @return An array of <code>Double</code>.\n     */\n    public static Number[] createNumberArray(double[] data) {", "metadata": {"defects4j_task_id": "b0a8fac583d21e622715bd321f461ebfa9fea9fe9a0ee24c28e8a9644bdc6d54", "task_id": "jfree_jfreechart/150", "ground_truth": "\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' argument.\");\n        }\n        Number[] result = new Number[data.length];\n        for (int i = 0; i < data.length; i++) {\n            result[i] = new Double(data[i]);\n        }\n        return result;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "DataUtilities.java"], "context_start_lineno": 0, "function_name": "createNumberArray", "left_context": "class DataUtilities {\n\n    /**\n     * Returns a clone of the specified array.\n     *\n     * @param source  the source array (<code>null</code> not permitted).\n     *\n     * @return A clone of the array.\n     *\n     * @since 1.0.13\n     */\n    public static double[][] clone(double[][] source) {\n        if (source == null) {\n            throw new IllegalArgumentException(\"Null 'source' argument.\");\n        }\n        double[][] clone = new double[source.length][];\n        for (int i = 0; i < source.length; i++) {\n            if (source[i] != null) {\n                double[] row = new double[source[i].length];\n                System.arraycopy(source[i], 0, row, 0, source[i].length);\n                clone[i] = row;\n            }\n        }\n        return clone;\n    }\n\n    /**\n     * Returns the total of the values in one column of the supplied data\n     * table.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     *\n     * @return The total of the values in the specified column.\n     */\n    public static double calculateColumnTotal(Values2D data, int column) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' argument.\");\n        }\n        double total = 0.0;\n        int rowCount = data.getRowCount();\n        for (int r = 0; r < rowCount; r++) {\n            Number n = data.getValue(r, column);\n            if (n != null) {\n                total += n.doubleValue();\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13\n     */\n     public static double calculateColumnTotal(Values2D data, int column,\n             int[] validRows) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' argument.\");\n        }\n        double total = 0.0;\n        int rowCount = data.getRowCount();\n        for (int v = 0; v < validRows.length; v++) {\n        \tint row = validRows[v];\n        \tif (row < rowCount) {\n\t            Number n = data.getValue(row, column);\n\t            if (n != null) {\n\t                total += n.doubleValue();\n\t            }\n        \t}\n        }\n        return total;\n    }\n\n    /**\n     * Returns the total of the values in one row of the supplied data\n     * table.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param row  the row index (zero-based).\n     *\n     * @return The total of the values in the specified row.\n     */\n    public static double calculateRowTotal(Values2D data, int row) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' argument.\");\n        }\n        double total = 0.0;\n        int columnCount = data.getColumnCount();\n        for (int c = 0; c < columnCount; c++) {\n            Number n = data.getValue(row, c);\n            if (n != null) {\n                total += n.doubleValue();\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Returns the total of the values in one row of the supplied data\n     * table by taking only the column numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param row  the row index (zero-based).\n     * @param validCols the array with valid cols (zero-based).\n     *\n     * @return The total of the valid values in the specified row.\n     *\n     * @since 1.0.13\n     */\n     public static double calculateRowTotal(Values2D data, int row,\n             int[] validCols) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' argument.\");\n        }\n        double total = 0.0;\n        int colCount = data.getColumnCount();\n        for (int v = 0; v < validCols.length; v++) {\n        \tint col = validCols[v];\n        \tif (col < colCount) {\n\t            Number n = data.getValue(row, col);\n\t            if (n != null) {\n\t                total += n.doubleValue();\n\t            }\n        \t}\n        }\n        return total;\n    }\n\n    /**\n     * Constructs an array of <code>Number</code> objects from an array of\n     * <code>double</code> primitives.\n     *\n     * @param data  the data (<code>null</code> not permitted).\n     *\n     * @return An array of <code>Double</code>.\n     */\n    public static Number[] createNumberArray(double[] data) {", "right_context": "}\n\n}", "class_name": "DataUtilities", "return_type": "Number[]", "parameters": [{"type": "double[]", "name": "data"}]}}
{"prompt": "class SlidingCategoryDataset extends AbstractDataset\n        implements CategoryDataset {\n\n    /** The index of the first category to present. */\n    private int firstCategoryIndex;\n\n    /** The maximum number of categories to present. */\n    private int maximumCategoryCount;\n\n    /**\n     * Creates a new instance.\n     *\n     * @param underlying  the underlying dataset (<code>null</code> not\n     *     permitted).\n     * @param firstColumn  the index of the first visible column from the\n     *     underlying dataset.\n     * @param maxColumns  the maximumColumnCount.\n     */\n    public SlidingCategoryDataset(CategoryDataset underlying, int firstColumn,\n            int maxColumns) {\n        this.underlying = underlying;\n        this.firstCategoryIndex = firstColumn;\n        this.maximumCategoryCount = maxColumns;\n    }\n\n    /**\n     * Returns the underlying dataset that was supplied to the constructor.\n     *\n     * @return The underlying dataset (never <code>null</code>).\n     */\n    public CategoryDataset getUnderlyingDataset() {\n        return this.underlying;\n    }\n\n    /**\n     * Returns the index of the first visible category.\n     *\n     * @return The index.\n     *\n     * @see #setFirstCategoryIndex(int)\n     */\n    public int getFirstCategoryIndex() {\n        return this.firstCategoryIndex;\n    }\n\n    /**\n     * Sets the index of the first category that should be used from the\n     * underlying dataset, and sends a {@link DatasetChangeEvent} to all\n     * registered listeners.\n     *\n     * @param first  the index.\n     *\n     * @see #getFirstCategoryIndex()\n     */\n    public void setFirstCategoryIndex(int first) {\n        if (first < 0 || first >= this.underlying.getColumnCount()) {\n            throw new IllegalArgumentException(\"Invalid index.\");\n        }\n        this.firstCategoryIndex = first;\n        fireDatasetChanged(new DatasetChangeInfo());\n        //TODO: fill in real change info\n    }\n\n    /**\n     * Returns the maximum category count.\n     *\n     * @return The maximum category count.\n     *\n     * @see #setMaximumCategoryCount(int)\n     */\n    public int getMaximumCategoryCount() {\n        return this.maximumCategoryCount;\n    }\n\n    /**\n     * Sets the maximum category count and sends a {@link DatasetChangeEvent}\n     * to all registered listeners.\n     *\n     * @param max  the maximum.\n     *\n     * @see #getMaximumCategoryCount()\n     */\n    public void setMaximumCategoryCount(int max) {\n        if (max < 0) {\n            throw new IllegalArgumentException(\"Requires 'max' >= 0.\");\n        }\n        this.maximumCategoryCount = max;\n        fireDatasetChanged(new DatasetChangeInfo());\n        //TODO: fill in real change info\n    }\n\n    /**\n     * Returns the index of the last column for this dataset, or -1.\n     *\n     * @return The index.\n     */\n    private int lastCategoryIndex() {\n        if (this.maximumCategoryCount == 0) {\n            return -1;\n        }\n        return Math.min(this.firstCategoryIndex + this.maximumCategoryCount,\n                this.underlying.getColumnCount()) - 1;\n    }\n\n    /**\n     * Returns the index for the specified column key.\n     *\n     * @param key  the key.\n     *\n     * @return The column index, or -1 if the key is not recognised.\n     */\n    public int getColumnIndex(Comparable key) {", "metadata": {"defects4j_task_id": "fc3f37f89110df790598f05efd65244cc18426b8a6859f7cd0e863fbbf895864", "task_id": "jfree_jfreechart/207", "ground_truth": "\n        int index = this.underlying.getColumnIndex(key);\n        if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n            return index - this.firstCategoryIndex;\n        }\n        return -1;  // we didn't find the key\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "category", "SlidingCategoryDataset.java"], "context_start_lineno": 0, "function_name": "getColumnIndex", "left_context": "class SlidingCategoryDataset extends AbstractDataset\n        implements CategoryDataset {\n\n    /** The index of the first category to present. */\n    private int firstCategoryIndex;\n\n    /** The maximum number of categories to present. */\n    private int maximumCategoryCount;\n\n    /**\n     * Creates a new instance.\n     *\n     * @param underlying  the underlying dataset (<code>null</code> not\n     *     permitted).\n     * @param firstColumn  the index of the first visible column from the\n     *     underlying dataset.\n     * @param maxColumns  the maximumColumnCount.\n     */\n    public SlidingCategoryDataset(CategoryDataset underlying, int firstColumn,\n            int maxColumns) {\n        this.underlying = underlying;\n        this.firstCategoryIndex = firstColumn;\n        this.maximumCategoryCount = maxColumns;\n    }\n\n    /**\n     * Returns the underlying dataset that was supplied to the constructor.\n     *\n     * @return The underlying dataset (never <code>null</code>).\n     */\n    public CategoryDataset getUnderlyingDataset() {\n        return this.underlying;\n    }\n\n    /**\n     * Returns the index of the first visible category.\n     *\n     * @return The index.\n     *\n     * @see #setFirstCategoryIndex(int)\n     */\n    public int getFirstCategoryIndex() {\n        return this.firstCategoryIndex;\n    }\n\n    /**\n     * Sets the index of the first category that should be used from the\n     * underlying dataset, and sends a {@link DatasetChangeEvent} to all\n     * registered listeners.\n     *\n     * @param first  the index.\n     *\n     * @see #getFirstCategoryIndex()\n     */\n    public void setFirstCategoryIndex(int first) {\n        if (first < 0 || first >= this.underlying.getColumnCount()) {\n            throw new IllegalArgumentException(\"Invalid index.\");\n        }\n        this.firstCategoryIndex = first;\n        fireDatasetChanged(new DatasetChangeInfo());\n        //TODO: fill in real change info\n    }\n\n    /**\n     * Returns the maximum category count.\n     *\n     * @return The maximum category count.\n     *\n     * @see #setMaximumCategoryCount(int)\n     */\n    public int getMaximumCategoryCount() {\n        return this.maximumCategoryCount;\n    }\n\n    /**\n     * Sets the maximum category count and sends a {@link DatasetChangeEvent}\n     * to all registered listeners.\n     *\n     * @param max  the maximum.\n     *\n     * @see #getMaximumCategoryCount()\n     */\n    public void setMaximumCategoryCount(int max) {\n        if (max < 0) {\n            throw new IllegalArgumentException(\"Requires 'max' >= 0.\");\n        }\n        this.maximumCategoryCount = max;\n        fireDatasetChanged(new DatasetChangeInfo());\n        //TODO: fill in real change info\n    }\n\n    /**\n     * Returns the index of the last column for this dataset, or -1.\n     *\n     * @return The index.\n     */\n    private int lastCategoryIndex() {\n        if (this.maximumCategoryCount == 0) {\n            return -1;\n        }\n        return Math.min(this.firstCategoryIndex + this.maximumCategoryCount,\n                this.underlying.getColumnCount()) - 1;\n    }\n\n    /**\n     * Returns the index for the specified column key.\n     *\n     * @param key  the key.\n     *\n     * @return The column index, or -1 if the key is not recognised.\n     */\n    public int getColumnIndex(Comparable key) {", "right_context": "}\n\n}", "class_name": "SlidingCategoryDataset", "return_type": "int", "parameters": [{"type": "Comparable", "name": "key"}]}}
{"prompt": "class DefaultIntervalCategoryDataset extends AbstractSeriesDataset\n        implements IntervalCategoryDataset {\n\n    /**\n     * Returns the data value for one category in a series.\n     * <P>\n     * This method is part of the CategoryDataset interface.  Not particularly\n     * meaningful for this class...returns the end value.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The data value for one category in a series (null possible).\n     *\n     * @see #getEndValue(int, int)\n     */\n    public Number getValue(int series, int category) {\n        return getEndValue(series, category);\n    }\n\n    /**\n     * Returns the start data value for one category in a series.\n     *\n     * @param series  the required series.\n     * @param category  the required category.\n     *\n     * @return The start data value for one category in a series\n     *         (possibly <code>null</code>).\n     *\n     * @see #getStartValue(int, int)\n     */\n    public Number getStartValue(Comparable series, Comparable category) {\n        int seriesIndex = getSeriesIndex(series);\n        if (seriesIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'series' key.\");\n        }\n        int itemIndex = getColumnIndex(category);\n        if (itemIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'category' key.\");\n        }\n        return getStartValue(seriesIndex, itemIndex);\n    }\n\n    /**\n     * Returns the start data value for one category in a series.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The start data value for one category in a series\n     *         (possibly <code>null</code>).\n     *\n     * @see #getStartValue(Comparable, Comparable)\n     */\n    public Number getStartValue(int series, int category) {\n\n        // check arguments...\n        if ((series < 0) || (series >= getSeriesCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"series index out of range.\");\n        }\n\n        if ((category < 0) || (category >= getCategoryCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"category index out of range.\");\n        }\n\n        // fetch the value...\n        return this.startData[series][category];\n\n    }\n\n    /**\n     * Returns the end data value for one category in a series.\n     *\n     * @param series  the required series.\n     * @param category  the required category.\n     *\n     * @return The end data value for one category in a series (null possible).\n     *\n     * @see #getEndValue(int, int)\n     */\n    public Number getEndValue(Comparable series, Comparable category) {\n        int seriesIndex = getSeriesIndex(series);\n        if (seriesIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'series' key.\");\n        }\n        int itemIndex = getColumnIndex(category);\n        if (itemIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'category' key.\");\n        }\n        return getEndValue(seriesIndex, itemIndex);\n    }\n\n    /**\n     * Returns the end data value for one category in a series.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The end data value for one category in a series (null possible).\n     *\n     * @see #getEndValue(Comparable, Comparable)\n     */\n    public Number getEndValue(int series, int category) {\n        if ((series < 0) || (series >= getSeriesCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"series index out of range.\");\n        }\n\n        if ((category < 0) || (category >= getCategoryCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"category index out of range.\");\n        }\n\n        return this.endData[series][category];\n    }\n\n    /**\n     * Sets the start data value for one category in a series.\n     *\n     * @param series  the series (zero-based index).\n     * @param category  the category.\n     *\n     * @param value The value.\n     *\n     * @see #setEndValue(int, Comparable, Number)\n     */\n    public void setStartValue(int series, Comparable category, Number value) {\n\n        // does the series exist?\n        if ((series < 0) || (series > getSeriesCount() - 1)) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"series outside valid range.\");\n        }\n\n        // is the category valid?\n        int categoryIndex = getCategoryIndex(category);\n        if (categoryIndex < 0) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"unrecognised category.\");\n        }\n\n        // update the data...\n        this.startData[series][categoryIndex] = value;\n        fireDatasetChanged(new DatasetChangeInfo());\n        // TODO: fill in real change details\n\n    }\n\n    /**\n     * Sets the end data value for one category in a series.\n     *\n     * @param series  the series (zero-based index).\n     * @param category  the category.\n     *\n     * @param value the value.\n     *\n     * @see #setStartValue(int, Comparable, Number)\n     */\n    public void setEndValue(int series, Comparable category, Number value) {\n\n        // does the series exist?\n        if ((series < 0) || (series > getSeriesCount() - 1)) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"series outside valid range.\");\n        }\n\n        // is the category valid?\n        int categoryIndex = getCategoryIndex(category);\n        if (categoryIndex < 0) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"unrecognised category.\");\n        }\n\n        // update the data...\n        this.endData[series][categoryIndex] = value;\n        fireDatasetChanged(new DatasetChangeInfo());\n        // TODO: fill in real change details\n\n    }\n\n    /**\n     * Returns the index for the given category.\n     *\n     * @param category  the category (<code>null</code> not permitted).\n     *\n     * @return The index.\n     *\n     * @see #getColumnIndex(Comparable)\n     */\n    public int getCategoryIndex(Comparable category) {\n        int result = -1;\n        for (int i = 0; i < this.categoryKeys.length; i++) {\n            if (category.equals(this.categoryKeys[i])) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Generates an array of keys, by appending a space plus an integer\n     * (starting with 1) to the supplied prefix string.\n     *\n     * @param count  the number of keys required.\n     * @param prefix  the name prefix.\n     *\n     * @return An array of <i>prefixN</i> with N = { 1 .. count}.\n     */\n    private Comparable[] generateKeys(int count, String prefix) {", "metadata": {"defects4j_task_id": "0119a0554439984af179af7564f0e878e0038e946c0a9a26cf21bcee84eca469", "task_id": "jfree_jfreechart/1", "ground_truth": "\n        Comparable[] result = new Comparable[count];\n        String name;\n        for (int i = 0; i < count; i++) {\n            name = prefix + (i + 1);\n            result[i] = name;\n        }\n        return result;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "category", "DefaultIntervalCategoryDataset.java"], "context_start_lineno": 0, "function_name": "generateKeys", "left_context": "class DefaultIntervalCategoryDataset extends AbstractSeriesDataset\n        implements IntervalCategoryDataset {\n\n    /**\n     * Returns the data value for one category in a series.\n     * <P>\n     * This method is part of the CategoryDataset interface.  Not particularly\n     * meaningful for this class...returns the end value.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The data value for one category in a series (null possible).\n     *\n     * @see #getEndValue(int, int)\n     */\n    public Number getValue(int series, int category) {\n        return getEndValue(series, category);\n    }\n\n    /**\n     * Returns the start data value for one category in a series.\n     *\n     * @param series  the required series.\n     * @param category  the required category.\n     *\n     * @return The start data value for one category in a series\n     *         (possibly <code>null</code>).\n     *\n     * @see #getStartValue(int, int)\n     */\n    public Number getStartValue(Comparable series, Comparable category) {\n        int seriesIndex = getSeriesIndex(series);\n        if (seriesIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'series' key.\");\n        }\n        int itemIndex = getColumnIndex(category);\n        if (itemIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'category' key.\");\n        }\n        return getStartValue(seriesIndex, itemIndex);\n    }\n\n    /**\n     * Returns the start data value for one category in a series.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The start data value for one category in a series\n     *         (possibly <code>null</code>).\n     *\n     * @see #getStartValue(Comparable, Comparable)\n     */\n    public Number getStartValue(int series, int category) {\n\n        // check arguments...\n        if ((series < 0) || (series >= getSeriesCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"series index out of range.\");\n        }\n\n        if ((category < 0) || (category >= getCategoryCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"category index out of range.\");\n        }\n\n        // fetch the value...\n        return this.startData[series][category];\n\n    }\n\n    /**\n     * Returns the end data value for one category in a series.\n     *\n     * @param series  the required series.\n     * @param category  the required category.\n     *\n     * @return The end data value for one category in a series (null possible).\n     *\n     * @see #getEndValue(int, int)\n     */\n    public Number getEndValue(Comparable series, Comparable category) {\n        int seriesIndex = getSeriesIndex(series);\n        if (seriesIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'series' key.\");\n        }\n        int itemIndex = getColumnIndex(category);\n        if (itemIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'category' key.\");\n        }\n        return getEndValue(seriesIndex, itemIndex);\n    }\n\n    /**\n     * Returns the end data value for one category in a series.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The end data value for one category in a series (null possible).\n     *\n     * @see #getEndValue(Comparable, Comparable)\n     */\n    public Number getEndValue(int series, int category) {\n        if ((series < 0) || (series >= getSeriesCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"series index out of range.\");\n        }\n\n        if ((category < 0) || (category >= getCategoryCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"category index out of range.\");\n        }\n\n        return this.endData[series][category];\n    }\n\n    /**\n     * Sets the start data value for one category in a series.\n     *\n     * @param series  the series (zero-based index).\n     * @param category  the category.\n     *\n     * @param value The value.\n     *\n     * @see #setEndValue(int, Comparable, Number)\n     */\n    public void setStartValue(int series, Comparable category, Number value) {\n\n        // does the series exist?\n        if ((series < 0) || (series > getSeriesCount() - 1)) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"series outside valid range.\");\n        }\n\n        // is the category valid?\n        int categoryIndex = getCategoryIndex(category);\n        if (categoryIndex < 0) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"unrecognised category.\");\n        }\n\n        // update the data...\n        this.startData[series][categoryIndex] = value;\n        fireDatasetChanged(new DatasetChangeInfo());\n        // TODO: fill in real change details\n\n    }\n\n    /**\n     * Sets the end data value for one category in a series.\n     *\n     * @param series  the series (zero-based index).\n     * @param category  the category.\n     *\n     * @param value the value.\n     *\n     * @see #setStartValue(int, Comparable, Number)\n     */\n    public void setEndValue(int series, Comparable category, Number value) {\n\n        // does the series exist?\n        if ((series < 0) || (series > getSeriesCount() - 1)) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"series outside valid range.\");\n        }\n\n        // is the category valid?\n        int categoryIndex = getCategoryIndex(category);\n        if (categoryIndex < 0) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"unrecognised category.\");\n        }\n\n        // update the data...\n        this.endData[series][categoryIndex] = value;\n        fireDatasetChanged(new DatasetChangeInfo());\n        // TODO: fill in real change details\n\n    }\n\n    /**\n     * Returns the index for the given category.\n     *\n     * @param category  the category (<code>null</code> not permitted).\n     *\n     * @return The index.\n     *\n     * @see #getColumnIndex(Comparable)\n     */\n    public int getCategoryIndex(Comparable category) {\n        int result = -1;\n        for (int i = 0; i < this.categoryKeys.length; i++) {\n            if (category.equals(this.categoryKeys[i])) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Generates an array of keys, by appending a space plus an integer\n     * (starting with 1) to the supplied prefix string.\n     *\n     * @param count  the number of keys required.\n     * @param prefix  the name prefix.\n     *\n     * @return An array of <i>prefixN</i> with N = { 1 .. count}.\n     */\n    private Comparable[] generateKeys(int count, String prefix) {", "right_context": "}\n\n}", "class_name": "DefaultIntervalCategoryDataset", "return_type": "Comparable[]", "parameters": [{"type": "int", "name": "count"}, {"type": "String", "name": "prefix"}]}}
{"prompt": "class DefaultKeyedValues implements KeyedValues, Cloneable,\n        PublicCloneable, Serializable {\n\n    /** Storage for the keys. */\n    private ArrayList keys;\n\n    /** Storage for the values. */\n    private ArrayList values;\n\n    /**\n     * Contains (key, Integer) mappings, where the Integer is the index for\n     * the key in the list.\n     */\n    private HashMap indexMap;\n\n  /**\n     * Creates a new collection (initially empty).\n     */\n    public DefaultKeyedValues() {\n        this.keys = new ArrayList();\n        this.values = new ArrayList();\n        this.indexMap = new HashMap();\n    }\n\n    /**\n     * Returns the number of items (values) in the collection.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.indexMap.size();\n    }\n\n    /**\n     * Returns a value.\n     *\n     * @param item  the item of interest (zero-based index).\n     *\n     * @return The value (possibly <code>null</code>).\n     *\n     * @throws IndexOutOfBoundsException if <code>item</code> is out of bounds.\n     */\n    public Number getValue(int item) {\n        return (Number) this.values.get(item);\n    }\n\n    /**\n     * Returns a key.\n     *\n     * @param index  the item index (zero-based).\n     *\n     * @return The row key.\n     *\n     * @throws IndexOutOfBoundsException if <code>item</code> is out of bounds.\n     */\n    public Comparable getKey(int index) {\n        return (Comparable) this.keys.get(index);\n    }\n\n    /**\n     * Returns the index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The index, or <code>-1</code> if the key is not recognised.\n     *\n     * @throws IllegalArgumentException if <code>key</code> is\n     *     <code>null</code>.\n     */\n    public int getIndex(Comparable key) {", "metadata": {"defects4j_task_id": "a049208da8d522fb1a066cf2d909fc59b7d8db093c7c26cfe35154ecf3e3a836", "task_id": "jfree_jfreechart/132", "ground_truth": "\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        final Integer i = (Integer) this.indexMap.get(key);\n        if (i == null) {\n            return -1;  // key not found\n        }\n        return i.intValue();\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "DefaultKeyedValues.java"], "context_start_lineno": 0, "function_name": "getIndex", "left_context": "class DefaultKeyedValues implements KeyedValues, Cloneable,\n        PublicCloneable, Serializable {\n\n    /** Storage for the keys. */\n    private ArrayList keys;\n\n    /** Storage for the values. */\n    private ArrayList values;\n\n    /**\n     * Contains (key, Integer) mappings, where the Integer is the index for\n     * the key in the list.\n     */\n    private HashMap indexMap;\n\n  /**\n     * Creates a new collection (initially empty).\n     */\n    public DefaultKeyedValues() {\n        this.keys = new ArrayList();\n        this.values = new ArrayList();\n        this.indexMap = new HashMap();\n    }\n\n    /**\n     * Returns the number of items (values) in the collection.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.indexMap.size();\n    }\n\n    /**\n     * Returns a value.\n     *\n     * @param item  the item of interest (zero-based index).\n     *\n     * @return The value (possibly <code>null</code>).\n     *\n     * @throws IndexOutOfBoundsException if <code>item</code> is out of bounds.\n     */\n    public Number getValue(int item) {\n        return (Number) this.values.get(item);\n    }\n\n    /**\n     * Returns a key.\n     *\n     * @param index  the item index (zero-based).\n     *\n     * @return The row key.\n     *\n     * @throws IndexOutOfBoundsException if <code>item</code> is out of bounds.\n     */\n    public Comparable getKey(int index) {\n        return (Comparable) this.keys.get(index);\n    }\n\n    /**\n     * Returns the index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The index, or <code>-1</code> if the key is not recognised.\n     *\n     * @throws IllegalArgumentException if <code>key</code> is\n     *     <code>null</code>.\n     */\n    public int getIndex(Comparable key) {", "right_context": "}\n\n}", "class_name": "DefaultKeyedValues", "return_type": "int", "parameters": [{"type": "Comparable", "name": "key"}]}}
{"prompt": "class KeyToGroupMap implements Cloneable, PublicCloneable, Serializable {\n\n    /** The default group. */\n    private Comparable defaultGroup;\n\n    /** The groups. */\n    private List groups;\n\n    /** A mapping between keys and groups. */\n    private Map keyToGroupMap;\n\n    /**\n     * Creates a new map with a default group named 'Default Group'.\n     */\n    public KeyToGroupMap() {\n        this(\"Default Group\");\n    }\n\n    /**\n     * Creates a new map with the specified default group.\n     *\n     * @param defaultGroup  the default group (<code>null</code> not permitted).\n     */\n    public KeyToGroupMap(Comparable defaultGroup) {\n        if (defaultGroup == null) {\n            throw new IllegalArgumentException(\"Null 'defaultGroup' argument.\");\n        }\n        this.defaultGroup = defaultGroup;\n        this.groups = new ArrayList();\n        this.keyToGroupMap = new HashMap();\n    }\n\n    /**\n     * Returns the number of groups in the map.\n     *\n     * @return The number of groups in the map.\n     */\n    public int getGroupCount() {\n        return this.groups.size() + 1;\n    }\n\n    /**\n     * Returns a list of the groups (always including the default group) in the\n     * map.  The returned list is independent of the map, so altering the list\n     * will have no effect.\n     *\n     * @return The groups (never <code>null</code>).\n     */\n    public List getGroups() {\n        List result = new ArrayList();\n        result.add(this.defaultGroup);\n        Iterator iterator = this.groups.iterator();\n        while (iterator.hasNext()) {\n            Comparable group = (Comparable) iterator.next();\n            if (!result.contains(group)) {\n                result.add(group);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index for the group.\n     *\n     * @param group  the group.\n     *\n     * @return The group index (or -1 if the group is not represented within\n     *         the map).\n     */\n    public int getGroupIndex(Comparable group) {\n        int result = this.groups.indexOf(group);\n        if (result < 0) {\n            if (this.defaultGroup.equals(group)) {\n                result = 0;\n            }\n        }\n        else {\n            result = result + 1;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the group that a key is mapped to.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The group (never <code>null</code>, returns the default group if\n     *         there is no mapping for the specified key).\n     */\n    public Comparable getGroup(Comparable key) {", "metadata": {"defects4j_task_id": "93b7c479716845f2ef1d28d819435345d1e5735eaf6c50700f79ce8810331cb4", "task_id": "jfree_jfreechart/120", "ground_truth": "\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Comparable result = this.defaultGroup;\n        Comparable group = (Comparable) this.keyToGroupMap.get(key);\n        if (group != null) {\n            result = group;\n        }\n        return result;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "KeyToGroupMap.java"], "context_start_lineno": 0, "function_name": "getGroup", "left_context": "class KeyToGroupMap implements Cloneable, PublicCloneable, Serializable {\n\n    /** The default group. */\n    private Comparable defaultGroup;\n\n    /** The groups. */\n    private List groups;\n\n    /** A mapping between keys and groups. */\n    private Map keyToGroupMap;\n\n    /**\n     * Creates a new map with a default group named 'Default Group'.\n     */\n    public KeyToGroupMap() {\n        this(\"Default Group\");\n    }\n\n    /**\n     * Creates a new map with the specified default group.\n     *\n     * @param defaultGroup  the default group (<code>null</code> not permitted).\n     */\n    public KeyToGroupMap(Comparable defaultGroup) {\n        if (defaultGroup == null) {\n            throw new IllegalArgumentException(\"Null 'defaultGroup' argument.\");\n        }\n        this.defaultGroup = defaultGroup;\n        this.groups = new ArrayList();\n        this.keyToGroupMap = new HashMap();\n    }\n\n    /**\n     * Returns the number of groups in the map.\n     *\n     * @return The number of groups in the map.\n     */\n    public int getGroupCount() {\n        return this.groups.size() + 1;\n    }\n\n    /**\n     * Returns a list of the groups (always including the default group) in the\n     * map.  The returned list is independent of the map, so altering the list\n     * will have no effect.\n     *\n     * @return The groups (never <code>null</code>).\n     */\n    public List getGroups() {\n        List result = new ArrayList();\n        result.add(this.defaultGroup);\n        Iterator iterator = this.groups.iterator();\n        while (iterator.hasNext()) {\n            Comparable group = (Comparable) iterator.next();\n            if (!result.contains(group)) {\n                result.add(group);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index for the group.\n     *\n     * @param group  the group.\n     *\n     * @return The group index (or -1 if the group is not represented within\n     *         the map).\n     */\n    public int getGroupIndex(Comparable group) {\n        int result = this.groups.indexOf(group);\n        if (result < 0) {\n            if (this.defaultGroup.equals(group)) {\n                result = 0;\n            }\n        }\n        else {\n            result = result + 1;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the group that a key is mapped to.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The group (never <code>null</code>, returns the default group if\n     *         there is no mapping for the specified key).\n     */\n    public Comparable getGroup(Comparable key) {", "right_context": "}\n\n}", "class_name": "KeyToGroupMap", "return_type": "Comparable", "parameters": [{"type": "Comparable", "name": "key"}]}}
{"prompt": "class SimpleHistogramBin implements Comparable,\n        Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 3480862537505941742L;\n\n    /** The lower bound for the bin. */\n    private double lowerBound;\n\n    /** The upper bound for the bin. */\n    private double upperBound;\n\n    /**\n     * A flag that controls whether the lower bound is included in the bin\n     * range.\n     */\n    private boolean includeLowerBound;\n\n    /**\n     * A flag that controls whether the upper bound is included in the bin\n     * range.\n     */\n    private boolean includeUpperBound;\n\n    /** The item count. */\n    private int itemCount;\n\n    /**\n     * A flag that indicates whether or not the bin is selected.\n     *\n     * @since 1.2.0\n     */\n    private boolean selected;\n\n    /**\n     * Creates a new bin.\n     *\n     * @param lowerBound  the lower bound (inclusive).\n     * @param upperBound  the upper bound (inclusive);\n     */\n    public SimpleHistogramBin(double lowerBound, double upperBound) {\n        this(lowerBound, upperBound, true, true);\n    }\n\n    /**\n     * Creates a new bin.\n     *\n     * @param lowerBound  the lower bound.\n     * @param upperBound  the upper bound.\n     * @param includeLowerBound  include the lower bound?\n     * @param includeUpperBound  include the upper bound?\n     */\n    public SimpleHistogramBin(double lowerBound, double upperBound,\n                              boolean includeLowerBound,\n                              boolean includeUpperBound) {\n        if (lowerBound >= upperBound) {\n            throw new IllegalArgumentException(\"Invalid bounds; \" + lowerBound\n                    + \" to \" + upperBound);\n        }\n        this.lowerBound = lowerBound;\n        this.upperBound = upperBound;\n        this.includeLowerBound = includeLowerBound;\n        this.includeUpperBound = includeUpperBound;\n        this.itemCount = 0;\n        this.selected = false;\n    }\n\n    /**\n     * Returns the lower bound.\n     *\n     * @return The lower bound.\n     *\n     * @see #getUpperBound()\n     */\n    public double getLowerBound() {\n        return this.lowerBound;\n    }\n\n    /**\n     * Return the upper bound.\n     *\n     * @return The upper bound.\n     *\n     * @see #getLowerBound()\n     */\n    public double getUpperBound() {\n        return this.upperBound;\n    }\n\n    /**\n     * Returns the item count.\n     *\n     * @return The item count.\n     *\n     * @see #setItemCount(int)\n     */\n    public int getItemCount() {\n        return this.itemCount;\n    }\n\n    /**\n     * Sets the item count.  No event notification occurs when calling this\n     * method - if the bin is contained within a\n     * {@link SimpleHistogramDataset}, you should not be calling this method\n     * directly.  Instead, update the bin using methods such as\n     * {@link SimpleHistogramDataset#addObservations(double[])}.\n     *\n     * @param count  the item count.\n     *\n     * @see #getItemCount()\n     */\n    public void setItemCount(int count) {\n        this.itemCount = count;\n    }\n\n    /**\n     * Returns a flag indicating whether or not the bin is selected.\n     *\n     * @return A boolean.\n     *\n     * @see #setSelected(boolean)\n     *\n     * @since 1.2.0\n     */\n    public boolean isSelected() {\n        return this.selected;\n    }\n\n    /**\n     * Sets the flag that indicates whether or not the bin is selected.\n     *\n     * @param selected  the new flag value.\n     *\n     * @see #isSelected()\n     *\n     * @since 1.2.0\n     */\n    public void setSelected(boolean selected) {\n        this.selected = selected;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified value belongs in the bin,\n     * and <code>false</code> otherwise.\n     *\n     * @param value  the value.\n     *\n     * @return A boolean.\n     */\n    public boolean accepts(double value) {\n        if (Double.isNaN(value)) {\n            return false;\n        }\n        if (value < this.lowerBound) {\n            return false;\n        }\n        if (value > this.upperBound) {\n            return false;\n        }\n        if (value == this.lowerBound) {\n            return this.includeLowerBound;\n        }\n        if (value == this.upperBound) {\n            return this.includeUpperBound;\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this bin overlaps with the specified bin,\n     * and <code>false</code> otherwise.\n     *\n     * @param bin  the other bin (<code>null</code> not permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean overlapsWith(SimpleHistogramBin bin) {", "metadata": {"defects4j_task_id": "db55a57e76cd8f750f8b2ac15a5f4d1255752797ad2d0a444b07c6dd39f7836b", "task_id": "jfree_jfreechart/181", "ground_truth": "\n        if (this.upperBound < bin.lowerBound) {\n            return false;\n        }\n        if (this.lowerBound > bin.upperBound) {\n            return false;\n        }\n        if (this.upperBound == bin.lowerBound) {\n            return this.includeUpperBound && bin.includeLowerBound;\n        }\n        if (this.lowerBound == bin.upperBound) {\n            return this.includeLowerBound && bin.includeUpperBound;\n        }\n        return true;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "statistics", "SimpleHistogramBin.java"], "context_start_lineno": 0, "function_name": "overlapsWith", "left_context": "class SimpleHistogramBin implements Comparable,\n        Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 3480862537505941742L;\n\n    /** The lower bound for the bin. */\n    private double lowerBound;\n\n    /** The upper bound for the bin. */\n    private double upperBound;\n\n    /**\n     * A flag that controls whether the lower bound is included in the bin\n     * range.\n     */\n    private boolean includeLowerBound;\n\n    /**\n     * A flag that controls whether the upper bound is included in the bin\n     * range.\n     */\n    private boolean includeUpperBound;\n\n    /** The item count. */\n    private int itemCount;\n\n    /**\n     * A flag that indicates whether or not the bin is selected.\n     *\n     * @since 1.2.0\n     */\n    private boolean selected;\n\n    /**\n     * Creates a new bin.\n     *\n     * @param lowerBound  the lower bound (inclusive).\n     * @param upperBound  the upper bound (inclusive);\n     */\n    public SimpleHistogramBin(double lowerBound, double upperBound) {\n        this(lowerBound, upperBound, true, true);\n    }\n\n    /**\n     * Creates a new bin.\n     *\n     * @param lowerBound  the lower bound.\n     * @param upperBound  the upper bound.\n     * @param includeLowerBound  include the lower bound?\n     * @param includeUpperBound  include the upper bound?\n     */\n    public SimpleHistogramBin(double lowerBound, double upperBound,\n                              boolean includeLowerBound,\n                              boolean includeUpperBound) {\n        if (lowerBound >= upperBound) {\n            throw new IllegalArgumentException(\"Invalid bounds; \" + lowerBound\n                    + \" to \" + upperBound);\n        }\n        this.lowerBound = lowerBound;\n        this.upperBound = upperBound;\n        this.includeLowerBound = includeLowerBound;\n        this.includeUpperBound = includeUpperBound;\n        this.itemCount = 0;\n        this.selected = false;\n    }\n\n    /**\n     * Returns the lower bound.\n     *\n     * @return The lower bound.\n     *\n     * @see #getUpperBound()\n     */\n    public double getLowerBound() {\n        return this.lowerBound;\n    }\n\n    /**\n     * Return the upper bound.\n     *\n     * @return The upper bound.\n     *\n     * @see #getLowerBound()\n     */\n    public double getUpperBound() {\n        return this.upperBound;\n    }\n\n    /**\n     * Returns the item count.\n     *\n     * @return The item count.\n     *\n     * @see #setItemCount(int)\n     */\n    public int getItemCount() {\n        return this.itemCount;\n    }\n\n    /**\n     * Sets the item count.  No event notification occurs when calling this\n     * method - if the bin is contained within a\n     * {@link SimpleHistogramDataset}, you should not be calling this method\n     * directly.  Instead, update the bin using methods such as\n     * {@link SimpleHistogramDataset#addObservations(double[])}.\n     *\n     * @param count  the item count.\n     *\n     * @see #getItemCount()\n     */\n    public void setItemCount(int count) {\n        this.itemCount = count;\n    }\n\n    /**\n     * Returns a flag indicating whether or not the bin is selected.\n     *\n     * @return A boolean.\n     *\n     * @see #setSelected(boolean)\n     *\n     * @since 1.2.0\n     */\n    public boolean isSelected() {\n        return this.selected;\n    }\n\n    /**\n     * Sets the flag that indicates whether or not the bin is selected.\n     *\n     * @param selected  the new flag value.\n     *\n     * @see #isSelected()\n     *\n     * @since 1.2.0\n     */\n    public void setSelected(boolean selected) {\n        this.selected = selected;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified value belongs in the bin,\n     * and <code>false</code> otherwise.\n     *\n     * @param value  the value.\n     *\n     * @return A boolean.\n     */\n    public boolean accepts(double value) {\n        if (Double.isNaN(value)) {\n            return false;\n        }\n        if (value < this.lowerBound) {\n            return false;\n        }\n        if (value > this.upperBound) {\n            return false;\n        }\n        if (value == this.lowerBound) {\n            return this.includeLowerBound;\n        }\n        if (value == this.upperBound) {\n            return this.includeUpperBound;\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this bin overlaps with the specified bin,\n     * and <code>false</code> otherwise.\n     *\n     * @param bin  the other bin (<code>null</code> not permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean overlapsWith(SimpleHistogramBin bin) {", "right_context": "}\n\n    /**\n     * Compares the bin to an arbitrary object and returns the relative\n     * ordering.\n     *\n     * @param obj  the object.\n     *\n     * @return An integer indicating the relative ordering of the this bin and\n     *         the given object.\n     */\n    public int compareTo(Object obj) {\n        if (!(obj instanceof SimpleHistogramBin)) {\n            return 0;\n        }\n        SimpleHistogramBin bin = (SimpleHistogramBin) obj;\n        if (this.lowerBound < bin.lowerBound) {\n            return -1;\n        }\n        if (this.lowerBound > bin.lowerBound) {\n            return 1;\n        }\n        // lower bounds are the same\n        if (this.upperBound < bin.upperBound) {\n            return -1;\n        }\n        if (this.upperBound > bin.upperBound) {\n            return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * Tests this bin for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (!(obj instanceof SimpleHistogramBin)) {\n            return false;\n        }\n        SimpleHistogramBin that = (SimpleHistogramBin) obj;\n        if (this.lowerBound != that.lowerBound) {\n            return false;\n        }\n        if (this.upperBound != that.upperBound) {\n            return false;\n        }\n        if (this.includeLowerBound != that.includeLowerBound) {\n            return false;\n        }\n        if (this.includeUpperBound != that.includeUpperBound) {\n            return false;\n        }\n        if (this.itemCount != that.itemCount) {\n            return false;\n        }\n        if (this.selected != that.selected) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a clone of the bin.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException not thrown by this class.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}", "class_name": "SimpleHistogramBin", "return_type": "boolean", "parameters": [{"type": "SimpleHistogramBin", "name": "bin"}]}}
{"prompt": "class Statistics {\n\n    /**\n     * Calculates the median for a sublist within a list of values\n     * (<code>Number</code> objects).  The entire list will be sorted if the\n     * <code>ascending</code< argument is <code>false</code>.\n     *\n     * @param values  the values (<code>null</code> not permitted).\n     * @param start  the start index.\n     * @param end  the end index.\n     * @param copyAndSort  a flag that that controls whether the list of values\n     *                     is copied and sorted.\n     *\n     * @return The median.\n     */\n    public static double calculateMedian(List values, int start, int end,\n                                         boolean copyAndSort) {\n\n        double result = Double.NaN;\n        if (copyAndSort) {\n            List working = new ArrayList(end - start + 1);\n            for (int i = start; i <= end; i++) {\n                working.add(values.get(i));\n            }\n            Collections.sort(working);\n            result = calculateMedian(working, false);\n        }\n        else {\n            int count = end - start + 1;\n            if (count > 0) {\n                if (count % 2 == 1) {\n                    if (count > 1) {\n                        Number value\n                            = (Number) values.get(start + (count - 1) / 2);\n                        result = value.doubleValue();\n                    }\n                    else {\n                        Number value = (Number) values.get(start);\n                        result = value.doubleValue();\n                    }\n                }\n                else {\n                    Number value1 = (Number) values.get(start + count / 2 - 1);\n                    Number value2 = (Number) values.get(start + count / 2);\n                    result\n                        = (value1.doubleValue() + value2.doubleValue()) / 2.0;\n                }\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the standard deviation of a set of numbers.\n     *\n     * @param data  the data (<code>null</code> or zero length array not\n     *     permitted).\n     *\n     * @return The standard deviation of a set of numbers.\n     */\n    public static double getStdDev(Number[] data) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' array.\");\n        }\n        if (data.length == 0) {\n            throw new IllegalArgumentException(\"Zero length 'data' array.\");\n        }\n        double avg = calculateMean(data);\n        double sum = 0.0;\n\n        for (int counter = 0; counter < data.length; counter++) {\n            double diff = data[counter].doubleValue() - avg;\n            sum = sum + diff * diff;\n        }\n        return Math.sqrt(sum / (data.length - 1));\n    }\n\n    /**\n     * Fits a straight line to a set of (x, y) data, returning the slope and\n     * intercept.\n     *\n     * @param xData  the x-data (<code>null</code> not permitted).\n     * @param yData  the y-data (<code>null</code> not permitted).\n     *\n     * @return A double array with the intercept in [0] and the slope in [1].\n     */\n    public static double[] getLinearFit(Number[] xData, Number[] yData) {\n\n        if (xData == null) {\n            throw new IllegalArgumentException(\"Null 'xData' argument.\");\n        }\n        if (yData == null) {\n            throw new IllegalArgumentException(\"Null 'yData' argument.\");\n        }\n        if (xData.length != yData.length) {\n            throw new IllegalArgumentException(\n                \"Statistics.getLinearFit(): array lengths must be equal.\");\n        }\n\n        double[] result = new double[2];\n        // slope\n        result[1] = getSlope(xData, yData);\n        // intercept\n        result[0] = calculateMean(yData) - result[1] * calculateMean(xData);\n\n        return result;\n\n    }\n\n    /**\n     * Finds the slope of a regression line using least squares.\n     *\n     * @param xData  the x-values (<code>null</code> not permitted).\n     * @param yData  the y-values (<code>null</code> not permitted).\n     *\n     * @return The slope.\n     */\n    public static double getSlope(Number[] xData, Number[] yData) {\n\n        if (xData == null) {\n            throw new IllegalArgumentException(\"Null 'xData' argument.\");\n        }\n        if (yData == null) {\n            throw new IllegalArgumentException(\"Null 'yData' argument.\");\n        }\n        if (xData.length != yData.length) {\n            throw new IllegalArgumentException(\"Array lengths must be equal.\");\n        }\n\n        // ********* stat function for linear slope ********\n        // y = a + bx\n        // a = ybar - b * xbar\n        //     sum(x * y) - (sum (x) * sum(y)) / n\n        // b = ------------------------------------\n        //     sum (x^2) - (sum(x)^2 / n\n        // *************************************************\n\n        // sum of x, x^2, x * y, y\n        double sx = 0.0, sxx = 0.0, sxy = 0.0, sy = 0.0;\n        int counter;\n        for (counter = 0; counter < xData.length; counter++) {\n            sx = sx + xData[counter].doubleValue();\n            sxx = sxx + Math.pow(xData[counter].doubleValue(), 2);\n            sxy = sxy + yData[counter].doubleValue()\n                      * xData[counter].doubleValue();\n            sy = sy + yData[counter].doubleValue();\n        }\n        return (sxy - (sx * sy) / counter) / (sxx - (sx * sx) / counter);\n\n    }\n\n    /**\n     * Calculates the correlation between two datasets.  Both arrays should\n     * contain the same number of items.  Null values are treated as zero.\n     * <P>\n     * Information about the correlation calculation was obtained from:\n     *\n     * http://trochim.human.cornell.edu/kb/statcorr.htm\n     *\n     * @param data1  the first dataset.\n     * @param data2  the second dataset.\n     *\n     * @return The correlation.\n     */\n    public static double getCorrelation(Number[] data1, Number[] data2) {", "metadata": {"defects4j_task_id": "06b18153831ceb9c48e13370f32ecdeb08121962c75d97ca3b78ac7e4df44824", "task_id": "jfree_jfreechart/7", "ground_truth": "\n        if (data1 == null) {\n            throw new IllegalArgumentException(\"Null 'data1' argument.\");\n        }\n        if (data2 == null) {\n            throw new IllegalArgumentException(\"Null 'data2' argument.\");\n        }\n        if (data1.length != data2.length) {\n            throw new IllegalArgumentException(\n                \"'data1' and 'data2' arrays must have same length.\"\n            );\n        }\n        int n = data1.length;\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumX2 = 0.0;\n        double sumY2 = 0.0;\n        double sumXY = 0.0;\n        for (int i = 0; i < n; i++) {\n            double x = 0.0;\n            if (data1[i] != null) {\n                x = data1[i].doubleValue();\n            }\n            double y = 0.0;\n            if (data2[i] != null) {\n                y = data2[i].doubleValue();\n            }\n            sumX = sumX + x;\n            sumY = sumY + y;\n            sumXY = sumXY + (x * y);\n            sumX2 = sumX2 + (x * x);\n            sumY2 = sumY2 + (y * y);\n        }\n        return (n * sumXY - sumX * sumY) / Math.pow((n * sumX2 - sumX * sumX)\n                * (n * sumY2 - sumY * sumY), 0.5);\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "statistics", "Statistics.java"], "context_start_lineno": 0, "function_name": "getCorrelation", "left_context": "class Statistics {\n\n    /**\n     * Calculates the median for a sublist within a list of values\n     * (<code>Number</code> objects).  The entire list will be sorted if the\n     * <code>ascending</code< argument is <code>false</code>.\n     *\n     * @param values  the values (<code>null</code> not permitted).\n     * @param start  the start index.\n     * @param end  the end index.\n     * @param copyAndSort  a flag that that controls whether the list of values\n     *                     is copied and sorted.\n     *\n     * @return The median.\n     */\n    public static double calculateMedian(List values, int start, int end,\n                                         boolean copyAndSort) {\n\n        double result = Double.NaN;\n        if (copyAndSort) {\n            List working = new ArrayList(end - start + 1);\n            for (int i = start; i <= end; i++) {\n                working.add(values.get(i));\n            }\n            Collections.sort(working);\n            result = calculateMedian(working, false);\n        }\n        else {\n            int count = end - start + 1;\n            if (count > 0) {\n                if (count % 2 == 1) {\n                    if (count > 1) {\n                        Number value\n                            = (Number) values.get(start + (count - 1) / 2);\n                        result = value.doubleValue();\n                    }\n                    else {\n                        Number value = (Number) values.get(start);\n                        result = value.doubleValue();\n                    }\n                }\n                else {\n                    Number value1 = (Number) values.get(start + count / 2 - 1);\n                    Number value2 = (Number) values.get(start + count / 2);\n                    result\n                        = (value1.doubleValue() + value2.doubleValue()) / 2.0;\n                }\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the standard deviation of a set of numbers.\n     *\n     * @param data  the data (<code>null</code> or zero length array not\n     *     permitted).\n     *\n     * @return The standard deviation of a set of numbers.\n     */\n    public static double getStdDev(Number[] data) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Null 'data' array.\");\n        }\n        if (data.length == 0) {\n            throw new IllegalArgumentException(\"Zero length 'data' array.\");\n        }\n        double avg = calculateMean(data);\n        double sum = 0.0;\n\n        for (int counter = 0; counter < data.length; counter++) {\n            double diff = data[counter].doubleValue() - avg;\n            sum = sum + diff * diff;\n        }\n        return Math.sqrt(sum / (data.length - 1));\n    }\n\n    /**\n     * Fits a straight line to a set of (x, y) data, returning the slope and\n     * intercept.\n     *\n     * @param xData  the x-data (<code>null</code> not permitted).\n     * @param yData  the y-data (<code>null</code> not permitted).\n     *\n     * @return A double array with the intercept in [0] and the slope in [1].\n     */\n    public static double[] getLinearFit(Number[] xData, Number[] yData) {\n\n        if (xData == null) {\n            throw new IllegalArgumentException(\"Null 'xData' argument.\");\n        }\n        if (yData == null) {\n            throw new IllegalArgumentException(\"Null 'yData' argument.\");\n        }\n        if (xData.length != yData.length) {\n            throw new IllegalArgumentException(\n                \"Statistics.getLinearFit(): array lengths must be equal.\");\n        }\n\n        double[] result = new double[2];\n        // slope\n        result[1] = getSlope(xData, yData);\n        // intercept\n        result[0] = calculateMean(yData) - result[1] * calculateMean(xData);\n\n        return result;\n\n    }\n\n    /**\n     * Finds the slope of a regression line using least squares.\n     *\n     * @param xData  the x-values (<code>null</code> not permitted).\n     * @param yData  the y-values (<code>null</code> not permitted).\n     *\n     * @return The slope.\n     */\n    public static double getSlope(Number[] xData, Number[] yData) {\n\n        if (xData == null) {\n            throw new IllegalArgumentException(\"Null 'xData' argument.\");\n        }\n        if (yData == null) {\n            throw new IllegalArgumentException(\"Null 'yData' argument.\");\n        }\n        if (xData.length != yData.length) {\n            throw new IllegalArgumentException(\"Array lengths must be equal.\");\n        }\n\n        // ********* stat function for linear slope ********\n        // y = a + bx\n        // a = ybar - b * xbar\n        //     sum(x * y) - (sum (x) * sum(y)) / n\n        // b = ------------------------------------\n        //     sum (x^2) - (sum(x)^2 / n\n        // *************************************************\n\n        // sum of x, x^2, x * y, y\n        double sx = 0.0, sxx = 0.0, sxy = 0.0, sy = 0.0;\n        int counter;\n        for (counter = 0; counter < xData.length; counter++) {\n            sx = sx + xData[counter].doubleValue();\n            sxx = sxx + Math.pow(xData[counter].doubleValue(), 2);\n            sxy = sxy + yData[counter].doubleValue()\n                      * xData[counter].doubleValue();\n            sy = sy + yData[counter].doubleValue();\n        }\n        return (sxy - (sx * sy) / counter) / (sxx - (sx * sx) / counter);\n\n    }\n\n    /**\n     * Calculates the correlation between two datasets.  Both arrays should\n     * contain the same number of items.  Null values are treated as zero.\n     * <P>\n     * Information about the correlation calculation was obtained from:\n     *\n     * http://trochim.human.cornell.edu/kb/statcorr.htm\n     *\n     * @param data1  the first dataset.\n     * @param data2  the second dataset.\n     *\n     * @return The correlation.\n     */\n    public static double getCorrelation(Number[] data1, Number[] data2) {", "right_context": "}\n\n}", "class_name": "Statistics", "return_type": "double", "parameters": [{"type": "Number[]", "name": "data1"}, {"type": "Number[]", "name": "data2"}]}}
{"prompt": "class DatasetUtilities {\n\n    /**\n     * Calculates the total of all the values in a {@link PieDataset}.  If\n     * the dataset contains negative or <code>null</code> values, they are\n     * ignored.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The total.\n     */\n    public static double calculatePieDatasetTotal(PieDataset dataset) {", "metadata": {"defects4j_task_id": "f50a6d8315ad86ce68f9137488e928b9c45fe5e909927ceab6014c3970a0ffc7", "task_id": "jfree_jfreechart/200", "ground_truth": "\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        List keys = dataset.getKeys();\n        double totalValue = 0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable current = (Comparable) iterator.next();\n            if (current != null) {\n                Number value = dataset.getValue(current);\n                double v = 0.0;\n                if (value != null) {\n                    v = value.doubleValue();\n                }\n                if (v > 0) {\n                    totalValue = totalValue + v;\n                }\n            }\n        }\n        return totalValue;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "general", "DatasetUtilities.java"], "context_start_lineno": 0, "function_name": "calculatePieDatasetTotal", "left_context": "class DatasetUtilities {\n\n    /**\n     * Calculates the total of all the values in a {@link PieDataset}.  If\n     * the dataset contains negative or <code>null</code> values, they are\n     * ignored.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The total.\n     */\n    public static double calculatePieDatasetTotal(PieDataset dataset) {", "right_context": "}\n\n}", "class_name": "DatasetUtilities", "return_type": "double", "parameters": [{"type": "PieDataset", "name": "dataset"}]}}
{"prompt": "class DatasetUtilities {\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param base  the base value for the bars.\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n            double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive = positive + value;\n                    }\n                    if (value < 0.0) {\n                        negative = negative + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, negative);\n            maximum = Math.max(maximum, positive);\n        }\n        if (minimum <= maximum) {\n            result = new Range(minimum, maximum);\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset.\n     * @param map  a structure that maps series to groups.\n     *\n     * @return The value range (<code>null</code> if the dataset contains no\n     *         values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n                                               KeyToGroupMap map) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean hasValidData = false;\n        Range result = null;\n\n        // create an array holding the group indices for each series...\n        int[] groupIndex = new int[dataset.getRowCount()];\n        for (int i = 0; i < dataset.getRowCount(); i++) {\n            groupIndex[i] = map.getGroupIndex(map.getGroup(\n                    dataset.getRowKey(i)));\n        }\n\n        // minimum and maximum for each group...\n        int groupCount = map.getGroupCount();\n        double[] minimum = new double[groupCount];\n        double[] maximum = new double[groupCount];\n\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value.\n     *\n     * @see #findMaximumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMinimumStackedRangeValue(CategoryDataset dataset) {", "metadata": {"defects4j_task_id": "28ec87df40a187dd174e3241259b2f46849a4aa9a6d348f8962135871766f0b3", "task_id": "jfree_jfreechart/36", "ground_truth": "\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double minimum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value < 0.0) {\n                        total = total + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, total);\n        }\n        if (hasValidData) {\n            result = new Double(minimum);\n        }\n        return result;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "general", "DatasetUtilities.java"], "context_start_lineno": 0, "function_name": "findMinimumStackedRangeValue", "left_context": "class DatasetUtilities {\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param base  the base value for the bars.\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n            double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive = positive + value;\n                    }\n                    if (value < 0.0) {\n                        negative = negative + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, negative);\n            maximum = Math.max(maximum, positive);\n        }\n        if (minimum <= maximum) {\n            result = new Range(minimum, maximum);\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset.\n     * @param map  a structure that maps series to groups.\n     *\n     * @return The value range (<code>null</code> if the dataset contains no\n     *         values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n                                               KeyToGroupMap map) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean hasValidData = false;\n        Range result = null;\n\n        // create an array holding the group indices for each series...\n        int[] groupIndex = new int[dataset.getRowCount()];\n        for (int i = 0; i < dataset.getRowCount(); i++) {\n            groupIndex[i] = map.getGroupIndex(map.getGroup(\n                    dataset.getRowKey(i)));\n        }\n\n        // minimum and maximum for each group...\n        int groupCount = map.getGroupCount();\n        double[] minimum = new double[groupCount];\n        double[] maximum = new double[groupCount];\n\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value.\n     *\n     * @see #findMaximumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMinimumStackedRangeValue(CategoryDataset dataset) {", "right_context": "}\n\n}", "class_name": "DatasetUtilities", "return_type": "Number", "parameters": [{"type": "CategoryDataset", "name": "dataset"}]}}
{"prompt": "class DatasetUtilities {\n\n    /**\n     * Returns the minimum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value.\n     *\n     * @see #findMaximumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMinimumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double minimum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value < 0.0) {\n                        total = total + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, total);\n        }\n        if (hasValidData) {\n            result = new Double(minimum);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     *\n     * @see #findMinimumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMaximumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double maximum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        total = total + value;\n                    }\n                }\n            }\n            maximum = Math.max(maximum, total);\n        }\n        if (hasValidData) {\n            result = new Double(maximum);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range ([0.0, 0.0] if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked, using the specified base value.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param base  the base value.\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset,\n                                               double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = base;\n        double maximum = base;\n        for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getSeriesCount();\n            for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n                double y = dataset.getYValue(seriesNo, itemNo);\n                if (!Double.isNaN(y)) {\n                    if (y > 0.0) {\n                        positive += y;\n                    }\n                    else {\n                        negative += y;\n                    }\n                }\n            }\n            if (positive > maximum) {\n                maximum = positive;\n            }\n            if (negative < minimum) {\n                minimum = negative;\n            }\n        }\n        if (minimum <= maximum) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Calculates the total for the y-values in all series for a given item\n     * index.\n     *\n     * @param dataset  the dataset.\n     * @param item  the item index.\n     *\n     * @return The total.\n     *\n     * @since 1.0.5\n     */\n    public static double calculateStackTotal(TableXYDataset dataset, int item) {\n        double total = 0.0;\n        int seriesCount = dataset.getSeriesCount();\n        for (int s = 0; s < seriesCount; s++) {\n            double value = dataset.getYValue(s, item);\n            if (!Double.isNaN(value)) {\n                total = total + value;\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Calculates the range of values for a dataset where each item is the\n     * running total of the items for the current series.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range.\n     *\n     * @see #findRangeBounds(CategoryDataset)\n     */\n    public static Range findCumulativeRangeBounds(CategoryDataset dataset) {", "metadata": {"defects4j_task_id": "9683b82bdeea78c211efb03b0e4cba68fddaba504c73df4f9479d49177b1d31f", "task_id": "jfree_jfreechart/123", "ground_truth": "\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean allItemsNull = true; // we'll set this to false if there is at\n                                     // least one non-null data item...\n        double minimum = 0.0;\n        double maximum = 0.0;\n        for (int row = 0; row < dataset.getRowCount(); row++) {\n            double runningTotal = 0.0;\n            for (int column = 0; column <= dataset.getColumnCount() - 1;\n                 column++) {\n                Number n = dataset.getValue(row, column);\n                if (n != null) {\n                    allItemsNull = false;\n                    double value = n.doubleValue();\n                    if (!Double.isNaN(value)) {\n                        runningTotal = runningTotal + value;\n                        minimum = Math.min(minimum, runningTotal);\n                        maximum = Math.max(maximum, runningTotal);\n                    }\n                }\n            }\n        }\n        if (!allItemsNull) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "general", "DatasetUtilities.java"], "context_start_lineno": 0, "function_name": "findCumulativeRangeBounds", "left_context": "class DatasetUtilities {\n\n    /**\n     * Returns the minimum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value.\n     *\n     * @see #findMaximumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMinimumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double minimum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value < 0.0) {\n                        total = total + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, total);\n        }\n        if (hasValidData) {\n            result = new Double(minimum);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     *\n     * @see #findMinimumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMaximumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double maximum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        total = total + value;\n                    }\n                }\n            }\n            maximum = Math.max(maximum, total);\n        }\n        if (hasValidData) {\n            result = new Double(maximum);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range ([0.0, 0.0] if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked, using the specified base value.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param base  the base value.\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset,\n                                               double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = base;\n        double maximum = base;\n        for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getSeriesCount();\n            for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n                double y = dataset.getYValue(seriesNo, itemNo);\n                if (!Double.isNaN(y)) {\n                    if (y > 0.0) {\n                        positive += y;\n                    }\n                    else {\n                        negative += y;\n                    }\n                }\n            }\n            if (positive > maximum) {\n                maximum = positive;\n            }\n            if (negative < minimum) {\n                minimum = negative;\n            }\n        }\n        if (minimum <= maximum) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Calculates the total for the y-values in all series for a given item\n     * index.\n     *\n     * @param dataset  the dataset.\n     * @param item  the item index.\n     *\n     * @return The total.\n     *\n     * @since 1.0.5\n     */\n    public static double calculateStackTotal(TableXYDataset dataset, int item) {\n        double total = 0.0;\n        int seriesCount = dataset.getSeriesCount();\n        for (int s = 0; s < seriesCount; s++) {\n            double value = dataset.getYValue(s, item);\n            if (!Double.isNaN(value)) {\n                total = total + value;\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Calculates the range of values for a dataset where each item is the\n     * running total of the items for the current series.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range.\n     *\n     * @see #findRangeBounds(CategoryDataset)\n     */\n    public static Range findCumulativeRangeBounds(CategoryDataset dataset) {", "right_context": "}}\n\n}", "class_name": "DatasetUtilities", "return_type": "Range", "parameters": [{"type": "CategoryDataset", "name": "dataset"}]}}
{"prompt": "class TaskSeriesCollection extends AbstractSeriesDataset\n        implements GanttCategoryDataset, Cloneable, PublicCloneable,\n                   Serializable {\n\n    /**\n     * Adds a series to the dataset and sends a\n     * {@link org.jfree.data.general.DatasetChangeEvent} to all registered\n     * listeners.\n     *\n     * @param series  the series (<code>null</code> not permitted).\n     */\n    public void add(TaskSeries series) {\n        if (series == null) {\n            throw new IllegalArgumentException(\"Null 'series' argument.\");\n        }\n        this.data.add(series);\n        series.addChangeListener(this);\n\n        // look for any keys that we don't already know about...\n        Iterator iterator = series.getTasks().iterator();\n        while (iterator.hasNext()) {\n            Task task = (Task) iterator.next();\n            String key = task.getDescription();\n            int index = this.keys.indexOf(key);\n            if (index < 0) {\n                this.keys.add(key);\n            }\n        }\n        fireDatasetChanged(new DatasetChangeInfo());\n        //TODO: fill in real change info\n    }\n\n    /**\n     * Removes a series from the collection and sends\n     * a {@link org.jfree.data.general.DatasetChangeEvent}\n     * to all registered listeners.\n     *\n     * @param series  the series.\n     */\n    public void remove(TaskSeries series) {\n        if (series == null) {\n            throw new IllegalArgumentException(\"Null 'series' argument.\");\n        }\n        if (this.data.contains(series)) {\n            series.removeChangeListener(this);\n            this.data.remove(series);\n            fireDatasetChanged(new DatasetChangeInfo());\n            //TODO: fill in real change info\n        }\n    }\n\n    /**\n     * Removes a series from the collection and sends\n     * a {@link org.jfree.data.general.DatasetChangeEvent}\n     * to all registered listeners.\n     *\n     * @param series  the series (zero based index).\n     */\n    public void remove(int series) {\n        if ((series < 0) || (series >= getSeriesCount())) {\n            throw new IllegalArgumentException(\n                \"TaskSeriesCollection.remove(): index outside valid range.\");\n        }\n\n        // fetch the series, remove the change listener, then remove the series.\n        TaskSeries ts = (TaskSeries) this.data.get(series);\n        ts.removeChangeListener(this);\n        this.data.remove(series);\n        fireDatasetChanged(new DatasetChangeInfo());\n        //TODO: fill in real change info\n\n    }\n\n    /**\n     * Removes all the series from the collection and sends\n     * a {@link org.jfree.data.general.DatasetChangeEvent}\n     * to all registered listeners.\n     */\n    public void removeAll() {\n\n        // deregister the collection as a change listener to each series in\n        // the collection.\n        Iterator iterator = this.data.iterator();\n        while (iterator.hasNext()) {\n            TaskSeries series = (TaskSeries) iterator.next();\n            series.removeChangeListener(this);\n        }\n\n        // remove all the series from the collection and notify listeners.\n        this.data.clear();\n        fireDatasetChanged(new DatasetChangeInfo());\n        //TODO: fill in real change info\n\n    }\n\n    /**\n     * Returns the value for an item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     *\n     * @return The item value.\n     */\n    public Number getValue(Comparable rowKey, Comparable columnKey) {\n        return getStartValue(rowKey, columnKey);\n    }\n\n    /**\n     * Returns the value for a task.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     *\n     * @return The start value.\n     */\n    public Number getValue(int row, int column) {\n        return getStartValue(row, column);\n    }\n\n    /**\n     * Returns the start value for a task.  This is a date/time value, measured\n     * in milliseconds since 1-Jan-1970.\n     *\n     * @param rowKey  the series.\n     * @param columnKey  the category.\n     *\n     * @return The start value (possibly <code>null</code>).\n     */\n    public Number getStartValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        int row = getRowIndex(rowKey);\n        TaskSeries series = (TaskSeries) this.data.get(row);\n        Task task = series.get(columnKey.toString());\n        if (task != null) {\n            TimePeriod duration = task.getDuration();\n            if (duration != null) {\n                result = new Long(duration.getStart().getTime());\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the start value for a task.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     *\n     * @return The start value.\n     */\n    public Number getStartValue(int row, int column) {\n        Comparable rowKey = getRowKey(row);\n        Comparable columnKey = getColumnKey(column);\n        return getStartValue(rowKey, columnKey);\n    }\n\n    /**\n     * Returns the end value for a task.  This is a date/time value, measured\n     * in milliseconds since 1-Jan-1970.\n     *\n     * @param rowKey  the series.\n     * @param columnKey  the category.\n     *\n     * @return The end value (possibly <code>null</code>).\n     */\n    public Number getEndValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        int row = getRowIndex(rowKey);\n        TaskSeries series = (TaskSeries) this.data.get(row);\n        Task task = series.get(columnKey.toString());\n        if (task != null) {\n            TimePeriod duration = task.getDuration();\n            if (duration != null) {\n                result = new Long(duration.getEnd().getTime());\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the end value for a task.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     *\n     * @return The end value.\n     */\n    public Number getEndValue(int row, int column) {\n        Comparable rowKey = getRowKey(row);\n        Comparable columnKey = getColumnKey(column);\n        return getEndValue(rowKey, columnKey);\n    }\n\n    /**\n     * Returns the percent complete for a given item.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     *\n     * @return The percent complete (possibly <code>null</code>).\n     */\n    public Number getPercentComplete(int row, int column) {\n        Comparable rowKey = getRowKey(row);\n        Comparable columnKey = getColumnKey(column);\n        return getPercentComplete(rowKey, columnKey);\n    }\n\n    /**\n     * Returns the percent complete for a given item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     *\n     * @return The percent complete.\n     */\n    public Number getPercentComplete(Comparable rowKey, Comparable columnKey) {", "metadata": {"defects4j_task_id": "02d83b0019bace69bbe286a809f3140783da861edb53cf17ab1f6631ed128ee2", "task_id": "jfree_jfreechart/3", "ground_truth": "\n        Number result = null;\n        int row = getRowIndex(rowKey);\n        TaskSeries series = (TaskSeries) this.data.get(row);\n        Task task = series.get(columnKey.toString());\n        if (task != null) {\n            result = task.getPercentComplete();\n        }\n        return result;\n    ", "fpath_tuple": ["jfree_jfreechart", "jfreechart", "source", "org", "jfree", "data", "gantt", "TaskSeriesCollection.java"], "context_start_lineno": 0, "function_name": "getPercentComplete", "left_context": "class TaskSeriesCollection extends AbstractSeriesDataset\n        implements GanttCategoryDataset, Cloneable, PublicCloneable,\n                   Serializable {\n\n    /**\n     * Adds a series to the dataset and sends a\n     * {@link org.jfree.data.general.DatasetChangeEvent} to all registered\n     * listeners.\n     *\n     * @param series  the series (<code>null</code> not permitted).\n     */\n    public void add(TaskSeries series) {\n        if (series == null) {\n            throw new IllegalArgumentException(\"Null 'series' argument.\");\n        }\n        this.data.add(series);\n        series.addChangeListener(this);\n\n        // look for any keys that we don't already know about...\n        Iterator iterator = series.getTasks().iterator();\n        while (iterator.hasNext()) {\n            Task task = (Task) iterator.next();\n            String key = task.getDescription();\n            int index = this.keys.indexOf(key);\n            if (index < 0) {\n                this.keys.add(key);\n            }\n        }\n        fireDatasetChanged(new DatasetChangeInfo());\n        //TODO: fill in real change info\n    }\n\n    /**\n     * Removes a series from the collection and sends\n     * a {@link org.jfree.data.general.DatasetChangeEvent}\n     * to all registered listeners.\n     *\n     * @param series  the series.\n     */\n    public void remove(TaskSeries series) {\n        if (series == null) {\n            throw new IllegalArgumentException(\"Null 'series' argument.\");\n        }\n        if (this.data.contains(series)) {\n            series.removeChangeListener(this);\n            this.data.remove(series);\n            fireDatasetChanged(new DatasetChangeInfo());\n            //TODO: fill in real change info\n        }\n    }\n\n    /**\n     * Removes a series from the collection and sends\n     * a {@link org.jfree.data.general.DatasetChangeEvent}\n     * to all registered listeners.\n     *\n     * @param series  the series (zero based index).\n     */\n    public void remove(int series) {\n        if ((series < 0) || (series >= getSeriesCount())) {\n            throw new IllegalArgumentException(\n                \"TaskSeriesCollection.remove(): index outside valid range.\");\n        }\n\n        // fetch the series, remove the change listener, then remove the series.\n        TaskSeries ts = (TaskSeries) this.data.get(series);\n        ts.removeChangeListener(this);\n        this.data.remove(series);\n        fireDatasetChanged(new DatasetChangeInfo());\n        //TODO: fill in real change info\n\n    }\n\n    /**\n     * Removes all the series from the collection and sends\n     * a {@link org.jfree.data.general.DatasetChangeEvent}\n     * to all registered listeners.\n     */\n    public void removeAll() {\n\n        // deregister the collection as a change listener to each series in\n        // the collection.\n        Iterator iterator = this.data.iterator();\n        while (iterator.hasNext()) {\n            TaskSeries series = (TaskSeries) iterator.next();\n            series.removeChangeListener(this);\n        }\n\n        // remove all the series from the collection and notify listeners.\n        this.data.clear();\n        fireDatasetChanged(new DatasetChangeInfo());\n        //TODO: fill in real change info\n\n    }\n\n    /**\n     * Returns the value for an item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     *\n     * @return The item value.\n     */\n    public Number getValue(Comparable rowKey, Comparable columnKey) {\n        return getStartValue(rowKey, columnKey);\n    }\n\n    /**\n     * Returns the value for a task.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     *\n     * @return The start value.\n     */\n    public Number getValue(int row, int column) {\n        return getStartValue(row, column);\n    }\n\n    /**\n     * Returns the start value for a task.  This is a date/time value, measured\n     * in milliseconds since 1-Jan-1970.\n     *\n     * @param rowKey  the series.\n     * @param columnKey  the category.\n     *\n     * @return The start value (possibly <code>null</code>).\n     */\n    public Number getStartValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        int row = getRowIndex(rowKey);\n        TaskSeries series = (TaskSeries) this.data.get(row);\n        Task task = series.get(columnKey.toString());\n        if (task != null) {\n            TimePeriod duration = task.getDuration();\n            if (duration != null) {\n                result = new Long(duration.getStart().getTime());\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the start value for a task.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     *\n     * @return The start value.\n     */\n    public Number getStartValue(int row, int column) {\n        Comparable rowKey = getRowKey(row);\n        Comparable columnKey = getColumnKey(column);\n        return getStartValue(rowKey, columnKey);\n    }\n\n    /**\n     * Returns the end value for a task.  This is a date/time value, measured\n     * in milliseconds since 1-Jan-1970.\n     *\n     * @param rowKey  the series.\n     * @param columnKey  the category.\n     *\n     * @return The end value (possibly <code>null</code>).\n     */\n    public Number getEndValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        int row = getRowIndex(rowKey);\n        TaskSeries series = (TaskSeries) this.data.get(row);\n        Task task = series.get(columnKey.toString());\n        if (task != null) {\n            TimePeriod duration = task.getDuration();\n            if (duration != null) {\n                result = new Long(duration.getEnd().getTime());\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the end value for a task.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     *\n     * @return The end value.\n     */\n    public Number getEndValue(int row, int column) {\n        Comparable rowKey = getRowKey(row);\n        Comparable columnKey = getColumnKey(column);\n        return getEndValue(rowKey, columnKey);\n    }\n\n    /**\n     * Returns the percent complete for a given item.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     *\n     * @return The percent complete (possibly <code>null</code>).\n     */\n    public Number getPercentComplete(int row, int column) {\n        Comparable rowKey = getRowKey(row);\n        Comparable columnKey = getColumnKey(column);\n        return getPercentComplete(rowKey, columnKey);\n    }\n\n    /**\n     * Returns the percent complete for a given item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     *\n     * @return The percent complete.\n     */\n    public Number getPercentComplete(Comparable rowKey, Comparable columnKey) {", "right_context": "}\n\n}", "class_name": "TaskSeriesCollection", "return_type": "Number", "parameters": [{"type": "Comparable", "name": "rowKey"}, {"type": "Comparable", "name": "columnKey"}]}}
{"prompt": "class FastDatePrinter implements DatePrinter, Serializable {\n    // A lot of the speed in this class comes from caching, but some comes\n    // from the special int to StringBuffer conversion.\n    //\n    // The following produces a padded 2 digit number:\n    //   buffer.append((char)(value / 10 + '0'));\n    //   buffer.append((char)(value % 10 + '0'));\n    //\n    // Note that the fastest append to StringBuffer is a single char (used here).\n    // Note that Integer.toString() is not called, the conversion is simply\n    // taking the value and adding (mathematically) the ASCII value for '0'.\n    // So, don't change this code! It works and is very fast.\n\n    /**\n     * <p>Inner class to output a two digit number.</p>\n     */\n    private static class TwoDigitNumberField implements NumberRule {\n        private final int mField;\n\n        /**\n         * Constructs an instance of {@code TwoDigitNumberField} with the specified field.\n         *\n         * @param field the field\n         */\n        TwoDigitNumberField(final int field) {\n            mField = field;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public final void appendTo(final StringBuffer buffer, final int value) {\n            if (value < 100) {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output a two digit year.</p>\n     */\n    private static class TwoDigitYearField implements NumberRule {\n        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();\n\n        /**\n         * Constructs an instance of {@code TwoDigitYearField}.\n         */\n        TwoDigitYearField() {\n            super();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public final void appendTo(final StringBuffer buffer, final int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    /**\n     * <p>Inner class to output a two digit month.</p>\n     */\n    private static class TwoDigitMonthField implements NumberRule {\n        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n\n        /**\n         * Constructs an instance of {@code TwoDigitMonthField}.\n         */\n        TwoDigitMonthField() {\n            super();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public final void appendTo(final StringBuffer buffer, final int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    /**\n     * <p>Inner class to output the twelve hour field.</p>\n     */\n    private static class TwelveHourField implements NumberRule {\n        private final NumberRule mRule;\n\n        /**\n         * Constructs an instance of {@code TwelveHourField} with the specified\n         * {@code NumberRule}.\n         *\n         * @param rule the rule\n         */\n        TwelveHourField(final NumberRule rule) {\n            mRule = rule;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR);\n            if (value == 0) {\n                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    /**\n     * <p>Inner class to output the twenty four hour field.</p>\n     */\n    private static class TwentyFourHourField implements NumberRule {\n        private final NumberRule mRule;\n\n        /**\n         * Constructs an instance of {@code TwentyFourHourField} with the specified\n         * {@code NumberRule}.\n         *\n         * @param rule the rule\n         */\n        TwentyFourHourField(final NumberRule rule) {\n            mRule = rule;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR_OF_DAY);\n            if (value == 0) {\n                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n\n    private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache =\n        new ConcurrentHashMap<TimeZoneDisplayKey, String>(7);\n    /**\n     * <p>Gets the time zone display name, using a cache for performance.</p>\n     *\n     * @param tz  the zone to query\n     * @param daylight  true if daylight savings\n     * @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}\n     * @param locale  the locale to use\n     * @return the textual name of the time zone\n     */\n    static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale) {", "metadata": {"defects4j_task_id": "fb1ee511477b64d1e57e91e7480b1a04ba5c67eacb628dc65958b040dbb05444", "task_id": "apache_commons-lang/206", "ground_truth": "\n        final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = cTimeZoneDisplayCache.get(key);\n        if (value == null) {\n            // This is a very slow call, so cache the results.\n            value = tz.getDisplayName(daylight, style, locale);\n            final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n            if (prior != null) {\n                value= prior;\n            }\n        }\n        return value;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "time", "FastDatePrinter.java"], "context_start_lineno": 0, "function_name": "getTimeZoneDisplay", "left_context": "class FastDatePrinter implements DatePrinter, Serializable {\n    // A lot of the speed in this class comes from caching, but some comes\n    // from the special int to StringBuffer conversion.\n    //\n    // The following produces a padded 2 digit number:\n    //   buffer.append((char)(value / 10 + '0'));\n    //   buffer.append((char)(value % 10 + '0'));\n    //\n    // Note that the fastest append to StringBuffer is a single char (used here).\n    // Note that Integer.toString() is not called, the conversion is simply\n    // taking the value and adding (mathematically) the ASCII value for '0'.\n    // So, don't change this code! It works and is very fast.\n\n    /**\n     * <p>Inner class to output a two digit number.</p>\n     */\n    private static class TwoDigitNumberField implements NumberRule {\n        private final int mField;\n\n        /**\n         * Constructs an instance of {@code TwoDigitNumberField} with the specified field.\n         *\n         * @param field the field\n         */\n        TwoDigitNumberField(final int field) {\n            mField = field;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n            appendTo(buffer, calendar.get(mField));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public final void appendTo(final StringBuffer buffer, final int value) {\n            if (value < 100) {\n                buffer.append((char)(value / 10 + '0'));\n                buffer.append((char)(value % 10 + '0'));\n            } else {\n                buffer.append(Integer.toString(value));\n            }\n        }\n    }\n\n    /**\n     * <p>Inner class to output a two digit year.</p>\n     */\n    private static class TwoDigitYearField implements NumberRule {\n        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();\n\n        /**\n         * Constructs an instance of {@code TwoDigitYearField}.\n         */\n        TwoDigitYearField() {\n            super();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public final void appendTo(final StringBuffer buffer, final int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    /**\n     * <p>Inner class to output a two digit month.</p>\n     */\n    private static class TwoDigitMonthField implements NumberRule {\n        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n\n        /**\n         * Constructs an instance of {@code TwoDigitMonthField}.\n         */\n        TwoDigitMonthField() {\n            super();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int estimateLength() {\n            return 2;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public final void appendTo(final StringBuffer buffer, final int value) {\n            buffer.append((char)(value / 10 + '0'));\n            buffer.append((char)(value % 10 + '0'));\n        }\n    }\n\n    /**\n     * <p>Inner class to output the twelve hour field.</p>\n     */\n    private static class TwelveHourField implements NumberRule {\n        private final NumberRule mRule;\n\n        /**\n         * Constructs an instance of {@code TwelveHourField} with the specified\n         * {@code NumberRule}.\n         *\n         * @param rule the rule\n         */\n        TwelveHourField(final NumberRule rule) {\n            mRule = rule;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR);\n            if (value == 0) {\n                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    /**\n     * <p>Inner class to output the twenty four hour field.</p>\n     */\n    private static class TwentyFourHourField implements NumberRule {\n        private final NumberRule mRule;\n\n        /**\n         * Constructs an instance of {@code TwentyFourHourField} with the specified\n         * {@code NumberRule}.\n         *\n         * @param rule the rule\n         */\n        TwentyFourHourField(final NumberRule rule) {\n            mRule = rule;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int estimateLength() {\n            return mRule.estimateLength();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n            int value = calendar.get(Calendar.HOUR_OF_DAY);\n            if (value == 0) {\n                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n            }\n            mRule.appendTo(buffer, value);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void appendTo(final StringBuffer buffer, final int value) {\n            mRule.appendTo(buffer, value);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n\n    private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache =\n        new ConcurrentHashMap<TimeZoneDisplayKey, String>(7);\n    /**\n     * <p>Gets the time zone display name, using a cache for performance.</p>\n     *\n     * @param tz  the zone to query\n     * @param daylight  true if daylight savings\n     * @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}\n     * @param locale  the locale to use\n     * @return the textual name of the time zone\n     */\n    static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale) {", "right_context": "}\n}", "class_name": "FastDatePrinter", "return_type": "String", "parameters": [{"type": "TimeZone", "name": "tz"}, {"type": "boolean", "name": "daylight"}, {"type": "int", "name": "style"}, {"type": "Locale", "name": "locale"}]}}
{"prompt": "class FastDateParser implements DateParser, Serializable {\n    /**\n     * Get the short and long values displayed for a field\n     * @param field The field of interest\n     * @param definingCalendar The calendar to obtain the short and long values\n     * @param locale The locale of display names\n     * @return A Map of the field key / value pairs\n     */\n    private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale) {\n        return definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale);\n    }\n\n    /**\n     * Adjust dates to be within 80 years before and 20 years after instantiation\n     * @param twoDigitYear The year to adjust\n     * @return A value within -80 and +20 years from instantiation of this instance\n     */\n    int adjustYear(final int twoDigitYear) {\n        final int trial= twoDigitYear + thisYear - thisYear%100;\n        if(trial < thisYear+20) {\n            return trial;\n        }\n        return trial-100;\n    }\n\n    /**\n     * Is the next field a number?\n     * @return true, if next field will be a number\n     */\n    boolean isNextNumber() {\n        return nextStrategy!=null && nextStrategy.isNumber();\n    }\n\n    /**\n     * What is the width of the current field?\n     * @return The number of characters in the current format field\n     */\n    int getFieldWidth() {\n        return currentFormatField.length();\n    }\n\n    /**\n     * A strategy to parse a single field from the parsing pattern\n     */\n    private static abstract class Strategy {\n        /**\n         * Is this field a number?\n         * The default implementation returns true.\n         * \n         * @return true, if field is a number\n         */\n        boolean isNumber() {\n            return false;\n        }\n        /**\n         * Set the Calendar with the parsed field.\n         * \n         * The default implementation does nothing.\n         * \n         * @param parser The parser calling this strategy\n         * @param cal The <code>Calendar</code> to set\n         * @param value The parsed field to translate and set in cal\n         */\n        void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {\n            \n        }\n        /**\n         * Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code>\n         * which will accept this field\n         * @param parser The parser calling this strategy\n         * @param regex The <code>StringBuilder</code> to append to\n         * @return true, if this field will set the calendar;\n         * false, if this field is a constant value\n         */\n        abstract boolean addRegex(FastDateParser parser, StringBuilder regex);\n    }\n\n    /**\n     * A <code>Pattern</code> to parse the user supplied SimpleDateFormat pattern\n     */\n    private static final Pattern formatPattern= Pattern.compile(\n            \"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n\n    /**\n     * Obtain a Strategy given a field from a SimpleDateFormat pattern\n     * @param formatField A sub-sequence of the SimpleDateFormat pattern\n     * @param definingCalendar The calendar to obtain the short and long values\n     * @return The Strategy that will handle parsing for the field\n     */\n    private Strategy getStrategy(String formatField, final Calendar definingCalendar) {\n        switch(formatField.charAt(0)) {\n        case '\\'':\n            if(formatField.length()>2) {\n                formatField= formatField.substring(1, formatField.length()-1);\n            }\n            //$FALL-THROUGH$\n        default:\n            return new CopyQuotedStrategy(formatField);\n        case 'D':\n            return DAY_OF_YEAR_STRATEGY;\n        case 'E':\n            return getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar);\n        case 'F':\n            return DAY_OF_WEEK_IN_MONTH_STRATEGY;\n        case 'G':\n            return getLocaleSpecificStrategy(Calendar.ERA, definingCalendar);\n        case 'H':\n            return MODULO_HOUR_OF_DAY_STRATEGY;\n        case 'K':\n            return HOUR_STRATEGY;\n        case 'M':\n            return formatField.length()>=3 ?getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) :NUMBER_MONTH_STRATEGY;\n        case 'S':\n            return MILLISECOND_STRATEGY;\n        case 'W':\n            return WEEK_OF_MONTH_STRATEGY;\n        case 'a':\n            return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar);\n        case 'd':\n            return DAY_OF_MONTH_STRATEGY;\n        case 'h':\n            return MODULO_HOUR_STRATEGY;\n        case 'k':\n            return HOUR_OF_DAY_STRATEGY;\n        case 'm':\n            return MINUTE_STRATEGY;\n        case 's':\n            return SECOND_STRATEGY;\n        case 'w':\n            return WEEK_OF_YEAR_STRATEGY;\n        case 'y':\n            return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\n        case 'Z':\n        case 'z':\n            return getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\") // OK because we are creating an array with no entries\n    private static ConcurrentMap<Locale, Strategy>[] caches = new ConcurrentMap[Calendar.FIELD_COUNT];\n\n    /**\n     * Get a cache of Strategies for a particular field\n     * @param field The Calendar field\n     * @return a cache of Locale to Strategy\n     */\n    private static ConcurrentMap<Locale, Strategy> getCache(final int field) {\n        synchronized(caches) {\n            if(caches[field]==null) {\n                caches[field]= new ConcurrentHashMap<Locale,Strategy>(3);\n            }\n            return caches[field];\n        }\n    }\n\n    /**\n     * Construct a Strategy that parses a Text field\n     * @param field The Calendar field\n     * @param definingCalendar The calendar to obtain the short and long values\n     * @return a TextStrategy for the field and Locale\n     */\n    private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar) {", "metadata": {"defects4j_task_id": "4f4463aecc16b8f2eb8b94e19eb7a5ef45677097f3d7ee18f0e4543a53ae44b6", "task_id": "apache_commons-lang/71", "ground_truth": "\n        final ConcurrentMap<Locale,Strategy> cache = getCache(field);\n        Strategy strategy= cache.get(locale);\n        if(strategy==null) {\n            strategy= field==Calendar.ZONE_OFFSET\n                    ? new TimeZoneStrategy(locale)\n                    : new TextStrategy(field, definingCalendar, locale);\n            final Strategy inCache= cache.putIfAbsent(locale, strategy);\n            if(inCache!=null) {\n                return inCache;\n            }\n        }\n        return strategy;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "time", "FastDateParser.java"], "context_start_lineno": 0, "function_name": "getLocaleSpecificStrategy", "left_context": "class FastDateParser implements DateParser, Serializable {\n    /**\n     * Get the short and long values displayed for a field\n     * @param field The field of interest\n     * @param definingCalendar The calendar to obtain the short and long values\n     * @param locale The locale of display names\n     * @return A Map of the field key / value pairs\n     */\n    private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale) {\n        return definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale);\n    }\n\n    /**\n     * Adjust dates to be within 80 years before and 20 years after instantiation\n     * @param twoDigitYear The year to adjust\n     * @return A value within -80 and +20 years from instantiation of this instance\n     */\n    int adjustYear(final int twoDigitYear) {\n        final int trial= twoDigitYear + thisYear - thisYear%100;\n        if(trial < thisYear+20) {\n            return trial;\n        }\n        return trial-100;\n    }\n\n    /**\n     * Is the next field a number?\n     * @return true, if next field will be a number\n     */\n    boolean isNextNumber() {\n        return nextStrategy!=null && nextStrategy.isNumber();\n    }\n\n    /**\n     * What is the width of the current field?\n     * @return The number of characters in the current format field\n     */\n    int getFieldWidth() {\n        return currentFormatField.length();\n    }\n\n    /**\n     * A strategy to parse a single field from the parsing pattern\n     */\n    private static abstract class Strategy {\n        /**\n         * Is this field a number?\n         * The default implementation returns true.\n         * \n         * @return true, if field is a number\n         */\n        boolean isNumber() {\n            return false;\n        }\n        /**\n         * Set the Calendar with the parsed field.\n         * \n         * The default implementation does nothing.\n         * \n         * @param parser The parser calling this strategy\n         * @param cal The <code>Calendar</code> to set\n         * @param value The parsed field to translate and set in cal\n         */\n        void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {\n            \n        }\n        /**\n         * Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code>\n         * which will accept this field\n         * @param parser The parser calling this strategy\n         * @param regex The <code>StringBuilder</code> to append to\n         * @return true, if this field will set the calendar;\n         * false, if this field is a constant value\n         */\n        abstract boolean addRegex(FastDateParser parser, StringBuilder regex);\n    }\n\n    /**\n     * A <code>Pattern</code> to parse the user supplied SimpleDateFormat pattern\n     */\n    private static final Pattern formatPattern= Pattern.compile(\n            \"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n\n    /**\n     * Obtain a Strategy given a field from a SimpleDateFormat pattern\n     * @param formatField A sub-sequence of the SimpleDateFormat pattern\n     * @param definingCalendar The calendar to obtain the short and long values\n     * @return The Strategy that will handle parsing for the field\n     */\n    private Strategy getStrategy(String formatField, final Calendar definingCalendar) {\n        switch(formatField.charAt(0)) {\n        case '\\'':\n            if(formatField.length()>2) {\n                formatField= formatField.substring(1, formatField.length()-1);\n            }\n            //$FALL-THROUGH$\n        default:\n            return new CopyQuotedStrategy(formatField);\n        case 'D':\n            return DAY_OF_YEAR_STRATEGY;\n        case 'E':\n            return getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar);\n        case 'F':\n            return DAY_OF_WEEK_IN_MONTH_STRATEGY;\n        case 'G':\n            return getLocaleSpecificStrategy(Calendar.ERA, definingCalendar);\n        case 'H':\n            return MODULO_HOUR_OF_DAY_STRATEGY;\n        case 'K':\n            return HOUR_STRATEGY;\n        case 'M':\n            return formatField.length()>=3 ?getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) :NUMBER_MONTH_STRATEGY;\n        case 'S':\n            return MILLISECOND_STRATEGY;\n        case 'W':\n            return WEEK_OF_MONTH_STRATEGY;\n        case 'a':\n            return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar);\n        case 'd':\n            return DAY_OF_MONTH_STRATEGY;\n        case 'h':\n            return MODULO_HOUR_STRATEGY;\n        case 'k':\n            return HOUR_OF_DAY_STRATEGY;\n        case 'm':\n            return MINUTE_STRATEGY;\n        case 's':\n            return SECOND_STRATEGY;\n        case 'w':\n            return WEEK_OF_YEAR_STRATEGY;\n        case 'y':\n            return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\n        case 'Z':\n        case 'z':\n            return getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\") // OK because we are creating an array with no entries\n    private static ConcurrentMap<Locale, Strategy>[] caches = new ConcurrentMap[Calendar.FIELD_COUNT];\n\n    /**\n     * Get a cache of Strategies for a particular field\n     * @param field The Calendar field\n     * @return a cache of Locale to Strategy\n     */\n    private static ConcurrentMap<Locale, Strategy> getCache(final int field) {\n        synchronized(caches) {\n            if(caches[field]==null) {\n                caches[field]= new ConcurrentHashMap<Locale,Strategy>(3);\n            }\n            return caches[field];\n        }\n    }\n\n    /**\n     * Construct a Strategy that parses a Text field\n     * @param field The Calendar field\n     * @param definingCalendar The calendar to obtain the short and long values\n     * @return a TextStrategy for the field and Locale\n     */\n    private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar) {", "right_context": "}\n}", "class_name": "FastDateParser", "return_type": "Strategy", "parameters": [{"type": "int", "name": "field"}, {"type": "Calendar", "name": "definingCalendar"}]}}
{"prompt": "class EnumUtils {\n\n    private static final String CANNOT_STORE_S_S_VALUES_IN_S_BITS = \"Cannot store %s %s values in %s bits\";\n    private static final String S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE = \"%s does not seem to be an Enum type\";\n    private static final String ENUM_CLASS_MUST_BE_DEFINED = \"EnumClass must be defined.\";\n\n    /**\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     */\n    public EnumUtils() {\n    }\n\n    /**\n     * <p>Gets the {@code Map} of enums by name.</p>\n     *\n     * <p>This method is useful when you need a map of enums by name.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @return the modifiable map of enum names to enums, never null\n     */\n    public static <E extends Enum<E>> Map<String, E> getEnumMap(final Class<E> enumClass) {\n        final Map<String, E> map = new LinkedHashMap<String, E>();\n        for (final E e: enumClass.getEnumConstants()) {\n            map.put(e.name(), e);\n        }\n        return map;\n    }\n\n    /**\n     * <p>Gets the {@code List} of enums.</p>\n     *\n     * <p>This method is useful when you need a list of enums rather than an array.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @return the modifiable list of enums, never null\n     */\n    public static <E extends Enum<E>> List<E> getEnumList(final Class<E> enumClass) {\n        return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants()));\n    }\n\n    /**\n     * <p>Checks if the specified name is a valid enum for the class.</p>\n     *\n     * <p>This method differs from {@link Enum#valueOf} in that checks if the name is\n     * a valid enum without needing to catch the exception.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @param enumName   the enum name, null returns false\n     * @return true if the enum name is valid, otherwise false\n     */\n    public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) {\n        if (enumName == null) {\n            return false;\n        }\n        try {\n            Enum.valueOf(enumClass, enumName);\n            return true;\n        } catch (final IllegalArgumentException ex) {\n            return false;\n        }\n    }\n\n    /**\n     * <p>Gets the enum for the class, returning {@code null} if not found.</p>\n     *\n     * <p>This method differs from {@link Enum#valueOf} in that it does not throw an exception\n     * for an invalid enum name.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @param enumName   the enum name, null returns null\n     * @return the enum, null if not found\n     */\n    public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {\n        if (enumName == null) {\n            return null;\n        }\n        try {\n            return Enum.valueOf(enumClass, enumName);\n        } catch (final IllegalArgumentException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * <p>Creates a long bit vector representation of the given subset of an Enum.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVector}.</p>\n     *\n     * <p>Do not use this method if you have more than 64 values in your Enum, as this\n     * would create a value greater than a long can hold.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long whose value provides a binary representation of the given set of enum values.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values,\n     *                                  or if any {@code values} {@code null}\n     * @since 3.0.1\n     * @see #generateBitVectors(Class, Iterable)\n     */\n    public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values) {", "metadata": {"defects4j_task_id": "e74ce3ea22dc353e8315bd09d07a7705cd069735609b5df5fa41c54332562f1f", "task_id": "apache_commons-lang/188", "ground_truth": "\n        checkBitVectorable(enumClass);\n        Validate.notNull(values);\n        long total = 0;\n        for (final E constant : values) {\n            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n            total |= 1 << constant.ordinal();\n        }\n        return total;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "EnumUtils.java"], "context_start_lineno": 0, "function_name": "generateBitVector", "left_context": "class EnumUtils {\n\n    private static final String CANNOT_STORE_S_S_VALUES_IN_S_BITS = \"Cannot store %s %s values in %s bits\";\n    private static final String S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE = \"%s does not seem to be an Enum type\";\n    private static final String ENUM_CLASS_MUST_BE_DEFINED = \"EnumClass must be defined.\";\n\n    /**\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     */\n    public EnumUtils() {\n    }\n\n    /**\n     * <p>Gets the {@code Map} of enums by name.</p>\n     *\n     * <p>This method is useful when you need a map of enums by name.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @return the modifiable map of enum names to enums, never null\n     */\n    public static <E extends Enum<E>> Map<String, E> getEnumMap(final Class<E> enumClass) {\n        final Map<String, E> map = new LinkedHashMap<String, E>();\n        for (final E e: enumClass.getEnumConstants()) {\n            map.put(e.name(), e);\n        }\n        return map;\n    }\n\n    /**\n     * <p>Gets the {@code List} of enums.</p>\n     *\n     * <p>This method is useful when you need a list of enums rather than an array.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @return the modifiable list of enums, never null\n     */\n    public static <E extends Enum<E>> List<E> getEnumList(final Class<E> enumClass) {\n        return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants()));\n    }\n\n    /**\n     * <p>Checks if the specified name is a valid enum for the class.</p>\n     *\n     * <p>This method differs from {@link Enum#valueOf} in that checks if the name is\n     * a valid enum without needing to catch the exception.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @param enumName   the enum name, null returns false\n     * @return true if the enum name is valid, otherwise false\n     */\n    public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) {\n        if (enumName == null) {\n            return false;\n        }\n        try {\n            Enum.valueOf(enumClass, enumName);\n            return true;\n        } catch (final IllegalArgumentException ex) {\n            return false;\n        }\n    }\n\n    /**\n     * <p>Gets the enum for the class, returning {@code null} if not found.</p>\n     *\n     * <p>This method differs from {@link Enum#valueOf} in that it does not throw an exception\n     * for an invalid enum name.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @param enumName   the enum name, null returns null\n     * @return the enum, null if not found\n     */\n    public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {\n        if (enumName == null) {\n            return null;\n        }\n        try {\n            return Enum.valueOf(enumClass, enumName);\n        } catch (final IllegalArgumentException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * <p>Creates a long bit vector representation of the given subset of an Enum.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVector}.</p>\n     *\n     * <p>Do not use this method if you have more than 64 values in your Enum, as this\n     * would create a value greater than a long can hold.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long whose value provides a binary representation of the given set of enum values.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values,\n     *                                  or if any {@code values} {@code null}\n     * @since 3.0.1\n     * @see #generateBitVectors(Class, Iterable)\n     */\n    public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values) {", "right_context": "}\n}", "class_name": "EnumUtils", "return_type": "long", "parameters": [{"type": "Class<E>", "name": "enumClass"}, {"type": "Iterable<E>", "name": "values"}]}}
{"prompt": "class EnumUtils {\n\n    private static final String CANNOT_STORE_S_S_VALUES_IN_S_BITS = \"Cannot store %s %s values in %s bits\";\n    private static final String S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE = \"%s does not seem to be an Enum type\";\n    private static final String ENUM_CLASS_MUST_BE_DEFINED = \"EnumClass must be defined.\";\n\n    /**\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     */\n    public EnumUtils() {\n    }\n\n    /**\n     * <p>Gets the {@code Map} of enums by name.</p>\n     *\n     * <p>This method is useful when you need a map of enums by name.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @return the modifiable map of enum names to enums, never null\n     */\n    public static <E extends Enum<E>> Map<String, E> getEnumMap(final Class<E> enumClass) {\n        final Map<String, E> map = new LinkedHashMap<String, E>();\n        for (final E e: enumClass.getEnumConstants()) {\n            map.put(e.name(), e);\n        }\n        return map;\n    }\n\n    /**\n     * <p>Gets the {@code List} of enums.</p>\n     *\n     * <p>This method is useful when you need a list of enums rather than an array.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @return the modifiable list of enums, never null\n     */\n    public static <E extends Enum<E>> List<E> getEnumList(final Class<E> enumClass) {\n        return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants()));\n    }\n\n    /**\n     * <p>Checks if the specified name is a valid enum for the class.</p>\n     *\n     * <p>This method differs from {@link Enum#valueOf} in that checks if the name is\n     * a valid enum without needing to catch the exception.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @param enumName   the enum name, null returns false\n     * @return true if the enum name is valid, otherwise false\n     */\n    public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) {\n        if (enumName == null) {\n            return false;\n        }\n        try {\n            Enum.valueOf(enumClass, enumName);\n            return true;\n        } catch (final IllegalArgumentException ex) {\n            return false;\n        }\n    }\n\n    /**\n     * <p>Gets the enum for the class, returning {@code null} if not found.</p>\n     *\n     * <p>This method differs from {@link Enum#valueOf} in that it does not throw an exception\n     * for an invalid enum name.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @param enumName   the enum name, null returns null\n     * @return the enum, null if not found\n     */\n    public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {\n        if (enumName == null) {\n            return null;\n        }\n        try {\n            return Enum.valueOf(enumClass, enumName);\n        } catch (final IllegalArgumentException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * <p>Creates a long bit vector representation of the given subset of an Enum.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVector}.</p>\n     *\n     * <p>Do not use this method if you have more than 64 values in your Enum, as this\n     * would create a value greater than a long can hold.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long whose value provides a binary representation of the given set of enum values.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values,\n     *                                  or if any {@code values} {@code null}\n     * @since 3.0.1\n     * @see #generateBitVectors(Class, Iterable)\n     */\n    public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values) {\n        checkBitVectorable(enumClass);\n        Validate.notNull(values);\n        long total = 0;\n        for (final E constant : values) {\n            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n            total |= 1 << constant.ordinal();\n        }\n        return total;\n    }\n\n    /**\n     * <p>Creates a bit vector representation of the given subset of an Enum using as many {@code long}s as needed.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVectors}.</p>\n     *\n     * <p>Use this method if you have more than 64 values in your Enum.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long[] whose values provide a binary representation of the given set of enum values\n     *         with least significant digits rightmost.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}\n     * @since 3.2\n     */\n    public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values) {", "metadata": {"defects4j_task_id": "e3fd5c1afba5da1c700e09a2551aa4400eb20bff75dd850739d76bdcebb2a23d", "task_id": "apache_commons-lang/185", "ground_truth": "\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E constant : values) {\n            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(constant);\n        }\n        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n        for (final E value : condensed) {\n            result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n        }\n        ArrayUtils.reverse(result);\n        return result;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "EnumUtils.java"], "context_start_lineno": 0, "function_name": "generateBitVectors", "left_context": "class EnumUtils {\n\n    private static final String CANNOT_STORE_S_S_VALUES_IN_S_BITS = \"Cannot store %s %s values in %s bits\";\n    private static final String S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE = \"%s does not seem to be an Enum type\";\n    private static final String ENUM_CLASS_MUST_BE_DEFINED = \"EnumClass must be defined.\";\n\n    /**\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     */\n    public EnumUtils() {\n    }\n\n    /**\n     * <p>Gets the {@code Map} of enums by name.</p>\n     *\n     * <p>This method is useful when you need a map of enums by name.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @return the modifiable map of enum names to enums, never null\n     */\n    public static <E extends Enum<E>> Map<String, E> getEnumMap(final Class<E> enumClass) {\n        final Map<String, E> map = new LinkedHashMap<String, E>();\n        for (final E e: enumClass.getEnumConstants()) {\n            map.put(e.name(), e);\n        }\n        return map;\n    }\n\n    /**\n     * <p>Gets the {@code List} of enums.</p>\n     *\n     * <p>This method is useful when you need a list of enums rather than an array.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @return the modifiable list of enums, never null\n     */\n    public static <E extends Enum<E>> List<E> getEnumList(final Class<E> enumClass) {\n        return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants()));\n    }\n\n    /**\n     * <p>Checks if the specified name is a valid enum for the class.</p>\n     *\n     * <p>This method differs from {@link Enum#valueOf} in that checks if the name is\n     * a valid enum without needing to catch the exception.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @param enumName   the enum name, null returns false\n     * @return true if the enum name is valid, otherwise false\n     */\n    public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) {\n        if (enumName == null) {\n            return false;\n        }\n        try {\n            Enum.valueOf(enumClass, enumName);\n            return true;\n        } catch (final IllegalArgumentException ex) {\n            return false;\n        }\n    }\n\n    /**\n     * <p>Gets the enum for the class, returning {@code null} if not found.</p>\n     *\n     * <p>This method differs from {@link Enum#valueOf} in that it does not throw an exception\n     * for an invalid enum name.</p>\n     *\n     * @param <E> the type of the enumeration\n     * @param enumClass  the class of the enum to query, not null\n     * @param enumName   the enum name, null returns null\n     * @return the enum, null if not found\n     */\n    public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {\n        if (enumName == null) {\n            return null;\n        }\n        try {\n            return Enum.valueOf(enumClass, enumName);\n        } catch (final IllegalArgumentException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * <p>Creates a long bit vector representation of the given subset of an Enum.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVector}.</p>\n     *\n     * <p>Do not use this method if you have more than 64 values in your Enum, as this\n     * would create a value greater than a long can hold.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long whose value provides a binary representation of the given set of enum values.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values,\n     *                                  or if any {@code values} {@code null}\n     * @since 3.0.1\n     * @see #generateBitVectors(Class, Iterable)\n     */\n    public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values) {\n        checkBitVectorable(enumClass);\n        Validate.notNull(values);\n        long total = 0;\n        for (final E constant : values) {\n            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n            total |= 1 << constant.ordinal();\n        }\n        return total;\n    }\n\n    /**\n     * <p>Creates a bit vector representation of the given subset of an Enum using as many {@code long}s as needed.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVectors}.</p>\n     *\n     * <p>Use this method if you have more than 64 values in your Enum.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long[] whose values provide a binary representation of the given set of enum values\n     *         with least significant digits rightmost.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}\n     * @since 3.2\n     */\n    public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values) {", "right_context": "}\n}", "class_name": "EnumUtils", "return_type": "long[]", "parameters": [{"type": "Class<E>", "name": "enumClass"}, {"type": "Iterable<E>", "name": "values"}]}}
{"prompt": "class EnumUtils {\n\n    /**\n     * <p>Creates a bit vector representation of the given subset of an Enum using as many {@code long}s as needed.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVectors}.</p>\n     *\n     * <p>Use this method if you have more than 64 values in your Enum.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long[] whose values provide a binary representation of the given set of enum values\n     *         with least significant digits rightmost.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}\n     * @since 3.2\n     */\n    public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values) {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E constant : values) {\n            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(constant);\n        }\n        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n        for (final E value : condensed) {\n            result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n        }\n        ArrayUtils.reverse(result);\n        return result;\n    }\n\n    /**\n     * <p>Creates a long bit vector representation of the given array of Enum values.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVector}.</p>\n     *\n     * <p>Do not use this method if you have more than 64 values in your Enum, as this\n     * would create a value greater than a long can hold.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long whose value provides a binary representation of the given set of enum values.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n     * @since 3.0.1\n     * @see #generateBitVectors(Class, Iterable)\n     */\n    public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {\n        Validate.noNullElements(values);\n        return generateBitVector(enumClass, Arrays.<E> asList(values));\n    }\n\n    /**\n     * <p>Creates a bit vector representation of the given subset of an Enum using as many {@code long}s as needed.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVectors}.</p>\n     *\n     * <p>Use this method if you have more than 64 values in your Enum.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long[] whose values provide a binary representation of the given set of enum values\n     *         with least significant digits rightmost.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}\n     * @since 3.2\n     */\n    public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) {\n        asEnum(enumClass);\n        Validate.noNullElements(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        Collections.addAll(condensed, values);\n        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n        for (final E value : condensed) {\n            result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n        }\n        ArrayUtils.reverse(result);\n        return result;\n    }\n\n    /**\n     * <p>Convert a long value created by {@link EnumUtils#generateBitVector} into the set of\n     * enum values that it represents.</p>\n     *\n     * <p>If you store this value, beware any changes to the enum that would affect ordinal values.</p>\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param value     the long value representation of a set of enum values\n     * @param <E>       the type of the enumeration\n     * @return a set of enum values\n     * @throws NullPointerException if {@code enumClass} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n     * @since 3.0.1\n     */\n    public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) {\n        checkBitVectorable(enumClass).getEnumConstants();\n        return processBitVectors(enumClass, value);\n    }\n\n    /**\n     * <p>Convert a {@code long[]} created by {@link EnumUtils#generateBitVectors} into the set of\n     * enum values that it represents.</p>\n     *\n     * <p>If you store this value, beware any changes to the enum that would affect ordinal values.</p>\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values     the long[] bearing the representation of a set of enum values, least significant digits rightmost, not {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a set of enum values\n     * @throws NullPointerException if {@code enumClass} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class\n     * @since 3.2\n     */\n    public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values) {", "metadata": {"defects4j_task_id": "55ceec3d86add131e10a3752c2943710c38855203b70eacfb874cfdc54552807", "task_id": "apache_commons-lang/75", "ground_truth": "\n        final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass));\n        values = ArrayUtils.clone(Validate.notNull(values));\n        ArrayUtils.reverse(values);\n        for (final E constant : enumClass.getEnumConstants()) {\n            final int block = constant.ordinal() / Long.SIZE;\n            if (block < values.length && (values[block] & 1 << (constant.ordinal() % Long.SIZE)) != 0) {\n                results.add(constant);\n            }\n        }\n        return results;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "EnumUtils.java"], "context_start_lineno": 0, "function_name": "processBitVectors", "left_context": "class EnumUtils {\n\n    /**\n     * <p>Creates a bit vector representation of the given subset of an Enum using as many {@code long}s as needed.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVectors}.</p>\n     *\n     * <p>Use this method if you have more than 64 values in your Enum.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long[] whose values provide a binary representation of the given set of enum values\n     *         with least significant digits rightmost.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}\n     * @since 3.2\n     */\n    public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values) {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E constant : values) {\n            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(constant);\n        }\n        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n        for (final E value : condensed) {\n            result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n        }\n        ArrayUtils.reverse(result);\n        return result;\n    }\n\n    /**\n     * <p>Creates a long bit vector representation of the given array of Enum values.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVector}.</p>\n     *\n     * <p>Do not use this method if you have more than 64 values in your Enum, as this\n     * would create a value greater than a long can hold.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long whose value provides a binary representation of the given set of enum values.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n     * @since 3.0.1\n     * @see #generateBitVectors(Class, Iterable)\n     */\n    public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {\n        Validate.noNullElements(values);\n        return generateBitVector(enumClass, Arrays.<E> asList(values));\n    }\n\n    /**\n     * <p>Creates a bit vector representation of the given subset of an Enum using as many {@code long}s as needed.</p>\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVectors}.</p>\n     *\n     * <p>Use this method if you have more than 64 values in your Enum.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a long[] whose values provide a binary representation of the given set of enum values\n     *         with least significant digits rightmost.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}\n     * @since 3.2\n     */\n    public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) {\n        asEnum(enumClass);\n        Validate.noNullElements(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        Collections.addAll(condensed, values);\n        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n        for (final E value : condensed) {\n            result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n        }\n        ArrayUtils.reverse(result);\n        return result;\n    }\n\n    /**\n     * <p>Convert a long value created by {@link EnumUtils#generateBitVector} into the set of\n     * enum values that it represents.</p>\n     *\n     * <p>If you store this value, beware any changes to the enum that would affect ordinal values.</p>\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param value     the long value representation of a set of enum values\n     * @param <E>       the type of the enumeration\n     * @return a set of enum values\n     * @throws NullPointerException if {@code enumClass} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n     * @since 3.0.1\n     */\n    public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) {\n        checkBitVectorable(enumClass).getEnumConstants();\n        return processBitVectors(enumClass, value);\n    }\n\n    /**\n     * <p>Convert a {@code long[]} created by {@link EnumUtils#generateBitVectors} into the set of\n     * enum values that it represents.</p>\n     *\n     * <p>If you store this value, beware any changes to the enum that would affect ordinal values.</p>\n     * @param enumClass the class of the enum we are working with, not {@code null}\n     * @param values     the long[] bearing the representation of a set of enum values, least significant digits rightmost, not {@code null}\n     * @param <E>       the type of the enumeration\n     * @return a set of enum values\n     * @throws NullPointerException if {@code enumClass} is {@code null}\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class\n     * @since 3.2\n     */\n    public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values) {", "right_context": "}\n}", "class_name": "EnumUtils", "return_type": "EnumSet<E>", "parameters": [{"type": "Class<E>", "name": "enumClass"}, {"type": "long", "name": "values"}]}}
{"prompt": "class ArrayUtils {\n\n    /**\n     * <p>Converts an array of object Characters to primitives.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Character} array, may be {@code null}\n     * @return a {@code char} array, {@code null} if null array input\n     * @throws NullPointerException if array content is {@code null}\n     */\n    public static char[] toPrimitive(final Character[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Character to primitives handling {@code null}.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Character} array, may be {@code null}\n     * @param valueForNull  the value to insert if {@code null} found\n     * @return a {@code char} array, {@code null} if null array input\n     */\n    public static char[] toPrimitive(final Character[] array, final char valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Character b = array[i];\n            result[i] = (b == null ? valueForNull : b.charValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive chars to objects.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array a {@code char} array\n     * @return a {@code Character} array, {@code null} if null array input\n     */\n    public static Character[] toObject(final char[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        final Character[] result = new Character[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Character.valueOf(array[i]);\n        }\n        return result;\n     }\n\n    // Long array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Longs to primitives.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Long} array, may be {@code null}\n     * @return a {@code long} array, {@code null} if null array input\n     * @throws NullPointerException if array content is {@code null}\n     */\n    public static long[] toPrimitive(final Long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Long to primitives handling {@code null}.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Long} array, may be {@code null}\n     * @param valueForNull  the value to insert if {@code null} found\n     * @return a {@code long} array, {@code null} if null array input\n     */\n    public static long[] toPrimitive(final Long[] array, final long valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Long b = array[i];\n            result[i] = (b == null ? valueForNull : b.longValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive longs to objects.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code long} array\n     * @return a {@code Long} array, {@code null} if null array input\n     */\n    public static Long[] toObject(final long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_OBJECT_ARRAY;\n        }\n        final Long[] result = new Long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Long.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    // Int array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Integers to primitives.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Integer} array, may be {@code null}\n     * @return an {@code int} array, {@code null} if null array input\n     * @throws NullPointerException if array content is {@code null}\n     */\n    public static int[] toPrimitive(final Integer[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Integer to primitives handling {@code null}.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Integer} array, may be {@code null}\n     * @param valueForNull  the value to insert if {@code null} found\n     * @return an {@code int} array, {@code null} if null array input\n     */\n    public static int[] toPrimitive(final Integer[] array, final int valueForNull) {", "metadata": {"defects4j_task_id": "f95292cea509be6cb6a3ed7abe8933e7930cb0965866159fa2ad6e6c1b9bf580", "task_id": "apache_commons-lang/202", "ground_truth": "\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "ArrayUtils.java"], "context_start_lineno": 0, "function_name": "toPrimitive", "left_context": "class ArrayUtils {\n\n    /**\n     * <p>Converts an array of object Characters to primitives.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Character} array, may be {@code null}\n     * @return a {@code char} array, {@code null} if null array input\n     * @throws NullPointerException if array content is {@code null}\n     */\n    public static char[] toPrimitive(final Character[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Character to primitives handling {@code null}.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Character} array, may be {@code null}\n     * @param valueForNull  the value to insert if {@code null} found\n     * @return a {@code char} array, {@code null} if null array input\n     */\n    public static char[] toPrimitive(final Character[] array, final char valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Character b = array[i];\n            result[i] = (b == null ? valueForNull : b.charValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive chars to objects.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array a {@code char} array\n     * @return a {@code Character} array, {@code null} if null array input\n     */\n    public static Character[] toObject(final char[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        final Character[] result = new Character[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Character.valueOf(array[i]);\n        }\n        return result;\n     }\n\n    // Long array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Longs to primitives.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Long} array, may be {@code null}\n     * @return a {@code long} array, {@code null} if null array input\n     * @throws NullPointerException if array content is {@code null}\n     */\n    public static long[] toPrimitive(final Long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Long to primitives handling {@code null}.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Long} array, may be {@code null}\n     * @param valueForNull  the value to insert if {@code null} found\n     * @return a {@code long} array, {@code null} if null array input\n     */\n    public static long[] toPrimitive(final Long[] array, final long valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Long b = array[i];\n            result[i] = (b == null ? valueForNull : b.longValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive longs to objects.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code long} array\n     * @return a {@code Long} array, {@code null} if null array input\n     */\n    public static Long[] toObject(final long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_OBJECT_ARRAY;\n        }\n        final Long[] result = new Long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Long.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    // Int array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Integers to primitives.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Integer} array, may be {@code null}\n     * @return an {@code int} array, {@code null} if null array input\n     * @throws NullPointerException if array content is {@code null}\n     */\n    public static int[] toPrimitive(final Integer[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Integer to primitives handling {@code null}.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code Integer} array, may be {@code null}\n     * @param valueForNull  the value to insert if {@code null} found\n     * @return an {@code int} array, {@code null} if null array input\n     */\n    public static int[] toPrimitive(final Integer[] array, final int valueForNull) {", "right_context": "}\n}", "class_name": "ArrayUtils", "return_type": "int[]", "parameters": [{"type": "Integer[]", "name": "array"}, {"type": "int", "name": "valueForNull"}]}}
{"prompt": "class Conversion {\n    /**\n     * <p>\n     * Converts an array of int into a long using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     * \n     * @param src the int array to convert\n     * @param srcPos the position in {@code src}, in int unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nInts the number of ints to convert\n     * @return a long containing the selected bits\n     * @throws IllegalArgumentException if {@code (nInts-1)*32+dstPos >= 64}\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nInts > src.length}\n     */\n    public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {\n        if ((src.length == 0 && srcPos == 0) || 0 == nInts) {\n            return dstInit;\n        }\n        if ((nInts - 1) * 32 + dstPos >= 64) {\n            throw new IllegalArgumentException(\n                \"(nInts-1)*32+dstPos is greather or equal to than 64\");\n        }\n        long out = dstInit;\n        int shift = 0;\n        for (int i = 0; i < nInts; i++ ) {\n            shift = i * 32 + dstPos;\n            final long bits = ((0xffffffffL & src[i + srcPos]) << shift);\n            final long mask = 0xffffffffL << shift;\n            out = (out & ~mask) | bits;\n        }\n        return out;\n    }\n\n    /**\n     * <p>\n     * Converts an array of short into a long using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     * \n     * @param src the short array to convert\n     * @param srcPos the position in {@code src}, in short unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nShorts the number of shorts to convert\n     * @return a long containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n     */\n    public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos,\n        final int nShorts) {\n        if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {\n            return dstInit;\n        }\n        if ((nShorts - 1) * 16 + dstPos >= 64) {\n            throw new IllegalArgumentException(\n                \"(nShorts-1)*16+dstPos is greather or equal to than 64\");\n        }\n        long out = dstInit;\n        int shift = 0;\n        for (int i = 0; i < nShorts; i++ ) {\n            shift = i * 16 + dstPos;\n            final long bits = (0xffffL & src[i + srcPos]) << shift;\n            final long mask = 0xffffL << shift;\n            out = (out & ~mask) | bits;\n        }\n        return out;\n    }\n\n    /**\n     * <p>\n     * Converts an array of short into a int using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     * \n     * @param src the short array to convert\n     * @param srcPos the position in {@code src}, in short unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination int\n     * @param dstPos the position of the lsb, in bits, in the result int\n     * @param nShorts the number of shorts to convert\n     * @return a int containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n     */\n    public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos,\n        final int nShorts) {\n        if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {\n            return dstInit;\n        }\n        if ((nShorts - 1) * 16 + dstPos >= 32) {\n            throw new IllegalArgumentException(\n                \"(nShorts-1)*16+dstPos is greather or equal to than 32\");\n        }\n        int out = dstInit;\n        int shift = 0;\n        for (int i = 0; i < nShorts; i++ ) {\n            shift = i * 16 + dstPos;\n            final int bits = (0xffff & src[i + srcPos]) << shift;\n            final int mask = 0xffff << shift;\n            out = (out & ~mask) | bits;\n        }\n        return out;\n    }\n\n    /**\n     * <p>\n     * Converts an array of byte into a long using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     * \n     * @param src the byte array to convert\n     * @param srcPos the position in {@code src}, in byte unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nBytes the number of bytes to convert\n     * @return a long containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n     */\n    public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos,\n        final int nBytes) {", "metadata": {"defects4j_task_id": "0183c109cc6a51cd012f3447706660f08bd929d681b1e8b4aeb4d0f99a1dc0d3", "task_id": "apache_commons-lang/2", "ground_truth": "\n        if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {\n            return dstInit;\n        }\n        if ((nBytes - 1) * 8 + dstPos >= 64) {\n            throw new IllegalArgumentException(\n                \"(nBytes-1)*8+dstPos is greather or equal to than 64\");\n        }\n        long out = dstInit;\n        int shift = 0;\n        for (int i = 0; i < nBytes; i++ ) {\n            shift = i * 8 + dstPos;\n            final long bits = (0xffL & src[i + srcPos]) << shift;\n            final long mask = 0xffL << shift;\n            out = (out & ~mask) | bits;\n        }\n        return out;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "Conversion.java"], "context_start_lineno": 0, "function_name": "byteArrayToLong", "left_context": "class Conversion {\n    /**\n     * <p>\n     * Converts an array of int into a long using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     * \n     * @param src the int array to convert\n     * @param srcPos the position in {@code src}, in int unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nInts the number of ints to convert\n     * @return a long containing the selected bits\n     * @throws IllegalArgumentException if {@code (nInts-1)*32+dstPos >= 64}\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nInts > src.length}\n     */\n    public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {\n        if ((src.length == 0 && srcPos == 0) || 0 == nInts) {\n            return dstInit;\n        }\n        if ((nInts - 1) * 32 + dstPos >= 64) {\n            throw new IllegalArgumentException(\n                \"(nInts-1)*32+dstPos is greather or equal to than 64\");\n        }\n        long out = dstInit;\n        int shift = 0;\n        for (int i = 0; i < nInts; i++ ) {\n            shift = i * 32 + dstPos;\n            final long bits = ((0xffffffffL & src[i + srcPos]) << shift);\n            final long mask = 0xffffffffL << shift;\n            out = (out & ~mask) | bits;\n        }\n        return out;\n    }\n\n    /**\n     * <p>\n     * Converts an array of short into a long using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     * \n     * @param src the short array to convert\n     * @param srcPos the position in {@code src}, in short unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nShorts the number of shorts to convert\n     * @return a long containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n     */\n    public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos,\n        final int nShorts) {\n        if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {\n            return dstInit;\n        }\n        if ((nShorts - 1) * 16 + dstPos >= 64) {\n            throw new IllegalArgumentException(\n                \"(nShorts-1)*16+dstPos is greather or equal to than 64\");\n        }\n        long out = dstInit;\n        int shift = 0;\n        for (int i = 0; i < nShorts; i++ ) {\n            shift = i * 16 + dstPos;\n            final long bits = (0xffffL & src[i + srcPos]) << shift;\n            final long mask = 0xffffL << shift;\n            out = (out & ~mask) | bits;\n        }\n        return out;\n    }\n\n    /**\n     * <p>\n     * Converts an array of short into a int using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     * \n     * @param src the short array to convert\n     * @param srcPos the position in {@code src}, in short unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination int\n     * @param dstPos the position of the lsb, in bits, in the result int\n     * @param nShorts the number of shorts to convert\n     * @return a int containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n     */\n    public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos,\n        final int nShorts) {\n        if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {\n            return dstInit;\n        }\n        if ((nShorts - 1) * 16 + dstPos >= 32) {\n            throw new IllegalArgumentException(\n                \"(nShorts-1)*16+dstPos is greather or equal to than 32\");\n        }\n        int out = dstInit;\n        int shift = 0;\n        for (int i = 0; i < nShorts; i++ ) {\n            shift = i * 16 + dstPos;\n            final int bits = (0xffff & src[i + srcPos]) << shift;\n            final int mask = 0xffff << shift;\n            out = (out & ~mask) | bits;\n        }\n        return out;\n    }\n\n    /**\n     * <p>\n     * Converts an array of byte into a long using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     * \n     * @param src the byte array to convert\n     * @param srcPos the position in {@code src}, in byte unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nBytes the number of bytes to convert\n     * @return a long containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n     */\n    public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos,\n        final int nBytes) {", "right_context": "}\n}", "class_name": "Conversion", "return_type": "long", "parameters": [{"type": "byte[]", "name": "src"}, {"type": "int", "name": "srcPos"}, {"type": "long", "name": "dstInit"}, {"type": "int", "name": "dstPos"}, {"type": "int", "name": "nBytes"}]}}
{"prompt": "class AnnotationUtils {\n\n    /**\n     * <p>{@code AnnotationUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used statically.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public AnnotationUtils() {\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if two annotations are equal using the criteria for equality\n     * presented in the {@link Annotation#equals(Object)} API docs.</p>\n     *\n     * @param a1 the first Annotation to compare, {@code null} returns\n     * {@code false} unless both are {@code null}\n     * @param a2 the second Annotation to compare, {@code null} returns\n     * {@code false} unless both are {@code null}\n     * @return {@code true} if the two annotations are {@code equal} or both\n     * {@code null}\n     */\n    public static boolean equals(final Annotation a1, final Annotation a2) {\n        if (a1 == a2) {\n            return true;\n        }\n        if (a1 == null || a2 == null) {\n            return false;\n        }\n        final Class<? extends Annotation> type = a1.annotationType();\n        final Class<? extends Annotation> type2 = a2.annotationType();\n        Validate.notNull(type, \"Annotation %s with null annotationType()\", a1);\n        Validate.notNull(type2, \"Annotation %s with null annotationType()\", a2);\n        if (!type.equals(type2)) {\n            return false;\n        }\n        try {\n            for (final Method m : type.getDeclaredMethods()) {\n                if (m.getParameterTypes().length == 0\n                        && isValidAnnotationMemberType(m.getReturnType())) {\n                    final Object v1 = m.invoke(a1);\n                    final Object v2 = m.invoke(a2);\n                    if (!memberEquals(m.getReturnType(), v1, v2)) {\n                        return false;\n                    }\n                }\n            }\n        } catch (final IllegalAccessException ex) {\n            return false;\n        } catch (final InvocationTargetException ex) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Generate a hash code for the given annotation using the algorithm\n     * presented in the {@link Annotation#hashCode()} API docs.</p>\n     *\n     * @param a the Annotation for a hash code calculation is desired, not\n     * {@code null}\n     * @return the calculated hash code\n     * @throws RuntimeException if an {@code Exception} is encountered during\n     * annotation member access\n     * @throws IllegalStateException if an annotation method invocation returns\n     * {@code null}\n     */\n    public static int hashCode(final Annotation a) {\n        int result = 0;\n        final Class<? extends Annotation> type = a.annotationType();\n        for (final Method m : type.getDeclaredMethods()) {\n            try {\n                final Object value = m.invoke(a);\n                if (value == null) {\n                    throw new IllegalStateException(\n                            String.format(\"Annotation method %s returned null\", m));\n                }\n                result += hashMember(m.getName(), value);\n            } catch (final RuntimeException ex) {\n                throw ex;\n            } catch (final Exception ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * <p>Generate a string representation of an Annotation, as suggested by\n     * {@link Annotation#toString()}.</p>\n     *\n     * @param a the annotation of which a string representation is desired\n     * @return the standard string representation of an annotation, not\n     * {@code null}\n     */\n    public static String toString(final Annotation a) {\n        final ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE);\n        for (final Method m : a.annotationType().getDeclaredMethods()) {\n            if (m.getParameterTypes().length > 0) {\n                continue; //wtf?\n            }\n            try {\n                builder.append(m.getName(), m.invoke(a));\n            } catch (final RuntimeException ex) {\n                throw ex;\n            } catch (final Exception ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n        return builder.build();\n    }\n\n    /**\n     * <p>Checks if the specified type is permitted as an annotation member.</p>\n     *\n     * <p>The Java language specification only permits certain types to be used\n     * in annotations. These include {@link String}, {@link Class}, primitive\n     * types, {@link Annotation}, {@link Enum}, and single-dimensional arrays of\n     * these types.</p>\n     *\n     * @param type the type to check, {@code null}\n     * @return {@code true} if the type is a valid type to use in an annotation\n     */\n    public static boolean isValidAnnotationMemberType(Class<?> type) {\n        if (type == null) {\n            return false;\n        }\n        if (type.isArray()) {\n            type = type.getComponentType();\n        }\n        return type.isPrimitive() || type.isEnum() || type.isAnnotation()\n                || String.class.equals(type) || Class.class.equals(type);\n    }\n\n    //besides modularity, this has the advantage of autoboxing primitives:\n    /**\n     * Helper method for generating a hash code for a member of an annotation.\n     *\n     * @param name the name of the member\n     * @param value the value of the member\n     * @return a hash code for this member\n     */\n    private static int hashMember(final String name, final Object value) {\n        final int part1 = name.hashCode() * 127;\n        if (value.getClass().isArray()) {\n            return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value);\n        }\n        if (value instanceof Annotation) {\n            return part1 ^ hashCode((Annotation) value);\n        }\n        return part1 ^ value.hashCode();\n    }\n\n    /**\n     * Helper method for checking whether two objects of the given type are\n     * equal. This method is used to compare the parameters of two annotation\n     * instances.\n     *\n     * @param type the type of the objects to be compared\n     * @param o1 the first object\n     * @param o2 the second object\n     * @return a flag whether these objects are equal\n     */\n    private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2) {", "metadata": {"defects4j_task_id": "ebc944c35f1526b3c88683f7ca9f4a43eaf39a2b5302a4c8a0db2820c6357fca", "task_id": "apache_commons-lang/194", "ground_truth": "\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (type.isArray()) {\n            return arrayMemberEquals(type.getComponentType(), o1, o2);\n        }\n        if (type.isAnnotation()) {\n            return equals((Annotation) o1, (Annotation) o2);\n        }\n        return o1.equals(o2);\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "AnnotationUtils.java"], "context_start_lineno": 0, "function_name": "memberEquals", "left_context": "class AnnotationUtils {\n\n    /**\n     * <p>{@code AnnotationUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used statically.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public AnnotationUtils() {\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if two annotations are equal using the criteria for equality\n     * presented in the {@link Annotation#equals(Object)} API docs.</p>\n     *\n     * @param a1 the first Annotation to compare, {@code null} returns\n     * {@code false} unless both are {@code null}\n     * @param a2 the second Annotation to compare, {@code null} returns\n     * {@code false} unless both are {@code null}\n     * @return {@code true} if the two annotations are {@code equal} or both\n     * {@code null}\n     */\n    public static boolean equals(final Annotation a1, final Annotation a2) {\n        if (a1 == a2) {\n            return true;\n        }\n        if (a1 == null || a2 == null) {\n            return false;\n        }\n        final Class<? extends Annotation> type = a1.annotationType();\n        final Class<? extends Annotation> type2 = a2.annotationType();\n        Validate.notNull(type, \"Annotation %s with null annotationType()\", a1);\n        Validate.notNull(type2, \"Annotation %s with null annotationType()\", a2);\n        if (!type.equals(type2)) {\n            return false;\n        }\n        try {\n            for (final Method m : type.getDeclaredMethods()) {\n                if (m.getParameterTypes().length == 0\n                        && isValidAnnotationMemberType(m.getReturnType())) {\n                    final Object v1 = m.invoke(a1);\n                    final Object v2 = m.invoke(a2);\n                    if (!memberEquals(m.getReturnType(), v1, v2)) {\n                        return false;\n                    }\n                }\n            }\n        } catch (final IllegalAccessException ex) {\n            return false;\n        } catch (final InvocationTargetException ex) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Generate a hash code for the given annotation using the algorithm\n     * presented in the {@link Annotation#hashCode()} API docs.</p>\n     *\n     * @param a the Annotation for a hash code calculation is desired, not\n     * {@code null}\n     * @return the calculated hash code\n     * @throws RuntimeException if an {@code Exception} is encountered during\n     * annotation member access\n     * @throws IllegalStateException if an annotation method invocation returns\n     * {@code null}\n     */\n    public static int hashCode(final Annotation a) {\n        int result = 0;\n        final Class<? extends Annotation> type = a.annotationType();\n        for (final Method m : type.getDeclaredMethods()) {\n            try {\n                final Object value = m.invoke(a);\n                if (value == null) {\n                    throw new IllegalStateException(\n                            String.format(\"Annotation method %s returned null\", m));\n                }\n                result += hashMember(m.getName(), value);\n            } catch (final RuntimeException ex) {\n                throw ex;\n            } catch (final Exception ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * <p>Generate a string representation of an Annotation, as suggested by\n     * {@link Annotation#toString()}.</p>\n     *\n     * @param a the annotation of which a string representation is desired\n     * @return the standard string representation of an annotation, not\n     * {@code null}\n     */\n    public static String toString(final Annotation a) {\n        final ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE);\n        for (final Method m : a.annotationType().getDeclaredMethods()) {\n            if (m.getParameterTypes().length > 0) {\n                continue; //wtf?\n            }\n            try {\n                builder.append(m.getName(), m.invoke(a));\n            } catch (final RuntimeException ex) {\n                throw ex;\n            } catch (final Exception ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n        return builder.build();\n    }\n\n    /**\n     * <p>Checks if the specified type is permitted as an annotation member.</p>\n     *\n     * <p>The Java language specification only permits certain types to be used\n     * in annotations. These include {@link String}, {@link Class}, primitive\n     * types, {@link Annotation}, {@link Enum}, and single-dimensional arrays of\n     * these types.</p>\n     *\n     * @param type the type to check, {@code null}\n     * @return {@code true} if the type is a valid type to use in an annotation\n     */\n    public static boolean isValidAnnotationMemberType(Class<?> type) {\n        if (type == null) {\n            return false;\n        }\n        if (type.isArray()) {\n            type = type.getComponentType();\n        }\n        return type.isPrimitive() || type.isEnum() || type.isAnnotation()\n                || String.class.equals(type) || Class.class.equals(type);\n    }\n\n    //besides modularity, this has the advantage of autoboxing primitives:\n    /**\n     * Helper method for generating a hash code for a member of an annotation.\n     *\n     * @param name the name of the member\n     * @param value the value of the member\n     * @return a hash code for this member\n     */\n    private static int hashMember(final String name, final Object value) {\n        final int part1 = name.hashCode() * 127;\n        if (value.getClass().isArray()) {\n            return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value);\n        }\n        if (value instanceof Annotation) {\n            return part1 ^ hashCode((Annotation) value);\n        }\n        return part1 ^ value.hashCode();\n    }\n\n    /**\n     * Helper method for checking whether two objects of the given type are\n     * equal. This method is used to compare the parameters of two annotation\n     * instances.\n     *\n     * @param type the type of the objects to be compared\n     * @param o1 the first object\n     * @param o2 the second object\n     * @return a flag whether these objects are equal\n     */\n    private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2) {", "right_context": "}\n}", "class_name": "AnnotationUtils", "return_type": "boolean", "parameters": [{"type": "Class<?>", "name": "type"}, {"type": "Object", "name": "o1"}, {"type": "Object", "name": "o2"}]}}
{"prompt": "class WordUtils {\n\n    /**\n     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n     * \n     * <p>New lines will be separated by the system property line separator.\n     * Very long words, such as URLs will <i>not</i> be wrapped.</p>\n     * \n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <pre>\n     * WordUtils.wrap(null, *) = null\n     * WordUtils.wrap(\"\", *) = \"\"\n     * </pre>\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @return a line with newlines inserted, <code>null</code> if null input\n     */\n    public static String wrap(final String str, final int wrapLength) {\n        return wrap(str, wrapLength, null, false);\n    }\n    \n    /**\n     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n     * \n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     * \n     * <pre>\n     * WordUtils.wrap(null, *, *, *) = null\n     * WordUtils.wrap(\"\", *, *, *) = \"\"\n     * </pre>\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line, \n     *  <code>null</code> uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @return a line with newlines inserted, <code>null</code> if null input\n     */\n    public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {\n        if (str == null) {\n            return null;\n        }\n        if (newLineStr == null) {\n            newLineStr = SystemUtils.LINE_SEPARATOR;\n        }\n        if (wrapLength < 1) {\n            wrapLength = 1;\n        }\n        final int inputLineLength = str.length();\n        int offset = 0;\n        final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n        \n        while (inputLineLength - offset > wrapLength) {\n            if (str.charAt(offset) == ' ') {\n                offset++;\n                continue;\n            }\n            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);\n\n            if (spaceToWrapAt >= offset) {\n                // normal case\n                wrappedLine.append(str.substring(offset, spaceToWrapAt));\n                wrappedLine.append(newLineStr);\n                offset = spaceToWrapAt + 1;\n                \n            } else {\n                // really long word or URL\n                if (wrapLongWords) {\n                    // wrap really long word one line at a time\n                    wrappedLine.append(str.substring(offset, wrapLength + offset));\n                    wrappedLine.append(newLineStr);\n                    offset += wrapLength;\n                } else {\n                    // do not wrap really long word, just extend beyond limit\n                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);\n                    if (spaceToWrapAt >= 0) {\n                        wrappedLine.append(str.substring(offset, spaceToWrapAt));\n                        wrappedLine.append(newLineStr);\n                        offset = spaceToWrapAt + 1;\n                    } else {\n                        wrappedLine.append(str.substring(offset));\n                        offset = inputLineLength;\n                    }\n                }\n            }\n        }\n\n        // Whatever is left in line is short enough to just pass through\n        wrappedLine.append(str.substring(offset));\n\n        return wrappedLine.toString();\n    }\n\n    // Capitalizing\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Capitalizes all the whitespace separated words in a String.\n     * Only the first letter of each word is changed. To convert the \n     * rest of each word to lowercase at the same time, \n     * use {@link #capitalizeFully(String)}.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null)        = null\n     * WordUtils.capitalize(\"\")          = \"\"\n     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str) {\n        return capitalize(str, null);\n    }\n\n    /**\n     * <p>Capitalizes all the delimiter separated words in a String.\n     * Only the first letter of each word is changed. To convert the \n     * rest of each word to lowercase at the same time, \n     * use {@link #capitalizeFully(String, char[])}.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null, *)            = null\n     * WordUtils.capitalize(\"\", *)              = \"\"\n     * WordUtils.capitalize(*, new char[0])     = *\n     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     * @since 2.1\n     */\n    public static String capitalize(final String str, final char... delimiters) {", "metadata": {"defects4j_task_id": "a4ec8458d00d7fa6a4f130cdf06ad151cb37451203bfdbf0ca45394a85daa1e8", "task_id": "apache_commons-lang/137", "ground_truth": "\n        final int delimLen = delimiters == null ? -1 : delimiters.length;\n        if (StringUtils.isEmpty(str) || delimLen == 0) {\n            return str;\n        }\n        final char[] buffer = str.toCharArray();\n        boolean capitalizeNext = true;\n        for (int i = 0; i < buffer.length; i++) {\n            final char ch = buffer[i];\n            if (isDelimiter(ch, delimiters)) {\n                capitalizeNext = true;\n            } else if (capitalizeNext) {\n                buffer[i] = Character.toTitleCase(ch);\n                capitalizeNext = false;\n            }\n        }\n        return new String(buffer);\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "WordUtils.java"], "context_start_lineno": 0, "function_name": "capitalize", "left_context": "class WordUtils {\n\n    /**\n     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n     * \n     * <p>New lines will be separated by the system property line separator.\n     * Very long words, such as URLs will <i>not</i> be wrapped.</p>\n     * \n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <pre>\n     * WordUtils.wrap(null, *) = null\n     * WordUtils.wrap(\"\", *) = \"\"\n     * </pre>\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @return a line with newlines inserted, <code>null</code> if null input\n     */\n    public static String wrap(final String str, final int wrapLength) {\n        return wrap(str, wrapLength, null, false);\n    }\n    \n    /**\n     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n     * \n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     * \n     * <pre>\n     * WordUtils.wrap(null, *, *, *) = null\n     * WordUtils.wrap(\"\", *, *, *) = \"\"\n     * </pre>\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line, \n     *  <code>null</code> uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @return a line with newlines inserted, <code>null</code> if null input\n     */\n    public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {\n        if (str == null) {\n            return null;\n        }\n        if (newLineStr == null) {\n            newLineStr = SystemUtils.LINE_SEPARATOR;\n        }\n        if (wrapLength < 1) {\n            wrapLength = 1;\n        }\n        final int inputLineLength = str.length();\n        int offset = 0;\n        final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n        \n        while (inputLineLength - offset > wrapLength) {\n            if (str.charAt(offset) == ' ') {\n                offset++;\n                continue;\n            }\n            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);\n\n            if (spaceToWrapAt >= offset) {\n                // normal case\n                wrappedLine.append(str.substring(offset, spaceToWrapAt));\n                wrappedLine.append(newLineStr);\n                offset = spaceToWrapAt + 1;\n                \n            } else {\n                // really long word or URL\n                if (wrapLongWords) {\n                    // wrap really long word one line at a time\n                    wrappedLine.append(str.substring(offset, wrapLength + offset));\n                    wrappedLine.append(newLineStr);\n                    offset += wrapLength;\n                } else {\n                    // do not wrap really long word, just extend beyond limit\n                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);\n                    if (spaceToWrapAt >= 0) {\n                        wrappedLine.append(str.substring(offset, spaceToWrapAt));\n                        wrappedLine.append(newLineStr);\n                        offset = spaceToWrapAt + 1;\n                    } else {\n                        wrappedLine.append(str.substring(offset));\n                        offset = inputLineLength;\n                    }\n                }\n            }\n        }\n\n        // Whatever is left in line is short enough to just pass through\n        wrappedLine.append(str.substring(offset));\n\n        return wrappedLine.toString();\n    }\n\n    // Capitalizing\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Capitalizes all the whitespace separated words in a String.\n     * Only the first letter of each word is changed. To convert the \n     * rest of each word to lowercase at the same time, \n     * use {@link #capitalizeFully(String)}.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null)        = null\n     * WordUtils.capitalize(\"\")          = \"\"\n     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str) {\n        return capitalize(str, null);\n    }\n\n    /**\n     * <p>Capitalizes all the delimiter separated words in a String.\n     * Only the first letter of each word is changed. To convert the \n     * rest of each word to lowercase at the same time, \n     * use {@link #capitalizeFully(String, char[])}.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null, *)            = null\n     * WordUtils.capitalize(\"\", *)              = \"\"\n     * WordUtils.capitalize(*, new char[0])     = *\n     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     * @since 2.1\n     */\n    public static String capitalize(final String str, final char... delimiters) {", "right_context": "}\n\n}", "class_name": "WordUtils", "return_type": "String", "parameters": [{"type": "String", "name": "str"}, {"type": "char", "name": "delimiters"}]}}
{"prompt": "class WordUtils {\n\n    /**\n     * <p>Capitalizes all the whitespace separated words in a String.\n     * Only the first letter of each word is changed. To convert the \n     * rest of each word to lowercase at the same time, \n     * use {@link #capitalizeFully(String)}.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null)        = null\n     * WordUtils.capitalize(\"\")          = \"\"\n     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str) {\n        return capitalize(str, null);\n    }\n\n    /**\n     * <p>Capitalizes all the delimiter separated words in a String.\n     * Only the first letter of each word is changed. To convert the \n     * rest of each word to lowercase at the same time, \n     * use {@link #capitalizeFully(String, char[])}.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null, *)            = null\n     * WordUtils.capitalize(\"\", *)              = \"\"\n     * WordUtils.capitalize(*, new char[0])     = *\n     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     * @since 2.1\n     */\n    public static String capitalize(final String str, final char... delimiters) {\n        final int delimLen = delimiters == null ? -1 : delimiters.length;\n        if (StringUtils.isEmpty(str) || delimLen == 0) {\n            return str;\n        }\n        final char[] buffer = str.toCharArray();\n        boolean capitalizeNext = true;\n        for (int i = 0; i < buffer.length; i++) {\n            final char ch = buffer[i];\n            if (isDelimiter(ch, delimiters)) {\n                capitalizeNext = true;\n            } else if (capitalizeNext) {\n                buffer[i] = Character.toTitleCase(ch);\n                capitalizeNext = false;\n            }\n        }\n        return new String(buffer);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Converts all the whitespace separated words in a String into capitalized words, \n     * that is each word is made up of a titlecase character and then a series of \n     * lowercase characters.  </p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null)        = null\n     * WordUtils.capitalizeFully(\"\")          = \"\"\n     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     */\n    public static String capitalizeFully(final String str) {\n        return capitalizeFully(str, null);\n    }\n\n    /**\n     * <p>Converts all the delimiter separated words in a String into capitalized words, \n     * that is each word is made up of a titlecase character and then a series of \n     * lowercase characters. </p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null, *)            = null\n     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n     * WordUtils.capitalizeFully(*, null)            = *\n     * WordUtils.capitalizeFully(*, new char[0])     = *\n     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String capitalizeFully(String str, final char... delimiters) {", "metadata": {"defects4j_task_id": "4a52452c26681e36bd258a0fbff46634696bb256b3aa512e36a354ce54a815ee", "task_id": "apache_commons-lang/66", "ground_truth": "\n        final int delimLen = delimiters == null ? -1 : delimiters.length;\n        if (StringUtils.isEmpty(str) || delimLen == 0) {\n            return str;\n        }\n        str = str.toLowerCase();\n        return capitalize(str, delimiters);\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "WordUtils.java"], "context_start_lineno": 0, "function_name": "capitalizeFully", "left_context": "class WordUtils {\n\n    /**\n     * <p>Capitalizes all the whitespace separated words in a String.\n     * Only the first letter of each word is changed. To convert the \n     * rest of each word to lowercase at the same time, \n     * use {@link #capitalizeFully(String)}.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null)        = null\n     * WordUtils.capitalize(\"\")          = \"\"\n     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str) {\n        return capitalize(str, null);\n    }\n\n    /**\n     * <p>Capitalizes all the delimiter separated words in a String.\n     * Only the first letter of each word is changed. To convert the \n     * rest of each word to lowercase at the same time, \n     * use {@link #capitalizeFully(String, char[])}.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null, *)            = null\n     * WordUtils.capitalize(\"\", *)              = \"\"\n     * WordUtils.capitalize(*, new char[0])     = *\n     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     * @since 2.1\n     */\n    public static String capitalize(final String str, final char... delimiters) {\n        final int delimLen = delimiters == null ? -1 : delimiters.length;\n        if (StringUtils.isEmpty(str) || delimLen == 0) {\n            return str;\n        }\n        final char[] buffer = str.toCharArray();\n        boolean capitalizeNext = true;\n        for (int i = 0; i < buffer.length; i++) {\n            final char ch = buffer[i];\n            if (isDelimiter(ch, delimiters)) {\n                capitalizeNext = true;\n            } else if (capitalizeNext) {\n                buffer[i] = Character.toTitleCase(ch);\n                capitalizeNext = false;\n            }\n        }\n        return new String(buffer);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Converts all the whitespace separated words in a String into capitalized words, \n     * that is each word is made up of a titlecase character and then a series of \n     * lowercase characters.  </p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null)        = null\n     * WordUtils.capitalizeFully(\"\")          = \"\"\n     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     */\n    public static String capitalizeFully(final String str) {\n        return capitalizeFully(str, null);\n    }\n\n    /**\n     * <p>Converts all the delimiter separated words in a String into capitalized words, \n     * that is each word is made up of a titlecase character and then a series of \n     * lowercase characters. </p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null, *)            = null\n     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n     * WordUtils.capitalizeFully(*, null)            = *\n     * WordUtils.capitalizeFully(*, new char[0])     = *\n     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String capitalizeFully(String str, final char... delimiters) {", "right_context": "}\n\n}", "class_name": "WordUtils", "return_type": "String", "parameters": [{"type": "String", "name": "str"}, {"type": "char", "name": "delimiters"}]}}
{"prompt": "class WordUtils {\n\n    /**\n     * <p>Converts all the whitespace separated words in a String into capitalized words, \n     * that is each word is made up of a titlecase character and then a series of \n     * lowercase characters.  </p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null)        = null\n     * WordUtils.capitalizeFully(\"\")          = \"\"\n     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     */\n    public static String capitalizeFully(final String str) {\n        return capitalizeFully(str, null);\n    }\n\n    /**\n     * <p>Converts all the delimiter separated words in a String into capitalized words, \n     * that is each word is made up of a titlecase character and then a series of \n     * lowercase characters. </p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null, *)            = null\n     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n     * WordUtils.capitalizeFully(*, null)            = *\n     * WordUtils.capitalizeFully(*, new char[0])     = *\n     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String capitalizeFully(String str, final char... delimiters) {\n        final int delimLen = delimiters == null ? -1 : delimiters.length;\n        if (StringUtils.isEmpty(str) || delimLen == 0) {\n            return str;\n        }\n        str = str.toLowerCase();\n        return capitalize(str, delimiters);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Uncapitalizes all the whitespace separated words in a String.\n     * Only the first letter of each word is changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null)        = null\n     * WordUtils.uncapitalize(\"\")          = \"\"\n     * WordUtils.uncapitalize(\"I Am FINE\") = \"i am fINE\"\n     * </pre>\n     * \n     * @param str  the String to uncapitalize, may be null\n     * @return uncapitalized String, <code>null</code> if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str) {\n        return uncapitalize(str, null);\n    }\n\n    /**\n     * <p>Uncapitalizes all the whitespace separated words in a String.\n     * Only the first letter of each word is changed.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be uncapitalized. </p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null, *)            = null\n     * WordUtils.uncapitalize(\"\", *)              = \"\"\n     * WordUtils.uncapitalize(*, null)            = *\n     * WordUtils.uncapitalize(*, new char[0])     = *\n     * WordUtils.uncapitalize(\"I AM.FINE\", {'.'}) = \"i AM.fINE\"\n     * </pre>\n     * \n     * @param str  the String to uncapitalize, may be null\n     * @param delimiters  set of characters to determine uncapitalization, null means whitespace\n     * @return uncapitalized String, <code>null</code> if null String input\n     * @see #capitalize(String)\n     * @since 2.1\n     */\n    public static String uncapitalize(final String str, final char... delimiters) {", "metadata": {"defects4j_task_id": "1166d6b814fb7d9d34f40264be1ff839b123d9a3ba0386ac271da29e053a113b", "task_id": "apache_commons-lang/18", "ground_truth": "\n        final int delimLen = delimiters == null ? -1 : delimiters.length;\n        if (StringUtils.isEmpty(str) || delimLen == 0) {\n            return str;\n        }\n        final char[] buffer = str.toCharArray();\n        boolean uncapitalizeNext = true;\n        for (int i = 0; i < buffer.length; i++) {\n            final char ch = buffer[i];\n            if (isDelimiter(ch, delimiters)) {\n                uncapitalizeNext = true;\n            } else if (uncapitalizeNext) {\n                buffer[i] = Character.toLowerCase(ch);\n                uncapitalizeNext = false;\n            }\n        }\n        return new String(buffer);\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "WordUtils.java"], "context_start_lineno": 0, "function_name": "uncapitalize", "left_context": "class WordUtils {\n\n    /**\n     * <p>Converts all the whitespace separated words in a String into capitalized words, \n     * that is each word is made up of a titlecase character and then a series of \n     * lowercase characters.  </p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null)        = null\n     * WordUtils.capitalizeFully(\"\")          = \"\"\n     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     */\n    public static String capitalizeFully(final String str) {\n        return capitalizeFully(str, null);\n    }\n\n    /**\n     * <p>Converts all the delimiter separated words in a String into capitalized words, \n     * that is each word is made up of a titlecase character and then a series of \n     * lowercase characters. </p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null, *)            = null\n     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n     * WordUtils.capitalizeFully(*, null)            = *\n     * WordUtils.capitalizeFully(*, new char[0])     = *\n     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n     * </pre>\n     * \n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String capitalizeFully(String str, final char... delimiters) {\n        final int delimLen = delimiters == null ? -1 : delimiters.length;\n        if (StringUtils.isEmpty(str) || delimLen == 0) {\n            return str;\n        }\n        str = str.toLowerCase();\n        return capitalize(str, delimiters);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Uncapitalizes all the whitespace separated words in a String.\n     * Only the first letter of each word is changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null)        = null\n     * WordUtils.uncapitalize(\"\")          = \"\"\n     * WordUtils.uncapitalize(\"I Am FINE\") = \"i am fINE\"\n     * </pre>\n     * \n     * @param str  the String to uncapitalize, may be null\n     * @return uncapitalized String, <code>null</code> if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str) {\n        return uncapitalize(str, null);\n    }\n\n    /**\n     * <p>Uncapitalizes all the whitespace separated words in a String.\n     * Only the first letter of each word is changed.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be uncapitalized. </p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null, *)            = null\n     * WordUtils.uncapitalize(\"\", *)              = \"\"\n     * WordUtils.uncapitalize(*, null)            = *\n     * WordUtils.uncapitalize(*, new char[0])     = *\n     * WordUtils.uncapitalize(\"I AM.FINE\", {'.'}) = \"i AM.fINE\"\n     * </pre>\n     * \n     * @param str  the String to uncapitalize, may be null\n     * @param delimiters  set of characters to determine uncapitalization, null means whitespace\n     * @return uncapitalized String, <code>null</code> if null String input\n     * @see #capitalize(String)\n     * @since 2.1\n     */\n    public static String uncapitalize(final String str, final char... delimiters) {", "right_context": "}\n\n}", "class_name": "WordUtils", "return_type": "String", "parameters": [{"type": "String", "name": "str"}, {"type": "char", "name": "delimiters"}]}}
{"prompt": "class WordUtils {\n\n    /**\n     * <p>Swaps the case of a String using a word based algorithm.</p>\n     * \n     * <ul>\n     *  <li>Upper case character converts to Lower case</li>\n     *  <li>Title case character converts to Lower case</li>\n     *  <li>Lower case character after Whitespace or at start converts to Title case</li>\n     *  <li>Other Lower case character converts to Upper case</li>\n     * </ul>\n     * \n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     * \n     * <pre>\n     * StringUtils.swapCase(null)                 = null\n     * StringUtils.swapCase(\"\")                   = \"\"\n     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n     * </pre>\n     * \n     * @param str  the String to swap case, may be null\n     * @return the changed String, <code>null</code> if null String input\n     */\n    public static String swapCase(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final char[] buffer = str.toCharArray();\n\n        boolean whitespace = true;\n\n        for (int i = 0; i < buffer.length; i++) {\n            final char ch = buffer[i];\n            if (Character.isUpperCase(ch)) {\n                buffer[i] = Character.toLowerCase(ch);\n                whitespace = false;\n            } else if (Character.isTitleCase(ch)) {\n                buffer[i] = Character.toLowerCase(ch);\n                whitespace = false;\n            } else if (Character.isLowerCase(ch)) {\n                if (whitespace) {\n                    buffer[i] = Character.toTitleCase(ch);\n                    whitespace = false;\n                } else {\n                    buffer[i] = Character.toUpperCase(ch);\n                }\n            } else {\n                whitespace = Character.isWhitespace(ch);\n            }\n        }\n        return new String(buffer);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Extracts the initial letters from each word in the String.</p>\n     * \n     * <p>The first letter of the string and all first letters after\n     * whitespace are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null)             = null\n     * WordUtils.initials(\"\")               = \"\"\n     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @return String of initial letters, <code>null</code> if null String input\n     * @see #initials(String,char[])\n     * @since 2.2\n     */\n    public static String initials(final String str) {\n        return initials(str, null);\n    }\n\n    /**\n     * <p>Extracts the initial letters from each word in the String.</p>\n     * \n     * <p>The first letter of the string and all first letters after the\n     * defined delimiters are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>If the delimiters array is null, then Whitespace is used.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * An empty delimiter array returns an empty String.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null, *)                = null\n     * WordUtils.initials(\"\", *)                  = \"\"\n     * WordUtils.initials(\"Ben John Lee\", null)   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\", null)      = \"BJ\"\n     * WordUtils.initials(\"Ben J.Lee\", [' ','.']) = \"BJL\"\n     * WordUtils.initials(*, new char[0])         = \"\"\n     * </pre>\n     * \n     * @param str  the String to get initials from, may be null\n     * @param delimiters  set of characters to determine words, null means whitespace\n     * @return String of initial letters, <code>null</code> if null String input\n     * @see #initials(String)\n     * @since 2.2\n     */\n    public static String initials(final String str, final char... delimiters) {", "metadata": {"defects4j_task_id": "2938740f2c87d08665ce81a9e0018ce9acecda13845ed9339739ec5c1085f38b", "task_id": "apache_commons-lang/38", "ground_truth": "\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (delimiters != null && delimiters.length == 0) {\n            return \"\";\n        }\n        final int strLen = str.length();\n        final char[] buf = new char[strLen / 2 + 1];\n        int count = 0;\n        boolean lastWasGap = true;\n        for (int i = 0; i < strLen; i++) {\n            final char ch = str.charAt(i);\n\n            if (isDelimiter(ch, delimiters)) {\n                lastWasGap = true;\n            } else if (lastWasGap) {\n                buf[count++] = ch;\n                lastWasGap = false;\n            } else {\n                continue; // ignore ch\n            }\n        }\n        return new String(buf, 0, count);\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "WordUtils.java"], "context_start_lineno": 0, "function_name": "initials", "left_context": "class WordUtils {\n\n    /**\n     * <p>Swaps the case of a String using a word based algorithm.</p>\n     * \n     * <ul>\n     *  <li>Upper case character converts to Lower case</li>\n     *  <li>Title case character converts to Lower case</li>\n     *  <li>Lower case character after Whitespace or at start converts to Title case</li>\n     *  <li>Other Lower case character converts to Upper case</li>\n     * </ul>\n     * \n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     * \n     * <pre>\n     * StringUtils.swapCase(null)                 = null\n     * StringUtils.swapCase(\"\")                   = \"\"\n     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n     * </pre>\n     * \n     * @param str  the String to swap case, may be null\n     * @return the changed String, <code>null</code> if null String input\n     */\n    public static String swapCase(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final char[] buffer = str.toCharArray();\n\n        boolean whitespace = true;\n\n        for (int i = 0; i < buffer.length; i++) {\n            final char ch = buffer[i];\n            if (Character.isUpperCase(ch)) {\n                buffer[i] = Character.toLowerCase(ch);\n                whitespace = false;\n            } else if (Character.isTitleCase(ch)) {\n                buffer[i] = Character.toLowerCase(ch);\n                whitespace = false;\n            } else if (Character.isLowerCase(ch)) {\n                if (whitespace) {\n                    buffer[i] = Character.toTitleCase(ch);\n                    whitespace = false;\n                } else {\n                    buffer[i] = Character.toUpperCase(ch);\n                }\n            } else {\n                whitespace = Character.isWhitespace(ch);\n            }\n        }\n        return new String(buffer);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Extracts the initial letters from each word in the String.</p>\n     * \n     * <p>The first letter of the string and all first letters after\n     * whitespace are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null)             = null\n     * WordUtils.initials(\"\")               = \"\"\n     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @return String of initial letters, <code>null</code> if null String input\n     * @see #initials(String,char[])\n     * @since 2.2\n     */\n    public static String initials(final String str) {\n        return initials(str, null);\n    }\n\n    /**\n     * <p>Extracts the initial letters from each word in the String.</p>\n     * \n     * <p>The first letter of the string and all first letters after the\n     * defined delimiters are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>If the delimiters array is null, then Whitespace is used.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * An empty delimiter array returns an empty String.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null, *)                = null\n     * WordUtils.initials(\"\", *)                  = \"\"\n     * WordUtils.initials(\"Ben John Lee\", null)   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\", null)      = \"BJ\"\n     * WordUtils.initials(\"Ben J.Lee\", [' ','.']) = \"BJL\"\n     * WordUtils.initials(*, new char[0])         = \"\"\n     * </pre>\n     * \n     * @param str  the String to get initials from, may be null\n     * @param delimiters  set of characters to determine words, null means whitespace\n     * @return String of initial letters, <code>null</code> if null String input\n     * @see #initials(String)\n     * @since 2.2\n     */\n    public static String initials(final String str, final char... delimiters) {", "right_context": "}\n\n}", "class_name": "WordUtils", "return_type": "String", "parameters": [{"type": "String", "name": "str"}, {"type": "char", "name": "delimiters"}]}}
{"prompt": "class StrSubstitutor {\n\n    /**\n     * Replaces all the occurrences of variables within the given source\n     * builder with their matching values from the resolver.\n     *\n     * @param source  the builder to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StrBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source\n     * builder with their matching values from the resolver.\n     * <p>\n     * Only the specified portion of the builder will be processed.\n     * The rest of the builder is not processed, but it is not deleted.\n     *\n     * @param source  the builder to replace in, null returns zero\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    public boolean replaceIn(final StrBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, offset, length);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method that substitutes the variables.\n     * <p>\n     * Most users of this class do not need to call this method. This method will\n     * be called automatically by another (public) method.\n     * <p>\n     * Writers of subclasses can override this method if they need access to\n     * the substitution process at the start or end.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    protected boolean substitute(final StrBuilder buf, final int offset, final int length) {\n        return substitute(buf, offset, length, null) > 0;\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation. This is the main\n     * interpolation method, which resolves the values of all variable references\n     * contained in the passed in text.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @param priorVariables  the stack keeping track of the replaced variables, may be null\n     * @return the length change that occurs, unless priorVariables is null when the int\n     *  represents a boolean flag as to whether any change occurred.\n     */\n    private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n        final StrMatcher prefixMatcher = getVariablePrefixMatcher();\n        final StrMatcher suffixMatcher = getVariableSuffixMatcher();\n        final char escape = getEscapeChar();\n\n        final boolean top = priorVariables == null;\n        boolean altered = false;\n        int lengthChange = 0;\n        char[] chars = buf.buffer;\n        int bufEnd = offset + length;\n        int pos = offset;\n        while (pos < bufEnd) {\n            final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen == 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos > offset && chars[pos - 1] == escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars = buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered = true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos = pos;\n                    pos += startMatchLen;\n                    int endMatchLen = 0;\n                    int nestedVarCount = 0;\n                    while (pos < bufEnd) {\n                        if (isEnableSubstitutionInVariables()\n                                && (endMatchLen = prefixMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) != 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos += endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen == 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount == 0) {\n                                String varName = new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (isEnableSubstitutionInVariables()) {\n                                    final StrBuilder bufName = new StrBuilder(varName);\n                                    substitute(bufName, 0, bufName.length());\n                                    varName = bufName.toString();\n                                }\n                                pos += endMatchLen;\n                                final int endPos = pos;\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables == null) {\n                                    priorVariables = new ArrayList<String>();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                final String varValue = resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue != null) {\n                                    // recursive replace\n                                    final int varLen = varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered = true;\n                                    int change = substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change = change\n                                            + varLen - (endPos - startPos);\n                                    pos += change;\n                                    bufEnd += change;\n                                    lengthChange += change;\n                                    chars = buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            } else {\n                                nestedVarCount--;\n                                pos += endMatchLen;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }\n\n    /**\n     * Checks if the specified variable is already in the stack (list) of variables.\n     *\n     * @param varName  the variable name to check\n     * @param priorVariables  the list of prior variables\n     */\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {", "metadata": {"defects4j_task_id": "101cb30f9844947f4416f0fd0efd61ad30ec5f30ced332e526028f6a62526598", "task_id": "apache_commons-lang/16", "ground_truth": "\n        if (priorVariables.contains(varName) == false) {\n            return;\n        }\n        final StrBuilder buf = new StrBuilder(256);\n        buf.append(\"Infinite loop in property interpolation of \");\n        buf.append(priorVariables.remove(0));\n        buf.append(\": \");\n        buf.appendWithSeparators(priorVariables, \"->\");\n        throw new IllegalStateException(buf.toString());\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "StrSubstitutor.java"], "context_start_lineno": 0, "function_name": "checkCyclicSubstitution", "left_context": "class StrSubstitutor {\n\n    /**\n     * Replaces all the occurrences of variables within the given source\n     * builder with their matching values from the resolver.\n     *\n     * @param source  the builder to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StrBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source\n     * builder with their matching values from the resolver.\n     * <p>\n     * Only the specified portion of the builder will be processed.\n     * The rest of the builder is not processed, but it is not deleted.\n     *\n     * @param source  the builder to replace in, null returns zero\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    public boolean replaceIn(final StrBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, offset, length);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method that substitutes the variables.\n     * <p>\n     * Most users of this class do not need to call this method. This method will\n     * be called automatically by another (public) method.\n     * <p>\n     * Writers of subclasses can override this method if they need access to\n     * the substitution process at the start or end.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    protected boolean substitute(final StrBuilder buf, final int offset, final int length) {\n        return substitute(buf, offset, length, null) > 0;\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation. This is the main\n     * interpolation method, which resolves the values of all variable references\n     * contained in the passed in text.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @param priorVariables  the stack keeping track of the replaced variables, may be null\n     * @return the length change that occurs, unless priorVariables is null when the int\n     *  represents a boolean flag as to whether any change occurred.\n     */\n    private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n        final StrMatcher prefixMatcher = getVariablePrefixMatcher();\n        final StrMatcher suffixMatcher = getVariableSuffixMatcher();\n        final char escape = getEscapeChar();\n\n        final boolean top = priorVariables == null;\n        boolean altered = false;\n        int lengthChange = 0;\n        char[] chars = buf.buffer;\n        int bufEnd = offset + length;\n        int pos = offset;\n        while (pos < bufEnd) {\n            final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen == 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos > offset && chars[pos - 1] == escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars = buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered = true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos = pos;\n                    pos += startMatchLen;\n                    int endMatchLen = 0;\n                    int nestedVarCount = 0;\n                    while (pos < bufEnd) {\n                        if (isEnableSubstitutionInVariables()\n                                && (endMatchLen = prefixMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) != 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos += endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen == 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount == 0) {\n                                String varName = new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (isEnableSubstitutionInVariables()) {\n                                    final StrBuilder bufName = new StrBuilder(varName);\n                                    substitute(bufName, 0, bufName.length());\n                                    varName = bufName.toString();\n                                }\n                                pos += endMatchLen;\n                                final int endPos = pos;\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables == null) {\n                                    priorVariables = new ArrayList<String>();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                final String varValue = resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue != null) {\n                                    // recursive replace\n                                    final int varLen = varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered = true;\n                                    int change = substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change = change\n                                            + varLen - (endPos - startPos);\n                                    pos += change;\n                                    bufEnd += change;\n                                    lengthChange += change;\n                                    chars = buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            } else {\n                                nestedVarCount--;\n                                pos += endMatchLen;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }\n\n    /**\n     * Checks if the specified variable is already in the stack (list) of variables.\n     *\n     * @param varName  the variable name to check\n     * @param priorVariables  the list of prior variables\n     */\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {", "right_context": "}\n}", "class_name": "StrSubstitutor", "return_type": "void", "parameters": [{"type": "String", "name": "varName"}, {"type": "List<String>", "name": "priorVariables"}]}}
{"prompt": "class StrSubstitutor {\n\n    /**\n     * Replaces all the occurrences of variables within the given source\n     * builder with their matching values from the resolver.\n     * <p>\n     * Only the specified portion of the builder will be processed.\n     * The rest of the builder is not processed, but it is not deleted.\n     *\n     * @param source  the builder to replace in, null returns zero\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    public boolean replaceIn(final StrBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, offset, length);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method that substitutes the variables.\n     * <p>\n     * Most users of this class do not need to call this method. This method will\n     * be called automatically by another (public) method.\n     * <p>\n     * Writers of subclasses can override this method if they need access to\n     * the substitution process at the start or end.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    protected boolean substitute(final StrBuilder buf, final int offset, final int length) {\n        return substitute(buf, offset, length, null) > 0;\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation. This is the main\n     * interpolation method, which resolves the values of all variable references\n     * contained in the passed in text.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @param priorVariables  the stack keeping track of the replaced variables, may be null\n     * @return the length change that occurs, unless priorVariables is null when the int\n     *  represents a boolean flag as to whether any change occurred.\n     */\n    private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n        final StrMatcher prefixMatcher = getVariablePrefixMatcher();\n        final StrMatcher suffixMatcher = getVariableSuffixMatcher();\n        final char escape = getEscapeChar();\n\n        final boolean top = priorVariables == null;\n        boolean altered = false;\n        int lengthChange = 0;\n        char[] chars = buf.buffer;\n        int bufEnd = offset + length;\n        int pos = offset;\n        while (pos < bufEnd) {\n            final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen == 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos > offset && chars[pos - 1] == escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars = buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered = true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos = pos;\n                    pos += startMatchLen;\n                    int endMatchLen = 0;\n                    int nestedVarCount = 0;\n                    while (pos < bufEnd) {\n                        if (isEnableSubstitutionInVariables()\n                                && (endMatchLen = prefixMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) != 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos += endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen == 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount == 0) {\n                                String varName = new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (isEnableSubstitutionInVariables()) {\n                                    final StrBuilder bufName = new StrBuilder(varName);\n                                    substitute(bufName, 0, bufName.length());\n                                    varName = bufName.toString();\n                                }\n                                pos += endMatchLen;\n                                final int endPos = pos;\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables == null) {\n                                    priorVariables = new ArrayList<String>();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                final String varValue = resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue != null) {\n                                    // recursive replace\n                                    final int varLen = varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered = true;\n                                    int change = substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change = change\n                                            + varLen - (endPos - startPos);\n                                    pos += change;\n                                    bufEnd += change;\n                                    lengthChange += change;\n                                    chars = buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            } else {\n                                nestedVarCount--;\n                                pos += endMatchLen;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }\n\n    /**\n     * Checks if the specified variable is already in the stack (list) of variables.\n     *\n     * @param varName  the variable name to check\n     * @param priorVariables  the list of prior variables\n     */\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\n        if (priorVariables.contains(varName) == false) {\n            return;\n        }\n        final StrBuilder buf = new StrBuilder(256);\n        buf.append(\"Infinite loop in property interpolation of \");\n        buf.append(priorVariables.remove(0));\n        buf.append(\": \");\n        buf.appendWithSeparators(priorVariables, \"->\");\n        throw new IllegalStateException(buf.toString());\n    }\n\n    /**\n     * Internal method that resolves the value of a variable.\n     * <p>\n     * Most users of this class do not need to call this method. This method is\n     * called automatically by the substitution process.\n     * <p>\n     * Writers of subclasses can override this method if they need to alter\n     * how each substitution occurs. The method is passed the variable's name\n     * and must return the corresponding value. This implementation uses the\n     * {@link #getVariableResolver()} with the variable's name as the key.\n     *\n     * @param variableName  the name of the variable, not null\n     * @param buf  the buffer where the substitution is occurring, not null\n     * @param startPos  the start position of the variable including the prefix, valid\n     * @param endPos  the end position of the variable including the suffix, valid\n     * @return the variable's value or <b>null</b> if the variable is unknown\n     */\n    protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) {", "metadata": {"defects4j_task_id": "5a7314142a6e15248a6f3209ef4e06253405eccbad1c3a2d77d1f1f12a86b767", "task_id": "apache_commons-lang/79", "ground_truth": "\n        final StrLookup<?> resolver = getVariableResolver();\n        if (resolver == null) {\n            return null;\n        }\n        return resolver.lookup(variableName);\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "StrSubstitutor.java"], "context_start_lineno": 0, "function_name": "resolveVariable", "left_context": "class StrSubstitutor {\n\n    /**\n     * Replaces all the occurrences of variables within the given source\n     * builder with their matching values from the resolver.\n     * <p>\n     * Only the specified portion of the builder will be processed.\n     * The rest of the builder is not processed, but it is not deleted.\n     *\n     * @param source  the builder to replace in, null returns zero\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    public boolean replaceIn(final StrBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, offset, length);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method that substitutes the variables.\n     * <p>\n     * Most users of this class do not need to call this method. This method will\n     * be called automatically by another (public) method.\n     * <p>\n     * Writers of subclasses can override this method if they need access to\n     * the substitution process at the start or end.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    protected boolean substitute(final StrBuilder buf, final int offset, final int length) {\n        return substitute(buf, offset, length, null) > 0;\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation. This is the main\n     * interpolation method, which resolves the values of all variable references\n     * contained in the passed in text.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @param priorVariables  the stack keeping track of the replaced variables, may be null\n     * @return the length change that occurs, unless priorVariables is null when the int\n     *  represents a boolean flag as to whether any change occurred.\n     */\n    private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n        final StrMatcher prefixMatcher = getVariablePrefixMatcher();\n        final StrMatcher suffixMatcher = getVariableSuffixMatcher();\n        final char escape = getEscapeChar();\n\n        final boolean top = priorVariables == null;\n        boolean altered = false;\n        int lengthChange = 0;\n        char[] chars = buf.buffer;\n        int bufEnd = offset + length;\n        int pos = offset;\n        while (pos < bufEnd) {\n            final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen == 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos > offset && chars[pos - 1] == escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars = buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered = true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos = pos;\n                    pos += startMatchLen;\n                    int endMatchLen = 0;\n                    int nestedVarCount = 0;\n                    while (pos < bufEnd) {\n                        if (isEnableSubstitutionInVariables()\n                                && (endMatchLen = prefixMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) != 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos += endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen == 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount == 0) {\n                                String varName = new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (isEnableSubstitutionInVariables()) {\n                                    final StrBuilder bufName = new StrBuilder(varName);\n                                    substitute(bufName, 0, bufName.length());\n                                    varName = bufName.toString();\n                                }\n                                pos += endMatchLen;\n                                final int endPos = pos;\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables == null) {\n                                    priorVariables = new ArrayList<String>();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                final String varValue = resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue != null) {\n                                    // recursive replace\n                                    final int varLen = varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered = true;\n                                    int change = substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change = change\n                                            + varLen - (endPos - startPos);\n                                    pos += change;\n                                    bufEnd += change;\n                                    lengthChange += change;\n                                    chars = buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            } else {\n                                nestedVarCount--;\n                                pos += endMatchLen;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }\n\n    /**\n     * Checks if the specified variable is already in the stack (list) of variables.\n     *\n     * @param varName  the variable name to check\n     * @param priorVariables  the list of prior variables\n     */\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\n        if (priorVariables.contains(varName) == false) {\n            return;\n        }\n        final StrBuilder buf = new StrBuilder(256);\n        buf.append(\"Infinite loop in property interpolation of \");\n        buf.append(priorVariables.remove(0));\n        buf.append(\": \");\n        buf.appendWithSeparators(priorVariables, \"->\");\n        throw new IllegalStateException(buf.toString());\n    }\n\n    /**\n     * Internal method that resolves the value of a variable.\n     * <p>\n     * Most users of this class do not need to call this method. This method is\n     * called automatically by the substitution process.\n     * <p>\n     * Writers of subclasses can override this method if they need to alter\n     * how each substitution occurs. The method is passed the variable's name\n     * and must return the corresponding value. This implementation uses the\n     * {@link #getVariableResolver()} with the variable's name as the key.\n     *\n     * @param variableName  the name of the variable, not null\n     * @param buf  the buffer where the substitution is occurring, not null\n     * @param startPos  the start position of the variable including the prefix, valid\n     * @param endPos  the end position of the variable including the suffix, valid\n     * @return the variable's value or <b>null</b> if the variable is unknown\n     */\n    protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) {", "right_context": "}\n}", "class_name": "StrSubstitutor", "return_type": "String", "parameters": [{"type": "String", "name": "variableName"}, {"type": "StrBuilder", "name": "buf"}, {"type": "int", "name": "startPos"}, {"type": "int", "name": "endPos"}]}}
{"prompt": "class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Required for serialization support.\n     * \n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 7628716375283629643L;\n\n    /** Internal data storage. */\n    protected char[] buffer; // TODO make private?\n    /** Current size of the buffer. */\n    protected int size; // TODO make private?\n    /** The new line. */\n    private String newLine;\n    /** The null text. */\n    private String nullText;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that creates an empty builder initial capacity 32 characters.\n     */\n    public StrBuilder() {\n        this(CAPACITY);\n    }\n\n    /**\n     * Constructor that creates an empty builder the specified initial capacity.\n     *\n     * @param initialCapacity  the initial capacity, zero or less will be converted to 32\n     */\n    public StrBuilder(int initialCapacity) {\n        super();\n        if (initialCapacity <= 0) {\n            initialCapacity = CAPACITY;\n        }\n        buffer = new char[initialCapacity];\n    }\n\n    /**\n     * Constructor that creates a builder from the string, allocating\n     * 32 extra characters for growth.\n     *\n     * @param str  the string to copy, null treated as blank string\n     */\n    public StrBuilder(final String str) {\n        super();\n        if (str == null) {\n            buffer = new char[CAPACITY];\n        } else {\n            buffer = new char[str.length() + CAPACITY];\n            append(str);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the text to be appended when a new line is added.\n     *\n     * @return the new line text, null means use system default\n     */\n    public String getNewLineText() {\n        return newLine;\n    }\n\n    /**\n     * Sets the text to be appended when a new line is added.\n     *\n     * @param newLine  the new line text, null means use system default\n     * @return this, to enable chaining\n     */\n    public StrBuilder setNewLineText(final String newLine) {\n        this.newLine = newLine;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the text to be appended when null is added.\n     *\n     * @return the null text, null means no append\n     */\n    public String getNullText() {\n        return nullText;\n    }\n\n    /**\n     * Sets the text to be appended when null is added.\n     *\n     * @param nullText  the null text, null means no append\n     * @return this, to enable chaining\n     */\n    public StrBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.isEmpty()) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the length of the string builder.\n     *\n     * @return the length\n     */\n    @Override\n    public int length() {\n        return size;\n    }\n\n    /**\n     * Updates the length of the builder by either dropping the last characters\n     * or adding filler of Unicode zero.\n     *\n     * @param length  the length to set to, must be zero or positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the length is negative\n     */\n    public StrBuilder setLength(final int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacity(length);\n            final int oldEnd = size;\n            final int newEnd = length;\n            size = length;\n            for (int i = oldEnd; i < newEnd; i++) {\n                buffer[i] = '\\0';\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return the capacity\n     */\n    public int capacity() {\n        return buffer.length;\n    }\n\n    /**\n     * Checks the capacity and ensures that it is at least the size specified.\n     *\n     * @param capacity  the capacity to ensure\n     * @return this, to enable chaining\n     */\n    public StrBuilder ensureCapacity(final int capacity) {", "metadata": {"defects4j_task_id": "961ba326d6fb64bc7545f11ae9fc5f41ca2ca7e7d3fec772bfc5e2b337e9478b", "task_id": "apache_commons-lang/122", "ground_truth": "\n        if (capacity > buffer.length) {\n            final char[] old = buffer;\n            buffer = new char[capacity * 2];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "StrBuilder.java"], "context_start_lineno": 0, "function_name": "ensureCapacity", "left_context": "class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Required for serialization support.\n     * \n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 7628716375283629643L;\n\n    /** Internal data storage. */\n    protected char[] buffer; // TODO make private?\n    /** Current size of the buffer. */\n    protected int size; // TODO make private?\n    /** The new line. */\n    private String newLine;\n    /** The null text. */\n    private String nullText;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that creates an empty builder initial capacity 32 characters.\n     */\n    public StrBuilder() {\n        this(CAPACITY);\n    }\n\n    /**\n     * Constructor that creates an empty builder the specified initial capacity.\n     *\n     * @param initialCapacity  the initial capacity, zero or less will be converted to 32\n     */\n    public StrBuilder(int initialCapacity) {\n        super();\n        if (initialCapacity <= 0) {\n            initialCapacity = CAPACITY;\n        }\n        buffer = new char[initialCapacity];\n    }\n\n    /**\n     * Constructor that creates a builder from the string, allocating\n     * 32 extra characters for growth.\n     *\n     * @param str  the string to copy, null treated as blank string\n     */\n    public StrBuilder(final String str) {\n        super();\n        if (str == null) {\n            buffer = new char[CAPACITY];\n        } else {\n            buffer = new char[str.length() + CAPACITY];\n            append(str);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the text to be appended when a new line is added.\n     *\n     * @return the new line text, null means use system default\n     */\n    public String getNewLineText() {\n        return newLine;\n    }\n\n    /**\n     * Sets the text to be appended when a new line is added.\n     *\n     * @param newLine  the new line text, null means use system default\n     * @return this, to enable chaining\n     */\n    public StrBuilder setNewLineText(final String newLine) {\n        this.newLine = newLine;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the text to be appended when null is added.\n     *\n     * @return the null text, null means no append\n     */\n    public String getNullText() {\n        return nullText;\n    }\n\n    /**\n     * Sets the text to be appended when null is added.\n     *\n     * @param nullText  the null text, null means no append\n     * @return this, to enable chaining\n     */\n    public StrBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.isEmpty()) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the length of the string builder.\n     *\n     * @return the length\n     */\n    @Override\n    public int length() {\n        return size;\n    }\n\n    /**\n     * Updates the length of the builder by either dropping the last characters\n     * or adding filler of Unicode zero.\n     *\n     * @param length  the length to set to, must be zero or positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the length is negative\n     */\n    public StrBuilder setLength(final int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacity(length);\n            final int oldEnd = size;\n            final int newEnd = length;\n            size = length;\n            for (int i = oldEnd; i < newEnd; i++) {\n                buffer[i] = '\\0';\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return the capacity\n     */\n    public int capacity() {\n        return buffer.length;\n    }\n\n    /**\n     * Checks the capacity and ensures that it is at least the size specified.\n     *\n     * @param capacity  the capacity to ensure\n     * @return this, to enable chaining\n     */\n    public StrBuilder ensureCapacity(final int capacity) {", "right_context": "}\n\n}", "class_name": "StrBuilder", "return_type": "StrBuilder", "parameters": [{"type": "int", "name": "capacity"}]}}
{"prompt": "class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Appends a separator if the builder is currently non-empty.\n     * The separator is appended using {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the\n     * loop except the first.\n     * <pre>\n     * for (Iterator it = list.iterator(); it.hasNext(); ) {\n     *   appendSeparator(',');\n     *   append(it.next());\n     * }\n     * </pre>\n     * Note that for this simple example, you should use\n     * {@link #appendWithSeparators(Iterable, String)}.\n     * \n     * @param separator  the separator to use\n     * @return this, to enable chaining\n     * @since 2.3\n     */\n    public StrBuilder appendSeparator(final char separator) {\n        if (size() > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Append one of both separators to the builder\n     * If the builder is currently empty it will append the defaultIfEmpty-separator\n     * Otherwise it will append the standard-separator\n     *\n     * The separator is appended using {@link #append(char)}.\n     * @param standard the separator if builder is not empty\n     * @param defaultIfEmpty the separator if builder is empty\n     * @return this, to enable chaining\n     * @since 2.5\n     */\n    public StrBuilder appendSeparator(final char standard, final char defaultIfEmpty) {\n        if (size() > 0) {\n            append(standard);\n        } else {\n            append(defaultIfEmpty);\n        }\n        return this;\n    }\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero.\n     * Appending a null separator will have no effect.\n     * The separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is useful for adding a separator each time around the\n     * loop except the first.\n     * <pre>\n     * for (int i = 0; i < list.size(); i++) {\n     *   appendSeparator(\",\", i);\n     *   append(list.get(i));\n     * }\n     * </pre>\n     * Note that for this simple example, you should use\n     * {@link #appendWithSeparators(Iterable, String)}.\n     * \n     * @param separator  the separator to use, null means no separator\n     * @param loopIndex  the loop index\n     * @return this, to enable chaining\n     * @since 2.3\n     */\n    public StrBuilder appendSeparator(final String separator, final int loopIndex) {\n        if (separator != null && loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero.\n     * The separator is appended using {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the\n     * loop except the first.\n     * <pre>\n     * for (int i = 0; i < list.size(); i++) {\n     *   appendSeparator(\",\", i);\n     *   append(list.get(i));\n     * }\n     * </pre>\n     * Note that for this simple example, you should use\n     * {@link #appendWithSeparators(Iterable, String)}.\n     * \n     * @param separator  the separator to use\n     * @param loopIndex  the loop index\n     * @return this, to enable chaining\n     * @since 2.3\n     */\n    public StrBuilder appendSeparator(final char separator, final int loopIndex) {\n        if (loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the pad character to the builder the specified number of times.\n     * \n     * @param length  the length to append, negative means no append\n     * @param padChar  the character to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendPadding(final int length, final char padChar) {\n        if (length >= 0) {\n            ensureCapacity(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n     * If the formatted value is larger than the length, the left hand side is lost.\n     * \n     * @param value  the value to append\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {\n        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {", "metadata": {"defects4j_task_id": "499a7d54fc08de4e1c9294298947f941dee57f551a6457ac670fde7ec86fab22", "task_id": "apache_commons-lang/65", "ground_truth": "\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "StrBuilder.java"], "context_start_lineno": 0, "function_name": "appendFixedWidthPadRight", "left_context": "class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Appends a separator if the builder is currently non-empty.\n     * The separator is appended using {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the\n     * loop except the first.\n     * <pre>\n     * for (Iterator it = list.iterator(); it.hasNext(); ) {\n     *   appendSeparator(',');\n     *   append(it.next());\n     * }\n     * </pre>\n     * Note that for this simple example, you should use\n     * {@link #appendWithSeparators(Iterable, String)}.\n     * \n     * @param separator  the separator to use\n     * @return this, to enable chaining\n     * @since 2.3\n     */\n    public StrBuilder appendSeparator(final char separator) {\n        if (size() > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Append one of both separators to the builder\n     * If the builder is currently empty it will append the defaultIfEmpty-separator\n     * Otherwise it will append the standard-separator\n     *\n     * The separator is appended using {@link #append(char)}.\n     * @param standard the separator if builder is not empty\n     * @param defaultIfEmpty the separator if builder is empty\n     * @return this, to enable chaining\n     * @since 2.5\n     */\n    public StrBuilder appendSeparator(final char standard, final char defaultIfEmpty) {\n        if (size() > 0) {\n            append(standard);\n        } else {\n            append(defaultIfEmpty);\n        }\n        return this;\n    }\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero.\n     * Appending a null separator will have no effect.\n     * The separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is useful for adding a separator each time around the\n     * loop except the first.\n     * <pre>\n     * for (int i = 0; i < list.size(); i++) {\n     *   appendSeparator(\",\", i);\n     *   append(list.get(i));\n     * }\n     * </pre>\n     * Note that for this simple example, you should use\n     * {@link #appendWithSeparators(Iterable, String)}.\n     * \n     * @param separator  the separator to use, null means no separator\n     * @param loopIndex  the loop index\n     * @return this, to enable chaining\n     * @since 2.3\n     */\n    public StrBuilder appendSeparator(final String separator, final int loopIndex) {\n        if (separator != null && loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero.\n     * The separator is appended using {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the\n     * loop except the first.\n     * <pre>\n     * for (int i = 0; i < list.size(); i++) {\n     *   appendSeparator(\",\", i);\n     *   append(list.get(i));\n     * }\n     * </pre>\n     * Note that for this simple example, you should use\n     * {@link #appendWithSeparators(Iterable, String)}.\n     * \n     * @param separator  the separator to use\n     * @param loopIndex  the loop index\n     * @return this, to enable chaining\n     * @since 2.3\n     */\n    public StrBuilder appendSeparator(final char separator, final int loopIndex) {\n        if (loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the pad character to the builder the specified number of times.\n     * \n     * @param length  the length to append, negative means no append\n     * @param padChar  the character to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendPadding(final int length, final char padChar) {\n        if (length >= 0) {\n            ensureCapacity(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n     * If the formatted value is larger than the length, the left hand side is lost.\n     * \n     * @param value  the value to append\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {\n        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {", "right_context": "}\n\n}", "class_name": "StrBuilder", "return_type": "StrBuilder", "parameters": [{"type": "Object", "name": "obj"}, {"type": "int", "name": "width"}, {"type": "char", "name": "padChar"}]}}
{"prompt": "class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Inserts part of the character array into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param chars  the char array to insert\n     * @param offset  the offset into the character array to start at, must be valid\n     * @param length  the length of the character array part to copy, must be positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    public StrBuilder insert(final int index, final char chars[], final int offset, final int length) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        if (offset < 0 || offset > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n        }\n        if (length < 0 || offset + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            ensureCapacity(size + length);\n            System.arraycopy(buffer, index, buffer, index + length, size - index);\n            System.arraycopy(chars, offset, buffer, index, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, final boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + 4);\n            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n            buffer[index++] = 't';\n            buffer[index++] = 'r';\n            buffer[index++] = 'u';\n            buffer[index] = 'e';\n            size += 4;\n        } else {\n            ensureCapacity(size + 5);\n            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n            buffer[index++] = 'f';\n            buffer[index++] = 'a';\n            buffer[index++] = 'l';\n            buffer[index++] = 's';\n            buffer[index] = 'e';\n            size += 5;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex  the start index, must be valid\n     * @param endIndex  the end index (exclusive), must be valid\n     * @param len  the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void deleteImpl(final int startIndex, final int endIndex, final int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    /**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder delete(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, endIndex, len);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                final int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                final int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(final String str) {", "metadata": {"defects4j_task_id": "3cf8b698e2b15a5fc5f462436a0a1dc18d364fb1fde788ea0a5ccb8507017eef", "task_id": "apache_commons-lang/55", "ground_truth": "\n        final int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            while (index >= 0) {\n                deleteImpl(index, index + len, len);\n                index = indexOf(str, index);\n            }\n        }\n        return this;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "StrBuilder.java"], "context_start_lineno": 0, "function_name": "deleteAll", "left_context": "class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Inserts part of the character array into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param chars  the char array to insert\n     * @param offset  the offset into the character array to start at, must be valid\n     * @param length  the length of the character array part to copy, must be positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    public StrBuilder insert(final int index, final char chars[], final int offset, final int length) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        if (offset < 0 || offset > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n        }\n        if (length < 0 || offset + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            ensureCapacity(size + length);\n            System.arraycopy(buffer, index, buffer, index + length, size - index);\n            System.arraycopy(chars, offset, buffer, index, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, final boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + 4);\n            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n            buffer[index++] = 't';\n            buffer[index++] = 'r';\n            buffer[index++] = 'u';\n            buffer[index] = 'e';\n            size += 4;\n        } else {\n            ensureCapacity(size + 5);\n            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n            buffer[index++] = 'f';\n            buffer[index++] = 'a';\n            buffer[index++] = 'l';\n            buffer[index++] = 's';\n            buffer[index] = 'e';\n            size += 5;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex  the start index, must be valid\n     * @param endIndex  the end index (exclusive), must be valid\n     * @param len  the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void deleteImpl(final int startIndex, final int endIndex, final int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    /**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder delete(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, endIndex, len);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                final int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                final int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(final String str) {", "right_context": "}\n\n}", "class_name": "StrBuilder", "return_type": "StrBuilder", "parameters": [{"type": "String", "name": "str"}]}}
{"prompt": "class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, final boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + 4);\n            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n            buffer[index++] = 't';\n            buffer[index++] = 'r';\n            buffer[index++] = 'u';\n            buffer[index] = 'e';\n            size += 4;\n        } else {\n            ensureCapacity(size + 5);\n            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n            buffer[index++] = 'f';\n            buffer[index++] = 'a';\n            buffer[index++] = 'l';\n            buffer[index++] = 's';\n            buffer[index] = 'e';\n            size += 5;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex  the start index, must be valid\n     * @param endIndex  the end index (exclusive), must be valid\n     * @param len  the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void deleteImpl(final int startIndex, final int endIndex, final int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    /**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder delete(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, endIndex, len);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                final int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                final int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(final String str) {\n        final int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            while (index >= 0) {\n                deleteImpl(index, index + len, len);\n                index = indexOf(str, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(final String str) {", "metadata": {"defects4j_task_id": "0370917ec7f90da7c60ce4f962cafdd4e79606c89c781be2e9b23578d896b8a6", "task_id": "apache_commons-lang/4", "ground_truth": "\n        final int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            final int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "StrBuilder.java"], "context_start_lineno": 0, "function_name": "deleteFirst", "left_context": "class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, final boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + 4);\n            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n            buffer[index++] = 't';\n            buffer[index++] = 'r';\n            buffer[index++] = 'u';\n            buffer[index] = 'e';\n            size += 4;\n        } else {\n            ensureCapacity(size + 5);\n            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n            buffer[index++] = 'f';\n            buffer[index++] = 'a';\n            buffer[index++] = 'l';\n            buffer[index++] = 's';\n            buffer[index] = 'e';\n            size += 5;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex  the start index, must be valid\n     * @param endIndex  the end index (exclusive), must be valid\n     * @param len  the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void deleteImpl(final int startIndex, final int endIndex, final int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    /**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder delete(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, endIndex, len);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                final int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                final int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(final String str) {\n        final int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            while (index >= 0) {\n                deleteImpl(index, index + len, len);\n                index = indexOf(str, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(final String str) {", "right_context": "}\n\n}", "class_name": "StrBuilder", "return_type": "StrBuilder", "parameters": [{"type": "String", "name": "str"}]}}
{"prompt": "class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Replaces the search character with the replace character\n     * throughout the builder.\n     *\n     * @param search  the search character\n     * @param replace  the replace character\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search character with the\n     * replace character in the builder.\n     *\n     * @param search  the search character\n     * @param replace  the replace character\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces the search string with the replace string throughout the builder.\n     *\n     * @param searchStr  the search string, null causes no action to occur\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(final String searchStr, final String replaceStr) {\n        final int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n            int index = indexOf(searchStr, 0);\n            while (index >= 0) {\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n                index = indexOf(searchStr, index + replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search string with the replace string.\n     *\n     * @param searchStr  the search string, null causes no action to occur\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(final String searchStr, final String replaceStr) {\n        final int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            final int index = indexOf(searchStr, 0);\n            if (index >= 0) {\n                final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all matches within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behaviour.\n     * For example you could write a matcher to replace all occurrences\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }\n\n    /**\n     * Replaces the first match within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behaviour.\n     * For example you could write a matcher to replace\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Advanced search and replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behaviour.\n     * For example you could write a matcher to delete all occurrences\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the string to replace the match with, null is a delete\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @param replaceCount  the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if start index is invalid\n     */\n    public StrBuilder replace(\n            final StrMatcher matcher, final String replaceStr,\n            final int startIndex, int endIndex, final int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }\n\n    /**\n     * Replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behaviour.\n     * For example you could write a matcher to delete all occurrences\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the string to replace the match with, null is a delete\n     * @param from  the start index, must be valid\n     * @param to  the end index (exclusive), must be valid\n     * @param replaceCount  the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private StrBuilder replaceImpl(\n            final StrMatcher matcher, final String replaceStr,\n            final int from, int to, int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n        final char[] buf = buffer;\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            final int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Reverses the string builder placing each character in the opposite index.\n     * \n     * @return this, to enable chaining\n     */\n    public StrBuilder reverse() {", "metadata": {"defects4j_task_id": "15e8343c78dfd639e2ee962ae72f71a8ae89845292202d010b7cc424eab07f62", "task_id": "apache_commons-lang/22", "ground_truth": "\n        if (size == 0) {\n            return this;\n        }\n        \n        final int half = size / 2;\n        final char[] buf = buffer;\n        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++,rightIdx--) {\n            final char swap = buf[leftIdx];\n            buf[leftIdx] = buf[rightIdx];\n            buf[rightIdx] = swap;\n        }\n        return this;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "StrBuilder.java"], "context_start_lineno": 0, "function_name": "reverse", "left_context": "class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Replaces the search character with the replace character\n     * throughout the builder.\n     *\n     * @param search  the search character\n     * @param replace  the replace character\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search character with the\n     * replace character in the builder.\n     *\n     * @param search  the search character\n     * @param replace  the replace character\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces the search string with the replace string throughout the builder.\n     *\n     * @param searchStr  the search string, null causes no action to occur\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(final String searchStr, final String replaceStr) {\n        final int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n            int index = indexOf(searchStr, 0);\n            while (index >= 0) {\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n                index = indexOf(searchStr, index + replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search string with the replace string.\n     *\n     * @param searchStr  the search string, null causes no action to occur\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(final String searchStr, final String replaceStr) {\n        final int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            final int index = indexOf(searchStr, 0);\n            if (index >= 0) {\n                final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all matches within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behaviour.\n     * For example you could write a matcher to replace all occurrences\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }\n\n    /**\n     * Replaces the first match within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behaviour.\n     * For example you could write a matcher to replace\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Advanced search and replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behaviour.\n     * For example you could write a matcher to delete all occurrences\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the string to replace the match with, null is a delete\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @param replaceCount  the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if start index is invalid\n     */\n    public StrBuilder replace(\n            final StrMatcher matcher, final String replaceStr,\n            final int startIndex, int endIndex, final int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }\n\n    /**\n     * Replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behaviour.\n     * For example you could write a matcher to delete all occurrences\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the string to replace the match with, null is a delete\n     * @param from  the start index, must be valid\n     * @param to  the end index (exclusive), must be valid\n     * @param replaceCount  the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private StrBuilder replaceImpl(\n            final StrMatcher matcher, final String replaceStr,\n            final int from, int to, int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n        final char[] buf = buffer;\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            final int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Reverses the string builder placing each character in the opposite index.\n     * \n     * @return this, to enable chaining\n     */\n    public StrBuilder reverse() {", "right_context": "}\n\n}", "class_name": "StrBuilder", "return_type": "StrBuilder", "parameters": []}}
{"prompt": "class ExtendedMessageFormat extends MessageFormat {\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param formatElementIndex format element index\n     * @param newFormat the new format\n     * @throws UnsupportedOperationException\n     */\n    @Override\n    public void setFormat(final int formatElementIndex, final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param argumentIndex argument index\n     * @param newFormat the new format\n     * @throws UnsupportedOperationException\n     */\n    @Override\n    public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param newFormats new formats\n     * @throws UnsupportedOperationException\n     */\n    @Override\n    public void setFormats(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param newFormats new formats\n     * @throws UnsupportedOperationException\n     */\n    @Override\n    public void setFormatsByArgumentIndex(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Check if this extended message format is equal to another object.\n     *\n     * @param obj the object to compare to\n     * @return true if this object equals the other, otherwise false\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {\n          return false;\n        }\n        final ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n            return false;\n        }\n        if (ObjectUtils.notEqual(registry, rhs.registry)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Return the hashcode.\n     *\n     * @return the hashcode\n     */\n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = HASH_SEED * result + ObjectUtils.hashCode(registry);\n        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);\n        return result;\n    }\n\n    /**\n     * Get a custom format from a format description.\n     *\n     * @param desc String\n     * @return Format\n     */\n    private Format getFormat(final String desc) {\n        if (registry != null) {\n            String name = desc;\n            String args = null;\n            final int i = desc.indexOf(START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            final FormatFactory factory = registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Read the argument index from the current format element\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @return argument index\n     */\n    private int readArgumentIndex(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final StringBuilder result = new StringBuilder();\n        boolean error = false;\n        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if (c != START_FMT && c != END_FE) {\n                    error = true;\n                    continue;\n                }\n            }\n            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n                try {\n                    return Integer.parseInt(result.toString());\n                } catch (final NumberFormatException e) { // NOPMD\n                    // we've already ensured only digits, so unless something\n                    // outlandishly large was specified we should be okay.\n                }\n            }\n            error = !Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new IllegalArgumentException(\n                    \"Invalid format argument index at position \" + start + \": \"\n                            + pattern.substring(start, pos.getIndex()));\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    /**\n     * Parse the format component of a format element.\n     *\n     * @param pattern string to parse\n     * @param pos current parse position\n     * @return Format description String\n     */\n    private String parseFormatDescription(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        int depth = 1;\n        for (; pos.getIndex() < pattern.length(); next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    return pattern.substring(text, pos.getIndex());\n                }\n                break;\n            case QUOTE:\n                getQuotedString(pattern, pos, false);\n                break;\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    /**\n     * Insert formats back into the pattern for toPattern() support.\n     *\n     * @param pattern source\n     * @param customPatterns The custom patterns to re-insert, if any\n     * @return full pattern\n     */\n    private String insertFormats(final String pattern, final ArrayList<String> customPatterns) {", "metadata": {"defects4j_task_id": "a8c5ad6cc2b56478e03224bb10383f109cb674c61534c2595dca24c215d34514", "task_id": "apache_commons-lang/141", "ground_truth": "\n        if (!containsElements(customPatterns)) {\n            return pattern;\n        }\n        final StringBuilder sb = new StringBuilder(pattern.length() * 2);\n        final ParsePosition pos = new ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            final char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, sb, false);\n                break;\n            case START_FE:\n                depth++;\n                if (depth == 1) {\n                    fe++;\n                    sb.append(START_FE).append(\n                            readArgumentIndex(pattern, next(pos)));\n                    final String customPattern = customPatterns.get(fe);\n                    if (customPattern != null) {\n                        sb.append(START_FMT).append(customPattern);\n                    }\n                }\n                break;\n            case END_FE:\n                depth--;\n                //$FALL-THROUGH$\n            default:\n                sb.append(c);\n                next(pos);\n            }\n        }\n        return sb.toString();\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "text", "ExtendedMessageFormat.java"], "context_start_lineno": 0, "function_name": "insertFormats", "left_context": "class ExtendedMessageFormat extends MessageFormat {\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param formatElementIndex format element index\n     * @param newFormat the new format\n     * @throws UnsupportedOperationException\n     */\n    @Override\n    public void setFormat(final int formatElementIndex, final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param argumentIndex argument index\n     * @param newFormat the new format\n     * @throws UnsupportedOperationException\n     */\n    @Override\n    public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param newFormats new formats\n     * @throws UnsupportedOperationException\n     */\n    @Override\n    public void setFormats(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param newFormats new formats\n     * @throws UnsupportedOperationException\n     */\n    @Override\n    public void setFormatsByArgumentIndex(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Check if this extended message format is equal to another object.\n     *\n     * @param obj the object to compare to\n     * @return true if this object equals the other, otherwise false\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {\n          return false;\n        }\n        final ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n            return false;\n        }\n        if (ObjectUtils.notEqual(registry, rhs.registry)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Return the hashcode.\n     *\n     * @return the hashcode\n     */\n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = HASH_SEED * result + ObjectUtils.hashCode(registry);\n        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);\n        return result;\n    }\n\n    /**\n     * Get a custom format from a format description.\n     *\n     * @param desc String\n     * @return Format\n     */\n    private Format getFormat(final String desc) {\n        if (registry != null) {\n            String name = desc;\n            String args = null;\n            final int i = desc.indexOf(START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            final FormatFactory factory = registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Read the argument index from the current format element\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @return argument index\n     */\n    private int readArgumentIndex(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final StringBuilder result = new StringBuilder();\n        boolean error = false;\n        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if (c != START_FMT && c != END_FE) {\n                    error = true;\n                    continue;\n                }\n            }\n            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n                try {\n                    return Integer.parseInt(result.toString());\n                } catch (final NumberFormatException e) { // NOPMD\n                    // we've already ensured only digits, so unless something\n                    // outlandishly large was specified we should be okay.\n                }\n            }\n            error = !Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new IllegalArgumentException(\n                    \"Invalid format argument index at position \" + start + \": \"\n                            + pattern.substring(start, pos.getIndex()));\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    /**\n     * Parse the format component of a format element.\n     *\n     * @param pattern string to parse\n     * @param pos current parse position\n     * @return Format description String\n     */\n    private String parseFormatDescription(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        int depth = 1;\n        for (; pos.getIndex() < pattern.length(); next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    return pattern.substring(text, pos.getIndex());\n                }\n                break;\n            case QUOTE:\n                getQuotedString(pattern, pos, false);\n                break;\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    /**\n     * Insert formats back into the pattern for toPattern() support.\n     *\n     * @param pattern source\n     * @param customPatterns The custom patterns to re-insert, if any\n     * @return full pattern\n     */\n    private String insertFormats(final String pattern, final ArrayList<String> customPatterns) {", "right_context": "}\n}", "class_name": "ExtendedMessageFormat", "return_type": "String", "parameters": [{"type": "String", "name": "pattern"}, {"type": "ArrayList<String>", "name": "customPatterns"}]}}
{"prompt": "class BooleanUtils {\n\n    /**\n     * <p>Converts an Integer to a Boolean using the convention that {@code zero}\n     * is {@code false}.</p>\n     *\n     * <p>{@code null} will be converted to {@code null}.</p>\n     *\n     * <p>NOTE: This returns null and will throw a NullPointerException if autoboxed to a boolean. </p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(Integer.valueOf(0))    = Boolean.FALSE\n     *   BooleanUtils.toBoolean(Integer.valueOf(1))    = Boolean.TRUE\n     *   BooleanUtils.toBoolean(Integer.valueOf(null)) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n     *  {@code null} if {@code null} input\n     */\n    public static Boolean toBooleanObject(final Integer value) {\n        if (value == null) {\n            return null;\n        }\n        return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n    }\n\n    /**\n     * <p>Converts an int to a boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(0, 1, 0) = false\n     *   BooleanUtils.toBoolean(1, 1, 0) = true\n     *   BooleanUtils.toBoolean(2, 1, 2) = false\n     *   BooleanUtils.toBoolean(2, 2, 0) = true\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for {@code true}\n     * @param falseValue  the value to match for {@code false}\n     * @return {@code true} or {@code false}\n     * @throws IllegalArgumentException if no match\n     */\n    public static boolean toBoolean(final int value, final int trueValue, final int falseValue) {\n        if (value == trueValue) {\n            return true;\n        }\n        if (value == falseValue) {\n            return false;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n\n    /**\n     * <p>Converts an Integer to a boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(Integer.valueOf(0), Integer.valueOf(1), Integer.valueOf(0)) = false\n     *   BooleanUtils.toBoolean(Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(0)) = true\n     *   BooleanUtils.toBoolean(Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(2)) = false\n     *   BooleanUtils.toBoolean(Integer.valueOf(2), Integer.valueOf(2), Integer.valueOf(0)) = true\n     *   BooleanUtils.toBoolean(null, null, Integer.valueOf(0))                     = true\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for {@code true}, may be {@code null}\n     * @param falseValue  the value to match for {@code false}, may be {@code null}\n     * @return {@code true} or {@code false}\n     * @throws IllegalArgumentException if no match\n     */\n    public static boolean toBoolean(final Integer value, final Integer trueValue, final Integer falseValue) {\n        if (value == null) {\n            if (trueValue == null) {\n                return true;\n            }\n            if (falseValue == null) {\n                return false;\n            }\n        } else if (value.equals(trueValue)) {\n            return true;\n        } else if (value.equals(falseValue)) {\n            return false;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n\n    /**\n     * <p>Converts an int to a Boolean specifying the conversion values.</p>\n     *\n     * <p>NOTE: This returns null and will throw a NullPointerException if autoboxed to a boolean. </p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(0, 0, 2, 3) = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(2, 1, 2, 3) = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(3, 1, 2, 3) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for {@code true}\n     * @param falseValue  the value to match for {@code false}\n     * @param nullValue  the value to to match for {@code null}\n     * @return Boolean.TRUE, Boolean.FALSE, or {@code null}\n     * @throws IllegalArgumentException if no match\n     */\n    public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) {\n        if (value == trueValue) {\n            return Boolean.TRUE;\n        }\n        if (value == falseValue) {\n            return Boolean.FALSE;\n        }\n        if (value == nullValue) {\n            return null;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n    }\n\n    /**\n     * <p>Converts an Integer to a Boolean specifying the conversion values.</p>\n     *\n     * <p>NOTE: This returns null and will throw a NullPointerException if autoboxed to a boolean. </p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(Integer.valueOf(0), Integer.valueOf(0), Integer.valueOf(2), Integer.valueOf(3)) = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3)) = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(Integer.valueOf(3), Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3)) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for {@code true}, may be {@code null}\n     * @param falseValue  the value to match for {@code false}, may be {@code null}\n     * @param nullValue  the value to to match for {@code null}, may be {@code null}\n     * @return Boolean.TRUE, Boolean.FALSE, or {@code null}\n     * @throws IllegalArgumentException if no match\n     */\n    public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) {", "metadata": {"defects4j_task_id": "9d89b165f4e584fe3242a00389c70e41a9a5fc4a44ba3584237175223a3952e8", "task_id": "apache_commons-lang/127", "ground_truth": "\n        if (value == null) {\n            if (trueValue == null) {\n                return Boolean.TRUE;\n            }\n            if (falseValue == null) {\n                return Boolean.FALSE;\n            }\n            if (nullValue == null) {\n                return null;\n            }\n        } else if (value.equals(trueValue)) {\n            return Boolean.TRUE;\n        } else if (value.equals(falseValue)) {\n            return Boolean.FALSE;\n        } else if (value.equals(nullValue)) {\n            return null;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "BooleanUtils.java"], "context_start_lineno": 0, "function_name": "toBooleanObject", "left_context": "class BooleanUtils {\n\n    /**\n     * <p>Converts an Integer to a Boolean using the convention that {@code zero}\n     * is {@code false}.</p>\n     *\n     * <p>{@code null} will be converted to {@code null}.</p>\n     *\n     * <p>NOTE: This returns null and will throw a NullPointerException if autoboxed to a boolean. </p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(Integer.valueOf(0))    = Boolean.FALSE\n     *   BooleanUtils.toBoolean(Integer.valueOf(1))    = Boolean.TRUE\n     *   BooleanUtils.toBoolean(Integer.valueOf(null)) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n     *  {@code null} if {@code null} input\n     */\n    public static Boolean toBooleanObject(final Integer value) {\n        if (value == null) {\n            return null;\n        }\n        return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n    }\n\n    /**\n     * <p>Converts an int to a boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(0, 1, 0) = false\n     *   BooleanUtils.toBoolean(1, 1, 0) = true\n     *   BooleanUtils.toBoolean(2, 1, 2) = false\n     *   BooleanUtils.toBoolean(2, 2, 0) = true\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for {@code true}\n     * @param falseValue  the value to match for {@code false}\n     * @return {@code true} or {@code false}\n     * @throws IllegalArgumentException if no match\n     */\n    public static boolean toBoolean(final int value, final int trueValue, final int falseValue) {\n        if (value == trueValue) {\n            return true;\n        }\n        if (value == falseValue) {\n            return false;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n\n    /**\n     * <p>Converts an Integer to a boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(Integer.valueOf(0), Integer.valueOf(1), Integer.valueOf(0)) = false\n     *   BooleanUtils.toBoolean(Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(0)) = true\n     *   BooleanUtils.toBoolean(Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(2)) = false\n     *   BooleanUtils.toBoolean(Integer.valueOf(2), Integer.valueOf(2), Integer.valueOf(0)) = true\n     *   BooleanUtils.toBoolean(null, null, Integer.valueOf(0))                     = true\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for {@code true}, may be {@code null}\n     * @param falseValue  the value to match for {@code false}, may be {@code null}\n     * @return {@code true} or {@code false}\n     * @throws IllegalArgumentException if no match\n     */\n    public static boolean toBoolean(final Integer value, final Integer trueValue, final Integer falseValue) {\n        if (value == null) {\n            if (trueValue == null) {\n                return true;\n            }\n            if (falseValue == null) {\n                return false;\n            }\n        } else if (value.equals(trueValue)) {\n            return true;\n        } else if (value.equals(falseValue)) {\n            return false;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n\n    /**\n     * <p>Converts an int to a Boolean specifying the conversion values.</p>\n     *\n     * <p>NOTE: This returns null and will throw a NullPointerException if autoboxed to a boolean. </p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(0, 0, 2, 3) = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(2, 1, 2, 3) = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(3, 1, 2, 3) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for {@code true}\n     * @param falseValue  the value to match for {@code false}\n     * @param nullValue  the value to to match for {@code null}\n     * @return Boolean.TRUE, Boolean.FALSE, or {@code null}\n     * @throws IllegalArgumentException if no match\n     */\n    public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) {\n        if (value == trueValue) {\n            return Boolean.TRUE;\n        }\n        if (value == falseValue) {\n            return Boolean.FALSE;\n        }\n        if (value == nullValue) {\n            return null;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n    }\n\n    /**\n     * <p>Converts an Integer to a Boolean specifying the conversion values.</p>\n     *\n     * <p>NOTE: This returns null and will throw a NullPointerException if autoboxed to a boolean. </p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(Integer.valueOf(0), Integer.valueOf(0), Integer.valueOf(2), Integer.valueOf(3)) = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3)) = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(Integer.valueOf(3), Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3)) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for {@code true}, may be {@code null}\n     * @param falseValue  the value to match for {@code false}, may be {@code null}\n     * @param nullValue  the value to to match for {@code null}, may be {@code null}\n     * @return Boolean.TRUE, Boolean.FALSE, or {@code null}\n     * @throws IllegalArgumentException if no match\n     */\n    public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) {", "right_context": "}\n\n}", "class_name": "BooleanUtils", "return_type": "Boolean", "parameters": [{"type": "Integer", "name": "value"}, {"type": "Integer", "name": "trueValue"}, {"type": "Integer", "name": "falseValue"}, {"type": "Integer", "name": "nullValue"}]}}
{"prompt": "class BooleanUtils {\n\n    /**\n     * <p>Converts a boolean to a String returning {@code 'on'}\n     * or {@code 'off'}.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringOnOff(true)   = \"on\"\n     *   BooleanUtils.toStringOnOff(false)  = \"off\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return {@code 'on'}, {@code 'off'}, or {@code null}\n     */\n    public static String toStringOnOff(final boolean bool) {\n        return toString(bool, \"on\", \"off\");\n    }\n\n    /**\n     * <p>Converts a boolean to a String returning {@code 'yes'}\n     * or {@code 'no'}.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringYesNo(true)   = \"yes\"\n     *   BooleanUtils.toStringYesNo(false)  = \"no\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return {@code 'yes'}, {@code 'no'}, or {@code null}\n     */\n    public static String toStringYesNo(final boolean bool) {\n        return toString(bool, \"yes\", \"no\");\n    }\n\n    /**\n     * <p>Converts a boolean to a String returning one of the input Strings.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toString(true, \"true\", \"false\")   = \"true\"\n     *   BooleanUtils.toString(false, \"true\", \"false\")  = \"false\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @param trueString  the String to return if {@code true}, may be {@code null}\n     * @param falseString  the String to return if {@code false}, may be {@code null}\n     * @return one of the two input Strings\n     */\n    public static String toString(final boolean bool, final String trueString, final String falseString) {\n        return bool ? trueString : falseString;\n    }\n\n    // logical operations\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Performs an and on a set of booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.and(true, true)         = true\n     *   BooleanUtils.and(false, false)       = false\n     *   BooleanUtils.and(true, false)        = false\n     *   BooleanUtils.and(true, true, false)  = false\n     *   BooleanUtils.and(true, true, true)   = true\n     * </pre>\n     *\n     * @param array  an array of {@code boolean}s\n     * @return {@code true} if the and is successful.\n     * @throws IllegalArgumentException if {@code array} is {@code null}\n     * @throws IllegalArgumentException if {@code array} is empty.\n     * @since 3.0.1\n     */\n    public static boolean and(final boolean... array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final boolean element : array) {\n            if (!element) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Performs an and on an array of Booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.and(Boolean.TRUE, Boolean.TRUE)                 = Boolean.TRUE\n     *   BooleanUtils.and(Boolean.FALSE, Boolean.FALSE)               = Boolean.FALSE\n     *   BooleanUtils.and(Boolean.TRUE, Boolean.FALSE)                = Boolean.FALSE\n     *   BooleanUtils.and(Boolean.TRUE, Boolean.TRUE, Boolean.TRUE)   = Boolean.TRUE\n     *   BooleanUtils.and(Boolean.FALSE, Boolean.FALSE, Boolean.TRUE) = Boolean.FALSE\n     *   BooleanUtils.and(Boolean.TRUE, Boolean.FALSE, Boolean.TRUE)  = Boolean.FALSE\n     * </pre>\n     *\n     * @param array  an array of {@code Boolean}s\n     * @return {@code true} if the and is successful.\n     * @throws IllegalArgumentException if {@code array} is {@code null}\n     * @throws IllegalArgumentException if {@code array} is empty.\n     * @throws IllegalArgumentException if {@code array} contains a {@code null}\n     * @since 3.0.1\n     */\n    public static Boolean and(final Boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return and(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }\n\n    /**\n     * <p>Performs an or on a set of booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.or(true, true)          = true\n     *   BooleanUtils.or(false, false)        = false\n     *   BooleanUtils.or(true, false)         = true\n     *   BooleanUtils.or(true, true, false)   = true\n     *   BooleanUtils.or(true, true, true)    = true\n     *   BooleanUtils.or(false, false, false) = false\n     * </pre>\n     *\n     * @param array  an array of {@code boolean}s\n     * @return {@code true} if the or is successful.\n     * @throws IllegalArgumentException if {@code array} is {@code null}\n     * @throws IllegalArgumentException if {@code array} is empty.\n     * @since 3.0.1\n     */\n    public static boolean or(final boolean... array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final boolean element : array) {\n            if (element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * <p>Performs an or on an array of Booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.or(Boolean.TRUE, Boolean.TRUE)                  = Boolean.TRUE\n     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE)                = Boolean.FALSE\n     *   BooleanUtils.or(Boolean.TRUE, Boolean.FALSE)                 = Boolean.TRUE\n     *   BooleanUtils.or(Boolean.TRUE, Boolean.TRUE, Boolean.TRUE)    = Boolean.TRUE\n     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE, Boolean.TRUE)  = Boolean.TRUE\n     *   BooleanUtils.or(Boolean.TRUE, Boolean.FALSE, Boolean.TRUE)   = Boolean.TRUE\n     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE, Boolean.FALSE) = Boolean.FALSE\n     * </pre>\n     *\n     * @param array  an array of {@code Boolean}s\n     * @return {@code true} if the or is successful.\n     * @throws IllegalArgumentException if {@code array} is {@code null}\n     * @throws IllegalArgumentException if {@code array} is empty.\n     * @throws IllegalArgumentException if {@code array} contains a {@code null}\n     * @since 3.0.1\n     */\n    public static Boolean or(final Boolean... array) {", "metadata": {"defects4j_task_id": "293029e63e0f294281052c04c0277d973070d32819b2189b25f7d44941575671", "task_id": "apache_commons-lang/37", "ground_truth": "\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "BooleanUtils.java"], "context_start_lineno": 0, "function_name": "or", "left_context": "class BooleanUtils {\n\n    /**\n     * <p>Converts a boolean to a String returning {@code 'on'}\n     * or {@code 'off'}.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringOnOff(true)   = \"on\"\n     *   BooleanUtils.toStringOnOff(false)  = \"off\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return {@code 'on'}, {@code 'off'}, or {@code null}\n     */\n    public static String toStringOnOff(final boolean bool) {\n        return toString(bool, \"on\", \"off\");\n    }\n\n    /**\n     * <p>Converts a boolean to a String returning {@code 'yes'}\n     * or {@code 'no'}.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringYesNo(true)   = \"yes\"\n     *   BooleanUtils.toStringYesNo(false)  = \"no\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return {@code 'yes'}, {@code 'no'}, or {@code null}\n     */\n    public static String toStringYesNo(final boolean bool) {\n        return toString(bool, \"yes\", \"no\");\n    }\n\n    /**\n     * <p>Converts a boolean to a String returning one of the input Strings.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toString(true, \"true\", \"false\")   = \"true\"\n     *   BooleanUtils.toString(false, \"true\", \"false\")  = \"false\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @param trueString  the String to return if {@code true}, may be {@code null}\n     * @param falseString  the String to return if {@code false}, may be {@code null}\n     * @return one of the two input Strings\n     */\n    public static String toString(final boolean bool, final String trueString, final String falseString) {\n        return bool ? trueString : falseString;\n    }\n\n    // logical operations\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Performs an and on a set of booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.and(true, true)         = true\n     *   BooleanUtils.and(false, false)       = false\n     *   BooleanUtils.and(true, false)        = false\n     *   BooleanUtils.and(true, true, false)  = false\n     *   BooleanUtils.and(true, true, true)   = true\n     * </pre>\n     *\n     * @param array  an array of {@code boolean}s\n     * @return {@code true} if the and is successful.\n     * @throws IllegalArgumentException if {@code array} is {@code null}\n     * @throws IllegalArgumentException if {@code array} is empty.\n     * @since 3.0.1\n     */\n    public static boolean and(final boolean... array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final boolean element : array) {\n            if (!element) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Performs an and on an array of Booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.and(Boolean.TRUE, Boolean.TRUE)                 = Boolean.TRUE\n     *   BooleanUtils.and(Boolean.FALSE, Boolean.FALSE)               = Boolean.FALSE\n     *   BooleanUtils.and(Boolean.TRUE, Boolean.FALSE)                = Boolean.FALSE\n     *   BooleanUtils.and(Boolean.TRUE, Boolean.TRUE, Boolean.TRUE)   = Boolean.TRUE\n     *   BooleanUtils.and(Boolean.FALSE, Boolean.FALSE, Boolean.TRUE) = Boolean.FALSE\n     *   BooleanUtils.and(Boolean.TRUE, Boolean.FALSE, Boolean.TRUE)  = Boolean.FALSE\n     * </pre>\n     *\n     * @param array  an array of {@code Boolean}s\n     * @return {@code true} if the and is successful.\n     * @throws IllegalArgumentException if {@code array} is {@code null}\n     * @throws IllegalArgumentException if {@code array} is empty.\n     * @throws IllegalArgumentException if {@code array} contains a {@code null}\n     * @since 3.0.1\n     */\n    public static Boolean and(final Boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return and(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }\n\n    /**\n     * <p>Performs an or on a set of booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.or(true, true)          = true\n     *   BooleanUtils.or(false, false)        = false\n     *   BooleanUtils.or(true, false)         = true\n     *   BooleanUtils.or(true, true, false)   = true\n     *   BooleanUtils.or(true, true, true)    = true\n     *   BooleanUtils.or(false, false, false) = false\n     * </pre>\n     *\n     * @param array  an array of {@code boolean}s\n     * @return {@code true} if the or is successful.\n     * @throws IllegalArgumentException if {@code array} is {@code null}\n     * @throws IllegalArgumentException if {@code array} is empty.\n     * @since 3.0.1\n     */\n    public static boolean or(final boolean... array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final boolean element : array) {\n            if (element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * <p>Performs an or on an array of Booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.or(Boolean.TRUE, Boolean.TRUE)                  = Boolean.TRUE\n     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE)                = Boolean.FALSE\n     *   BooleanUtils.or(Boolean.TRUE, Boolean.FALSE)                 = Boolean.TRUE\n     *   BooleanUtils.or(Boolean.TRUE, Boolean.TRUE, Boolean.TRUE)    = Boolean.TRUE\n     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE, Boolean.TRUE)  = Boolean.TRUE\n     *   BooleanUtils.or(Boolean.TRUE, Boolean.FALSE, Boolean.TRUE)   = Boolean.TRUE\n     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE, Boolean.FALSE) = Boolean.FALSE\n     * </pre>\n     *\n     * @param array  an array of {@code Boolean}s\n     * @return {@code true} if the or is successful.\n     * @throws IllegalArgumentException if {@code array} is {@code null}\n     * @throws IllegalArgumentException if {@code array} is empty.\n     * @throws IllegalArgumentException if {@code array} contains a {@code null}\n     * @since 3.0.1\n     */\n    public static Boolean or(final Boolean... array) {", "right_context": "}\n\n}", "class_name": "BooleanUtils", "return_type": "Boolean", "parameters": [{"type": "Boolean", "name": "array"}]}}
{"prompt": "class ObjectUtils {\n\n    /**\n     * <p>Null safe comparison of Comparables.\n     * {@code null} is assumed to be less than a non-{@code null} value.</p>\n     *\n     * @param <T> type of the values processed by this method\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @return a negative value if c1 < c2, zero if c1 = c2\n     *  and a positive value if c1 > c2\n     */\n    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2) {\n        return compare(c1, c2, false);\n    }\n\n    /**\n     * <p>Null safe comparison of Comparables.</p>\n     *\n     * @param <T> type of the values processed by this method\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @param nullGreater if true {@code null} is considered greater\n     *  than a non-{@code null} value or if false {@code null} is\n     *  considered less than a Non-{@code null} value\n     * @return a negative value if c1 < c2, zero if c1 = c2\n     *  and a positive value if c1 > c2\n     * @see java.util.Comparator#compare(Object, Object)\n     */\n    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {\n        if (c1 == c2) {\n            return 0;\n        } else if (c1 == null) {\n            return nullGreater ? 1 : -1;\n        } else if (c2 == null) {\n            return nullGreater ? -1 : 1;\n        }\n        return c1.compareTo(c2);\n    }\n\n    /**\n     * Find the \"best guess\" middle value among comparables. If there is an even\n     * number of total values, the lower of the two middle values will be returned.\n     * @param <T> type of values processed by this method\n     * @param items to compare\n     * @return T at middle position\n     * @throws NullPointerException if items is {@code null}\n     * @throws IllegalArgumentException if items is empty or contains {@code null} values\n     * @since 3.0.1\n     */\n    public static <T extends Comparable<? super T>> T median(final T... items) {\n        Validate.notEmpty(items);\n        Validate.noNullElements(items);\n        final TreeSet<T> sort = new TreeSet<T>();\n        Collections.addAll(sort, items);\n        @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n        final\n        T result = (T) sort.toArray()[(sort.size() - 1) / 2];\n        return result;\n    }\n\n    /**\n     * Find the \"best guess\" middle value among comparables. If there is an even\n     * number of total values, the lower of the two middle values will be returned.\n     * @param <T> type of values processed by this method\n     * @param comparator to use for comparisons\n     * @param items to compare\n     * @return T at middle position\n     * @throws NullPointerException if items or comparator is {@code null}\n     * @throws IllegalArgumentException if items is empty or contains {@code null} values\n     * @since 3.0.1\n     */\n    public static <T> T median(final Comparator<T> comparator, final T... items) {\n        Validate.notEmpty(items, \"null/empty items\");\n        Validate.noNullElements(items);\n        Validate.notNull(comparator, \"null comparator\");\n        final TreeSet<T> sort = new TreeSet<T>(comparator);\n        Collections.addAll(sort, items);\n        @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n        final\n        T result = (T) sort.toArray()[(sort.size() - 1) / 2];\n        return result;\n    }\n\n    // Mode\n    //-----------------------------------------------------------------------\n    /**\n     * Find the most frequently occurring item.\n     * \n     * @param <T> type of values processed by this method\n     * @param items to check\n     * @return most populous T, {@code null} if non-unique or no items supplied\n     * @since 3.0.1\n     */\n    public static <T> T mode(final T... items) {\n        if (ArrayUtils.isNotEmpty(items)) {\n            final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length);\n            for (final T t : items) {\n                final MutableInt count = occurrences.get(t);\n                if (count == null) {\n                    occurrences.put(t, new MutableInt(1));\n                } else {\n                    count.increment();\n                }\n            }\n            T result = null;\n            int max = 0;\n            for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n                final int cmp = e.getValue().intValue();\n                if (cmp == max) {\n                    result = null;\n                } else if (cmp > max) {\n                    max = cmp;\n                    result = e.getKey();\n                }\n            }\n            return result;\n        }\n        return null;\n    }\n\n    // cloning\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Clone an object.</p>\n     *\n     * @param <T> the type of the object\n     * @param obj  the object to clone, null returns null\n     * @return the clone if the object implements {@link Cloneable} otherwise {@code null}\n     * @throws CloneFailedException if the object is cloneable and the clone operation fails\n     * @since 3.0\n     */\n    public static <T> T clone(final T obj) {", "metadata": {"defects4j_task_id": "84ced501caa036d8cedc651bc33d79461eaa2c1c0d4f814d7d29e51cc9257b10", "task_id": "apache_commons-lang/109", "ground_truth": "\n        if (obj instanceof Cloneable) {\n            final Object result;\n            if (obj.getClass().isArray()) {\n                final Class<?> componentType = obj.getClass().getComponentType();\n                if (!componentType.isPrimitive()) {\n                    result = ((Object[]) obj).clone();\n                } else {\n                    int length = Array.getLength(obj);\n                    result = Array.newInstance(componentType, length);\n                    while (length-- > 0) {\n                        Array.set(result, length, Array.get(obj, length));\n                    }\n                }\n            } else {\n                try {\n                    final Method clone = obj.getClass().getMethod(\"clone\");\n                    result = clone.invoke(obj);\n                } catch (final NoSuchMethodException e) {\n                    throw new CloneFailedException(\"Cloneable type \"\n                        + obj.getClass().getName()\n                        + \" has no clone method\", e);\n                } catch (final IllegalAccessException e) {\n                    throw new CloneFailedException(\"Cannot clone Cloneable type \"\n                        + obj.getClass().getName(), e);\n                } catch (final InvocationTargetException e) {\n                    throw new CloneFailedException(\"Exception cloning Cloneable type \"\n                        + obj.getClass().getName(), e.getCause());\n                }\n            }\n            @SuppressWarnings(\"unchecked\") // OK because input is of type T\n            final T checked = (T) result;\n            return checked;\n        }\n\n        return null;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "ObjectUtils.java"], "context_start_lineno": 0, "function_name": "clone", "left_context": "class ObjectUtils {\n\n    /**\n     * <p>Null safe comparison of Comparables.\n     * {@code null} is assumed to be less than a non-{@code null} value.</p>\n     *\n     * @param <T> type of the values processed by this method\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @return a negative value if c1 < c2, zero if c1 = c2\n     *  and a positive value if c1 > c2\n     */\n    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2) {\n        return compare(c1, c2, false);\n    }\n\n    /**\n     * <p>Null safe comparison of Comparables.</p>\n     *\n     * @param <T> type of the values processed by this method\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @param nullGreater if true {@code null} is considered greater\n     *  than a non-{@code null} value or if false {@code null} is\n     *  considered less than a Non-{@code null} value\n     * @return a negative value if c1 < c2, zero if c1 = c2\n     *  and a positive value if c1 > c2\n     * @see java.util.Comparator#compare(Object, Object)\n     */\n    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {\n        if (c1 == c2) {\n            return 0;\n        } else if (c1 == null) {\n            return nullGreater ? 1 : -1;\n        } else if (c2 == null) {\n            return nullGreater ? -1 : 1;\n        }\n        return c1.compareTo(c2);\n    }\n\n    /**\n     * Find the \"best guess\" middle value among comparables. If there is an even\n     * number of total values, the lower of the two middle values will be returned.\n     * @param <T> type of values processed by this method\n     * @param items to compare\n     * @return T at middle position\n     * @throws NullPointerException if items is {@code null}\n     * @throws IllegalArgumentException if items is empty or contains {@code null} values\n     * @since 3.0.1\n     */\n    public static <T extends Comparable<? super T>> T median(final T... items) {\n        Validate.notEmpty(items);\n        Validate.noNullElements(items);\n        final TreeSet<T> sort = new TreeSet<T>();\n        Collections.addAll(sort, items);\n        @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n        final\n        T result = (T) sort.toArray()[(sort.size() - 1) / 2];\n        return result;\n    }\n\n    /**\n     * Find the \"best guess\" middle value among comparables. If there is an even\n     * number of total values, the lower of the two middle values will be returned.\n     * @param <T> type of values processed by this method\n     * @param comparator to use for comparisons\n     * @param items to compare\n     * @return T at middle position\n     * @throws NullPointerException if items or comparator is {@code null}\n     * @throws IllegalArgumentException if items is empty or contains {@code null} values\n     * @since 3.0.1\n     */\n    public static <T> T median(final Comparator<T> comparator, final T... items) {\n        Validate.notEmpty(items, \"null/empty items\");\n        Validate.noNullElements(items);\n        Validate.notNull(comparator, \"null comparator\");\n        final TreeSet<T> sort = new TreeSet<T>(comparator);\n        Collections.addAll(sort, items);\n        @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n        final\n        T result = (T) sort.toArray()[(sort.size() - 1) / 2];\n        return result;\n    }\n\n    // Mode\n    //-----------------------------------------------------------------------\n    /**\n     * Find the most frequently occurring item.\n     * \n     * @param <T> type of values processed by this method\n     * @param items to check\n     * @return most populous T, {@code null} if non-unique or no items supplied\n     * @since 3.0.1\n     */\n    public static <T> T mode(final T... items) {\n        if (ArrayUtils.isNotEmpty(items)) {\n            final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length);\n            for (final T t : items) {\n                final MutableInt count = occurrences.get(t);\n                if (count == null) {\n                    occurrences.put(t, new MutableInt(1));\n                } else {\n                    count.increment();\n                }\n            }\n            T result = null;\n            int max = 0;\n            for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n                final int cmp = e.getValue().intValue();\n                if (cmp == max) {\n                    result = null;\n                } else if (cmp > max) {\n                    max = cmp;\n                    result = e.getKey();\n                }\n            }\n            return result;\n        }\n        return null;\n    }\n\n    // cloning\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Clone an object.</p>\n     *\n     * @param <T> the type of the object\n     * @param obj  the object to clone, null returns null\n     * @return the clone if the object implements {@link Cloneable} otherwise {@code null}\n     * @throws CloneFailedException if the object is cloneable and the clone operation fails\n     * @since 3.0\n     */\n    public static <T> T clone(final T obj) {", "right_context": "}\n\n}", "class_name": "ObjectUtils", "return_type": "T", "parameters": [{"type": "T", "name": "obj"}]}}
{"prompt": "class Range<T> implements Serializable {\n\n    /**\n     * <p>Gets the comparator being used to determine if objects are within the range.</p>\n     * \n     * <p>Natural ordering uses an internal comparator implementation, thus this\n     * method never returns null. See {@link #isNaturalOrdering()}.</p>\n     *\n     * @return the comparator being used, not null\n     */\n    public Comparator<T> getComparator() {\n        return comparator;\n    }\n\n    /**\n     * <p>Whether or not the Range is using the natural ordering of the elements.</p>\n     * \n     * <p>Natural ordering uses an internal comparator implementation, thus this\n     * method is the only way to check if a null comparator was specified.</p>\n     *\n     * @return true if using natural ordering\n     */\n    public boolean isNaturalOrdering() {\n        return comparator == ComparableComparator.INSTANCE;\n    }\n\n    // Element tests\n    //--------------------------------------------------------------------\n\n    /**\n     * <p>Checks whether the specified element occurs within this range.</p>\n     *\n     * @param element  the element to check for, null returns false\n     * @return true if the specified element occurs within this range\n     */\n    public boolean contains(final T element) {\n        if (element == null) {\n            return false;\n        }\n        return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;\n    }\n\n    /**\n     * <p>Checks whether this range is after the specified element.</p>\n     *\n     * @param element  the element to check for, null returns false\n     * @return true if this range is entirely after the specified element\n     */\n    public boolean isAfter(final T element) {\n        if (element == null) {\n            return false;\n        }\n        return comparator.compare(element, minimum) < 0;\n    }\n\n    /**\n     * <p>Checks whether this range starts with the specified element.</p>\n     *\n     * @param element  the element to check for, null returns false\n     * @return true if the specified element occurs within this range\n     */\n    public boolean isStartedBy(final T element) {\n        if (element == null) {\n            return false;\n        }\n        return comparator.compare(element, minimum) == 0;\n    }\n\n    /**\n     * <p>Checks whether this range starts with the specified element.</p>\n     *\n     * @param element  the element to check for, null returns false\n     * @return true if the specified element occurs within this range\n     */\n    public boolean isEndedBy(final T element) {\n        if (element == null) {\n            return false;\n        }\n        return comparator.compare(element, maximum) == 0;\n    }\n\n    /**\n     * <p>Checks whether this range is before the specified element.</p>\n     *\n     * @param element  the element to check for, null returns false\n     * @return true if this range is entirely before the specified element\n     */\n    public boolean isBefore(final T element) {\n        if (element == null) {\n            return false;\n        }\n        return comparator.compare(element, maximum) > 0;\n    }\n\n    /**\n     * <p>Checks where the specified element occurs relative to this range.</p>\n     * \n     * <p>The API is reminiscent of the Comparable interface returning {@code -1} if\n     * the element is before the range, {@code 0} if contained within the range and\n     * {@code 1} if the element is after the range. </p>\n     *\n     * @param element  the element to check for, not null\n     * @return -1, 0 or +1 depending on the element's location relative to the range\n     */\n    public int elementCompareTo(final T element) {\n        if (element == null) {\n            // Comparable API says throw NPE on null\n            throw new NullPointerException(\"Element is null\");\n        }\n        if (isAfter(element)) {\n            return -1;\n        } else if (isBefore(element)) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    // Range tests\n    //--------------------------------------------------------------------\n\n    /**\n     * <p>Checks whether this range contains all the elements of the specified range.</p>\n     *\n     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n     *\n     * @param otherRange  the range to check, null returns false\n     * @return true if this range contains the specified range\n     * @throws RuntimeException if ranges cannot be compared\n     */\n    public boolean containsRange(final Range<T> otherRange) {\n        if (otherRange == null) {\n            return false;\n        }\n        return contains(otherRange.minimum)\n            && contains(otherRange.maximum);\n    }\n\n    /**\n     * <p>Checks whether this range is completely after the specified range.</p>\n     *\n     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n     *\n     * @param otherRange  the range to check, null returns false\n     * @return true if this range is completely after the specified range\n     * @throws RuntimeException if ranges cannot be compared\n     */\n    public boolean isAfterRange(final Range<T> otherRange) {\n        if (otherRange == null) {\n            return false;\n        }\n        return isAfter(otherRange.maximum);\n    }\n\n    /**\n     * <p>Checks whether this range is overlapped by the specified range.</p>\n     * \n     * <p>Two ranges overlap if there is at least one element in common.</p>\n     *\n     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n     *\n     * @param otherRange  the range to test, null returns false\n     * @return true if the specified range overlaps with this\n     *  range; otherwise, {@code false}\n     * @throws RuntimeException if ranges cannot be compared\n     */\n    public boolean isOverlappedBy(final Range<T> otherRange) {\n        if (otherRange == null) {\n            return false;\n        }\n        return otherRange.contains(minimum)\n            || otherRange.contains(maximum)\n            || contains(otherRange.minimum);\n    }\n\n    /**\n     * <p>Checks whether this range is completely before the specified range.</p>\n     *\n     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n     *\n     * @param otherRange  the range to check, null returns false\n     * @return true if this range is completely before the specified range\n     * @throws RuntimeException if ranges cannot be compared\n     */\n    public boolean isBeforeRange(final Range<T> otherRange) {\n        if (otherRange == null) {\n            return false;\n        }\n        return isBefore(otherRange.minimum);\n    }\n\n    /**\n     * Calculate the intersection of {@code this} and an overlapping Range.\n     * @param other overlapping Range\n     * @return range representing the intersection of {@code this} and {@code other} ({@code this} if equal)\n     * @throws IllegalArgumentException if {@code other} does not overlap {@code this}\n     * @since 3.0.1\n     */\n    public Range<T> intersectionWith(final Range<T> other) {", "metadata": {"defects4j_task_id": "ea46c9556d247940bb6d672a7942bb1b4dfdc06047a2b02c95fcbdbb8a8d5fd8", "task_id": "apache_commons-lang/192", "ground_truth": "\n        if (!this.isOverlappedBy(other)) {\n            throw new IllegalArgumentException(String.format(\n                \"Cannot calculate intersection with non-overlapping range %s\", other));\n        }\n        if (this.equals(other)) {\n            return this;\n        }\n        final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum;\n        final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum;\n        return between(min, max, getComparator());\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "Range.java"], "context_start_lineno": 0, "function_name": "intersectionWith", "left_context": "class Range<T> implements Serializable {\n\n    /**\n     * <p>Gets the comparator being used to determine if objects are within the range.</p>\n     * \n     * <p>Natural ordering uses an internal comparator implementation, thus this\n     * method never returns null. See {@link #isNaturalOrdering()}.</p>\n     *\n     * @return the comparator being used, not null\n     */\n    public Comparator<T> getComparator() {\n        return comparator;\n    }\n\n    /**\n     * <p>Whether or not the Range is using the natural ordering of the elements.</p>\n     * \n     * <p>Natural ordering uses an internal comparator implementation, thus this\n     * method is the only way to check if a null comparator was specified.</p>\n     *\n     * @return true if using natural ordering\n     */\n    public boolean isNaturalOrdering() {\n        return comparator == ComparableComparator.INSTANCE;\n    }\n\n    // Element tests\n    //--------------------------------------------------------------------\n\n    /**\n     * <p>Checks whether the specified element occurs within this range.</p>\n     *\n     * @param element  the element to check for, null returns false\n     * @return true if the specified element occurs within this range\n     */\n    public boolean contains(final T element) {\n        if (element == null) {\n            return false;\n        }\n        return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;\n    }\n\n    /**\n     * <p>Checks whether this range is after the specified element.</p>\n     *\n     * @param element  the element to check for, null returns false\n     * @return true if this range is entirely after the specified element\n     */\n    public boolean isAfter(final T element) {\n        if (element == null) {\n            return false;\n        }\n        return comparator.compare(element, minimum) < 0;\n    }\n\n    /**\n     * <p>Checks whether this range starts with the specified element.</p>\n     *\n     * @param element  the element to check for, null returns false\n     * @return true if the specified element occurs within this range\n     */\n    public boolean isStartedBy(final T element) {\n        if (element == null) {\n            return false;\n        }\n        return comparator.compare(element, minimum) == 0;\n    }\n\n    /**\n     * <p>Checks whether this range starts with the specified element.</p>\n     *\n     * @param element  the element to check for, null returns false\n     * @return true if the specified element occurs within this range\n     */\n    public boolean isEndedBy(final T element) {\n        if (element == null) {\n            return false;\n        }\n        return comparator.compare(element, maximum) == 0;\n    }\n\n    /**\n     * <p>Checks whether this range is before the specified element.</p>\n     *\n     * @param element  the element to check for, null returns false\n     * @return true if this range is entirely before the specified element\n     */\n    public boolean isBefore(final T element) {\n        if (element == null) {\n            return false;\n        }\n        return comparator.compare(element, maximum) > 0;\n    }\n\n    /**\n     * <p>Checks where the specified element occurs relative to this range.</p>\n     * \n     * <p>The API is reminiscent of the Comparable interface returning {@code -1} if\n     * the element is before the range, {@code 0} if contained within the range and\n     * {@code 1} if the element is after the range. </p>\n     *\n     * @param element  the element to check for, not null\n     * @return -1, 0 or +1 depending on the element's location relative to the range\n     */\n    public int elementCompareTo(final T element) {\n        if (element == null) {\n            // Comparable API says throw NPE on null\n            throw new NullPointerException(\"Element is null\");\n        }\n        if (isAfter(element)) {\n            return -1;\n        } else if (isBefore(element)) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    // Range tests\n    //--------------------------------------------------------------------\n\n    /**\n     * <p>Checks whether this range contains all the elements of the specified range.</p>\n     *\n     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n     *\n     * @param otherRange  the range to check, null returns false\n     * @return true if this range contains the specified range\n     * @throws RuntimeException if ranges cannot be compared\n     */\n    public boolean containsRange(final Range<T> otherRange) {\n        if (otherRange == null) {\n            return false;\n        }\n        return contains(otherRange.minimum)\n            && contains(otherRange.maximum);\n    }\n\n    /**\n     * <p>Checks whether this range is completely after the specified range.</p>\n     *\n     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n     *\n     * @param otherRange  the range to check, null returns false\n     * @return true if this range is completely after the specified range\n     * @throws RuntimeException if ranges cannot be compared\n     */\n    public boolean isAfterRange(final Range<T> otherRange) {\n        if (otherRange == null) {\n            return false;\n        }\n        return isAfter(otherRange.maximum);\n    }\n\n    /**\n     * <p>Checks whether this range is overlapped by the specified range.</p>\n     * \n     * <p>Two ranges overlap if there is at least one element in common.</p>\n     *\n     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n     *\n     * @param otherRange  the range to test, null returns false\n     * @return true if the specified range overlaps with this\n     *  range; otherwise, {@code false}\n     * @throws RuntimeException if ranges cannot be compared\n     */\n    public boolean isOverlappedBy(final Range<T> otherRange) {\n        if (otherRange == null) {\n            return false;\n        }\n        return otherRange.contains(minimum)\n            || otherRange.contains(maximum)\n            || contains(otherRange.minimum);\n    }\n\n    /**\n     * <p>Checks whether this range is completely before the specified range.</p>\n     *\n     * <p>This method may fail if the ranges have two different comparators or element types.</p>\n     *\n     * @param otherRange  the range to check, null returns false\n     * @return true if this range is completely before the specified range\n     * @throws RuntimeException if ranges cannot be compared\n     */\n    public boolean isBeforeRange(final Range<T> otherRange) {\n        if (otherRange == null) {\n            return false;\n        }\n        return isBefore(otherRange.minimum);\n    }\n\n    /**\n     * Calculate the intersection of {@code this} and an overlapping Range.\n     * @param other overlapping Range\n     * @return range representing the intersection of {@code this} and {@code other} ({@code this} if equal)\n     * @throws IllegalArgumentException if {@code other} does not overlap {@code this}\n     * @since 3.0.1\n     */\n    public Range<T> intersectionWith(final Range<T> other) {", "right_context": "}\n    }\n\n}", "class_name": "Range", "return_type": "Range<T>", "parameters": [{"type": "Range<T>", "name": "other"}]}}
{"prompt": "class FieldUtils {\n\n    /**\n     * Gets an accessible <code>Field</code> by name respecting scope. Superclasses/interfaces will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getField(final Class<?> cls, final String fieldName) {\n        final Field field = getField(cls, fieldName, false);\n        MemberUtils.setAccessibleWorkaround(field);\n        return field;\n    }\n\n    /**\n     * Gets an accessible <code>Field</code> by name breaking scope if requested. Superclasses/interfaces will be\n     * considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n     *            will only match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n        if (cls == null) {\n            throw new IllegalArgumentException(\"The class must not be null\");\n        }\n        if (fieldName == null) {\n            throw new IllegalArgumentException(\"The field name must not be null\");\n        }\n        // Sun Java 1.3 has a bugged implementation of getField hence we write the\n        // code ourselves\n\n        // getField() will return the Field object with the declaring class\n        // set correctly to the class that declares the field. Thus requesting the\n        // field on a subclass will return the field from the superclass.\n        //\n        // priority order for lookup:\n        // searchclass private/protected/package/public\n        // superclass protected/package/public\n        // private/different package blocks access to further superclasses\n        // implementedinterface public\n\n        // check up the superclass hierarchy\n        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n            try {\n                final Field field = acls.getDeclaredField(fieldName);\n                // getDeclaredField checks for non-public scopes as well\n                // and it returns accurate results\n                if (!Modifier.isPublic(field.getModifiers())) {\n                    if (forceAccess) {\n                        field.setAccessible(true);\n                    } else {\n                        continue;\n                    }\n                }\n                return field;\n            } catch (final NoSuchFieldException ex) { // NOPMD\n                // ignore\n            }\n        }\n        // check the public interface case. This must be manually searched for\n        // incase there is a public supersuperclass field hidden by a private/package\n        // superclass field.\n        Field match = null;\n        for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {\n            try {\n                final Field test = ((Class<?>) class1).getField(fieldName);\n                if (match != null) {\n                    throw new IllegalArgumentException(\"Reference to field \" + fieldName + \" is ambiguous relative to \" + cls +\n                            \"; a matching field exists on two or more implemented interfaces.\");\n                }\n                match = test;\n            } catch (final NoSuchFieldException ex) { // NOPMD\n                // ignore\n            }\n        }\n        return match;\n    }\n\n    /**\n     * Gets an accessible <code>Field</code> by name respecting scope. Only the specified class will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getDeclaredField(final Class<?> cls, final String fieldName) {\n        return getDeclaredField(cls, fieldName, false);\n    }\n\n    /**\n     * Gets an accessible <code>Field</code> by name breaking scope if requested. Only the specified class will be\n     * considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. False will only\n     *            match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n        if (cls == null) {\n            throw new IllegalArgumentException(\"The class must not be null\");\n        }\n        if (fieldName == null) {\n            throw new IllegalArgumentException(\"The field name must not be null\");\n        }\n        try {\n            // only consider the specified class by using getDeclaredField()\n            final Field field = cls.getDeclaredField(fieldName);\n            if (!MemberUtils.isAccessible(field)) {\n                if (forceAccess) {\n                    field.setAccessible(true);\n                } else {\n                    return null;\n                }\n            }\n            return field;\n        } catch (final NoSuchFieldException e) { // NOPMD\n            // ignore\n        }\n        return null;\n    }\n\n    /**\n     * Gets all fields of the given class and its parents (if any).\n     * \n     * @param cls\n     *            the class to query\n     * @return an array of Fields (maybe an empty array).\n     * @since 3.2\n     */\n    public static Field[] getAllFields(Class<?> cls) {\n        final List<Field> allFieldsList = getAllFieldsList(cls);\n        return allFieldsList.toArray(new Field[allFieldsList.size()]);\n    }\n\n    /**\n     * Gets all fields of the given class and its parents (if any).\n     * \n     * @param cls\n     *            the class to query\n     * @return an array of Fields (maybe an empty array).\n     * @since 3.2\n     */\n    public static List<Field> getAllFieldsList(Class<?> cls) {", "metadata": {"defects4j_task_id": "a000e062a1654626502aacd57ea97025219fc6e9e6fe4a55f96d63c2ff30af92", "task_id": "apache_commons-lang/131", "ground_truth": "\n        if (cls == null) {\n            throw new IllegalArgumentException(\"The class must not be null\");\n        }\n        List<Field> allFields = new ArrayList<Field>();\n        Class<?> currentClass = cls;\n        while (currentClass != null) {\n            final Field[] declaredFields = currentClass.getDeclaredFields();\n            for (Field field : declaredFields) {\n                allFields.add(field);\n            }\n            currentClass = currentClass.getSuperclass();\n        }\n        return allFields;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "reflect", "FieldUtils.java"], "context_start_lineno": 0, "function_name": "getAllFieldsList", "left_context": "class FieldUtils {\n\n    /**\n     * Gets an accessible <code>Field</code> by name respecting scope. Superclasses/interfaces will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getField(final Class<?> cls, final String fieldName) {\n        final Field field = getField(cls, fieldName, false);\n        MemberUtils.setAccessibleWorkaround(field);\n        return field;\n    }\n\n    /**\n     * Gets an accessible <code>Field</code> by name breaking scope if requested. Superclasses/interfaces will be\n     * considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n     *            will only match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n        if (cls == null) {\n            throw new IllegalArgumentException(\"The class must not be null\");\n        }\n        if (fieldName == null) {\n            throw new IllegalArgumentException(\"The field name must not be null\");\n        }\n        // Sun Java 1.3 has a bugged implementation of getField hence we write the\n        // code ourselves\n\n        // getField() will return the Field object with the declaring class\n        // set correctly to the class that declares the field. Thus requesting the\n        // field on a subclass will return the field from the superclass.\n        //\n        // priority order for lookup:\n        // searchclass private/protected/package/public\n        // superclass protected/package/public\n        // private/different package blocks access to further superclasses\n        // implementedinterface public\n\n        // check up the superclass hierarchy\n        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n            try {\n                final Field field = acls.getDeclaredField(fieldName);\n                // getDeclaredField checks for non-public scopes as well\n                // and it returns accurate results\n                if (!Modifier.isPublic(field.getModifiers())) {\n                    if (forceAccess) {\n                        field.setAccessible(true);\n                    } else {\n                        continue;\n                    }\n                }\n                return field;\n            } catch (final NoSuchFieldException ex) { // NOPMD\n                // ignore\n            }\n        }\n        // check the public interface case. This must be manually searched for\n        // incase there is a public supersuperclass field hidden by a private/package\n        // superclass field.\n        Field match = null;\n        for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {\n            try {\n                final Field test = ((Class<?>) class1).getField(fieldName);\n                if (match != null) {\n                    throw new IllegalArgumentException(\"Reference to field \" + fieldName + \" is ambiguous relative to \" + cls +\n                            \"; a matching field exists on two or more implemented interfaces.\");\n                }\n                match = test;\n            } catch (final NoSuchFieldException ex) { // NOPMD\n                // ignore\n            }\n        }\n        return match;\n    }\n\n    /**\n     * Gets an accessible <code>Field</code> by name respecting scope. Only the specified class will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getDeclaredField(final Class<?> cls, final String fieldName) {\n        return getDeclaredField(cls, fieldName, false);\n    }\n\n    /**\n     * Gets an accessible <code>Field</code> by name breaking scope if requested. Only the specified class will be\n     * considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. False will only\n     *            match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n        if (cls == null) {\n            throw new IllegalArgumentException(\"The class must not be null\");\n        }\n        if (fieldName == null) {\n            throw new IllegalArgumentException(\"The field name must not be null\");\n        }\n        try {\n            // only consider the specified class by using getDeclaredField()\n            final Field field = cls.getDeclaredField(fieldName);\n            if (!MemberUtils.isAccessible(field)) {\n                if (forceAccess) {\n                    field.setAccessible(true);\n                } else {\n                    return null;\n                }\n            }\n            return field;\n        } catch (final NoSuchFieldException e) { // NOPMD\n            // ignore\n        }\n        return null;\n    }\n\n    /**\n     * Gets all fields of the given class and its parents (if any).\n     * \n     * @param cls\n     *            the class to query\n     * @return an array of Fields (maybe an empty array).\n     * @since 3.2\n     */\n    public static Field[] getAllFields(Class<?> cls) {\n        final List<Field> allFieldsList = getAllFieldsList(cls);\n        return allFieldsList.toArray(new Field[allFieldsList.size()]);\n    }\n\n    /**\n     * Gets all fields of the given class and its parents (if any).\n     * \n     * @param cls\n     *            the class to query\n     * @return an array of Fields (maybe an empty array).\n     * @since 3.2\n     */\n    public static List<Field> getAllFieldsList(Class<?> cls) {", "right_context": "}\n}", "class_name": "FieldUtils", "return_type": "List<Field>", "parameters": [{"type": "Class<?>", "name": "cls"}]}}
{"prompt": "class FieldUtils {\n\n    /**\n     * Gets an accessible <code>Field</code> by name breaking scope if requested. Superclasses/interfaces will be\n     * considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n     *            will only match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n        if (cls == null) {\n            throw new IllegalArgumentException(\"The class must not be null\");\n        }\n        if (fieldName == null) {\n            throw new IllegalArgumentException(\"The field name must not be null\");\n        }\n        // Sun Java 1.3 has a bugged implementation of getField hence we write the\n        // code ourselves\n\n        // getField() will return the Field object with the declaring class\n        // set correctly to the class that declares the field. Thus requesting the\n        // field on a subclass will return the field from the superclass.\n        //\n        // priority order for lookup:\n        // searchclass private/protected/package/public\n        // superclass protected/package/public\n        // private/different package blocks access to further superclasses\n        // implementedinterface public\n\n        // check up the superclass hierarchy\n        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n            try {\n                final Field field = acls.getDeclaredField(fieldName);\n                // getDeclaredField checks for non-public scopes as well\n                // and it returns accurate results\n                if (!Modifier.isPublic(field.getModifiers())) {\n                    if (forceAccess) {\n                        field.setAccessible(true);\n                    } else {\n                        continue;\n                    }\n                }\n                return field;\n            } catch (final NoSuchFieldException ex) { // NOPMD\n                // ignore\n            }\n        }\n        // check the public interface case. This must be manually searched for\n        // incase there is a public supersuperclass field hidden by a private/package\n        // superclass field.\n        Field match = null;\n        for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {\n            try {\n                final Field test = ((Class<?>) class1).getField(fieldName);\n                if (match != null) {\n                    throw new IllegalArgumentException(\"Reference to field \" + fieldName + \" is ambiguous relative to \" + cls +\n                            \"; a matching field exists on two or more implemented interfaces.\");\n                }\n                match = test;\n            } catch (final NoSuchFieldException ex) { // NOPMD\n                // ignore\n            }\n        }\n        return match;\n    }\n\n    /**\n     * Gets an accessible <code>Field</code> by name respecting scope. Only the specified class will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getDeclaredField(final Class<?> cls, final String fieldName) {\n        return getDeclaredField(cls, fieldName, false);\n    }\n\n    /**\n     * Gets an accessible <code>Field</code> by name breaking scope if requested. Only the specified class will be\n     * considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. False will only\n     *            match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n        if (cls == null) {\n            throw new IllegalArgumentException(\"The class must not be null\");\n        }\n        if (fieldName == null) {\n            throw new IllegalArgumentException(\"The field name must not be null\");\n        }\n        try {\n            // only consider the specified class by using getDeclaredField()\n            final Field field = cls.getDeclaredField(fieldName);\n            if (!MemberUtils.isAccessible(field)) {\n                if (forceAccess) {\n                    field.setAccessible(true);\n                } else {\n                    return null;\n                }\n            }\n            return field;\n        } catch (final NoSuchFieldException e) { // NOPMD\n            // ignore\n        }\n        return null;\n    }\n\n    /**\n     * Gets all fields of the given class and its parents (if any).\n     * \n     * @param cls\n     *            the class to query\n     * @return an array of Fields (maybe an empty array).\n     * @since 3.2\n     */\n    public static Field[] getAllFields(Class<?> cls) {\n        final List<Field> allFieldsList = getAllFieldsList(cls);\n        return allFieldsList.toArray(new Field[allFieldsList.size()]);\n    }\n\n    /**\n     * Gets all fields of the given class and its parents (if any).\n     * \n     * @param cls\n     *            the class to query\n     * @return an array of Fields (maybe an empty array).\n     * @since 3.2\n     */\n    public static List<Field> getAllFieldsList(Class<?> cls) {\n        if (cls == null) {\n            throw new IllegalArgumentException(\"The class must not be null\");\n        }\n        List<Field> allFields = new ArrayList<Field>();\n        Class<?> currentClass = cls;\n        while (currentClass != null) {\n            final Field[] declaredFields = currentClass.getDeclaredFields();\n            for (Field field : declaredFields) {\n                allFields.add(field);\n            }\n            currentClass = currentClass.getSuperclass();\n        }\n        return allFields;\n    }\n\n    /**\n     * Reads an accessible static Field.\n     * \n     * @param field\n     *            to read\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null or not static\n     * @throws IllegalAccessException\n     *             if the field is not accessible\n     */\n    public static Object readStaticField(final Field field) throws IllegalAccessException {\n        return readStaticField(field, false);\n    }\n\n    /**\n     * Reads a static Field.\n     * \n     * @param field\n     *            to read\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method.\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null or not static\n     * @throws IllegalAccessException\n     *             if the field is not made accessible\n     */\n    public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException {", "metadata": {"defects4j_task_id": "0958559065a1bfefe316223fe66a5ea93965fb8ec8cf7367b51b625b893c8b6f", "task_id": "apache_commons-lang/9", "ground_truth": "\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!Modifier.isStatic(field.getModifiers())) {\n            throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n        }\n        return readField(field, (Object) null, forceAccess);\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "reflect", "FieldUtils.java"], "context_start_lineno": 0, "function_name": "readStaticField", "left_context": "class FieldUtils {\n\n    /**\n     * Gets an accessible <code>Field</code> by name breaking scope if requested. Superclasses/interfaces will be\n     * considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n     *            will only match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n        if (cls == null) {\n            throw new IllegalArgumentException(\"The class must not be null\");\n        }\n        if (fieldName == null) {\n            throw new IllegalArgumentException(\"The field name must not be null\");\n        }\n        // Sun Java 1.3 has a bugged implementation of getField hence we write the\n        // code ourselves\n\n        // getField() will return the Field object with the declaring class\n        // set correctly to the class that declares the field. Thus requesting the\n        // field on a subclass will return the field from the superclass.\n        //\n        // priority order for lookup:\n        // searchclass private/protected/package/public\n        // superclass protected/package/public\n        // private/different package blocks access to further superclasses\n        // implementedinterface public\n\n        // check up the superclass hierarchy\n        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n            try {\n                final Field field = acls.getDeclaredField(fieldName);\n                // getDeclaredField checks for non-public scopes as well\n                // and it returns accurate results\n                if (!Modifier.isPublic(field.getModifiers())) {\n                    if (forceAccess) {\n                        field.setAccessible(true);\n                    } else {\n                        continue;\n                    }\n                }\n                return field;\n            } catch (final NoSuchFieldException ex) { // NOPMD\n                // ignore\n            }\n        }\n        // check the public interface case. This must be manually searched for\n        // incase there is a public supersuperclass field hidden by a private/package\n        // superclass field.\n        Field match = null;\n        for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {\n            try {\n                final Field test = ((Class<?>) class1).getField(fieldName);\n                if (match != null) {\n                    throw new IllegalArgumentException(\"Reference to field \" + fieldName + \" is ambiguous relative to \" + cls +\n                            \"; a matching field exists on two or more implemented interfaces.\");\n                }\n                match = test;\n            } catch (final NoSuchFieldException ex) { // NOPMD\n                // ignore\n            }\n        }\n        return match;\n    }\n\n    /**\n     * Gets an accessible <code>Field</code> by name respecting scope. Only the specified class will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getDeclaredField(final Class<?> cls, final String fieldName) {\n        return getDeclaredField(cls, fieldName, false);\n    }\n\n    /**\n     * Gets an accessible <code>Field</code> by name breaking scope if requested. Only the specified class will be\n     * considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. False will only\n     *            match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     */\n    public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n        if (cls == null) {\n            throw new IllegalArgumentException(\"The class must not be null\");\n        }\n        if (fieldName == null) {\n            throw new IllegalArgumentException(\"The field name must not be null\");\n        }\n        try {\n            // only consider the specified class by using getDeclaredField()\n            final Field field = cls.getDeclaredField(fieldName);\n            if (!MemberUtils.isAccessible(field)) {\n                if (forceAccess) {\n                    field.setAccessible(true);\n                } else {\n                    return null;\n                }\n            }\n            return field;\n        } catch (final NoSuchFieldException e) { // NOPMD\n            // ignore\n        }\n        return null;\n    }\n\n    /**\n     * Gets all fields of the given class and its parents (if any).\n     * \n     * @param cls\n     *            the class to query\n     * @return an array of Fields (maybe an empty array).\n     * @since 3.2\n     */\n    public static Field[] getAllFields(Class<?> cls) {\n        final List<Field> allFieldsList = getAllFieldsList(cls);\n        return allFieldsList.toArray(new Field[allFieldsList.size()]);\n    }\n\n    /**\n     * Gets all fields of the given class and its parents (if any).\n     * \n     * @param cls\n     *            the class to query\n     * @return an array of Fields (maybe an empty array).\n     * @since 3.2\n     */\n    public static List<Field> getAllFieldsList(Class<?> cls) {\n        if (cls == null) {\n            throw new IllegalArgumentException(\"The class must not be null\");\n        }\n        List<Field> allFields = new ArrayList<Field>();\n        Class<?> currentClass = cls;\n        while (currentClass != null) {\n            final Field[] declaredFields = currentClass.getDeclaredFields();\n            for (Field field : declaredFields) {\n                allFields.add(field);\n            }\n            currentClass = currentClass.getSuperclass();\n        }\n        return allFields;\n    }\n\n    /**\n     * Reads an accessible static Field.\n     * \n     * @param field\n     *            to read\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null or not static\n     * @throws IllegalAccessException\n     *             if the field is not accessible\n     */\n    public static Object readStaticField(final Field field) throws IllegalAccessException {\n        return readStaticField(field, false);\n    }\n\n    /**\n     * Reads a static Field.\n     * \n     * @param field\n     *            to read\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method.\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null or not static\n     * @throws IllegalAccessException\n     *             if the field is not made accessible\n     */\n    public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException {", "right_context": "}\n}", "class_name": "FieldUtils", "return_type": "Object", "parameters": [{"type": "Field", "name": "field"}, {"type": "boolean", "name": "forceAccess"}]}}
{"prompt": "class FieldUtils {\n\n    /**\n     * Gets a static Field value by name. The field must be public. Only the specified class will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the value of the field\n     * @throws IllegalArgumentException\n     *             if the class is null, the field name is null or if the field could not be found\n     * @throws IllegalAccessException\n     *             if the field is not accessible\n     */\n    public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException {\n        return readDeclaredStaticField(cls, fieldName, false);\n    }\n\n    /**\n     * Gets a static Field value by name. Only the specified class will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n     *            will only match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class is null, the field name is null or if the field could not be found\n     * @throws IllegalAccessException\n     *             if the field is not made accessible\n     */\n    public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n        if (field == null) {\n            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n        }\n        // already forced access above, don't repeat it here:\n        return readStaticField(field, false);\n    }\n\n    /**\n     * Reads an accessible Field.\n     * \n     * @param field\n     *            the field to use\n     * @param target\n     *            the object to call on, may be null for static fields\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null\n     * @throws IllegalAccessException\n     *             if the field is not accessible\n     */\n    public static Object readField(final Field field, final Object target) throws IllegalAccessException {\n        return readField(field, target, false);\n    }\n\n    /**\n     * Reads a Field.\n     * \n     * @param field\n     *            the field to use\n     * @param target\n     *            the object to call on, may be null for static fields\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method.\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null\n     * @throws IllegalAccessException\n     *             if the field is not made accessible\n     */\n    public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException {\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (forceAccess && !field.isAccessible()) {\n            field.setAccessible(true);\n        } else {\n            MemberUtils.setAccessibleWorkaround(field);\n        }\n        return field.get(target);\n    }\n\n    /**\n     * Reads the named public field. Superclasses will be considered.\n     * \n     * @param target\n     *            the object to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the value of the field\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     * @throws IllegalAccessException\n     *             if the named field is not public\n     */\n    public static Object readField(final Object target, final String fieldName) throws IllegalAccessException {\n        return readField(target, fieldName, false);\n    }\n\n    /**\n     * Reads the named field. Superclasses will be considered.\n     * \n     * @param target\n     *            the object to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n     *            will only match public fields.\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     * @throws IllegalAccessException\n     *             if the named field is not made accessible\n     */\n    public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n        if (target == null) {\n            throw new IllegalArgumentException(\"target object must not be null\");\n        }\n        final Class<?> cls = target.getClass();\n        final Field field = getField(cls, fieldName, forceAccess);\n        if (field == null) {\n            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n        }\n        // already forced access above, don't repeat it here:\n        return readField(field, target);\n    }\n\n    /**\n     * Reads the named public field. Only the class of the specified object will be considered.\n     * \n     * @param target\n     *            the object to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the value of the field\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     * @throws IllegalAccessException\n     *             if the named field is not public\n     */\n    public static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException {\n        return readDeclaredField(target, fieldName, false);\n    }\n\n    /**\n     * <p<>Gets a Field value by name. Only the class of the specified object will be considered.\n     * \n     * @param target\n     *            the object to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n     *            will only match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if <code>target</code> or <code>fieldName</code> is null\n     * @throws IllegalAccessException\n     *             if the field is not made accessible\n     */\n    public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {", "metadata": {"defects4j_task_id": "bb70e9da2512bf236dae43a8379d9c59f80b3f50dd4232796d500df1331da127", "task_id": "apache_commons-lang/157", "ground_truth": "\n        if (target == null) {\n            throw new IllegalArgumentException(\"target object must not be null\");\n        }\n        final Class<?> cls = target.getClass();\n        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n        if (field == null) {\n            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n        }\n        // already forced access above, don't repeat it here:\n        return readField(field, target);\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "reflect", "FieldUtils.java"], "context_start_lineno": 0, "function_name": "readDeclaredField", "left_context": "class FieldUtils {\n\n    /**\n     * Gets a static Field value by name. The field must be public. Only the specified class will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the value of the field\n     * @throws IllegalArgumentException\n     *             if the class is null, the field name is null or if the field could not be found\n     * @throws IllegalAccessException\n     *             if the field is not accessible\n     */\n    public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException {\n        return readDeclaredStaticField(cls, fieldName, false);\n    }\n\n    /**\n     * Gets a static Field value by name. Only the specified class will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n     *            will only match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if the class is null, the field name is null or if the field could not be found\n     * @throws IllegalAccessException\n     *             if the field is not made accessible\n     */\n    public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n        if (field == null) {\n            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n        }\n        // already forced access above, don't repeat it here:\n        return readStaticField(field, false);\n    }\n\n    /**\n     * Reads an accessible Field.\n     * \n     * @param field\n     *            the field to use\n     * @param target\n     *            the object to call on, may be null for static fields\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null\n     * @throws IllegalAccessException\n     *             if the field is not accessible\n     */\n    public static Object readField(final Field field, final Object target) throws IllegalAccessException {\n        return readField(field, target, false);\n    }\n\n    /**\n     * Reads a Field.\n     * \n     * @param field\n     *            the field to use\n     * @param target\n     *            the object to call on, may be null for static fields\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method.\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null\n     * @throws IllegalAccessException\n     *             if the field is not made accessible\n     */\n    public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException {\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (forceAccess && !field.isAccessible()) {\n            field.setAccessible(true);\n        } else {\n            MemberUtils.setAccessibleWorkaround(field);\n        }\n        return field.get(target);\n    }\n\n    /**\n     * Reads the named public field. Superclasses will be considered.\n     * \n     * @param target\n     *            the object to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the value of the field\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     * @throws IllegalAccessException\n     *             if the named field is not public\n     */\n    public static Object readField(final Object target, final String fieldName) throws IllegalAccessException {\n        return readField(target, fieldName, false);\n    }\n\n    /**\n     * Reads the named field. Superclasses will be considered.\n     * \n     * @param target\n     *            the object to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n     *            will only match public fields.\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     * @throws IllegalAccessException\n     *             if the named field is not made accessible\n     */\n    public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n        if (target == null) {\n            throw new IllegalArgumentException(\"target object must not be null\");\n        }\n        final Class<?> cls = target.getClass();\n        final Field field = getField(cls, fieldName, forceAccess);\n        if (field == null) {\n            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n        }\n        // already forced access above, don't repeat it here:\n        return readField(field, target);\n    }\n\n    /**\n     * Reads the named public field. Only the class of the specified object will be considered.\n     * \n     * @param target\n     *            the object to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @return the value of the field\n     * @throws IllegalArgumentException\n     *             if the class or field name is null\n     * @throws IllegalAccessException\n     *             if the named field is not public\n     */\n    public static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException {\n        return readDeclaredField(target, fieldName, false);\n    }\n\n    /**\n     * <p<>Gets a Field value by name. Only the class of the specified object will be considered.\n     * \n     * @param target\n     *            the object to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n     *            will only match public fields.\n     * @return the Field object\n     * @throws IllegalArgumentException\n     *             if <code>target</code> or <code>fieldName</code> is null\n     * @throws IllegalAccessException\n     *             if the field is not made accessible\n     */\n    public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {", "right_context": "}\n}", "class_name": "FieldUtils", "return_type": "Object", "parameters": [{"type": "Object", "name": "target"}, {"type": "String", "name": "fieldName"}, {"type": "boolean", "name": "forceAccess"}]}}
{"prompt": "class CharSetUtils {\n\n    /**\n     * <p>Squeezes any repetitions of a character that is mentioned in the\n     * supplied set.</p>\n     *\n     * <pre>\n     * CharSetUtils.squeeze(null, *)        = null\n     * CharSetUtils.squeeze(\"\", *)          = \"\"\n     * CharSetUtils.squeeze(*, null)        = *\n     * CharSetUtils.squeeze(*, \"\")          = *\n     * CharSetUtils.squeeze(\"hello\", \"k-p\") = \"helo\"\n     * CharSetUtils.squeeze(\"hello\", \"a-e\") = \"hello\"\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  the string to squeeze, may be null\n     * @param set  the character set to use for manipulation, may be null\n     * @return the modified String, {@code null} if null string input\n     */\n    public static String squeeze(final String str, final String... set) {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        char lastChar = ' ';\n        char ch = ' ';\n        for (int i = 0; i < sz; i++) {\n            ch = chrs[i];\n            // Compare with contains() last for performance.\n            if (ch == lastChar && i != 0 && chars.contains(ch)) {\n                continue;\n            }\n            buffer.append(ch);\n            lastChar = ch;\n        }\n        return buffer.toString();\n    }\n\n    // ContainsAny\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Takes an argument in set-syntax, see evaluateSet,\n     * and identifies whether any of the characters are present in the specified string.</p>\n     *\n     * <pre>\n     * CharSetUtils.containsAny(null, *)        = false\n     * CharSetUtils.containsAny(\"\", *)          = false\n     * CharSetUtils.containsAny(*, null)        = false\n     * CharSetUtils.containsAny(*, \"\")          = false\n     * CharSetUtils.containsAny(\"hello\", \"k-p\") = true\n     * CharSetUtils.containsAny(\"hello\", \"a-d\") = false\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  String to look for characters in, may be null\n     * @param set  String[] set of characters to identify, may be null\n     * @return whether or not the characters in the set are in the primary string\n     */\n    public static boolean containsAny(final String str, final String... set) {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return false;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Count\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Takes an argument in set-syntax, see evaluateSet,\n     * and returns the number of characters present in the specified string.</p>\n     *\n     * <pre>\n     * CharSetUtils.count(null, *)        = 0\n     * CharSetUtils.count(\"\", *)          = 0\n     * CharSetUtils.count(*, null)        = 0\n     * CharSetUtils.count(*, \"\")          = 0\n     * CharSetUtils.count(\"hello\", \"k-p\") = 3\n     * CharSetUtils.count(\"hello\", \"a-e\") = 1\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  String to count characters in, may be null\n     * @param set  String[] set of characters to count, may be null\n     * @return the character count, zero if null string input\n     */\n    public static int count(final String str, final String... set) {", "metadata": {"defects4j_task_id": "d5bb15d066a7ee569ec0456b4614026ea1cb658ef513d2a9e51bd7ec60457293", "task_id": "apache_commons-lang/175", "ground_truth": "\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "CharSetUtils.java"], "context_start_lineno": 0, "function_name": "count", "left_context": "class CharSetUtils {\n\n    /**\n     * <p>Squeezes any repetitions of a character that is mentioned in the\n     * supplied set.</p>\n     *\n     * <pre>\n     * CharSetUtils.squeeze(null, *)        = null\n     * CharSetUtils.squeeze(\"\", *)          = \"\"\n     * CharSetUtils.squeeze(*, null)        = *\n     * CharSetUtils.squeeze(*, \"\")          = *\n     * CharSetUtils.squeeze(\"hello\", \"k-p\") = \"helo\"\n     * CharSetUtils.squeeze(\"hello\", \"a-e\") = \"hello\"\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  the string to squeeze, may be null\n     * @param set  the character set to use for manipulation, may be null\n     * @return the modified String, {@code null} if null string input\n     */\n    public static String squeeze(final String str, final String... set) {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        char lastChar = ' ';\n        char ch = ' ';\n        for (int i = 0; i < sz; i++) {\n            ch = chrs[i];\n            // Compare with contains() last for performance.\n            if (ch == lastChar && i != 0 && chars.contains(ch)) {\n                continue;\n            }\n            buffer.append(ch);\n            lastChar = ch;\n        }\n        return buffer.toString();\n    }\n\n    // ContainsAny\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Takes an argument in set-syntax, see evaluateSet,\n     * and identifies whether any of the characters are present in the specified string.</p>\n     *\n     * <pre>\n     * CharSetUtils.containsAny(null, *)        = false\n     * CharSetUtils.containsAny(\"\", *)          = false\n     * CharSetUtils.containsAny(*, null)        = false\n     * CharSetUtils.containsAny(*, \"\")          = false\n     * CharSetUtils.containsAny(\"hello\", \"k-p\") = true\n     * CharSetUtils.containsAny(\"hello\", \"a-d\") = false\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  String to look for characters in, may be null\n     * @param set  String[] set of characters to identify, may be null\n     * @return whether or not the characters in the set are in the primary string\n     */\n    public static boolean containsAny(final String str, final String... set) {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return false;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Count\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Takes an argument in set-syntax, see evaluateSet,\n     * and returns the number of characters present in the specified string.</p>\n     *\n     * <pre>\n     * CharSetUtils.count(null, *)        = 0\n     * CharSetUtils.count(\"\", *)          = 0\n     * CharSetUtils.count(*, null)        = 0\n     * CharSetUtils.count(*, \"\")          = 0\n     * CharSetUtils.count(\"hello\", \"k-p\") = 3\n     * CharSetUtils.count(\"hello\", \"a-e\") = 1\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  String to count characters in, may be null\n     * @param set  String[] set of characters to count, may be null\n     * @return the character count, zero if null string input\n     */\n    public static int count(final String str, final String... set) {", "right_context": "}\n}", "class_name": "CharSetUtils", "return_type": "int", "parameters": [{"type": "String", "name": "str"}, {"type": "String", "name": "set"}]}}
{"prompt": "class CharSetUtils {\n\n    /**\n     * <p>Squeezes any repetitions of a character that is mentioned in the\n     * supplied set.</p>\n     *\n     * <pre>\n     * CharSetUtils.squeeze(null, *)        = null\n     * CharSetUtils.squeeze(\"\", *)          = \"\"\n     * CharSetUtils.squeeze(*, null)        = *\n     * CharSetUtils.squeeze(*, \"\")          = *\n     * CharSetUtils.squeeze(\"hello\", \"k-p\") = \"helo\"\n     * CharSetUtils.squeeze(\"hello\", \"a-e\") = \"hello\"\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  the string to squeeze, may be null\n     * @param set  the character set to use for manipulation, may be null\n     * @return the modified String, {@code null} if null string input\n     */\n    public static String squeeze(final String str, final String... set) {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        char lastChar = ' ';\n        char ch = ' ';\n        for (int i = 0; i < sz; i++) {\n            ch = chrs[i];\n            // Compare with contains() last for performance.\n            if (ch == lastChar && i != 0 && chars.contains(ch)) {\n                continue;\n            }\n            buffer.append(ch);\n            lastChar = ch;\n        }\n        return buffer.toString();\n    }\n\n    // ContainsAny\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Takes an argument in set-syntax, see evaluateSet,\n     * and identifies whether any of the characters are present in the specified string.</p>\n     *\n     * <pre>\n     * CharSetUtils.containsAny(null, *)        = false\n     * CharSetUtils.containsAny(\"\", *)          = false\n     * CharSetUtils.containsAny(*, null)        = false\n     * CharSetUtils.containsAny(*, \"\")          = false\n     * CharSetUtils.containsAny(\"hello\", \"k-p\") = true\n     * CharSetUtils.containsAny(\"hello\", \"a-d\") = false\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  String to look for characters in, may be null\n     * @param set  String[] set of characters to identify, may be null\n     * @return whether or not the characters in the set are in the primary string\n     */\n    public static boolean containsAny(final String str, final String... set) {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return false;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Count\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Takes an argument in set-syntax, see evaluateSet,\n     * and returns the number of characters present in the specified string.</p>\n     *\n     * <pre>\n     * CharSetUtils.count(null, *)        = 0\n     * CharSetUtils.count(\"\", *)          = 0\n     * CharSetUtils.count(*, null)        = 0\n     * CharSetUtils.count(*, \"\")          = 0\n     * CharSetUtils.count(\"hello\", \"k-p\") = 3\n     * CharSetUtils.count(\"hello\", \"a-e\") = 1\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  String to count characters in, may be null\n     * @param set  String[] set of characters to count, may be null\n     * @return the character count, zero if null string input\n     */\n    public static int count(final String str, final String... set) {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    // Keep\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Takes an argument in set-syntax, see evaluateSet,\n     * and keeps any of characters present in the specified string.</p>\n     *\n     * <pre>\n     * CharSetUtils.keep(null, *)        = null\n     * CharSetUtils.keep(\"\", *)          = \"\"\n     * CharSetUtils.keep(*, null)        = \"\"\n     * CharSetUtils.keep(*, \"\")          = \"\"\n     * CharSetUtils.keep(\"hello\", \"hl\")  = \"hll\"\n     * CharSetUtils.keep(\"hello\", \"le\")  = \"ell\"\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  String to keep characters from, may be null\n     * @param set  String[] set of characters to keep, may be null\n     * @return the modified String, {@code null} if null string input\n     * @since 2.0\n     */\n    public static String keep(final String str, final String... set) {", "metadata": {"defects4j_task_id": "193382850a7bfbd28bc0af67bd3eda8a2715ba5a92cc84dadbf3a3922b691c21", "task_id": "apache_commons-lang/27", "ground_truth": "\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty() || deepEmpty(set)) {\n            return StringUtils.EMPTY;\n        }\n        return modify(str, set, true);\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "CharSetUtils.java"], "context_start_lineno": 0, "function_name": "keep", "left_context": "class CharSetUtils {\n\n    /**\n     * <p>Squeezes any repetitions of a character that is mentioned in the\n     * supplied set.</p>\n     *\n     * <pre>\n     * CharSetUtils.squeeze(null, *)        = null\n     * CharSetUtils.squeeze(\"\", *)          = \"\"\n     * CharSetUtils.squeeze(*, null)        = *\n     * CharSetUtils.squeeze(*, \"\")          = *\n     * CharSetUtils.squeeze(\"hello\", \"k-p\") = \"helo\"\n     * CharSetUtils.squeeze(\"hello\", \"a-e\") = \"hello\"\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  the string to squeeze, may be null\n     * @param set  the character set to use for manipulation, may be null\n     * @return the modified String, {@code null} if null string input\n     */\n    public static String squeeze(final String str, final String... set) {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        char lastChar = ' ';\n        char ch = ' ';\n        for (int i = 0; i < sz; i++) {\n            ch = chrs[i];\n            // Compare with contains() last for performance.\n            if (ch == lastChar && i != 0 && chars.contains(ch)) {\n                continue;\n            }\n            buffer.append(ch);\n            lastChar = ch;\n        }\n        return buffer.toString();\n    }\n\n    // ContainsAny\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Takes an argument in set-syntax, see evaluateSet,\n     * and identifies whether any of the characters are present in the specified string.</p>\n     *\n     * <pre>\n     * CharSetUtils.containsAny(null, *)        = false\n     * CharSetUtils.containsAny(\"\", *)          = false\n     * CharSetUtils.containsAny(*, null)        = false\n     * CharSetUtils.containsAny(*, \"\")          = false\n     * CharSetUtils.containsAny(\"hello\", \"k-p\") = true\n     * CharSetUtils.containsAny(\"hello\", \"a-d\") = false\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  String to look for characters in, may be null\n     * @param set  String[] set of characters to identify, may be null\n     * @return whether or not the characters in the set are in the primary string\n     */\n    public static boolean containsAny(final String str, final String... set) {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return false;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Count\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Takes an argument in set-syntax, see evaluateSet,\n     * and returns the number of characters present in the specified string.</p>\n     *\n     * <pre>\n     * CharSetUtils.count(null, *)        = 0\n     * CharSetUtils.count(\"\", *)          = 0\n     * CharSetUtils.count(*, null)        = 0\n     * CharSetUtils.count(*, \"\")          = 0\n     * CharSetUtils.count(\"hello\", \"k-p\") = 3\n     * CharSetUtils.count(\"hello\", \"a-e\") = 1\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  String to count characters in, may be null\n     * @param set  String[] set of characters to count, may be null\n     * @return the character count, zero if null string input\n     */\n    public static int count(final String str, final String... set) {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    // Keep\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Takes an argument in set-syntax, see evaluateSet,\n     * and keeps any of characters present in the specified string.</p>\n     *\n     * <pre>\n     * CharSetUtils.keep(null, *)        = null\n     * CharSetUtils.keep(\"\", *)          = \"\"\n     * CharSetUtils.keep(*, null)        = \"\"\n     * CharSetUtils.keep(*, \"\")          = \"\"\n     * CharSetUtils.keep(\"hello\", \"hl\")  = \"hll\"\n     * CharSetUtils.keep(\"hello\", \"le\")  = \"ell\"\n     * </pre>\n     *\n     * @see CharSet#getInstance(java.lang.String...) for set-syntax.\n     * @param str  String to keep characters from, may be null\n     * @param set  String[] set of characters to keep, may be null\n     * @return the modified String, {@code null} if null string input\n     * @since 2.0\n     */\n    public static String keep(final String str, final String... set) {", "right_context": "}\n}", "class_name": "CharSetUtils", "return_type": "String", "parameters": [{"type": "String", "name": "str"}, {"type": "String", "name": "set"}]}}
{"prompt": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * {@code java.lang.Character.getType(char)}. Groups of contiguous\n     * characters of the same type are returned as complete tokens.\n     * <pre>\n     * StringUtils.splitByCharacterType(null)         = null\n     * StringUtils.splitByCharacterType(\"\")           = []\n     * StringUtils.splitByCharacterType(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterType(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterType(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n     * StringUtils.splitByCharacterType(\"number5\")    = [\"number\", \"5\"]\n     * StringUtils.splitByCharacterType(\"fooBar\")     = [\"foo\", \"B\", \"ar\"]\n     * StringUtils.splitByCharacterType(\"foo200Bar\")  = [\"foo\", \"200\", \"B\", \"ar\"]\n     * StringUtils.splitByCharacterType(\"ASFRules\")   = [\"ASFR\", \"ules\"]\n     * </pre>\n     * @param str the String to split, may be {@code null}\n     * @return an array of parsed Strings, {@code null} if null String input\n     * @since 2.4\n     */\n    public static String[] splitByCharacterType(final String str) {\n        return splitByCharacterType(str, false);\n    }\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * {@code java.lang.Character.getType(char)}. Groups of contiguous\n     * characters of the same type are returned as complete tokens, with the\n     * following exception: the character of type\n     * {@code Character.UPPERCASE_LETTER}, if any, immediately\n     * preceding a token of type {@code Character.LOWERCASE_LETTER}\n     * will belong to the following token rather than to the preceding, if any,\n     * {@code Character.UPPERCASE_LETTER} token.\n     * <pre>\n     * StringUtils.splitByCharacterTypeCamelCase(null)         = null\n     * StringUtils.splitByCharacterTypeCamelCase(\"\")           = []\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"number5\")    = [\"number\", \"5\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"fooBar\")     = [\"foo\", \"Bar\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"foo200Bar\")  = [\"foo\", \"200\", \"Bar\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ASFRules\")   = [\"ASF\", \"Rules\"]\n     * </pre>\n     * @param str the String to split, may be {@code null}\n     * @return an array of parsed Strings, {@code null} if null String input\n     * @since 2.4\n     */\n    public static String[] splitByCharacterTypeCamelCase(final String str) {\n        return splitByCharacterType(str, true);\n    }\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * {@code java.lang.Character.getType(char)}. Groups of contiguous\n     * characters of the same type are returned as complete tokens, with the\n     * following exception: if {@code camelCase} is {@code true},\n     * the character of type {@code Character.UPPERCASE_LETTER}, if any,\n     * immediately preceding a token of type {@code Character.LOWERCASE_LETTER}\n     * will belong to the following token rather than to the preceding, if any,\n     * {@code Character.UPPERCASE_LETTER} token.\n     * @param str the String to split, may be {@code null}\n     * @param camelCase whether to use so-called \"camel-case\" for letter types\n     * @return an array of parsed Strings, {@code null} if null String input\n     * @since 2.4\n     */\n    private static String[] splitByCharacterType(final String str, final boolean camelCase) {", "metadata": {"defects4j_task_id": "dcacb9697aa6a38292904604a12ca110710de8c79e8465ef77e7a39ccbc431c8", "task_id": "apache_commons-lang/182", "ground_truth": "\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final char[] c = str.toCharArray();\n        final List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            final int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                final int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "StringUtils.java"], "context_start_lineno": 0, "function_name": "splitByCharacterType", "left_context": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * {@code java.lang.Character.getType(char)}. Groups of contiguous\n     * characters of the same type are returned as complete tokens.\n     * <pre>\n     * StringUtils.splitByCharacterType(null)         = null\n     * StringUtils.splitByCharacterType(\"\")           = []\n     * StringUtils.splitByCharacterType(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterType(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterType(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n     * StringUtils.splitByCharacterType(\"number5\")    = [\"number\", \"5\"]\n     * StringUtils.splitByCharacterType(\"fooBar\")     = [\"foo\", \"B\", \"ar\"]\n     * StringUtils.splitByCharacterType(\"foo200Bar\")  = [\"foo\", \"200\", \"B\", \"ar\"]\n     * StringUtils.splitByCharacterType(\"ASFRules\")   = [\"ASFR\", \"ules\"]\n     * </pre>\n     * @param str the String to split, may be {@code null}\n     * @return an array of parsed Strings, {@code null} if null String input\n     * @since 2.4\n     */\n    public static String[] splitByCharacterType(final String str) {\n        return splitByCharacterType(str, false);\n    }\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * {@code java.lang.Character.getType(char)}. Groups of contiguous\n     * characters of the same type are returned as complete tokens, with the\n     * following exception: the character of type\n     * {@code Character.UPPERCASE_LETTER}, if any, immediately\n     * preceding a token of type {@code Character.LOWERCASE_LETTER}\n     * will belong to the following token rather than to the preceding, if any,\n     * {@code Character.UPPERCASE_LETTER} token.\n     * <pre>\n     * StringUtils.splitByCharacterTypeCamelCase(null)         = null\n     * StringUtils.splitByCharacterTypeCamelCase(\"\")           = []\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"number5\")    = [\"number\", \"5\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"fooBar\")     = [\"foo\", \"Bar\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"foo200Bar\")  = [\"foo\", \"200\", \"Bar\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ASFRules\")   = [\"ASF\", \"Rules\"]\n     * </pre>\n     * @param str the String to split, may be {@code null}\n     * @return an array of parsed Strings, {@code null} if null String input\n     * @since 2.4\n     */\n    public static String[] splitByCharacterTypeCamelCase(final String str) {\n        return splitByCharacterType(str, true);\n    }\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * {@code java.lang.Character.getType(char)}. Groups of contiguous\n     * characters of the same type are returned as complete tokens, with the\n     * following exception: if {@code camelCase} is {@code true},\n     * the character of type {@code Character.UPPERCASE_LETTER}, if any,\n     * immediately preceding a token of type {@code Character.LOWERCASE_LETTER}\n     * will belong to the following token rather than to the preceding, if any,\n     * {@code Character.UPPERCASE_LETTER} token.\n     * @param str the String to split, may be {@code null}\n     * @param camelCase whether to use so-called \"camel-case\" for letter types\n     * @return an array of parsed Strings, {@code null} if null String input\n     * @since 2.4\n     */\n    private static String[] splitByCharacterType(final String str, final boolean camelCase) {", "right_context": "}\n\n}", "class_name": "StringUtils", "return_type": "String[]", "parameters": [{"type": "String", "name": "str"}, {"type": "boolean", "name": "camelCase"}]}}
{"prompt": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Joins the elements of the provided {@code Iterator} into\n     * a single String containing the provided elements.</p>\n     *\n     * <p>No delimiter is added before or after the list. Null objects or empty\n     * strings within the iteration are represented by empty strings.</p>\n     *\n     * <p>See the examples here: {@link #join(Object[],char)}. </p>\n     *\n     * @param iterator  the {@code Iterator} of values to join together, may be null\n     * @param separator  the separator character to use\n     * @return the joined String, {@code null} if null iterator input\n     * @since 2.0\n     */\n    public static String join(final Iterator<?> iterator, final char separator) {\n\n        // handle null, zero and one elements before building a buffer\n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        final Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        // two or more elements\n        final StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            buf.append(separator);\n            final Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n\n        return buf.toString();\n    }\n\n    /**\n     * <p>Joins the elements of the provided {@code Iterator} into\n     * a single String containing the provided elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * A {@code null} separator is the same as an empty String (\"\").</p>\n     *\n     * <p>See the examples here: {@link #join(Object[],String)}. </p>\n     *\n     * @param iterator  the {@code Iterator} of values to join together, may be null\n     * @param separator  the separator character to use, null treated as \"\"\n     * @return the joined String, {@code null} if null iterator input\n     */\n    public static String join(final Iterator<?> iterator, final String separator) {\n\n        // handle null, zero and one elements before building a buffer\n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        final Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        // two or more elements\n        final StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            if (separator != null) {\n                buf.append(separator);\n            }\n            final Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * <p>Joins the elements of the provided {@code Iterable} into\n     * a single String containing the provided elements.</p>\n     *\n     * <p>No delimiter is added before or after the list. Null objects or empty\n     * strings within the iteration are represented by empty strings.</p>\n     *\n     * <p>See the examples here: {@link #join(Object[],char)}. </p>\n     *\n     * @param iterable  the {@code Iterable} providing the values to join together, may be null\n     * @param separator  the separator character to use\n     * @return the joined String, {@code null} if null iterator input\n     * @since 2.3\n     */\n    public static String join(final Iterable<?> iterable, final char separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    /**\n     * <p>Joins the elements of the provided {@code Iterable} into\n     * a single String containing the provided elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * A {@code null} separator is the same as an empty String (\"\").</p>\n     *\n     * <p>See the examples here: {@link #join(Object[],String)}. </p>\n     *\n     * @param iterable  the {@code Iterable} providing the values to join together, may be null\n     * @param separator  the separator character to use, null treated as \"\"\n     * @return the joined String, {@code null} if null iterator input\n     * @since 2.3\n     */\n    public static String join(final Iterable<?> iterable, final String separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    // Delete\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Deletes all whitespaces from a String as defined by\n     * {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.deleteWhitespace(null)         = null\n     * StringUtils.deleteWhitespace(\"\")           = \"\"\n     * StringUtils.deleteWhitespace(\"abc\")        = \"abc\"\n     * StringUtils.deleteWhitespace(\"   ab  c  \") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to delete whitespace from, may be null\n     * @return the String without whitespaces, {@code null} if null String input\n     */\n    public static String deleteWhitespace(final String str) {", "metadata": {"defects4j_task_id": "ef20ba69abcde2459be87e3e4d562048f26dd6b5bad2066c139589deff97be53", "task_id": "apache_commons-lang/197", "ground_truth": "\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "StringUtils.java"], "context_start_lineno": 0, "function_name": "deleteWhitespace", "left_context": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Joins the elements of the provided {@code Iterator} into\n     * a single String containing the provided elements.</p>\n     *\n     * <p>No delimiter is added before or after the list. Null objects or empty\n     * strings within the iteration are represented by empty strings.</p>\n     *\n     * <p>See the examples here: {@link #join(Object[],char)}. </p>\n     *\n     * @param iterator  the {@code Iterator} of values to join together, may be null\n     * @param separator  the separator character to use\n     * @return the joined String, {@code null} if null iterator input\n     * @since 2.0\n     */\n    public static String join(final Iterator<?> iterator, final char separator) {\n\n        // handle null, zero and one elements before building a buffer\n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        final Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        // two or more elements\n        final StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            buf.append(separator);\n            final Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n\n        return buf.toString();\n    }\n\n    /**\n     * <p>Joins the elements of the provided {@code Iterator} into\n     * a single String containing the provided elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * A {@code null} separator is the same as an empty String (\"\").</p>\n     *\n     * <p>See the examples here: {@link #join(Object[],String)}. </p>\n     *\n     * @param iterator  the {@code Iterator} of values to join together, may be null\n     * @param separator  the separator character to use, null treated as \"\"\n     * @return the joined String, {@code null} if null iterator input\n     */\n    public static String join(final Iterator<?> iterator, final String separator) {\n\n        // handle null, zero and one elements before building a buffer\n        if (iterator == null) {\n            return null;\n        }\n        if (!iterator.hasNext()) {\n            return EMPTY;\n        }\n        final Object first = iterator.next();\n        if (!iterator.hasNext()) {\n            return ObjectUtils.toString(first);\n        }\n\n        // two or more elements\n        final StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n        if (first != null) {\n            buf.append(first);\n        }\n\n        while (iterator.hasNext()) {\n            if (separator != null) {\n                buf.append(separator);\n            }\n            final Object obj = iterator.next();\n            if (obj != null) {\n                buf.append(obj);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * <p>Joins the elements of the provided {@code Iterable} into\n     * a single String containing the provided elements.</p>\n     *\n     * <p>No delimiter is added before or after the list. Null objects or empty\n     * strings within the iteration are represented by empty strings.</p>\n     *\n     * <p>See the examples here: {@link #join(Object[],char)}. </p>\n     *\n     * @param iterable  the {@code Iterable} providing the values to join together, may be null\n     * @param separator  the separator character to use\n     * @return the joined String, {@code null} if null iterator input\n     * @since 2.3\n     */\n    public static String join(final Iterable<?> iterable, final char separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    /**\n     * <p>Joins the elements of the provided {@code Iterable} into\n     * a single String containing the provided elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * A {@code null} separator is the same as an empty String (\"\").</p>\n     *\n     * <p>See the examples here: {@link #join(Object[],String)}. </p>\n     *\n     * @param iterable  the {@code Iterable} providing the values to join together, may be null\n     * @param separator  the separator character to use, null treated as \"\"\n     * @return the joined String, {@code null} if null iterator input\n     * @since 2.3\n     */\n    public static String join(final Iterable<?> iterable, final String separator) {\n        if (iterable == null) {\n            return null;\n        }\n        return join(iterable.iterator(), separator);\n    }\n\n    // Delete\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Deletes all whitespaces from a String as defined by\n     * {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.deleteWhitespace(null)         = null\n     * StringUtils.deleteWhitespace(\"\")           = \"\"\n     * StringUtils.deleteWhitespace(\"abc\")        = \"abc\"\n     * StringUtils.deleteWhitespace(\"   ab  c  \") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to delete whitespace from, may be null\n     * @return the String without whitespaces, {@code null} if null String input\n     */\n    public static String deleteWhitespace(final String str) {", "right_context": "}\n\n}", "class_name": "StringUtils", "return_type": "String", "parameters": [{"type": "String", "name": "str"}]}}
{"prompt": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Removes {@code separator} from the end of\n     * {@code str} if it's there, otherwise leave it alone.</p>\n     *\n     * <p>NOTE: This method changed in version 2.0.\n     * It now more closely matches Perl chomp.\n     * For the previous behavior, use {@link #substringBeforeLast(String, String)}.\n     * This method uses {@link String#endsWith(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.chomp(null, *)         = null\n     * StringUtils.chomp(\"\", *)           = \"\"\n     * StringUtils.chomp(\"foobar\", \"bar\") = \"foo\"\n     * StringUtils.chomp(\"foobar\", \"baz\") = \"foobar\"\n     * StringUtils.chomp(\"foo\", \"foo\")    = \"\"\n     * StringUtils.chomp(\"foo \", \"foo\")   = \"foo \"\n     * StringUtils.chomp(\" foo\", \"foo\")   = \" \"\n     * StringUtils.chomp(\"foo\", \"foooo\")  = \"foo\"\n     * StringUtils.chomp(\"foo\", \"\")       = \"foo\"\n     * StringUtils.chomp(\"foo\", null)     = \"foo\"\n     * </pre>\n     *\n     * @param str  the String to chomp from, may be null\n     * @param separator  separator String, may be null\n     * @return String without trailing separator, {@code null} if null String input\n     * @deprecated This feature will be removed in Lang 4.0, use {@link StringUtils#removeEnd(String, String)} instead\n     */\n    @Deprecated\n    public static String chomp(final String str, final String separator) {\n        return removeEnd(str,separator);\n    }\n\n    // Chopping\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Remove the last character from a String.</p>\n     *\n     * <p>If the String ends in {@code \\r\\n}, then remove both\n     * of them.</p>\n     *\n     * <pre>\n     * StringUtils.chop(null)          = null\n     * StringUtils.chop(\"\")            = \"\"\n     * StringUtils.chop(\"abc \\r\")      = \"abc \"\n     * StringUtils.chop(\"abc\\n\")       = \"abc\"\n     * StringUtils.chop(\"abc\\r\\n\")     = \"abc\"\n     * StringUtils.chop(\"abc\")         = \"ab\"\n     * StringUtils.chop(\"abc\\nabc\")    = \"abc\\nab\"\n     * StringUtils.chop(\"a\")           = \"\"\n     * StringUtils.chop(\"\\r\")          = \"\"\n     * StringUtils.chop(\"\\n\")          = \"\"\n     * StringUtils.chop(\"\\r\\n\")        = \"\"\n     * </pre>\n     *\n     * @param str  the String to chop last character from, may be null\n     * @return String without last character, {@code null} if null String input\n     */\n    public static String chop(final String str) {\n        if (str == null) {\n            return null;\n        }\n        final int strLen = str.length();\n        if (strLen < 2) {\n            return EMPTY;\n        }\n        final int lastIdx = strLen - 1;\n        final String ret = str.substring(0, lastIdx);\n        final char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {\n            return ret.substring(0, lastIdx - 1);\n        }\n        return ret;\n    }\n\n    // Conversion\n    //-----------------------------------------------------------------------\n\n    // Padding\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Repeat a String {@code repeat} times to form a\n     * new String.</p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, 2) = null\n     * StringUtils.repeat(\"\", 0)   = \"\"\n     * StringUtils.repeat(\"\", 2)   = \"\"\n     * StringUtils.repeat(\"a\", 3)  = \"aaa\"\n     * StringUtils.repeat(\"ab\", 2) = \"abab\"\n     * StringUtils.repeat(\"a\", -2) = \"\"\n     * </pre>\n     *\n     * @param str  the String to repeat, may be null\n     * @param repeat  number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     *  {@code null} if null String input\n     */\n    public static String repeat(final String str, final int repeat) {", "metadata": {"defects4j_task_id": "d541bdb689d884bd7fe8eb245beaead748c88e3273a96c928e74708d4e3c61d3", "task_id": "apache_commons-lang/173", "ground_truth": "\n        // Performance tuned for 2.0 (JDK1.4)\n\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "StringUtils.java"], "context_start_lineno": 0, "function_name": "repeat", "left_context": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Removes {@code separator} from the end of\n     * {@code str} if it's there, otherwise leave it alone.</p>\n     *\n     * <p>NOTE: This method changed in version 2.0.\n     * It now more closely matches Perl chomp.\n     * For the previous behavior, use {@link #substringBeforeLast(String, String)}.\n     * This method uses {@link String#endsWith(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.chomp(null, *)         = null\n     * StringUtils.chomp(\"\", *)           = \"\"\n     * StringUtils.chomp(\"foobar\", \"bar\") = \"foo\"\n     * StringUtils.chomp(\"foobar\", \"baz\") = \"foobar\"\n     * StringUtils.chomp(\"foo\", \"foo\")    = \"\"\n     * StringUtils.chomp(\"foo \", \"foo\")   = \"foo \"\n     * StringUtils.chomp(\" foo\", \"foo\")   = \" \"\n     * StringUtils.chomp(\"foo\", \"foooo\")  = \"foo\"\n     * StringUtils.chomp(\"foo\", \"\")       = \"foo\"\n     * StringUtils.chomp(\"foo\", null)     = \"foo\"\n     * </pre>\n     *\n     * @param str  the String to chomp from, may be null\n     * @param separator  separator String, may be null\n     * @return String without trailing separator, {@code null} if null String input\n     * @deprecated This feature will be removed in Lang 4.0, use {@link StringUtils#removeEnd(String, String)} instead\n     */\n    @Deprecated\n    public static String chomp(final String str, final String separator) {\n        return removeEnd(str,separator);\n    }\n\n    // Chopping\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Remove the last character from a String.</p>\n     *\n     * <p>If the String ends in {@code \\r\\n}, then remove both\n     * of them.</p>\n     *\n     * <pre>\n     * StringUtils.chop(null)          = null\n     * StringUtils.chop(\"\")            = \"\"\n     * StringUtils.chop(\"abc \\r\")      = \"abc \"\n     * StringUtils.chop(\"abc\\n\")       = \"abc\"\n     * StringUtils.chop(\"abc\\r\\n\")     = \"abc\"\n     * StringUtils.chop(\"abc\")         = \"ab\"\n     * StringUtils.chop(\"abc\\nabc\")    = \"abc\\nab\"\n     * StringUtils.chop(\"a\")           = \"\"\n     * StringUtils.chop(\"\\r\")          = \"\"\n     * StringUtils.chop(\"\\n\")          = \"\"\n     * StringUtils.chop(\"\\r\\n\")        = \"\"\n     * </pre>\n     *\n     * @param str  the String to chop last character from, may be null\n     * @return String without last character, {@code null} if null String input\n     */\n    public static String chop(final String str) {\n        if (str == null) {\n            return null;\n        }\n        final int strLen = str.length();\n        if (strLen < 2) {\n            return EMPTY;\n        }\n        final int lastIdx = strLen - 1;\n        final String ret = str.substring(0, lastIdx);\n        final char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {\n            return ret.substring(0, lastIdx - 1);\n        }\n        return ret;\n    }\n\n    // Conversion\n    //-----------------------------------------------------------------------\n\n    // Padding\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Repeat a String {@code repeat} times to form a\n     * new String.</p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, 2) = null\n     * StringUtils.repeat(\"\", 0)   = \"\"\n     * StringUtils.repeat(\"\", 2)   = \"\"\n     * StringUtils.repeat(\"a\", 3)  = \"aaa\"\n     * StringUtils.repeat(\"ab\", 2) = \"abab\"\n     * StringUtils.repeat(\"a\", -2) = \"\"\n     * </pre>\n     *\n     * @param str  the String to repeat, may be null\n     * @param repeat  number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     *  {@code null} if null String input\n     */\n    public static String repeat(final String str, final int repeat) {", "right_context": "}\n\n}", "class_name": "StringUtils", "return_type": "String", "parameters": [{"type": "String", "name": "str"}, {"type": "int", "name": "repeat"}]}}
{"prompt": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Left pad a String with a specified String.</p>\n     *\n     * <p>Pad to a size of {@code size}.</p>\n     *\n     * <pre>\n     * StringUtils.leftPad(null, *, *)      = null\n     * StringUtils.leftPad(\"\", 3, \"z\")      = \"zzz\"\n     * StringUtils.leftPad(\"bat\", 3, \"yz\")  = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5, \"yz\")  = \"yzbat\"\n     * StringUtils.leftPad(\"bat\", 8, \"yz\")  = \"yzyzybat\"\n     * StringUtils.leftPad(\"bat\", 1, \"yz\")  = \"bat\"\n     * StringUtils.leftPad(\"bat\", -1, \"yz\") = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5, null)  = \"  bat\"\n     * StringUtils.leftPad(\"bat\", 5, \"\")    = \"  bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @param padStr  the String to pad with, null or empty treated as single space\n     * @return left padded String or original String if no padding is necessary,\n     *  {@code null} if null String input\n     */\n    public static String leftPad(final String str, final int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = SPACE;\n        }\n        final int padLen = padStr.length();\n        final int strLen = str.length();\n        final int pads = size - strLen;\n        if (pads <= 0) {\n            return str; // returns original String when possible\n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return leftPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return padStr.concat(str);\n        } else if (pads < padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            final char[] padding = new char[pads];\n            final char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }\n\n    /**\n     * Gets a CharSequence length or {@code 0} if the CharSequence is\n     * {@code null}.\n     *\n     * @param cs\n     *            a CharSequence or {@code null}\n     * @return CharSequence length or {@code 0} if the CharSequence is\n     *         {@code null}.\n     * @since 2.4\n     * @since 3.0 Changed signature from length(String) to length(CharSequence)\n     */\n    public static int length(final CharSequence cs) {\n        return cs == null ? 0 : cs.length();\n    }\n\n    // Centering\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Centers a String in a larger String of size {@code size}\n     * using the space character (' ').<p>\n     *\n     * <p>If the size is less than the String length, the String is returned.\n     * A {@code null} String returns {@code null}.\n     * A negative size is treated as zero.</p>\n     *\n     * <p>Equivalent to {@code center(str, size, \" \")}.</p>\n     *\n     * <pre>\n     * StringUtils.center(null, *)   = null\n     * StringUtils.center(\"\", 4)     = \"    \"\n     * StringUtils.center(\"ab\", -1)  = \"ab\"\n     * StringUtils.center(\"ab\", 4)   = \" ab \"\n     * StringUtils.center(\"abcd\", 2) = \"abcd\"\n     * StringUtils.center(\"a\", 4)    = \" a  \"\n     * </pre>\n     *\n     * @param str  the String to center, may be null\n     * @param size  the int size of new String, negative treated as zero\n     * @return centered String, {@code null} if null String input\n     */\n    public static String center(final String str, final int size) {\n        return center(str, size, ' ');\n    }\n\n    /**\n     * <p>Centers a String in a larger String of size {@code size}.\n     * Uses a supplied character as the value to pad the String with.</p>\n     *\n     * <p>If the size is less than the String length, the String is returned.\n     * A {@code null} String returns {@code null}.\n     * A negative size is treated as zero.</p>\n     *\n     * <pre>\n     * StringUtils.center(null, *, *)     = null\n     * StringUtils.center(\"\", 4, ' ')     = \"    \"\n     * StringUtils.center(\"ab\", -1, ' ')  = \"ab\"\n     * StringUtils.center(\"ab\", 4, ' ')   = \" ab \"\n     * StringUtils.center(\"abcd\", 2, ' ') = \"abcd\"\n     * StringUtils.center(\"a\", 4, ' ')    = \" a  \"\n     * StringUtils.center(\"a\", 4, 'y')    = \"yayy\"\n     * </pre>\n     *\n     * @param str  the String to center, may be null\n     * @param size  the int size of new String, negative treated as zero\n     * @param padChar  the character to pad the new String with\n     * @return centered String, {@code null} if null String input\n     * @since 2.0\n     */\n    public static String center(String str, final int size, final char padChar) {", "metadata": {"defects4j_task_id": "7493c2dd84bc45260471e081c963380137d6a8820d443be48b9ad4b538425044", "task_id": "apache_commons-lang/98", "ground_truth": "\n        if (str == null || size <= 0) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "StringUtils.java"], "context_start_lineno": 0, "function_name": "center", "left_context": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Left pad a String with a specified String.</p>\n     *\n     * <p>Pad to a size of {@code size}.</p>\n     *\n     * <pre>\n     * StringUtils.leftPad(null, *, *)      = null\n     * StringUtils.leftPad(\"\", 3, \"z\")      = \"zzz\"\n     * StringUtils.leftPad(\"bat\", 3, \"yz\")  = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5, \"yz\")  = \"yzbat\"\n     * StringUtils.leftPad(\"bat\", 8, \"yz\")  = \"yzyzybat\"\n     * StringUtils.leftPad(\"bat\", 1, \"yz\")  = \"bat\"\n     * StringUtils.leftPad(\"bat\", -1, \"yz\") = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5, null)  = \"  bat\"\n     * StringUtils.leftPad(\"bat\", 5, \"\")    = \"  bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @param padStr  the String to pad with, null or empty treated as single space\n     * @return left padded String or original String if no padding is necessary,\n     *  {@code null} if null String input\n     */\n    public static String leftPad(final String str, final int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (isEmpty(padStr)) {\n            padStr = SPACE;\n        }\n        final int padLen = padStr.length();\n        final int strLen = str.length();\n        final int pads = size - strLen;\n        if (pads <= 0) {\n            return str; // returns original String when possible\n        }\n        if (padLen == 1 && pads <= PAD_LIMIT) {\n            return leftPad(str, size, padStr.charAt(0));\n        }\n\n        if (pads == padLen) {\n            return padStr.concat(str);\n        } else if (pads < padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            final char[] padding = new char[pads];\n            final char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }\n\n    /**\n     * Gets a CharSequence length or {@code 0} if the CharSequence is\n     * {@code null}.\n     *\n     * @param cs\n     *            a CharSequence or {@code null}\n     * @return CharSequence length or {@code 0} if the CharSequence is\n     *         {@code null}.\n     * @since 2.4\n     * @since 3.0 Changed signature from length(String) to length(CharSequence)\n     */\n    public static int length(final CharSequence cs) {\n        return cs == null ? 0 : cs.length();\n    }\n\n    // Centering\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Centers a String in a larger String of size {@code size}\n     * using the space character (' ').<p>\n     *\n     * <p>If the size is less than the String length, the String is returned.\n     * A {@code null} String returns {@code null}.\n     * A negative size is treated as zero.</p>\n     *\n     * <p>Equivalent to {@code center(str, size, \" \")}.</p>\n     *\n     * <pre>\n     * StringUtils.center(null, *)   = null\n     * StringUtils.center(\"\", 4)     = \"    \"\n     * StringUtils.center(\"ab\", -1)  = \"ab\"\n     * StringUtils.center(\"ab\", 4)   = \" ab \"\n     * StringUtils.center(\"abcd\", 2) = \"abcd\"\n     * StringUtils.center(\"a\", 4)    = \" a  \"\n     * </pre>\n     *\n     * @param str  the String to center, may be null\n     * @param size  the int size of new String, negative treated as zero\n     * @return centered String, {@code null} if null String input\n     */\n    public static String center(final String str, final int size) {\n        return center(str, size, ' ');\n    }\n\n    /**\n     * <p>Centers a String in a larger String of size {@code size}.\n     * Uses a supplied character as the value to pad the String with.</p>\n     *\n     * <p>If the size is less than the String length, the String is returned.\n     * A {@code null} String returns {@code null}.\n     * A negative size is treated as zero.</p>\n     *\n     * <pre>\n     * StringUtils.center(null, *, *)     = null\n     * StringUtils.center(\"\", 4, ' ')     = \"    \"\n     * StringUtils.center(\"ab\", -1, ' ')  = \"ab\"\n     * StringUtils.center(\"ab\", 4, ' ')   = \" ab \"\n     * StringUtils.center(\"abcd\", 2, ' ') = \"abcd\"\n     * StringUtils.center(\"a\", 4, ' ')    = \" a  \"\n     * StringUtils.center(\"a\", 4, 'y')    = \"yayy\"\n     * </pre>\n     *\n     * @param str  the String to center, may be null\n     * @param size  the int size of new String, negative treated as zero\n     * @param padChar  the character to pad the new String with\n     * @return centered String, {@code null} if null String input\n     * @since 2.0\n     */\n    public static String center(String str, final int size, final char padChar) {", "right_context": "}\n\n}", "class_name": "StringUtils", "return_type": "String", "parameters": [{"type": "String", "name": "str"}, {"type": "int", "name": "size"}, {"type": "char", "name": "padChar"}]}}
{"prompt": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Reverses a String that is delimited by a specific character.</p>\n     *\n     * <p>The Strings between the delimiters are not reversed.\n     * Thus java.lang.String becomes String.lang.java (if the delimiter\n     * is {@code '.'}).</p>\n     *\n     * <pre>\n     * StringUtils.reverseDelimited(null, *)      = null\n     * StringUtils.reverseDelimited(\"\", *)        = \"\"\n     * StringUtils.reverseDelimited(\"a.b.c\", 'x') = \"a.b.c\"\n     * StringUtils.reverseDelimited(\"a.b.c\", \".\") = \"c.b.a\"\n     * </pre>\n     *\n     * @param str  the String to reverse, may be null\n     * @param separatorChar  the separator character to use\n     * @return the reversed String, {@code null} if null String input\n     * @since 2.0\n     */\n    public static String reverseDelimited(final String str, final char separatorChar) {\n        if (str == null) {\n            return null;\n        }\n        // could implement manually, but simple way is to reuse other,\n        // probably slower, methods.\n        final String[] strs = split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return join(strs, separatorChar);\n    }\n\n    // Abbreviating\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Abbreviates a String using ellipses. This will turn\n     * \"Now is the time for all good men\" into \"Now is the time for...\"</p>\n     *\n     * <p>Specifically:\n     * <ul>\n     *   <li>If {@code str} is less than {@code maxWidth} characters\n     *       long, return it.</li>\n     *   <li>Else abbreviate it to {@code (substring(str, 0, max-3) + \"...\")}.</li>\n     *   <li>If {@code maxWidth} is less than {@code 4}, throw an\n     *       {@code IllegalArgumentException}.</li>\n     *   <li>In no case will it return a String of length greater than\n     *       {@code maxWidth}.</li>\n     * </ul>\n     * </p>\n     *\n     * <pre>\n     * StringUtils.abbreviate(null, *)      = null\n     * StringUtils.abbreviate(\"\", 4)        = \"\"\n     * StringUtils.abbreviate(\"abcdefg\", 6) = \"abc...\"\n     * StringUtils.abbreviate(\"abcdefg\", 7) = \"abcdefg\"\n     * StringUtils.abbreviate(\"abcdefg\", 8) = \"abcdefg\"\n     * StringUtils.abbreviate(\"abcdefg\", 4) = \"a...\"\n     * StringUtils.abbreviate(\"abcdefg\", 3) = IllegalArgumentException\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param maxWidth  maximum length of result String, must be at least 4\n     * @return abbreviated String, {@code null} if null String input\n     * @throws IllegalArgumentException if the width is too small\n     * @since 2.0\n     */\n    public static String abbreviate(final String str, final int maxWidth) {\n        return abbreviate(str, 0, maxWidth);\n    }\n\n    /**\n     * <p>Abbreviates a String using ellipses. This will turn\n     * \"Now is the time for all good men\" into \"...is the time for...\"</p>\n     *\n     * <p>Works like {@code abbreviate(String, int)}, but allows you to specify\n     * a \"left edge\" offset.  Note that this left edge is not necessarily going to\n     * be the leftmost character in the result, or the first character following the\n     * ellipses, but it will appear somewhere in the result.\n     *\n     * <p>In no case will it return a String of length greater than\n     * {@code maxWidth}.</p>\n     *\n     * <pre>\n     * StringUtils.abbreviate(null, *, *)                = null\n     * StringUtils.abbreviate(\"\", 0, 4)                  = \"\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", -1, 10) = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 0, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 1, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 4, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 5, 10)  = \"...fghi...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 6, 10)  = \"...ghij...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 8, 10)  = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 10, 10) = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 12, 10) = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghij\", 0, 3)        = IllegalArgumentException\n     * StringUtils.abbreviate(\"abcdefghij\", 5, 6)        = IllegalArgumentException\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param offset  left edge of source String\n     * @param maxWidth  maximum length of result String, must be at least 4\n     * @return abbreviated String, {@code null} if null String input\n     * @throws IllegalArgumentException if the width is too small\n     * @since 2.0\n     */\n    public static String abbreviate(final String str, int offset, final int maxWidth) {", "metadata": {"defects4j_task_id": "d0b37a35c0e24e60e47779c414bbf1ca760eb2f3f5b764439c78711d63fefac2", "task_id": "apache_commons-lang/170", "ground_truth": "\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if (str.length() - offset < maxWidth - 3) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        final String abrevMarker = \"...\";\n        if (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + abrevMarker;\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if (offset + maxWidth - 3 < str.length()) {\n            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "StringUtils.java"], "context_start_lineno": 0, "function_name": "abbreviate", "left_context": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Reverses a String that is delimited by a specific character.</p>\n     *\n     * <p>The Strings between the delimiters are not reversed.\n     * Thus java.lang.String becomes String.lang.java (if the delimiter\n     * is {@code '.'}).</p>\n     *\n     * <pre>\n     * StringUtils.reverseDelimited(null, *)      = null\n     * StringUtils.reverseDelimited(\"\", *)        = \"\"\n     * StringUtils.reverseDelimited(\"a.b.c\", 'x') = \"a.b.c\"\n     * StringUtils.reverseDelimited(\"a.b.c\", \".\") = \"c.b.a\"\n     * </pre>\n     *\n     * @param str  the String to reverse, may be null\n     * @param separatorChar  the separator character to use\n     * @return the reversed String, {@code null} if null String input\n     * @since 2.0\n     */\n    public static String reverseDelimited(final String str, final char separatorChar) {\n        if (str == null) {\n            return null;\n        }\n        // could implement manually, but simple way is to reuse other,\n        // probably slower, methods.\n        final String[] strs = split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return join(strs, separatorChar);\n    }\n\n    // Abbreviating\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Abbreviates a String using ellipses. This will turn\n     * \"Now is the time for all good men\" into \"Now is the time for...\"</p>\n     *\n     * <p>Specifically:\n     * <ul>\n     *   <li>If {@code str} is less than {@code maxWidth} characters\n     *       long, return it.</li>\n     *   <li>Else abbreviate it to {@code (substring(str, 0, max-3) + \"...\")}.</li>\n     *   <li>If {@code maxWidth} is less than {@code 4}, throw an\n     *       {@code IllegalArgumentException}.</li>\n     *   <li>In no case will it return a String of length greater than\n     *       {@code maxWidth}.</li>\n     * </ul>\n     * </p>\n     *\n     * <pre>\n     * StringUtils.abbreviate(null, *)      = null\n     * StringUtils.abbreviate(\"\", 4)        = \"\"\n     * StringUtils.abbreviate(\"abcdefg\", 6) = \"abc...\"\n     * StringUtils.abbreviate(\"abcdefg\", 7) = \"abcdefg\"\n     * StringUtils.abbreviate(\"abcdefg\", 8) = \"abcdefg\"\n     * StringUtils.abbreviate(\"abcdefg\", 4) = \"a...\"\n     * StringUtils.abbreviate(\"abcdefg\", 3) = IllegalArgumentException\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param maxWidth  maximum length of result String, must be at least 4\n     * @return abbreviated String, {@code null} if null String input\n     * @throws IllegalArgumentException if the width is too small\n     * @since 2.0\n     */\n    public static String abbreviate(final String str, final int maxWidth) {\n        return abbreviate(str, 0, maxWidth);\n    }\n\n    /**\n     * <p>Abbreviates a String using ellipses. This will turn\n     * \"Now is the time for all good men\" into \"...is the time for...\"</p>\n     *\n     * <p>Works like {@code abbreviate(String, int)}, but allows you to specify\n     * a \"left edge\" offset.  Note that this left edge is not necessarily going to\n     * be the leftmost character in the result, or the first character following the\n     * ellipses, but it will appear somewhere in the result.\n     *\n     * <p>In no case will it return a String of length greater than\n     * {@code maxWidth}.</p>\n     *\n     * <pre>\n     * StringUtils.abbreviate(null, *, *)                = null\n     * StringUtils.abbreviate(\"\", 0, 4)                  = \"\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", -1, 10) = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 0, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 1, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 4, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 5, 10)  = \"...fghi...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 6, 10)  = \"...ghij...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 8, 10)  = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 10, 10) = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 12, 10) = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghij\", 0, 3)        = IllegalArgumentException\n     * StringUtils.abbreviate(\"abcdefghij\", 5, 6)        = IllegalArgumentException\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param offset  left edge of source String\n     * @param maxWidth  maximum length of result String, must be at least 4\n     * @return abbreviated String, {@code null} if null String input\n     * @throws IllegalArgumentException if the width is too small\n     * @since 2.0\n     */\n    public static String abbreviate(final String str, int offset, final int maxWidth) {", "right_context": "}\n\n}", "class_name": "StringUtils", "return_type": "String", "parameters": [{"type": "String", "name": "str"}, {"type": "int", "name": "offset"}, {"type": "int", "name": "maxWidth"}]}}
{"prompt": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Check if a CharSequence starts with a specified prefix.</p>\n     *\n     * <p>{@code null}s are handled without exceptions. Two {@code null}\n     * references are considered to be equal. The comparison is case sensitive.</p>\n     *\n     * <pre>\n     * StringUtils.startsWith(null, null)      = true\n     * StringUtils.startsWith(null, \"abc\")     = false\n     * StringUtils.startsWith(\"abcdef\", null)  = false\n     * StringUtils.startsWith(\"abcdef\", \"abc\") = true\n     * StringUtils.startsWith(\"ABCDEF\", \"abc\") = false\n     * </pre>\n     *\n     * @see java.lang.String#startsWith(String)\n     * @param str  the CharSequence to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @return {@code true} if the CharSequence starts with the prefix, case sensitive, or\n     *  both {@code null}\n     * @since 2.4\n     * @since 3.0 Changed signature from startsWith(String, String) to startsWith(CharSequence, CharSequence)\n     */\n    public static boolean startsWith(final CharSequence str, final CharSequence prefix) {\n        return startsWith(str, prefix, false);\n    }\n\n    /**\n     * <p>Case insensitive check if a CharSequence starts with a specified prefix.</p>\n     *\n     * <p>{@code null}s are handled without exceptions. Two {@code null}\n     * references are considered to be equal. The comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.startsWithIgnoreCase(null, null)      = true\n     * StringUtils.startsWithIgnoreCase(null, \"abc\")     = false\n     * StringUtils.startsWithIgnoreCase(\"abcdef\", null)  = false\n     * StringUtils.startsWithIgnoreCase(\"abcdef\", \"abc\") = true\n     * StringUtils.startsWithIgnoreCase(\"ABCDEF\", \"abc\") = true\n     * </pre>\n     *\n     * @see java.lang.String#startsWith(String)\n     * @param str  the CharSequence to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @return {@code true} if the CharSequence starts with the prefix, case insensitive, or\n     *  both {@code null}\n     * @since 2.4\n     * @since 3.0 Changed signature from startsWithIgnoreCase(String, String) to startsWithIgnoreCase(CharSequence, CharSequence)\n     */\n    public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {\n        return startsWith(str, prefix, true);\n    }\n\n    /**\n     * <p>Check if a CharSequence starts with a specified prefix (optionally case insensitive).</p>\n     *\n     * @see java.lang.String#startsWith(String)\n     * @param str  the CharSequence to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @param ignoreCase indicates whether the compare should ignore case\n     *  (case insensitive) or not.\n     * @return {@code true} if the CharSequence starts with the prefix or\n     *  both {@code null}\n     */\n    private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {", "metadata": {"defects4j_task_id": "cddc1c49e9484e9ca4bc75de41fe2e04c37b00ccdd91a4917e4d6de89fae701c", "task_id": "apache_commons-lang/168", "ground_truth": "\n        if (str == null || prefix == null) {\n            return str == null && prefix == null;\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "StringUtils.java"], "context_start_lineno": 0, "function_name": "startsWith", "left_context": "class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n\n    /**\n     * <p>Check if a CharSequence starts with a specified prefix.</p>\n     *\n     * <p>{@code null}s are handled without exceptions. Two {@code null}\n     * references are considered to be equal. The comparison is case sensitive.</p>\n     *\n     * <pre>\n     * StringUtils.startsWith(null, null)      = true\n     * StringUtils.startsWith(null, \"abc\")     = false\n     * StringUtils.startsWith(\"abcdef\", null)  = false\n     * StringUtils.startsWith(\"abcdef\", \"abc\") = true\n     * StringUtils.startsWith(\"ABCDEF\", \"abc\") = false\n     * </pre>\n     *\n     * @see java.lang.String#startsWith(String)\n     * @param str  the CharSequence to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @return {@code true} if the CharSequence starts with the prefix, case sensitive, or\n     *  both {@code null}\n     * @since 2.4\n     * @since 3.0 Changed signature from startsWith(String, String) to startsWith(CharSequence, CharSequence)\n     */\n    public static boolean startsWith(final CharSequence str, final CharSequence prefix) {\n        return startsWith(str, prefix, false);\n    }\n\n    /**\n     * <p>Case insensitive check if a CharSequence starts with a specified prefix.</p>\n     *\n     * <p>{@code null}s are handled without exceptions. Two {@code null}\n     * references are considered to be equal. The comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.startsWithIgnoreCase(null, null)      = true\n     * StringUtils.startsWithIgnoreCase(null, \"abc\")     = false\n     * StringUtils.startsWithIgnoreCase(\"abcdef\", null)  = false\n     * StringUtils.startsWithIgnoreCase(\"abcdef\", \"abc\") = true\n     * StringUtils.startsWithIgnoreCase(\"ABCDEF\", \"abc\") = true\n     * </pre>\n     *\n     * @see java.lang.String#startsWith(String)\n     * @param str  the CharSequence to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @return {@code true} if the CharSequence starts with the prefix, case insensitive, or\n     *  both {@code null}\n     * @since 2.4\n     * @since 3.0 Changed signature from startsWithIgnoreCase(String, String) to startsWithIgnoreCase(CharSequence, CharSequence)\n     */\n    public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {\n        return startsWith(str, prefix, true);\n    }\n\n    /**\n     * <p>Check if a CharSequence starts with a specified prefix (optionally case insensitive).</p>\n     *\n     * @see java.lang.String#startsWith(String)\n     * @param str  the CharSequence to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @param ignoreCase indicates whether the compare should ignore case\n     *  (case insensitive) or not.\n     * @return {@code true} if the CharSequence starts with the prefix or\n     *  both {@code null}\n     */\n    private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {", "right_context": "}\n\n}", "class_name": "StringUtils", "return_type": "boolean", "parameters": [{"type": "CharSequence", "name": "str"}, {"type": "CharSequence", "name": "prefix"}, {"type": "boolean", "name": "ignoreCase"}]}}
{"prompt": "class ExceptionUtils {\n    \n    /**\n     * <p>Prints a compact stack trace for the root cause of a throwable\n     * to <code>System.err</code>.</p>\n     *\n     * <p>The compact stack trace starts with the root cause and prints\n     * stack frames up to the place where it was caught and wrapped.\n     * Then it prints the wrapped exception and continues with stack frames\n     * until the wrapper exception is caught and wrapped again, etc.</p>\n     *\n     * <p>The output of this method is consistent across JDK versions.\n     * Note that this is the opposite order to the JDK1.4 display.</p>\n     *\n     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n     * that don't have nested causes.</p>\n     *\n     * @param throwable  the throwable to output\n     * @since 2.0\n     */\n    public static void printRootCauseStackTrace(final Throwable throwable) {\n        printRootCauseStackTrace(throwable, System.err);\n    }\n\n    /**\n     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n     *\n     * <p>The compact stack trace starts with the root cause and prints\n     * stack frames up to the place where it was caught and wrapped.\n     * Then it prints the wrapped exception and continues with stack frames\n     * until the wrapper exception is caught and wrapped again, etc.</p>\n     *\n     * <p>The output of this method is consistent across JDK versions.\n     * Note that this is the opposite order to the JDK1.4 display.</p>\n     *\n     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n     * that don't have nested causes.</p>\n     *\n     * @param throwable  the throwable to output, may be null\n     * @param stream  the stream to output to, may not be null\n     * @throws IllegalArgumentException if the stream is <code>null</code>\n     * @since 2.0\n     */\n    public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream) {\n        if (throwable == null) {\n            return;\n        }\n        if (stream == null) {\n            throw new IllegalArgumentException(\"The PrintStream must not be null\");\n        }\n        final String trace[] = getRootCauseStackTrace(throwable);\n        for (final String element : trace) {\n            stream.println(element);\n        }\n        stream.flush();\n    }\n\n    /**\n     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n     *\n     * <p>The compact stack trace starts with the root cause and prints\n     * stack frames up to the place where it was caught and wrapped.\n     * Then it prints the wrapped exception and continues with stack frames\n     * until the wrapper exception is caught and wrapped again, etc.</p>\n     *\n     * <p>The output of this method is consistent across JDK versions.\n     * Note that this is the opposite order to the JDK1.4 display.</p>\n     *\n     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n     * that don't have nested causes.</p>\n     *\n     * @param throwable  the throwable to output, may be null\n     * @param writer  the writer to output to, may not be null\n     * @throws IllegalArgumentException if the writer is <code>null</code>\n     * @since 2.0\n     */\n    public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) {\n        if (throwable == null) {\n            return;\n        }\n        if (writer == null) {\n            throw new IllegalArgumentException(\"The PrintWriter must not be null\");\n        }\n        final String trace[] = getRootCauseStackTrace(throwable);\n        for (final String element : trace) {\n            writer.println(element);\n        }\n        writer.flush();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Creates a compact stack trace for the root cause of the supplied\n     * <code>Throwable</code>.</p>\n     *\n     * <p>The output of this method is consistent across JDK versions.\n     * It consists of the root exception followed by each of its wrapping\n     * exceptions separated by '[wrapped]'. Note that this is the opposite\n     * order to the JDK1.4 display.</p>\n     *\n     * @param throwable  the throwable to examine, may be null\n     * @return an array of stack trace frames, never null\n     * @since 2.0\n     */\n    public static String[] getRootCauseStackTrace(final Throwable throwable) {\n        if (throwable == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final Throwable throwables[] = getThrowables(throwable);\n        final int count = throwables.length;\n        final List<String> frames = new ArrayList<String>();\n        List<String> nextTrace = getStackFrameList(throwables[count - 1]);\n        for (int i = count; --i >= 0;) {\n            final List<String> trace = nextTrace;\n            if (i != 0) {\n                nextTrace = getStackFrameList(throwables[i - 1]);\n                removeCommonFrames(trace, nextTrace);\n            }\n            if (i == count - 1) {\n                frames.add(throwables[i].toString());\n            } else {\n                frames.add(WRAPPED_MARKER + throwables[i].toString());\n            }\n            for (int j = 0; j < trace.size(); j++) {\n                frames.add(trace.get(j));\n            }\n        }\n        return frames.toArray(new String[frames.size()]);\n    }\n\n    /**\n     * <p>Removes common frames from the cause trace given the two stack traces.</p>\n     *\n     * @param causeFrames  stack trace of a cause throwable\n     * @param wrapperFrames  stack trace of a wrapper throwable\n     * @throws IllegalArgumentException if either argument is null\n     * @since 2.0\n     */\n    public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) {\n        if (causeFrames == null || wrapperFrames == null) {\n            throw new IllegalArgumentException(\"The List must not be null\");\n        }\n        int causeFrameIndex = causeFrames.size() - 1;\n        int wrapperFrameIndex = wrapperFrames.size() - 1;\n        while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n            // Remove the frame from the cause trace if it is the same\n            // as in the wrapper trace\n            final String causeFrame = causeFrames.get(causeFrameIndex);\n            final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);\n            if (causeFrame.equals(wrapperFrame)) {\n                causeFrames.remove(causeFrameIndex);\n            }\n            causeFrameIndex--;\n            wrapperFrameIndex--;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets the stack trace from a Throwable as a String.</p>\n     *\n     * <p>The result of this method vary by JDK version as this method\n     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n     * On JDK1.3 and earlier, the cause exception will not be shown\n     * unless the specified throwable alters printStackTrace.</p>\n     *\n     * @param throwable  the <code>Throwable</code> to be examined\n     * @return the stack trace as generated by the exception's\n     *  <code>printStackTrace(PrintWriter)</code> method\n     */\n    public static String getStackTrace(final Throwable throwable) {", "metadata": {"defects4j_task_id": "1ef63d15d371dc2c7582b83cbbcb4192e5f90ecbb264b51a0a5045adf6794f27", "task_id": "apache_commons-lang/31", "ground_truth": "\n        final StringWriter sw = new StringWriter();\n        final PrintWriter pw = new PrintWriter(sw, true);\n        throwable.printStackTrace(pw);\n        return sw.getBuffer().toString();\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "exception", "ExceptionUtils.java"], "context_start_lineno": 0, "function_name": "getStackTrace", "left_context": "class ExceptionUtils {\n    \n    /**\n     * <p>Prints a compact stack trace for the root cause of a throwable\n     * to <code>System.err</code>.</p>\n     *\n     * <p>The compact stack trace starts with the root cause and prints\n     * stack frames up to the place where it was caught and wrapped.\n     * Then it prints the wrapped exception and continues with stack frames\n     * until the wrapper exception is caught and wrapped again, etc.</p>\n     *\n     * <p>The output of this method is consistent across JDK versions.\n     * Note that this is the opposite order to the JDK1.4 display.</p>\n     *\n     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n     * that don't have nested causes.</p>\n     *\n     * @param throwable  the throwable to output\n     * @since 2.0\n     */\n    public static void printRootCauseStackTrace(final Throwable throwable) {\n        printRootCauseStackTrace(throwable, System.err);\n    }\n\n    /**\n     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n     *\n     * <p>The compact stack trace starts with the root cause and prints\n     * stack frames up to the place where it was caught and wrapped.\n     * Then it prints the wrapped exception and continues with stack frames\n     * until the wrapper exception is caught and wrapped again, etc.</p>\n     *\n     * <p>The output of this method is consistent across JDK versions.\n     * Note that this is the opposite order to the JDK1.4 display.</p>\n     *\n     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n     * that don't have nested causes.</p>\n     *\n     * @param throwable  the throwable to output, may be null\n     * @param stream  the stream to output to, may not be null\n     * @throws IllegalArgumentException if the stream is <code>null</code>\n     * @since 2.0\n     */\n    public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream) {\n        if (throwable == null) {\n            return;\n        }\n        if (stream == null) {\n            throw new IllegalArgumentException(\"The PrintStream must not be null\");\n        }\n        final String trace[] = getRootCauseStackTrace(throwable);\n        for (final String element : trace) {\n            stream.println(element);\n        }\n        stream.flush();\n    }\n\n    /**\n     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n     *\n     * <p>The compact stack trace starts with the root cause and prints\n     * stack frames up to the place where it was caught and wrapped.\n     * Then it prints the wrapped exception and continues with stack frames\n     * until the wrapper exception is caught and wrapped again, etc.</p>\n     *\n     * <p>The output of this method is consistent across JDK versions.\n     * Note that this is the opposite order to the JDK1.4 display.</p>\n     *\n     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n     * that don't have nested causes.</p>\n     *\n     * @param throwable  the throwable to output, may be null\n     * @param writer  the writer to output to, may not be null\n     * @throws IllegalArgumentException if the writer is <code>null</code>\n     * @since 2.0\n     */\n    public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) {\n        if (throwable == null) {\n            return;\n        }\n        if (writer == null) {\n            throw new IllegalArgumentException(\"The PrintWriter must not be null\");\n        }\n        final String trace[] = getRootCauseStackTrace(throwable);\n        for (final String element : trace) {\n            writer.println(element);\n        }\n        writer.flush();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Creates a compact stack trace for the root cause of the supplied\n     * <code>Throwable</code>.</p>\n     *\n     * <p>The output of this method is consistent across JDK versions.\n     * It consists of the root exception followed by each of its wrapping\n     * exceptions separated by '[wrapped]'. Note that this is the opposite\n     * order to the JDK1.4 display.</p>\n     *\n     * @param throwable  the throwable to examine, may be null\n     * @return an array of stack trace frames, never null\n     * @since 2.0\n     */\n    public static String[] getRootCauseStackTrace(final Throwable throwable) {\n        if (throwable == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final Throwable throwables[] = getThrowables(throwable);\n        final int count = throwables.length;\n        final List<String> frames = new ArrayList<String>();\n        List<String> nextTrace = getStackFrameList(throwables[count - 1]);\n        for (int i = count; --i >= 0;) {\n            final List<String> trace = nextTrace;\n            if (i != 0) {\n                nextTrace = getStackFrameList(throwables[i - 1]);\n                removeCommonFrames(trace, nextTrace);\n            }\n            if (i == count - 1) {\n                frames.add(throwables[i].toString());\n            } else {\n                frames.add(WRAPPED_MARKER + throwables[i].toString());\n            }\n            for (int j = 0; j < trace.size(); j++) {\n                frames.add(trace.get(j));\n            }\n        }\n        return frames.toArray(new String[frames.size()]);\n    }\n\n    /**\n     * <p>Removes common frames from the cause trace given the two stack traces.</p>\n     *\n     * @param causeFrames  stack trace of a cause throwable\n     * @param wrapperFrames  stack trace of a wrapper throwable\n     * @throws IllegalArgumentException if either argument is null\n     * @since 2.0\n     */\n    public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) {\n        if (causeFrames == null || wrapperFrames == null) {\n            throw new IllegalArgumentException(\"The List must not be null\");\n        }\n        int causeFrameIndex = causeFrames.size() - 1;\n        int wrapperFrameIndex = wrapperFrames.size() - 1;\n        while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n            // Remove the frame from the cause trace if it is the same\n            // as in the wrapper trace\n            final String causeFrame = causeFrames.get(causeFrameIndex);\n            final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);\n            if (causeFrame.equals(wrapperFrame)) {\n                causeFrames.remove(causeFrameIndex);\n            }\n            causeFrameIndex--;\n            wrapperFrameIndex--;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets the stack trace from a Throwable as a String.</p>\n     *\n     * <p>The result of this method vary by JDK version as this method\n     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n     * On JDK1.3 and earlier, the cause exception will not be shown\n     * unless the specified throwable alters printStackTrace.</p>\n     *\n     * @param throwable  the <code>Throwable</code> to be examined\n     * @return the stack trace as generated by the exception's\n     *  <code>printStackTrace(PrintWriter)</code> method\n     */\n    public static String getStackTrace(final Throwable throwable) {", "right_context": "}\n\n}", "class_name": "ExceptionUtils", "return_type": "String", "parameters": [{"type": "Throwable", "name": "throwable"}]}}
{"prompt": "class ExceptionUtils {\n    \n    /**\n     * <p>Creates a compact stack trace for the root cause of the supplied\n     * <code>Throwable</code>.</p>\n     *\n     * <p>The output of this method is consistent across JDK versions.\n     * It consists of the root exception followed by each of its wrapping\n     * exceptions separated by '[wrapped]'. Note that this is the opposite\n     * order to the JDK1.4 display.</p>\n     *\n     * @param throwable  the throwable to examine, may be null\n     * @return an array of stack trace frames, never null\n     * @since 2.0\n     */\n    public static String[] getRootCauseStackTrace(final Throwable throwable) {\n        if (throwable == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final Throwable throwables[] = getThrowables(throwable);\n        final int count = throwables.length;\n        final List<String> frames = new ArrayList<String>();\n        List<String> nextTrace = getStackFrameList(throwables[count - 1]);\n        for (int i = count; --i >= 0;) {\n            final List<String> trace = nextTrace;\n            if (i != 0) {\n                nextTrace = getStackFrameList(throwables[i - 1]);\n                removeCommonFrames(trace, nextTrace);\n            }\n            if (i == count - 1) {\n                frames.add(throwables[i].toString());\n            } else {\n                frames.add(WRAPPED_MARKER + throwables[i].toString());\n            }\n            for (int j = 0; j < trace.size(); j++) {\n                frames.add(trace.get(j));\n            }\n        }\n        return frames.toArray(new String[frames.size()]);\n    }\n\n    /**\n     * <p>Removes common frames from the cause trace given the two stack traces.</p>\n     *\n     * @param causeFrames  stack trace of a cause throwable\n     * @param wrapperFrames  stack trace of a wrapper throwable\n     * @throws IllegalArgumentException if either argument is null\n     * @since 2.0\n     */\n    public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) {\n        if (causeFrames == null || wrapperFrames == null) {\n            throw new IllegalArgumentException(\"The List must not be null\");\n        }\n        int causeFrameIndex = causeFrames.size() - 1;\n        int wrapperFrameIndex = wrapperFrames.size() - 1;\n        while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n            // Remove the frame from the cause trace if it is the same\n            // as in the wrapper trace\n            final String causeFrame = causeFrames.get(causeFrameIndex);\n            final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);\n            if (causeFrame.equals(wrapperFrame)) {\n                causeFrames.remove(causeFrameIndex);\n            }\n            causeFrameIndex--;\n            wrapperFrameIndex--;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets the stack trace from a Throwable as a String.</p>\n     *\n     * <p>The result of this method vary by JDK version as this method\n     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n     * On JDK1.3 and earlier, the cause exception will not be shown\n     * unless the specified throwable alters printStackTrace.</p>\n     *\n     * @param throwable  the <code>Throwable</code> to be examined\n     * @return the stack trace as generated by the exception's\n     *  <code>printStackTrace(PrintWriter)</code> method\n     */\n    public static String getStackTrace(final Throwable throwable) {\n        final StringWriter sw = new StringWriter();\n        final PrintWriter pw = new PrintWriter(sw, true);\n        throwable.printStackTrace(pw);\n        return sw.getBuffer().toString();\n    }\n\n    /**\n     * <p>Captures the stack trace associated with the specified\n     * <code>Throwable</code> object, decomposing it into a list of\n     * stack frames.</p>\n     *\n     * <p>The result of this method vary by JDK version as this method\n     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n     * On JDK1.3 and earlier, the cause exception will not be shown\n     * unless the specified throwable alters printStackTrace.</p>\n     *\n     * @param throwable  the <code>Throwable</code> to examine, may be null\n     * @return an array of strings describing each stack frame, never null\n     */\n    public static String[] getStackFrames(final Throwable throwable) {\n        if (throwable == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        return getStackFrames(getStackTrace(throwable));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Returns an array where each element is a line from the argument.</p>\n     *\n     * <p>The end of line is determined by the value of {@link SystemUtils#LINE_SEPARATOR}.</p>\n     *\n     * @param stackTrace  a stack trace String\n     * @return an array where each element is a line from the argument\n     */\n    static String[] getStackFrames(final String stackTrace) {\n        final String linebreak = SystemUtils.LINE_SEPARATOR;\n        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n        final List<String> list = new ArrayList<String>();\n        while (frames.hasMoreTokens()) {\n            list.add(frames.nextToken());\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * <p>Produces a <code>List</code> of stack frames - the message\n     * is not included. Only the trace of the specified exception is\n     * returned, any caused by trace is stripped.</p>\n     *\n     * <p>This works in most cases - it will only fail if the exception\n     * message contains a line that starts with:\n     * <code>&quot;&nbsp;&nbsp;&nbsp;at&quot;.</code></p>\n     * \n     * @param t is any throwable\n     * @return List of stack frames\n     */\n    static List<String> getStackFrameList(final Throwable t) {", "metadata": {"defects4j_task_id": "71b1323fbc568536c00810ee6f93f2b65426619007052c7b05b62a7708acf135", "task_id": "apache_commons-lang/96", "ground_truth": "\n        final String stackTrace = getStackTrace(t);\n        final String linebreak = SystemUtils.LINE_SEPARATOR;\n        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n        final List<String> list = new ArrayList<String>();\n        boolean traceStarted = false;\n        while (frames.hasMoreTokens()) {\n            final String token = frames.nextToken();\n            // Determine if the line starts with <whitespace>at\n            final int at = token.indexOf(\"at\");\n            if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n                traceStarted = true;\n                list.add(token);\n            } else if (traceStarted) {\n                break;\n            }\n        }\n        return list;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "exception", "ExceptionUtils.java"], "context_start_lineno": 0, "function_name": "getStackFrameList", "left_context": "class ExceptionUtils {\n    \n    /**\n     * <p>Creates a compact stack trace for the root cause of the supplied\n     * <code>Throwable</code>.</p>\n     *\n     * <p>The output of this method is consistent across JDK versions.\n     * It consists of the root exception followed by each of its wrapping\n     * exceptions separated by '[wrapped]'. Note that this is the opposite\n     * order to the JDK1.4 display.</p>\n     *\n     * @param throwable  the throwable to examine, may be null\n     * @return an array of stack trace frames, never null\n     * @since 2.0\n     */\n    public static String[] getRootCauseStackTrace(final Throwable throwable) {\n        if (throwable == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final Throwable throwables[] = getThrowables(throwable);\n        final int count = throwables.length;\n        final List<String> frames = new ArrayList<String>();\n        List<String> nextTrace = getStackFrameList(throwables[count - 1]);\n        for (int i = count; --i >= 0;) {\n            final List<String> trace = nextTrace;\n            if (i != 0) {\n                nextTrace = getStackFrameList(throwables[i - 1]);\n                removeCommonFrames(trace, nextTrace);\n            }\n            if (i == count - 1) {\n                frames.add(throwables[i].toString());\n            } else {\n                frames.add(WRAPPED_MARKER + throwables[i].toString());\n            }\n            for (int j = 0; j < trace.size(); j++) {\n                frames.add(trace.get(j));\n            }\n        }\n        return frames.toArray(new String[frames.size()]);\n    }\n\n    /**\n     * <p>Removes common frames from the cause trace given the two stack traces.</p>\n     *\n     * @param causeFrames  stack trace of a cause throwable\n     * @param wrapperFrames  stack trace of a wrapper throwable\n     * @throws IllegalArgumentException if either argument is null\n     * @since 2.0\n     */\n    public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) {\n        if (causeFrames == null || wrapperFrames == null) {\n            throw new IllegalArgumentException(\"The List must not be null\");\n        }\n        int causeFrameIndex = causeFrames.size() - 1;\n        int wrapperFrameIndex = wrapperFrames.size() - 1;\n        while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n            // Remove the frame from the cause trace if it is the same\n            // as in the wrapper trace\n            final String causeFrame = causeFrames.get(causeFrameIndex);\n            final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);\n            if (causeFrame.equals(wrapperFrame)) {\n                causeFrames.remove(causeFrameIndex);\n            }\n            causeFrameIndex--;\n            wrapperFrameIndex--;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets the stack trace from a Throwable as a String.</p>\n     *\n     * <p>The result of this method vary by JDK version as this method\n     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n     * On JDK1.3 and earlier, the cause exception will not be shown\n     * unless the specified throwable alters printStackTrace.</p>\n     *\n     * @param throwable  the <code>Throwable</code> to be examined\n     * @return the stack trace as generated by the exception's\n     *  <code>printStackTrace(PrintWriter)</code> method\n     */\n    public static String getStackTrace(final Throwable throwable) {\n        final StringWriter sw = new StringWriter();\n        final PrintWriter pw = new PrintWriter(sw, true);\n        throwable.printStackTrace(pw);\n        return sw.getBuffer().toString();\n    }\n\n    /**\n     * <p>Captures the stack trace associated with the specified\n     * <code>Throwable</code> object, decomposing it into a list of\n     * stack frames.</p>\n     *\n     * <p>The result of this method vary by JDK version as this method\n     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n     * On JDK1.3 and earlier, the cause exception will not be shown\n     * unless the specified throwable alters printStackTrace.</p>\n     *\n     * @param throwable  the <code>Throwable</code> to examine, may be null\n     * @return an array of strings describing each stack frame, never null\n     */\n    public static String[] getStackFrames(final Throwable throwable) {\n        if (throwable == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        return getStackFrames(getStackTrace(throwable));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Returns an array where each element is a line from the argument.</p>\n     *\n     * <p>The end of line is determined by the value of {@link SystemUtils#LINE_SEPARATOR}.</p>\n     *\n     * @param stackTrace  a stack trace String\n     * @return an array where each element is a line from the argument\n     */\n    static String[] getStackFrames(final String stackTrace) {\n        final String linebreak = SystemUtils.LINE_SEPARATOR;\n        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n        final List<String> list = new ArrayList<String>();\n        while (frames.hasMoreTokens()) {\n            list.add(frames.nextToken());\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * <p>Produces a <code>List</code> of stack frames - the message\n     * is not included. Only the trace of the specified exception is\n     * returned, any caused by trace is stripped.</p>\n     *\n     * <p>This works in most cases - it will only fail if the exception\n     * message contains a line that starts with:\n     * <code>&quot;&nbsp;&nbsp;&nbsp;at&quot;.</code></p>\n     * \n     * @param t is any throwable\n     * @return List of stack frames\n     */\n    static List<String> getStackFrameList(final Throwable t) {", "right_context": "}\n\n}", "class_name": "ExceptionUtils", "return_type": "List<String>", "parameters": [{"type": "Throwable", "name": "t"}]}}
{"prompt": "class NumberUtils {\n    \n    /**\n     * <p>Utility method for {@link #createNumber(java.lang.String)}.</p>\n     *\n     * <p>Returns <code>true</code> if s is <code>null</code>.</p>\n     * \n     * @param str  the String to check\n     * @return if it is all zeros or <code>null</code>\n     */\n    private static boolean isAllZeros(final String str) {\n        if (str == null) {\n            return true;\n        }\n        for (int i = str.length() - 1; i >= 0; i--) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        return str.length() > 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Convert a <code>String</code> to a <code>Float</code>.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Float</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Float createFloat(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return Float.valueOf(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>Double</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Double</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Double createDouble(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return Double.valueOf(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(final String str) {\n        if (str == null) {\n            return null;\n        }\n        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n        return Integer.decode(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>Long</code>; \n     * since 3.1 it handles hex and octal notations.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Long</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Long createLong(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return Long.decode(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigInteger</code>;\n     * since 3.2 it handles hex (0x or #) and octal (0) notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigInteger</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigInteger createBigInteger(final String str) {", "metadata": {"defects4j_task_id": "5e41187c16e6acd79f435b1a18312ee7ed86ff3a228e95c6269e523e78c37552", "task_id": "apache_commons-lang/81", "ground_truth": "\n        if (str == null) {\n            return null;\n        }\n        int pos = 0; // offset within string\n        int radix = 10;\n        boolean negate = false; // need to negate later?\n        if (str.startsWith(\"-\")) {\n            negate = true;\n            pos = 1;\n        }\n        if (str.startsWith(\"0x\", pos) || str.startsWith(\"0x\", pos)) { // hex\n            radix = 16;\n            pos += 2;\n        } else if (str.startsWith(\"#\", pos)) { // alternative hex (allowed by Long/Integer)\n            radix = 16;\n            pos ++;\n        } else if (str.startsWith(\"0\", pos) && str.length() > pos + 1) { // octal; so long as there are additional digits\n            radix = 8;\n            pos ++;\n        } // default is to treat as decimal\n\n        final BigInteger value = new BigInteger(str.substring(pos), radix);\n        return negate ? value.negate() : value;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "math", "NumberUtils.java"], "context_start_lineno": 0, "function_name": "createBigInteger", "left_context": "class NumberUtils {\n    \n    /**\n     * <p>Utility method for {@link #createNumber(java.lang.String)}.</p>\n     *\n     * <p>Returns <code>true</code> if s is <code>null</code>.</p>\n     * \n     * @param str  the String to check\n     * @return if it is all zeros or <code>null</code>\n     */\n    private static boolean isAllZeros(final String str) {\n        if (str == null) {\n            return true;\n        }\n        for (int i = str.length() - 1; i >= 0; i--) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        return str.length() > 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Convert a <code>String</code> to a <code>Float</code>.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Float</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Float createFloat(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return Float.valueOf(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>Double</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Double</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Double createDouble(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return Double.valueOf(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(final String str) {\n        if (str == null) {\n            return null;\n        }\n        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n        return Integer.decode(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>Long</code>; \n     * since 3.1 it handles hex and octal notations.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Long</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Long createLong(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return Long.decode(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigInteger</code>;\n     * since 3.2 it handles hex (0x or #) and octal (0) notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigInteger</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigInteger createBigInteger(final String str) {", "right_context": "}\n\n}", "class_name": "NumberUtils", "return_type": "BigInteger", "parameters": [{"type": "String", "name": "str"}]}}
{"prompt": "class ClassUtils {\n\n    /**\n     * <p>Gets the class name minus the package name for an {@code Object}.</p>\n     *\n     * @param object  the class to get the short name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the class name of the object without the package name, or the null value\n     */\n    public static String getShortClassName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }\n\n    /**\n     * <p>Gets the class name minus the package name from a {@code Class}.</p>\n     *\n     * <p>Consider using the Java 5 API {@link Class#getSimpleName()} instead.\n     * The one known difference is that this code will return {@code \"Map.Entry\"} while\n     * the {@code java.lang.Class} variant will simply return {@code \"Entry\"}. </p>\n     *\n     * @param cls  the class to get the short name for.\n     * @return the class name without the package name or an empty string\n     */\n    public static String getShortClassName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortClassName(cls.getName());\n    }\n\n    /**\n     * <p>Gets the class name minus the package name from a String.</p>\n     *\n     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n\n     * <p>Note that this method differs from Class.getSimpleName() in that this will\n     * return {@code \"Map.Entry\"} whilst the {@code java.lang.Class} variant will simply\n     * return {@code \"Entry\"}. </p>\n     *\n     * @param className  the className to get the short name for\n     * @return the class name of the class without the package name or an empty string\n     */\n    public static String getShortClassName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        final StringBuilder arrayPrefix = new StringBuilder();\n\n        // Handle array encoding\n        if (className.startsWith(\"[\")) {\n            while (className.charAt(0) == '[') {\n                className = className.substring(1);\n                arrayPrefix.append(\"[]\");\n            }\n            // Strip Object type encoding\n            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n                className = className.substring(1, className.length() - 1);\n            }\n\n            if (reverseAbbreviationMap.containsKey(className)) {\n                className = reverseAbbreviationMap.get(className);\n            }\n        }\n\n        final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        final int innerIdx = className.indexOf(\n                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n        String out = className.substring(lastDotIdx + 1);\n        if (innerIdx != -1) {\n            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n        }\n        return out + arrayPrefix;\n    }\n\n    /**\n     * <p>Null-safe version of <code>aClass.getSimpleName()</code></p>\n     *\n     * @param cls the class for which to get the simple name.\n     * @return the simple class name.\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return cls.getSimpleName();\n    }\n\n    /**\n     * <p>Null-safe version of <code>aClass.getSimpleName()</code></p>\n     *\n     * @param object the object for which to get the simple class name.\n     * @param valueIfNull the value to return if <code>object</code> is <code>null</code>\n     * @return the simple class name.\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getSimpleName(object.getClass());\n    }\n\n    // Package name\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets the package name of an {@code Object}.</p>\n     *\n     * @param object  the class to get the package name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the package name of the object, or the null value\n     */\n    public static String getPackageName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }\n\n    /**\n     * <p>Gets the package name of a {@code Class}.</p>\n     *\n     * @param cls  the class to get the package name for, may be {@code null}.\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageName(cls.getName());\n    }\n\n    /**\n     * <p>Gets the package name from a {@code String}.</p>\n     *\n     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n     * <p>If the class is unpackaged, return an empty string.</p>\n     *\n     * @param className  the className to get the package name for, may be {@code null}\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        // Strip array encoding\n        while (className.charAt(0) == '[') {\n            className = className.substring(1);\n        }\n        // Strip Object type encoding\n        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n            className = className.substring(1);\n        }\n\n        final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        if (i == -1) {\n            return StringUtils.EMPTY;\n        }\n        return className.substring(0, i);\n    }\n\n    // Superclasses/Superinterfaces\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets a {@code List} of superclasses for the given class.</p>\n     *\n     * @param cls  the class to look up, may be {@code null}\n     * @return the {@code List} of superclasses in order going up from this one\n     *  {@code null} if null input\n     */\n    public static List<Class<?>> getAllSuperclasses(final Class<?> cls) {", "metadata": {"defects4j_task_id": "56d008b6b15494794c8b0072af946e3184f828f48a537d4cc6219d54c5803c06", "task_id": "apache_commons-lang/76", "ground_truth": "\n        if (cls == null) {\n            return null;\n        }\n        final List<Class<?>> classes = new ArrayList<Class<?>>();\n        Class<?> superclass = cls.getSuperclass();\n        while (superclass != null) {\n            classes.add(superclass);\n            superclass = superclass.getSuperclass();\n        }\n        return classes;\n    ", "fpath_tuple": ["apache_commons-lang", "commons-lang", "src", "main", "java", "org", "apache", "commons", "lang3", "ClassUtils.java"], "context_start_lineno": 0, "function_name": "getAllSuperclasses", "left_context": "class ClassUtils {\n\n    /**\n     * <p>Gets the class name minus the package name for an {@code Object}.</p>\n     *\n     * @param object  the class to get the short name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the class name of the object without the package name, or the null value\n     */\n    public static String getShortClassName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }\n\n    /**\n     * <p>Gets the class name minus the package name from a {@code Class}.</p>\n     *\n     * <p>Consider using the Java 5 API {@link Class#getSimpleName()} instead.\n     * The one known difference is that this code will return {@code \"Map.Entry\"} while\n     * the {@code java.lang.Class} variant will simply return {@code \"Entry\"}. </p>\n     *\n     * @param cls  the class to get the short name for.\n     * @return the class name without the package name or an empty string\n     */\n    public static String getShortClassName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortClassName(cls.getName());\n    }\n\n    /**\n     * <p>Gets the class name minus the package name from a String.</p>\n     *\n     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n\n     * <p>Note that this method differs from Class.getSimpleName() in that this will\n     * return {@code \"Map.Entry\"} whilst the {@code java.lang.Class} variant will simply\n     * return {@code \"Entry\"}. </p>\n     *\n     * @param className  the className to get the short name for\n     * @return the class name of the class without the package name or an empty string\n     */\n    public static String getShortClassName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        final StringBuilder arrayPrefix = new StringBuilder();\n\n        // Handle array encoding\n        if (className.startsWith(\"[\")) {\n            while (className.charAt(0) == '[') {\n                className = className.substring(1);\n                arrayPrefix.append(\"[]\");\n            }\n            // Strip Object type encoding\n            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n                className = className.substring(1, className.length() - 1);\n            }\n\n            if (reverseAbbreviationMap.containsKey(className)) {\n                className = reverseAbbreviationMap.get(className);\n            }\n        }\n\n        final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        final int innerIdx = className.indexOf(\n                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n        String out = className.substring(lastDotIdx + 1);\n        if (innerIdx != -1) {\n            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n        }\n        return out + arrayPrefix;\n    }\n\n    /**\n     * <p>Null-safe version of <code>aClass.getSimpleName()</code></p>\n     *\n     * @param cls the class for which to get the simple name.\n     * @return the simple class name.\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return cls.getSimpleName();\n    }\n\n    /**\n     * <p>Null-safe version of <code>aClass.getSimpleName()</code></p>\n     *\n     * @param object the object for which to get the simple class name.\n     * @param valueIfNull the value to return if <code>object</code> is <code>null</code>\n     * @return the simple class name.\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getSimpleName(object.getClass());\n    }\n\n    // Package name\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets the package name of an {@code Object}.</p>\n     *\n     * @param object  the class to get the package name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the package name of the object, or the null value\n     */\n    public static String getPackageName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }\n\n    /**\n     * <p>Gets the package name of a {@code Class}.</p>\n     *\n     * @param cls  the class to get the package name for, may be {@code null}.\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageName(cls.getName());\n    }\n\n    /**\n     * <p>Gets the package name from a {@code String}.</p>\n     *\n     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n     * <p>If the class is unpackaged, return an empty string.</p>\n     *\n     * @param className  the className to get the package name for, may be {@code null}\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        // Strip array encoding\n        while (className.charAt(0) == '[') {\n            className = className.substring(1);\n        }\n        // Strip Object type encoding\n        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n            className = className.substring(1);\n        }\n\n        final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        if (i == -1) {\n            return StringUtils.EMPTY;\n        }\n        return className.substring(0, i);\n    }\n\n    // Superclasses/Superinterfaces\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets a {@code List} of superclasses for the given class.</p>\n     *\n     * @param cls  the class to look up, may be {@code null}\n     * @return the {@code List} of superclasses in order going up from this one\n     *  {@code null} if null input\n     */\n    public static List<Class<?>> getAllSuperclasses(final Class<?> cls) {", "right_context": "}\n\n}", "class_name": "ClassUtils", "return_type": "List<Class<?>>", "parameters": [{"type": "Class<?>", "name": "cls"}]}}
{"prompt": "class TransformedSet<E> extends TransformedCollection<E> implements Set<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 306127383500410386L;\n\n    /**\n     * Factory method to create a transforming set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedSet(Set, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed set\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedSet<E> transformingSet(final Set<E> set,\n            final Transformer<? super E, ? extends E> transformer) {\n        return new TransformedSet<E>(set, transformer);\n    }\n\n    /**\n     * Factory method to create a transforming set that will transform\n     * existing contents of the specified set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingSet(Set, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed set\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0\n     */\n    public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {", "metadata": {"defects4j_task_id": "9535e644850b7403d5ebfa2fd10028125cf891e66c2715a148cedc698fabea51", "task_id": "apache_commons-collections/121", "ground_truth": "\n        final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n        if (set.size() > 0) {\n            @SuppressWarnings(\"unchecked\") // set is type E\n            final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics\n            set.clear();\n            for (final E value : values) {\n                decorated.decorated().add(transformer.transform(value));\n            }\n        }\n        return decorated;\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "set", "TransformedSet.java"], "context_start_lineno": 0, "function_name": "transformedSet", "left_context": "class TransformedSet<E> extends TransformedCollection<E> implements Set<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 306127383500410386L;\n\n    /**\n     * Factory method to create a transforming set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedSet(Set, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed set\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedSet<E> transformingSet(final Set<E> set,\n            final Transformer<? super E, ? extends E> transformer) {\n        return new TransformedSet<E>(set, transformer);\n    }\n\n    /**\n     * Factory method to create a transforming set that will transform\n     * existing contents of the specified set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingSet(Set, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed set\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0\n     */\n    public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {", "right_context": "}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\n    protected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n        super(set, transformer);\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n}", "class_name": "TransformedSet", "return_type": "Set<E>", "parameters": [{"type": "Set<E>", "name": "set"}, {"type": "Transformer<? super E,? extends E>", "name": "transformer"}]}}
{"prompt": "class ListOrderedSet<E>\n    extends AbstractSerializableSetDecorator<E> {\n\n    /** Internal list to hold the sequence of objects */\n    private final List<E> setOrder;\n\n    /**\n     * Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {\n        if (set == null) {\n            throw new NullPointerException(\"Set must not be null\");\n        }\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        if (set.size() > 0 || list.size() > 0) {\n            throw new IllegalArgumentException(\"Set and List must be empty\");\n        }\n        return new ListOrderedSet<E>(set, list);\n    }\n\n    /**\n     * Factory method to create an ordered set.\n     * <p>\n     * An <code>ArrayList</code> is used to retain order.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must not be null\n     * @return a new ordered set\n     * @throws NullPointerException if set is null\n     * @since 4.0\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {\n        return new ListOrderedSet<E>(set);\n    }\n\n    /**\n     * Factory method to create an ordered set using the supplied list to retain order.\n     * <p>\n     * A <code>HashSet</code> is used for the set behaviour.\n     * <p>\n     * NOTE: If the list contains duplicates, the duplicates are removed,\n     * altering the specified list.\n     *\n     * @param <E> the element type\n     * @param list the list to decorate, must not be null\n     * @return a new ordered set\n     * @throws NullPointerException if list is null\n     * @since 4.0\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {", "metadata": {"defects4j_task_id": "30acdca2db283d6c4271729e351019712aac51b005612e48c267f64079bed622", "task_id": "apache_commons-collections/42", "ground_truth": "\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n        final Set<E> set = new HashSet<E>(list);\n\n        return new ListOrderedSet<E>(set, list);\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "set", "ListOrderedSet.java"], "context_start_lineno": 0, "function_name": "listOrderedSet", "left_context": "class ListOrderedSet<E>\n    extends AbstractSerializableSetDecorator<E> {\n\n    /** Internal list to hold the sequence of objects */\n    private final List<E> setOrder;\n\n    /**\n     * Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {\n        if (set == null) {\n            throw new NullPointerException(\"Set must not be null\");\n        }\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        if (set.size() > 0 || list.size() > 0) {\n            throw new IllegalArgumentException(\"Set and List must be empty\");\n        }\n        return new ListOrderedSet<E>(set, list);\n    }\n\n    /**\n     * Factory method to create an ordered set.\n     * <p>\n     * An <code>ArrayList</code> is used to retain order.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must not be null\n     * @return a new ordered set\n     * @throws NullPointerException if set is null\n     * @since 4.0\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {\n        return new ListOrderedSet<E>(set);\n    }\n\n    /**\n     * Factory method to create an ordered set using the supplied list to retain order.\n     * <p>\n     * A <code>HashSet</code> is used for the set behaviour.\n     * <p>\n     * NOTE: If the list contains duplicates, the duplicates are removed,\n     * altering the specified list.\n     *\n     * @param <E> the element type\n     * @param list the list to decorate, must not be null\n     * @return a new ordered set\n     * @throws NullPointerException if list is null\n     * @since 4.0\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {", "right_context": "}\n\n}", "class_name": "ListOrderedSet", "return_type": "ListOrderedSet<E>", "parameters": [{"type": "List<E>", "name": "list"}]}}
{"prompt": "class FilterIterator<E> implements Iterator<E> {\n\n    /** The iterator being used */\n    private Iterator<? extends E> iterator;\n    /** The predicate being used */\n    private Predicate<? super E> predicate;\n    /** The next object in the iteration */\n    private E nextObject;\n    /** Whether the next object has been calculated yet */\n    private boolean nextObjectSet = false;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a new <code>FilterIterator</code> that will not function\n     * until {@link #setIterator(Iterator) setIterator} is invoked.\n     */\n    public FilterIterator() {\n        super();\n    }\n\n    /**\n     * Constructs a new <code>FilterIterator</code> that will not function\n     * until {@link #setPredicate(Predicate) setPredicate} is invoked.\n     *\n     * @param iterator  the iterator to use\n     */\n    public FilterIterator(final Iterator<? extends E> iterator) {\n        super();\n        this.iterator = iterator;\n    }\n\n    /**\n     * Constructs a new <code>FilterIterator</code> that will use the\n     * given iterator and predicate.\n     *\n     * @param iterator  the iterator to use\n     * @param predicate  the predicate to use\n     */\n    public FilterIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n        super();\n        this.iterator = iterator;\n        this.predicate = predicate;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if the underlying iterator contains an object that\n     * matches the predicate.\n     *\n     * @return true if there is another object that matches the predicate\n     * @throws NullPointerException if either the iterator or predicate are null\n     */\n    @Override\n    public boolean hasNext() {\n        return nextObjectSet || setNextObject();\n    }\n\n    /**\n     * Returns the next object that matches the predicate.\n     *\n     * @return the next object which matches the given predicate\n     * @throws NullPointerException if either the iterator or predicate are null\n     * @throws NoSuchElementException if there are no more elements that\n     *  match the predicate\n     */\n    @Override\n    public E next() {\n        if (!nextObjectSet) {\n            if (!setNextObject()) {\n                throw new NoSuchElementException();\n            }\n        }\n        nextObjectSet = false;\n        return nextObject;\n    }\n\n    /**\n     * Removes from the underlying collection of the base iterator the last\n     * element returned by this iterator.\n     * This method can only be called\n     * if <code>next()</code> was called, but not after\n     * <code>hasNext()</code>, because the <code>hasNext()</code> call\n     * changes the base iterator.\n     *\n     * @throws IllegalStateException if <code>hasNext()</code> has already\n     *  been called.\n     */\n    @Override\n    public void remove() {\n        if (nextObjectSet) {\n            throw new IllegalStateException(\"remove() cannot be called\");\n        }\n        iterator.remove();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the iterator this iterator is using.\n     *\n     * @return the iterator\n     */\n    public Iterator<? extends E> getIterator() {\n        return iterator;\n    }\n\n    /**\n     * Sets the iterator for this iterator to use.\n     * If iteration has started, this effectively resets the iterator.\n     *\n     * @param iterator  the iterator to use\n     */\n    public void setIterator(final Iterator<? extends E> iterator) {\n        this.iterator = iterator;\n        nextObject = null;\n        nextObjectSet = false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the predicate this iterator is using.\n     *\n     * @return the predicate\n     */\n    public Predicate<? super E> getPredicate() {\n        return predicate;\n    }\n\n    /**\n     * Sets the predicate this the iterator to use.\n     *\n     * @param predicate  the predicate to use\n     */\n    public void setPredicate(final Predicate<? super E> predicate) {\n        this.predicate = predicate;\n        nextObject = null;\n        nextObjectSet = false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set nextObject to the next object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */\n    private boolean setNextObject() {", "metadata": {"defects4j_task_id": "538433bd68c3c1b1f63294e7687e416ffa36ad4384d9efc935fb807b7a6ee70e", "task_id": "apache_commons-collections/72", "ground_truth": "\n        while (iterator.hasNext()) {\n            final E object = iterator.next();\n            if (predicate.evaluate(object)) {\n                nextObject = object;\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        return false;\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "iterators", "FilterIterator.java"], "context_start_lineno": 0, "function_name": "setNextObject", "left_context": "class FilterIterator<E> implements Iterator<E> {\n\n    /** The iterator being used */\n    private Iterator<? extends E> iterator;\n    /** The predicate being used */\n    private Predicate<? super E> predicate;\n    /** The next object in the iteration */\n    private E nextObject;\n    /** Whether the next object has been calculated yet */\n    private boolean nextObjectSet = false;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a new <code>FilterIterator</code> that will not function\n     * until {@link #setIterator(Iterator) setIterator} is invoked.\n     */\n    public FilterIterator() {\n        super();\n    }\n\n    /**\n     * Constructs a new <code>FilterIterator</code> that will not function\n     * until {@link #setPredicate(Predicate) setPredicate} is invoked.\n     *\n     * @param iterator  the iterator to use\n     */\n    public FilterIterator(final Iterator<? extends E> iterator) {\n        super();\n        this.iterator = iterator;\n    }\n\n    /**\n     * Constructs a new <code>FilterIterator</code> that will use the\n     * given iterator and predicate.\n     *\n     * @param iterator  the iterator to use\n     * @param predicate  the predicate to use\n     */\n    public FilterIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n        super();\n        this.iterator = iterator;\n        this.predicate = predicate;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if the underlying iterator contains an object that\n     * matches the predicate.\n     *\n     * @return true if there is another object that matches the predicate\n     * @throws NullPointerException if either the iterator or predicate are null\n     */\n    @Override\n    public boolean hasNext() {\n        return nextObjectSet || setNextObject();\n    }\n\n    /**\n     * Returns the next object that matches the predicate.\n     *\n     * @return the next object which matches the given predicate\n     * @throws NullPointerException if either the iterator or predicate are null\n     * @throws NoSuchElementException if there are no more elements that\n     *  match the predicate\n     */\n    @Override\n    public E next() {\n        if (!nextObjectSet) {\n            if (!setNextObject()) {\n                throw new NoSuchElementException();\n            }\n        }\n        nextObjectSet = false;\n        return nextObject;\n    }\n\n    /**\n     * Removes from the underlying collection of the base iterator the last\n     * element returned by this iterator.\n     * This method can only be called\n     * if <code>next()</code> was called, but not after\n     * <code>hasNext()</code>, because the <code>hasNext()</code> call\n     * changes the base iterator.\n     *\n     * @throws IllegalStateException if <code>hasNext()</code> has already\n     *  been called.\n     */\n    @Override\n    public void remove() {\n        if (nextObjectSet) {\n            throw new IllegalStateException(\"remove() cannot be called\");\n        }\n        iterator.remove();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the iterator this iterator is using.\n     *\n     * @return the iterator\n     */\n    public Iterator<? extends E> getIterator() {\n        return iterator;\n    }\n\n    /**\n     * Sets the iterator for this iterator to use.\n     * If iteration has started, this effectively resets the iterator.\n     *\n     * @param iterator  the iterator to use\n     */\n    public void setIterator(final Iterator<? extends E> iterator) {\n        this.iterator = iterator;\n        nextObject = null;\n        nextObjectSet = false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the predicate this iterator is using.\n     *\n     * @return the predicate\n     */\n    public Predicate<? super E> getPredicate() {\n        return predicate;\n    }\n\n    /**\n     * Sets the predicate this the iterator to use.\n     *\n     * @param predicate  the predicate to use\n     */\n    public void setPredicate(final Predicate<? super E> predicate) {\n        this.predicate = predicate;\n        nextObject = null;\n        nextObjectSet = false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set nextObject to the next object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */\n    private boolean setNextObject() {", "right_context": "}\n\n}", "class_name": "FilterIterator", "return_type": "boolean", "parameters": []}}
{"prompt": "class CollatingIterator<E> implements Iterator<E> {\n\n    /**\n     * Adds the given {@link Iterator} to the iterators being collated.\n     *\n     * @param iterator the iterator to add to the collation, must not be null\n     * @throws IllegalStateException if iteration has started\n     * @throws NullPointerException if the iterator is null\n     */\n    public void addIterator(final Iterator<? extends E> iterator) {\n        checkNotStarted();\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        iterators.add(iterator);\n    }\n\n    /**\n     * Sets the iterator at the given index.\n     *\n     * @param index index of the Iterator to replace\n     * @param iterator Iterator to place at the given index\n     * @throws IndexOutOfBoundsException if index &lt; 0 or index &gt; size()\n     * @throws IllegalStateException if iteration has started\n     * @throws NullPointerException if the iterator is null\n     */\n    public void setIterator(final int index, final Iterator<? extends E> iterator) {\n        checkNotStarted();\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        iterators.set(index, iterator);\n    }\n\n    /**\n     * Gets the list of Iterators (unmodifiable).\n     *\n     * @return the unmodifiable list of iterators added\n     */\n    public List<Iterator<? extends E>> getIterators() {\n        return UnmodifiableList.unmodifiableList(iterators);\n    }\n\n    /**\n     * Gets the {@link Comparator} by which collatation occurs.\n     *\n     * @return the {@link Comparator}\n     */\n    public Comparator<? super E> getComparator() {\n        return comparator;\n    }\n\n    /**\n     * Sets the {@link Comparator} by which collation occurs. If you\n     * would like to use the natural sort order (or, in other words,\n     * if the elements in the iterators are implementing the\n     * {@link java.lang.Comparable} interface), then use the\n     * {@link org.apache.commons.collections4.comparators.ComparableComparator}.\n     *\n     * @param comp the {@link Comparator} to set\n     * @throws IllegalStateException if iteration has started\n     */\n    public void setComparator(final Comparator<? super E> comp) {\n        checkNotStarted();\n        comparator = comp;\n    }\n\n    // Iterator Methods\n    // -------------------------------------------------------------------\n    /**\n     * Returns <code>true</code> if any child iterator has remaining elements.\n     *\n     * @return true if this iterator has remaining elements\n     */\n    @Override\n    public boolean hasNext() {\n        start();\n        return anyValueSet(valueSet) || anyHasNext(iterators);\n    }\n\n    /**\n     * Returns the next ordered element from a child iterator.\n     *\n     * @return the next ordered element\n     * @throws NoSuchElementException if no child iterator has any more elements\n     */\n    @Override\n    public E next() throws NoSuchElementException {\n        if (hasNext() == false) {\n            throw new NoSuchElementException();\n        }\n        final int leastIndex = least();\n        if (leastIndex == -1) {\n            throw new NoSuchElementException();\n        }\n        final E val = values.get(leastIndex);\n        clear(leastIndex);\n        lastReturned = leastIndex;\n        return val;\n    }\n\n    /**\n     * Removes the last returned element from the child iterator that produced it.\n     *\n     * @throws IllegalStateException if there is no last returned element, or if\n     * the last returned element has already been removed\n     */\n    @Override\n    public void remove() {\n        if (lastReturned == -1) {\n            throw new IllegalStateException(\"No value can be removed at present\");\n        }\n        iterators.get(lastReturned).remove();\n    }\n\n    /**\n     * Returns the index of the iterator that returned the last element.\n     *\n     * @return the index of the iterator that returned the last element\n     * @throws IllegalStateException if there is no last returned element\n     */\n    public int getIteratorIndex() {\n        if (lastReturned == -1) {\n            throw new IllegalStateException(\"No value has been returned yet\");\n        }\n\n        return lastReturned;\n    }\n\n    // Private Methods\n    // -------------------------------------------------------------------\n    /**\n     * Initializes the collating state if it hasn't been already.\n     */\n    private void start() {\n        if (values == null) {\n            values = new ArrayList<E>(iterators.size());\n            valueSet = new BitSet(iterators.size());\n            for (int i = 0; i < iterators.size(); i++) {\n                values.add(null);\n                valueSet.clear(i);\n            }\n        }\n    }\n\n    /**\n     * Sets the {@link #values} and {@link #valueSet} attributes at position\n     * <i>i</i> to the next value of the {@link #iterators iterator} at position\n     * <i>i</i>, or clear them if the <i>i</i><sup>th</sup> iterator has no next\n     * value.\n     *\n     * @return {@code false} iff there was no value to set\n     */\n    private boolean set(final int i) {\n        final Iterator<? extends E> it = iterators.get(i);\n        if (it.hasNext()) {\n            values.set(i, it.next());\n            valueSet.set(i);\n            return true;\n        }\n        values.set(i, null);\n        valueSet.clear(i);\n        return false;\n    }\n\n    /**\n     * Clears the {@link #values} and {@link #valueSet} attributes at position\n     * <i>i</i>.\n     */\n    private void clear(final int i) {\n        values.set(i, null);\n        valueSet.clear(i);\n    }\n\n    /**\n     * Throws {@link IllegalStateException} if iteration has started via\n     * {@link #start}.\n     *\n     * @throws IllegalStateException if iteration started\n     */\n    private void checkNotStarted() throws IllegalStateException {\n        if (values != null) {\n            throw new IllegalStateException(\"Can't do that after next or hasNext has been called.\");\n        }\n    }\n\n    /**\n     * Returns the index of the least element in {@link #values},\n     * {@link #set(int) setting} any uninitialized values.\n     *\n     * @throws NullPointerException if no comparator is set\n     */\n    private int least() {", "metadata": {"defects4j_task_id": "4c553b5b5c51e1d9ef850c957a7fec03a3f018a096643268bbc380de18070e31", "task_id": "apache_commons-collections/68", "ground_truth": "\n        int leastIndex = -1;\n        E leastObject = null;\n        for (int i = 0; i < values.size(); i++) {\n            if (valueSet.get(i) == false) {\n                set(i);\n            }\n            if (valueSet.get(i)) {\n                if (leastIndex == -1) {\n                    leastIndex = i;\n                    leastObject = values.get(i);\n                } else {\n                    final E curObject = values.get(i);\n                    if (comparator == null) {\n                        throw new NullPointerException(\"You must invoke setComparator() to set a comparator first.\");\n                    }\n                    if (comparator.compare(curObject, leastObject) < 0) {\n                        leastObject = curObject;\n                        leastIndex = i;\n                    }\n                }\n            }\n        }\n        return leastIndex;\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "iterators", "CollatingIterator.java"], "context_start_lineno": 0, "function_name": "least", "left_context": "class CollatingIterator<E> implements Iterator<E> {\n\n    /**\n     * Adds the given {@link Iterator} to the iterators being collated.\n     *\n     * @param iterator the iterator to add to the collation, must not be null\n     * @throws IllegalStateException if iteration has started\n     * @throws NullPointerException if the iterator is null\n     */\n    public void addIterator(final Iterator<? extends E> iterator) {\n        checkNotStarted();\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        iterators.add(iterator);\n    }\n\n    /**\n     * Sets the iterator at the given index.\n     *\n     * @param index index of the Iterator to replace\n     * @param iterator Iterator to place at the given index\n     * @throws IndexOutOfBoundsException if index &lt; 0 or index &gt; size()\n     * @throws IllegalStateException if iteration has started\n     * @throws NullPointerException if the iterator is null\n     */\n    public void setIterator(final int index, final Iterator<? extends E> iterator) {\n        checkNotStarted();\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        iterators.set(index, iterator);\n    }\n\n    /**\n     * Gets the list of Iterators (unmodifiable).\n     *\n     * @return the unmodifiable list of iterators added\n     */\n    public List<Iterator<? extends E>> getIterators() {\n        return UnmodifiableList.unmodifiableList(iterators);\n    }\n\n    /**\n     * Gets the {@link Comparator} by which collatation occurs.\n     *\n     * @return the {@link Comparator}\n     */\n    public Comparator<? super E> getComparator() {\n        return comparator;\n    }\n\n    /**\n     * Sets the {@link Comparator} by which collation occurs. If you\n     * would like to use the natural sort order (or, in other words,\n     * if the elements in the iterators are implementing the\n     * {@link java.lang.Comparable} interface), then use the\n     * {@link org.apache.commons.collections4.comparators.ComparableComparator}.\n     *\n     * @param comp the {@link Comparator} to set\n     * @throws IllegalStateException if iteration has started\n     */\n    public void setComparator(final Comparator<? super E> comp) {\n        checkNotStarted();\n        comparator = comp;\n    }\n\n    // Iterator Methods\n    // -------------------------------------------------------------------\n    /**\n     * Returns <code>true</code> if any child iterator has remaining elements.\n     *\n     * @return true if this iterator has remaining elements\n     */\n    @Override\n    public boolean hasNext() {\n        start();\n        return anyValueSet(valueSet) || anyHasNext(iterators);\n    }\n\n    /**\n     * Returns the next ordered element from a child iterator.\n     *\n     * @return the next ordered element\n     * @throws NoSuchElementException if no child iterator has any more elements\n     */\n    @Override\n    public E next() throws NoSuchElementException {\n        if (hasNext() == false) {\n            throw new NoSuchElementException();\n        }\n        final int leastIndex = least();\n        if (leastIndex == -1) {\n            throw new NoSuchElementException();\n        }\n        final E val = values.get(leastIndex);\n        clear(leastIndex);\n        lastReturned = leastIndex;\n        return val;\n    }\n\n    /**\n     * Removes the last returned element from the child iterator that produced it.\n     *\n     * @throws IllegalStateException if there is no last returned element, or if\n     * the last returned element has already been removed\n     */\n    @Override\n    public void remove() {\n        if (lastReturned == -1) {\n            throw new IllegalStateException(\"No value can be removed at present\");\n        }\n        iterators.get(lastReturned).remove();\n    }\n\n    /**\n     * Returns the index of the iterator that returned the last element.\n     *\n     * @return the index of the iterator that returned the last element\n     * @throws IllegalStateException if there is no last returned element\n     */\n    public int getIteratorIndex() {\n        if (lastReturned == -1) {\n            throw new IllegalStateException(\"No value has been returned yet\");\n        }\n\n        return lastReturned;\n    }\n\n    // Private Methods\n    // -------------------------------------------------------------------\n    /**\n     * Initializes the collating state if it hasn't been already.\n     */\n    private void start() {\n        if (values == null) {\n            values = new ArrayList<E>(iterators.size());\n            valueSet = new BitSet(iterators.size());\n            for (int i = 0; i < iterators.size(); i++) {\n                values.add(null);\n                valueSet.clear(i);\n            }\n        }\n    }\n\n    /**\n     * Sets the {@link #values} and {@link #valueSet} attributes at position\n     * <i>i</i> to the next value of the {@link #iterators iterator} at position\n     * <i>i</i>, or clear them if the <i>i</i><sup>th</sup> iterator has no next\n     * value.\n     *\n     * @return {@code false} iff there was no value to set\n     */\n    private boolean set(final int i) {\n        final Iterator<? extends E> it = iterators.get(i);\n        if (it.hasNext()) {\n            values.set(i, it.next());\n            valueSet.set(i);\n            return true;\n        }\n        values.set(i, null);\n        valueSet.clear(i);\n        return false;\n    }\n\n    /**\n     * Clears the {@link #values} and {@link #valueSet} attributes at position\n     * <i>i</i>.\n     */\n    private void clear(final int i) {\n        values.set(i, null);\n        valueSet.clear(i);\n    }\n\n    /**\n     * Throws {@link IllegalStateException} if iteration has started via\n     * {@link #start}.\n     *\n     * @throws IllegalStateException if iteration started\n     */\n    private void checkNotStarted() throws IllegalStateException {\n        if (values != null) {\n            throw new IllegalStateException(\"Can't do that after next or hasNext has been called.\");\n        }\n    }\n\n    /**\n     * Returns the index of the least element in {@link #values},\n     * {@link #set(int) setting} any uninitialized values.\n     *\n     * @throws NullPointerException if no comparator is set\n     */\n    private int least() {", "right_context": "}\n\n}", "class_name": "CollatingIterator", "return_type": "int", "parameters": []}}
{"prompt": "class UnmodifiableIterator<E> implements Iterator<E>, Unmodifiable {\n\n    /** The iterator being decorated */\n    private final Iterator<? extends E> iterator;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Decorates the specified iterator such that it cannot be modified.\n     * <p>\n     * If the iterator is already unmodifiable it is returned directly.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable iterator\n     * @throws NullPointerException if the iterator is null\n     */\n    public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator) {", "metadata": {"defects4j_task_id": "ab719340964b7ba4bc14c25819f17f1de9d30e27ddddfe86ce4abaa1a068fd60", "task_id": "apache_commons-collections/145", "ground_truth": "\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (iterator instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n            return tmpIterator;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "iterators", "UnmodifiableIterator.java"], "context_start_lineno": 0, "function_name": "unmodifiableIterator", "left_context": "class UnmodifiableIterator<E> implements Iterator<E>, Unmodifiable {\n\n    /** The iterator being decorated */\n    private final Iterator<? extends E> iterator;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Decorates the specified iterator such that it cannot be modified.\n     * <p>\n     * If the iterator is already unmodifiable it is returned directly.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable iterator\n     * @throws NullPointerException if the iterator is null\n     */\n    public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator) {", "right_context": "}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param iterator  the iterator to decorate\n     */\n    private UnmodifiableIterator(final Iterator<? extends E> iterator) {\n        super();\n        this.iterator = iterator;\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    @Override\n    public E next() {\n        return iterator.next();\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove() is not supported\");\n    }\n\n}", "class_name": "UnmodifiableIterator", "return_type": "Iterator<E>", "parameters": [{"type": "Iterator<? extends E>", "name": "iterator"}]}}
{"prompt": "class CollectionUtils {\n\n    /**\n     * Helper class for set-related operations, e.g. union, subtract, intersection.\n     * @param <O>  the element type\n     */\n    private static class SetOperationCardinalityHelper<O> extends CardinalityHelper<O> implements Iterable<O> {\n\n        /** Contains the unique elements of the two collections. */\n        private final Set<O> elements;\n\n        /** Output collection. */\n        private final List<O> newList;\n\n        /**\n         * Create a new set operation helper from the two collections.\n         * @param a  the first collection\n         * @param b  the second collection\n         */\n        public SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n            super(a, b);\n            elements = new HashSet<O>();\n            addAll(elements, a);\n            addAll(elements, b);\n            // the resulting list must contain at least each unique element, but may grow\n            newList = new ArrayList<O>(elements.size());\n        }\n\n        @Override\n        public Iterator<O> iterator() {\n            return elements.iterator();\n        }\n\n        /**\n         * Add the object {@code count} times to the result collection.\n         * @param obj  the object to add\n         * @param count  the count\n         */\n        public void setCardinality(final O obj, final int count) {\n            for (int i = 0; i < count; i++) {\n                newList.add(obj);\n            }\n        }\n\n        /**\n         * Returns the resulting collection.\n         * @return the result\n         */\n        public Collection<O> list() {\n            return newList;\n        }\n\n    }\n\n    /**\n     * An empty unmodifiable collection.\n     * The JDK provides empty Set and List implementations which could be used for\n     * this purpose. However they could be cast to Set or List which might be\n     * undesirable. This implementation only implements Collection.\n     */\n    @SuppressWarnings(\"rawtypes\") // we deliberately use the raw type here\n    public static final Collection EMPTY_COLLECTION =\n        UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());\n\n    /**\n     * <code>CollectionUtils</code> should not normally be instantiated.\n     */\n    private CollectionUtils() {}\n\n    /**\n     * Returns the immutable EMPTY_COLLECTION with generic type safety.\n     *\n     * @see #EMPTY_COLLECTION\n     * @since 4.0\n     * @param <T> the element type\n     * @return immutable empty collection\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n    public static <T> Collection<T> emptyCollection() {\n        return EMPTY_COLLECTION;\n    }\n\n    /**\n     * Returns an immutable empty collection if the argument is <code>null</code>,\n     * or the argument itself otherwise.\n     *\n     * @param <T> the element type\n     * @param collection the collection, possibly <code>null</code>\n     * @return an empty collection if the argument is <code>null</code>\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n    public static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n        return collection == null ? EMPTY_COLLECTION : collection;\n    }\n\n    /**\n     * Returns a {@link Collection} containing the union of the given\n     * {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the maximum of the cardinality of that element in the two\n     * given {@link Iterable}s.\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the union of the two collections\n     * @see Collection#addAll\n     */\n    public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {", "metadata": {"defects4j_task_id": "48ae672c9549af57dc9801695a7ab4928f1d48a547d915543880ac17d7198801", "task_id": "apache_commons-collections/63", "ground_truth": "\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.max(obj));\n        }\n        return helper.list();\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "CollectionUtils.java"], "context_start_lineno": 0, "function_name": "union", "left_context": "class CollectionUtils {\n\n    /**\n     * Helper class for set-related operations, e.g. union, subtract, intersection.\n     * @param <O>  the element type\n     */\n    private static class SetOperationCardinalityHelper<O> extends CardinalityHelper<O> implements Iterable<O> {\n\n        /** Contains the unique elements of the two collections. */\n        private final Set<O> elements;\n\n        /** Output collection. */\n        private final List<O> newList;\n\n        /**\n         * Create a new set operation helper from the two collections.\n         * @param a  the first collection\n         * @param b  the second collection\n         */\n        public SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n            super(a, b);\n            elements = new HashSet<O>();\n            addAll(elements, a);\n            addAll(elements, b);\n            // the resulting list must contain at least each unique element, but may grow\n            newList = new ArrayList<O>(elements.size());\n        }\n\n        @Override\n        public Iterator<O> iterator() {\n            return elements.iterator();\n        }\n\n        /**\n         * Add the object {@code count} times to the result collection.\n         * @param obj  the object to add\n         * @param count  the count\n         */\n        public void setCardinality(final O obj, final int count) {\n            for (int i = 0; i < count; i++) {\n                newList.add(obj);\n            }\n        }\n\n        /**\n         * Returns the resulting collection.\n         * @return the result\n         */\n        public Collection<O> list() {\n            return newList;\n        }\n\n    }\n\n    /**\n     * An empty unmodifiable collection.\n     * The JDK provides empty Set and List implementations which could be used for\n     * this purpose. However they could be cast to Set or List which might be\n     * undesirable. This implementation only implements Collection.\n     */\n    @SuppressWarnings(\"rawtypes\") // we deliberately use the raw type here\n    public static final Collection EMPTY_COLLECTION =\n        UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());\n\n    /**\n     * <code>CollectionUtils</code> should not normally be instantiated.\n     */\n    private CollectionUtils() {}\n\n    /**\n     * Returns the immutable EMPTY_COLLECTION with generic type safety.\n     *\n     * @see #EMPTY_COLLECTION\n     * @since 4.0\n     * @param <T> the element type\n     * @return immutable empty collection\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n    public static <T> Collection<T> emptyCollection() {\n        return EMPTY_COLLECTION;\n    }\n\n    /**\n     * Returns an immutable empty collection if the argument is <code>null</code>,\n     * or the argument itself otherwise.\n     *\n     * @param <T> the element type\n     * @param collection the collection, possibly <code>null</code>\n     * @return an empty collection if the argument is <code>null</code>\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n    public static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n        return collection == null ? EMPTY_COLLECTION : collection;\n    }\n\n    /**\n     * Returns a {@link Collection} containing the union of the given\n     * {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the maximum of the cardinality of that element in the two\n     * given {@link Iterable}s.\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the union of the two collections\n     * @see Collection#addAll\n     */\n    public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {", "right_context": "}\n}", "class_name": "CollectionUtils", "return_type": "Collection<O>", "parameters": [{"type": "Iterable<? extends O>", "name": "a"}, {"type": "Iterable<? extends O>", "name": "b"}]}}
{"prompt": "class CollectionUtils {\n\n    /**\n     * Helper class for set-related operations, e.g. union, subtract, intersection.\n     * @param <O>  the element type\n     */\n    private static class SetOperationCardinalityHelper<O> extends CardinalityHelper<O> implements Iterable<O> {\n\n        /** Contains the unique elements of the two collections. */\n        private final Set<O> elements;\n\n        /** Output collection. */\n        private final List<O> newList;\n\n        /**\n         * Create a new set operation helper from the two collections.\n         * @param a  the first collection\n         * @param b  the second collection\n         */\n        public SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n            super(a, b);\n            elements = new HashSet<O>();\n            addAll(elements, a);\n            addAll(elements, b);\n            // the resulting list must contain at least each unique element, but may grow\n            newList = new ArrayList<O>(elements.size());\n        }\n\n        @Override\n        public Iterator<O> iterator() {\n            return elements.iterator();\n        }\n\n        /**\n         * Add the object {@code count} times to the result collection.\n         * @param obj  the object to add\n         * @param count  the count\n         */\n        public void setCardinality(final O obj, final int count) {\n            for (int i = 0; i < count; i++) {\n                newList.add(obj);\n            }\n        }\n\n        /**\n         * Returns the resulting collection.\n         * @return the result\n         */\n        public Collection<O> list() {\n            return newList;\n        }\n\n    }\n\n    /**\n     * An empty unmodifiable collection.\n     * The JDK provides empty Set and List implementations which could be used for\n     * this purpose. However they could be cast to Set or List which might be\n     * undesirable. This implementation only implements Collection.\n     */\n    @SuppressWarnings(\"rawtypes\") // we deliberately use the raw type here\n    public static final Collection EMPTY_COLLECTION =\n        UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());\n\n    /**\n     * <code>CollectionUtils</code> should not normally be instantiated.\n     */\n    private CollectionUtils() {}\n\n    /**\n     * Returns the immutable EMPTY_COLLECTION with generic type safety.\n     *\n     * @see #EMPTY_COLLECTION\n     * @since 4.0\n     * @param <T> the element type\n     * @return immutable empty collection\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n    public static <T> Collection<T> emptyCollection() {\n        return EMPTY_COLLECTION;\n    }\n\n    /**\n     * Returns an immutable empty collection if the argument is <code>null</code>,\n     * or the argument itself otherwise.\n     *\n     * @param <T> the element type\n     * @param collection the collection, possibly <code>null</code>\n     * @return an empty collection if the argument is <code>null</code>\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n    public static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n        return collection == null ? EMPTY_COLLECTION : collection;\n    }\n\n    /**\n     * Returns a {@link Collection} containing the union of the given\n     * {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the maximum of the cardinality of that element in the two\n     * given {@link Iterable}s.\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the union of the two collections\n     * @see Collection#addAll\n     */\n    public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.max(obj));\n        }\n        return helper.list();\n    }\n\n    /**\n     * Returns a {@link Collection} containing the intersection of the given\n     * {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the minimum of the cardinality of that element in the two\n     * given {@link Iterable}s.\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the intersection of the two collections\n     * @see Collection#retainAll\n     * @see #containsAny\n     */\n    public static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.min(obj));\n        }\n        return helper.list();\n    }\n\n    /**\n     * Returns a {@link Collection} containing the exclusive disjunction\n     * (symmetric difference) of the given {@link Iterable}s.\n     * <p>\n     * The cardinality of each element <i>e</i> in the returned\n     * {@link Collection} will be equal to\n     * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),\n     * cardinality(<i>e</i>,<i>b</i>))</tt>.\n     * <p>\n     * This is equivalent to\n     * {@code {@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})}\n     * or\n     * {@code {@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})}.\n\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the symmetric difference of the two collections\n     */\n    public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {", "metadata": {"defects4j_task_id": "176a4e9a6c3197884d5242cef03befaf74d9986583345e0badba41fb3c86e109", "task_id": "apache_commons-collections/25", "ground_truth": "\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n        }\n        return helper.list();\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "CollectionUtils.java"], "context_start_lineno": 0, "function_name": "disjunction", "left_context": "class CollectionUtils {\n\n    /**\n     * Helper class for set-related operations, e.g. union, subtract, intersection.\n     * @param <O>  the element type\n     */\n    private static class SetOperationCardinalityHelper<O> extends CardinalityHelper<O> implements Iterable<O> {\n\n        /** Contains the unique elements of the two collections. */\n        private final Set<O> elements;\n\n        /** Output collection. */\n        private final List<O> newList;\n\n        /**\n         * Create a new set operation helper from the two collections.\n         * @param a  the first collection\n         * @param b  the second collection\n         */\n        public SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n            super(a, b);\n            elements = new HashSet<O>();\n            addAll(elements, a);\n            addAll(elements, b);\n            // the resulting list must contain at least each unique element, but may grow\n            newList = new ArrayList<O>(elements.size());\n        }\n\n        @Override\n        public Iterator<O> iterator() {\n            return elements.iterator();\n        }\n\n        /**\n         * Add the object {@code count} times to the result collection.\n         * @param obj  the object to add\n         * @param count  the count\n         */\n        public void setCardinality(final O obj, final int count) {\n            for (int i = 0; i < count; i++) {\n                newList.add(obj);\n            }\n        }\n\n        /**\n         * Returns the resulting collection.\n         * @return the result\n         */\n        public Collection<O> list() {\n            return newList;\n        }\n\n    }\n\n    /**\n     * An empty unmodifiable collection.\n     * The JDK provides empty Set and List implementations which could be used for\n     * this purpose. However they could be cast to Set or List which might be\n     * undesirable. This implementation only implements Collection.\n     */\n    @SuppressWarnings(\"rawtypes\") // we deliberately use the raw type here\n    public static final Collection EMPTY_COLLECTION =\n        UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());\n\n    /**\n     * <code>CollectionUtils</code> should not normally be instantiated.\n     */\n    private CollectionUtils() {}\n\n    /**\n     * Returns the immutable EMPTY_COLLECTION with generic type safety.\n     *\n     * @see #EMPTY_COLLECTION\n     * @since 4.0\n     * @param <T> the element type\n     * @return immutable empty collection\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n    public static <T> Collection<T> emptyCollection() {\n        return EMPTY_COLLECTION;\n    }\n\n    /**\n     * Returns an immutable empty collection if the argument is <code>null</code>,\n     * or the argument itself otherwise.\n     *\n     * @param <T> the element type\n     * @param collection the collection, possibly <code>null</code>\n     * @return an empty collection if the argument is <code>null</code>\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n    public static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n        return collection == null ? EMPTY_COLLECTION : collection;\n    }\n\n    /**\n     * Returns a {@link Collection} containing the union of the given\n     * {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the maximum of the cardinality of that element in the two\n     * given {@link Iterable}s.\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the union of the two collections\n     * @see Collection#addAll\n     */\n    public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.max(obj));\n        }\n        return helper.list();\n    }\n\n    /**\n     * Returns a {@link Collection} containing the intersection of the given\n     * {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the minimum of the cardinality of that element in the two\n     * given {@link Iterable}s.\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the intersection of the two collections\n     * @see Collection#retainAll\n     * @see #containsAny\n     */\n    public static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.min(obj));\n        }\n        return helper.list();\n    }\n\n    /**\n     * Returns a {@link Collection} containing the exclusive disjunction\n     * (symmetric difference) of the given {@link Iterable}s.\n     * <p>\n     * The cardinality of each element <i>e</i> in the returned\n     * {@link Collection} will be equal to\n     * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),\n     * cardinality(<i>e</i>,<i>b</i>))</tt>.\n     * <p>\n     * This is equivalent to\n     * {@code {@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})}\n     * or\n     * {@code {@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})}.\n\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the symmetric difference of the two collections\n     */\n    public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {", "right_context": "}\n}", "class_name": "CollectionUtils", "return_type": "Collection<O>", "parameters": [{"type": "Iterable<? extends O>", "name": "a"}, {"type": "Iterable<? extends O>", "name": "b"}]}}
{"prompt": "class CollectionUtils {\n\n    /**\n     * Returns a new {@link Collection} containing {@code <i>a</i> - <i>b</i>}.\n     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n     * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n     * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n     *\n     * @param a  the collection to subtract from, must not be null\n     * @param b  the collection to subtract, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return a new collection with the results\n     * @see Collection#removeAll\n     */\n    public static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n        final Predicate<O> p = TruePredicate.truePredicate();\n        return subtract(a, b, p);\n    }\n\n    /**\n     * Returns a new {@link Collection} containing <i>a</i> minus a subset of\n     * <i>b</i>.  Only the elements of <i>b</i> that satisfy the predicate\n     * condition, <i>p</i> are subtracted from <i>a</i>.\n     *\n     * <p>The cardinality of each element <i>e</i> in the returned {@link Collection}\n     * that satisfies the predicate condition will be the cardinality of <i>e</i> in <i>a</i>\n     * minus the cardinality of <i>e</i> in <i>b</i>, or zero, whichever is greater.</p>\n     * <p>The cardinality of each element <i>e</i> in the returned {@link Collection} that does <b>not</b>\n     * satisfy the predicate condition will be equal to the cardinality of <i>e</i> in <i>a</i>.</p>\n     *\n     * @param a  the collection to subtract from, must not be null\n     * @param b  the collection to subtract, must not be null\n     * @param p  the condition used to determine which elements of <i>b</i> are\n     *        subtracted.\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return a new collection with the results\n     * @since 4.0\n     * @see Collection#removeAll\n     */\n    public static <O> Collection<O> subtract(final Iterable<? extends O> a,\n                                             final Iterable<? extends O> b,\n                                             final Predicate<O> p) {\n        final ArrayList<O> list = new ArrayList<O>();\n        final HashBag<O> bag = new HashBag<O>();\n        for (final O element : b) {\n            if (p.evaluate(element)) {\n                bag.add(element);\n            }\n        }\n        for (final O element : a) {\n            if (!bag.remove(element, 1)) {\n                list.add(element);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Returns <code>true</code> iff all elements of {@code coll2} are also contained\n     * in {@code coll1}. The cardinality of values in {@code coll2} is not taken into account,\n     * which is the same behavior as {@link Collection#containsAll(Collection)}.\n     * <p>\n     * In other words, this method returns <code>true</code> iff the\n     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> has the same cardinality as\n     * the set of unique values from {@code coll2}. In case {@code coll2} is empty, {@code true}\n     * will be returned.\n     * <p>\n     * This method is intended as a replacement for {@link Collection#containsAll(Collection)}\n     * with a guaranteed runtime complexity of {@code O(n + m)}. Depending on the type of\n     * {@link Collection} provided, this method will be much faster than calling\n     * {@link Collection#containsAll(Collection)} instead, though this will come at the\n     * cost of an additional space complexity O(n).\n     *\n     * @param coll1  the first collection, must not be null\n     * @param coll2  the second collection, must not be null\n     * @return <code>true</code> iff the intersection of the collections has the same cardinality\n     *   as the set of unique elements from the second collection\n     * @since 4.0\n     */\n    public static boolean containsAll(final Collection<?> coll1, final Collection<?> coll2) {\n        if (coll2.isEmpty()) {\n            return true;\n        } else {\n            final Iterator<?> it = coll1.iterator();\n            final Set<Object> elementsAlreadySeen = new HashSet<Object>();\n            for (final Object nextElement : coll2) {\n                if (elementsAlreadySeen.contains(nextElement)) {\n                    continue;\n                }\n\n                boolean foundCurrentElement = false;\n                while (it.hasNext()) {\n                    final Object p = it.next();\n                    elementsAlreadySeen.add(p);\n                    if (nextElement == null ? p == null : nextElement.equals(p)) {\n                        foundCurrentElement = true;\n                        break;\n                    }\n                }\n\n                if (foundCurrentElement) {\n                    continue;\n                } else {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> iff at least one element is in both collections.\n     * <p>\n     * In other words, this method returns <code>true</code> iff the\n     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n     *\n     * @param coll1  the first collection, must not be null\n     * @param coll2  the second collection, must not be null\n     * @return <code>true</code> iff the intersection of the collections is non-empty\n     * @since 2.1\n     * @see #intersection\n     */\n    public static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n        if (coll1.size() < coll2.size()) {\n            for (final Object aColl1 : coll1) {\n                if (coll2.contains(aColl1)) {\n                    return true;\n                }\n            }\n        } else {\n            for (final Object aColl2 : coll2) {\n                if (coll1.contains(aColl2)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns a {@link Map} mapping each unique element in the given\n     * {@link Collection} to an {@link Integer} representing the number\n     * of occurrences of that element in the {@link Collection}.\n     * <p>\n     * Only those elements present in the collection will appear as\n     * keys in the map.\n     *\n     * @param <O>  the type of object in the returned {@link Map}. This is a super type of <I>.\n     * @param coll  the collection to get the cardinality map for, must not be null\n     * @return the populated cardinality map\n     */\n    public static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {", "metadata": {"defects4j_task_id": "c717730a66e02357eda2be63cdcb24fd2e5025cafdc05e9f34fa3dcb2b956137", "task_id": "apache_commons-collections/161", "ground_truth": "\n        final Map<O, Integer> count = new HashMap<O, Integer>();\n        for (final O obj : coll) {\n            final Integer c = count.get(obj);\n            if (c == null) {\n                count.put(obj, Integer.valueOf(1));\n            } else {\n                count.put(obj, Integer.valueOf(c.intValue() + 1));\n            }\n        }\n        return count;\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "CollectionUtils.java"], "context_start_lineno": 0, "function_name": "getCardinalityMap", "left_context": "class CollectionUtils {\n\n    /**\n     * Returns a new {@link Collection} containing {@code <i>a</i> - <i>b</i>}.\n     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n     * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n     * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n     *\n     * @param a  the collection to subtract from, must not be null\n     * @param b  the collection to subtract, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return a new collection with the results\n     * @see Collection#removeAll\n     */\n    public static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n        final Predicate<O> p = TruePredicate.truePredicate();\n        return subtract(a, b, p);\n    }\n\n    /**\n     * Returns a new {@link Collection} containing <i>a</i> minus a subset of\n     * <i>b</i>.  Only the elements of <i>b</i> that satisfy the predicate\n     * condition, <i>p</i> are subtracted from <i>a</i>.\n     *\n     * <p>The cardinality of each element <i>e</i> in the returned {@link Collection}\n     * that satisfies the predicate condition will be the cardinality of <i>e</i> in <i>a</i>\n     * minus the cardinality of <i>e</i> in <i>b</i>, or zero, whichever is greater.</p>\n     * <p>The cardinality of each element <i>e</i> in the returned {@link Collection} that does <b>not</b>\n     * satisfy the predicate condition will be equal to the cardinality of <i>e</i> in <i>a</i>.</p>\n     *\n     * @param a  the collection to subtract from, must not be null\n     * @param b  the collection to subtract, must not be null\n     * @param p  the condition used to determine which elements of <i>b</i> are\n     *        subtracted.\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return a new collection with the results\n     * @since 4.0\n     * @see Collection#removeAll\n     */\n    public static <O> Collection<O> subtract(final Iterable<? extends O> a,\n                                             final Iterable<? extends O> b,\n                                             final Predicate<O> p) {\n        final ArrayList<O> list = new ArrayList<O>();\n        final HashBag<O> bag = new HashBag<O>();\n        for (final O element : b) {\n            if (p.evaluate(element)) {\n                bag.add(element);\n            }\n        }\n        for (final O element : a) {\n            if (!bag.remove(element, 1)) {\n                list.add(element);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Returns <code>true</code> iff all elements of {@code coll2} are also contained\n     * in {@code coll1}. The cardinality of values in {@code coll2} is not taken into account,\n     * which is the same behavior as {@link Collection#containsAll(Collection)}.\n     * <p>\n     * In other words, this method returns <code>true</code> iff the\n     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> has the same cardinality as\n     * the set of unique values from {@code coll2}. In case {@code coll2} is empty, {@code true}\n     * will be returned.\n     * <p>\n     * This method is intended as a replacement for {@link Collection#containsAll(Collection)}\n     * with a guaranteed runtime complexity of {@code O(n + m)}. Depending on the type of\n     * {@link Collection} provided, this method will be much faster than calling\n     * {@link Collection#containsAll(Collection)} instead, though this will come at the\n     * cost of an additional space complexity O(n).\n     *\n     * @param coll1  the first collection, must not be null\n     * @param coll2  the second collection, must not be null\n     * @return <code>true</code> iff the intersection of the collections has the same cardinality\n     *   as the set of unique elements from the second collection\n     * @since 4.0\n     */\n    public static boolean containsAll(final Collection<?> coll1, final Collection<?> coll2) {\n        if (coll2.isEmpty()) {\n            return true;\n        } else {\n            final Iterator<?> it = coll1.iterator();\n            final Set<Object> elementsAlreadySeen = new HashSet<Object>();\n            for (final Object nextElement : coll2) {\n                if (elementsAlreadySeen.contains(nextElement)) {\n                    continue;\n                }\n\n                boolean foundCurrentElement = false;\n                while (it.hasNext()) {\n                    final Object p = it.next();\n                    elementsAlreadySeen.add(p);\n                    if (nextElement == null ? p == null : nextElement.equals(p)) {\n                        foundCurrentElement = true;\n                        break;\n                    }\n                }\n\n                if (foundCurrentElement) {\n                    continue;\n                } else {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> iff at least one element is in both collections.\n     * <p>\n     * In other words, this method returns <code>true</code> iff the\n     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n     *\n     * @param coll1  the first collection, must not be null\n     * @param coll2  the second collection, must not be null\n     * @return <code>true</code> iff the intersection of the collections is non-empty\n     * @since 2.1\n     * @see #intersection\n     */\n    public static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n        if (coll1.size() < coll2.size()) {\n            for (final Object aColl1 : coll1) {\n                if (coll2.contains(aColl1)) {\n                    return true;\n                }\n            }\n        } else {\n            for (final Object aColl2 : coll2) {\n                if (coll1.contains(aColl2)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns a {@link Map} mapping each unique element in the given\n     * {@link Collection} to an {@link Integer} representing the number\n     * of occurrences of that element in the {@link Collection}.\n     * <p>\n     * Only those elements present in the collection will appear as\n     * keys in the map.\n     *\n     * @param <O>  the type of object in the returned {@link Map}. This is a super type of <I>.\n     * @param coll  the collection to get the cardinality map for, must not be null\n     * @return the populated cardinality map\n     */\n    public static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {", "right_context": "}\n}", "class_name": "CollectionUtils", "return_type": "Map<O,Integer>", "parameters": [{"type": "Iterable<? extends O>", "name": "coll"}]}}
{"prompt": "class CollectionUtils {\n\n    /**\n     * Returns the <code>index</code>-th <code>Map.Entry</code> in the <code>map</code>'s <code>entrySet</code>,\n     * throwing <code>IndexOutOfBoundsException</code> if there is no such element.\n     *\n     * @param <K>  the key type in the {@link Map}\n     * @param <V>  the key type in the {@link Map}\n     * @param map  the object to get a value from\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public static <K,V> Map.Entry<K, V> get(final Map<K,V> map, final int index) {\n        checkIndexBounds(index);\n        return get(map.entrySet(), index);\n    }\n\n    /**\n     * Gets the size of the collection/iterator specified.\n     * <p>\n     * This method can handles objects as follows\n     * <ul>\n     * <li>Collection - the collection size\n     * <li>Map - the map size\n     * <li>Array - the array size\n     * <li>Iterator - the number of elements remaining in the iterator\n     * <li>Enumeration - the number of elements remaining in the enumeration\n     * </ul>\n     *\n     * @param object  the object to get the size of, may be null\n     * @return the size of the specified collection or 0 if the object was null\n     * @throws IllegalArgumentException thrown if object is not recognized\n     * @since 3.1\n     */\n    public static int size(final Object object) {\n        if (object == null) {\n            return 0;\n        }\n        int total = 0;\n        if (object instanceof Map<?,?>) {\n            total = ((Map<?, ?>) object).size();\n        } else if (object instanceof Collection<?>) {\n            total = ((Collection<?>) object).size();\n        } else if (object instanceof Iterable<?>) {\n            total = IterableUtils.size((Iterable<?>) object);\n        } else if (object instanceof Object[]) {\n            total = ((Object[]) object).length;\n        } else if (object instanceof Iterator<?>) {\n            total = IteratorUtils.size((Iterator<?>) object);\n        } else if (object instanceof Enumeration<?>) {\n            final Enumeration<?> it = (Enumeration<?>) object;\n            while (it.hasMoreElements()) {\n                total++;\n                it.nextElement();\n            }\n        } else {\n            try {\n                total = Array.getLength(object);\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Checks if the specified collection/array/iterator is empty.\n     * <p>\n     * This method can handles objects as follows\n     * <ul>\n     * <li>Collection - via collection isEmpty\n     * <li>Map - via map isEmpty\n     * <li>Array - using array size\n     * <li>Iterator - via hasNext\n     * <li>Enumeration - via hasMoreElements\n     * </ul>\n     * <p>\n     * Note: This method is named to avoid clashing with\n     * {@link #isEmpty(Collection)}.\n     *\n     * @param object  the object to get the size of, may be null\n     * @return true if empty or null\n     * @throws IllegalArgumentException thrown if object is not recognized\n     * @since 3.2\n     */\n    public static boolean sizeIsEmpty(final Object object) {", "metadata": {"defects4j_task_id": "6624aaedc62ade86f7ffac3dff850b0d60070a079330ab958c9f9eca787f0cbf", "task_id": "apache_commons-collections/87", "ground_truth": "\n        if (object == null) {\n            return true;\n        } else if (object instanceof Collection<?>) {\n            return ((Collection<?>) object).isEmpty();\n        } else if (object instanceof Iterable<?>) {\n            return IterableUtils.isEmpty((Iterable<?>) object);\n        } else if (object instanceof Map<?, ?>) {\n            return ((Map<?, ?>) object).isEmpty();\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator<?>) {\n            return ((Iterator<?>) object).hasNext() == false;\n        } else if (object instanceof Enumeration<?>) {\n            return ((Enumeration<?>) object).hasMoreElements() == false;\n        } else {\n            try {\n                return Array.getLength(object) == 0;\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "CollectionUtils.java"], "context_start_lineno": 0, "function_name": "sizeIsEmpty", "left_context": "class CollectionUtils {\n\n    /**\n     * Returns the <code>index</code>-th <code>Map.Entry</code> in the <code>map</code>'s <code>entrySet</code>,\n     * throwing <code>IndexOutOfBoundsException</code> if there is no such element.\n     *\n     * @param <K>  the key type in the {@link Map}\n     * @param <V>  the key type in the {@link Map}\n     * @param map  the object to get a value from\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public static <K,V> Map.Entry<K, V> get(final Map<K,V> map, final int index) {\n        checkIndexBounds(index);\n        return get(map.entrySet(), index);\n    }\n\n    /**\n     * Gets the size of the collection/iterator specified.\n     * <p>\n     * This method can handles objects as follows\n     * <ul>\n     * <li>Collection - the collection size\n     * <li>Map - the map size\n     * <li>Array - the array size\n     * <li>Iterator - the number of elements remaining in the iterator\n     * <li>Enumeration - the number of elements remaining in the enumeration\n     * </ul>\n     *\n     * @param object  the object to get the size of, may be null\n     * @return the size of the specified collection or 0 if the object was null\n     * @throws IllegalArgumentException thrown if object is not recognized\n     * @since 3.1\n     */\n    public static int size(final Object object) {\n        if (object == null) {\n            return 0;\n        }\n        int total = 0;\n        if (object instanceof Map<?,?>) {\n            total = ((Map<?, ?>) object).size();\n        } else if (object instanceof Collection<?>) {\n            total = ((Collection<?>) object).size();\n        } else if (object instanceof Iterable<?>) {\n            total = IterableUtils.size((Iterable<?>) object);\n        } else if (object instanceof Object[]) {\n            total = ((Object[]) object).length;\n        } else if (object instanceof Iterator<?>) {\n            total = IteratorUtils.size((Iterator<?>) object);\n        } else if (object instanceof Enumeration<?>) {\n            final Enumeration<?> it = (Enumeration<?>) object;\n            while (it.hasMoreElements()) {\n                total++;\n                it.nextElement();\n            }\n        } else {\n            try {\n                total = Array.getLength(object);\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Checks if the specified collection/array/iterator is empty.\n     * <p>\n     * This method can handles objects as follows\n     * <ul>\n     * <li>Collection - via collection isEmpty\n     * <li>Map - via map isEmpty\n     * <li>Array - using array size\n     * <li>Iterator - via hasNext\n     * <li>Enumeration - via hasMoreElements\n     * </ul>\n     * <p>\n     * Note: This method is named to avoid clashing with\n     * {@link #isEmpty(Collection)}.\n     *\n     * @param object  the object to get the size of, may be null\n     * @return true if empty or null\n     * @throws IllegalArgumentException thrown if object is not recognized\n     * @since 3.2\n     */\n    public static boolean sizeIsEmpty(final Object object) {", "right_context": "}\n}", "class_name": "CollectionUtils", "return_type": "boolean", "parameters": [{"type": "Object", "name": "object"}]}}
{"prompt": "class IteratorUtils {\n    // validation is done in this class in certain cases because the\n    // public classes allow invalid states\n\n    /**\n     * Gets an {@link Iterator} that wraps the specified node's childNodes.\n     * The returned {@link Iterator} can be used for a single iteration.\n     * <p>\n     * Convenience method, allows easy iteration over NodeLists:\n     * <pre>\n     *   Iterator&lt;Node&gt; iterator = IteratorUtils.nodeListIterator(node);\n     *   for(Node childNode : IteratorUtils.asIterable(iterator)) {\n     *     ...\n     *   }\n     * </pre>\n     *\n     * @param node  the node to use, may not be null\n     * @return a new, single use {@link Iterator}\n     * @throws NullPointerException if node is null\n     * @since 4.0\n     */\n    public static NodeListIterator nodeListIterator(final Node node) {\n        if (node == null) {\n            throw new NullPointerException(\"Node must not be null\");\n        }\n        return new NodeListIterator(node);\n    }\n\n    // Peeking\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets an iterator that supports one-element lookahead.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a peeking iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0\n     */\n    public static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n        return PeekingIterator.peekingIterator(iterator);\n    }\n\n    // Pushback\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets an iterator that supports pushback of elements.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a pushback iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0\n     */\n    public static <E> Iterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n        return PushbackIterator.pushbackIterator(iterator);\n    }\n\n    // Skipping\n    //-----------------------------------------------------------------------\n    /**\n     * Decorates the specified iterator to skip the first N elements.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the first number of elements to skip\n     * @return a new skipping iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if offset is negative\n     * @since 4.1\n     */\n    public static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, long offset) {\n        return new SkippingIterator<E>(iterator, offset);\n    }\n\n    // Zipping\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E> the element type\n     * @param a  the first iterator to interleave\n     * @param b  the second iterator to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws NullPointerException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a,\n                                                         final Iterator<? extends E> b) {\n        return new ZippingIterator<E>(a, b);\n    }\n\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E> the element type\n     * @param a  the first iterator to interleave\n     * @param b  the second iterator to interleave\n     * @param c  the third iterator to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws NullPointerException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a,\n                                                         final Iterator<? extends E> b,\n                                                         final Iterator<? extends E> c) {\n        return new ZippingIterator<E>(a, b, c);\n    }\n\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E> the element type\n     * @param iterators  the array of iterators to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws NullPointerException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E>... iterators) {\n        return new ZippingIterator<E>(iterators);\n    }\n\n    // Views\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that provides an iterator view of the given enumeration.\n     *\n     * @param <E> the element type\n     * @param enumeration  the enumeration to use, may not be null\n     * @return a new iterator\n     * @throws NullPointerException if enumeration is null\n     */\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n        if (enumeration == null) {\n            throw new NullPointerException(\"Enumeration must not be null\");\n        }\n        return new EnumerationIterator<E>(enumeration);\n    }\n\n    /**\n     * Gets an iterator that provides an iterator view of the given enumeration\n     * that will remove elements from the specified collection.\n     *\n     * @param <E> the element type\n     * @param enumeration  the enumeration to use, may not be null\n     * @param removeCollection  the collection to remove elements from, may not be null\n     * @return a new iterator\n     * @throws NullPointerException if enumeration or removeCollection is null\n     */\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration,\n                                             final Collection<? super E> removeCollection) {\n        if (enumeration == null) {\n            throw new NullPointerException(\"Enumeration must not be null\");\n        }\n        if (removeCollection == null) {\n            throw new NullPointerException(\"Collection must not be null\");\n        }\n        return new EnumerationIterator<E>(enumeration, removeCollection);\n    }\n\n    /**\n     * Gets an enumeration that wraps an iterator.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new enumeration\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new IteratorEnumeration<E>(iterator);\n    }\n\n    /**\n     * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n     * used for a single iteration.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new, single use {@link Iterable}\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {", "metadata": {"defects4j_task_id": "03ab7a19a52de8480bc7bcbb078ea407935a637e14a712e1d32d88238054bbba", "task_id": "apache_commons-collections/5", "ground_truth": "\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new IteratorIterable<E>(iterator, false);\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "IteratorUtils.java"], "context_start_lineno": 0, "function_name": "asIterable", "left_context": "class IteratorUtils {\n    // validation is done in this class in certain cases because the\n    // public classes allow invalid states\n\n    /**\n     * Gets an {@link Iterator} that wraps the specified node's childNodes.\n     * The returned {@link Iterator} can be used for a single iteration.\n     * <p>\n     * Convenience method, allows easy iteration over NodeLists:\n     * <pre>\n     *   Iterator&lt;Node&gt; iterator = IteratorUtils.nodeListIterator(node);\n     *   for(Node childNode : IteratorUtils.asIterable(iterator)) {\n     *     ...\n     *   }\n     * </pre>\n     *\n     * @param node  the node to use, may not be null\n     * @return a new, single use {@link Iterator}\n     * @throws NullPointerException if node is null\n     * @since 4.0\n     */\n    public static NodeListIterator nodeListIterator(final Node node) {\n        if (node == null) {\n            throw new NullPointerException(\"Node must not be null\");\n        }\n        return new NodeListIterator(node);\n    }\n\n    // Peeking\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets an iterator that supports one-element lookahead.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a peeking iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0\n     */\n    public static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n        return PeekingIterator.peekingIterator(iterator);\n    }\n\n    // Pushback\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets an iterator that supports pushback of elements.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a pushback iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0\n     */\n    public static <E> Iterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n        return PushbackIterator.pushbackIterator(iterator);\n    }\n\n    // Skipping\n    //-----------------------------------------------------------------------\n    /**\n     * Decorates the specified iterator to skip the first N elements.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the first number of elements to skip\n     * @return a new skipping iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if offset is negative\n     * @since 4.1\n     */\n    public static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, long offset) {\n        return new SkippingIterator<E>(iterator, offset);\n    }\n\n    // Zipping\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E> the element type\n     * @param a  the first iterator to interleave\n     * @param b  the second iterator to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws NullPointerException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a,\n                                                         final Iterator<? extends E> b) {\n        return new ZippingIterator<E>(a, b);\n    }\n\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E> the element type\n     * @param a  the first iterator to interleave\n     * @param b  the second iterator to interleave\n     * @param c  the third iterator to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws NullPointerException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a,\n                                                         final Iterator<? extends E> b,\n                                                         final Iterator<? extends E> c) {\n        return new ZippingIterator<E>(a, b, c);\n    }\n\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E> the element type\n     * @param iterators  the array of iterators to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws NullPointerException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E>... iterators) {\n        return new ZippingIterator<E>(iterators);\n    }\n\n    // Views\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that provides an iterator view of the given enumeration.\n     *\n     * @param <E> the element type\n     * @param enumeration  the enumeration to use, may not be null\n     * @return a new iterator\n     * @throws NullPointerException if enumeration is null\n     */\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n        if (enumeration == null) {\n            throw new NullPointerException(\"Enumeration must not be null\");\n        }\n        return new EnumerationIterator<E>(enumeration);\n    }\n\n    /**\n     * Gets an iterator that provides an iterator view of the given enumeration\n     * that will remove elements from the specified collection.\n     *\n     * @param <E> the element type\n     * @param enumeration  the enumeration to use, may not be null\n     * @param removeCollection  the collection to remove elements from, may not be null\n     * @return a new iterator\n     * @throws NullPointerException if enumeration or removeCollection is null\n     */\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration,\n                                             final Collection<? super E> removeCollection) {\n        if (enumeration == null) {\n            throw new NullPointerException(\"Enumeration must not be null\");\n        }\n        if (removeCollection == null) {\n            throw new NullPointerException(\"Collection must not be null\");\n        }\n        return new EnumerationIterator<E>(enumeration, removeCollection);\n    }\n\n    /**\n     * Gets an enumeration that wraps an iterator.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new enumeration\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new IteratorEnumeration<E>(iterator);\n    }\n\n    /**\n     * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n     * used for a single iteration.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new, single use {@link Iterable}\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {", "right_context": "}\n\n}", "class_name": "IteratorUtils", "return_type": "Iterable<E>", "parameters": [{"type": "Iterator<? extends E>", "name": "iterator"}]}}
{"prompt": "class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n\n    /** The factory for creating value collections. */\n    private final Factory<? extends Collection<V>> collectionFactory;\n    /** The cached values. */\n    private transient Collection<V> valuesView;\n\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to wrap\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n        return MultiValueMap.<K, V, ArrayList> multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * maps keys to collections of type <code>collectionClass</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to wrap\n     * @param collectionClass  the type of the collection class\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n                                                                                    final Class<C> collectionClass) {\n        return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory (must return a Collection object).\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n            final Factory<C> collectionFactory) {\n        return new MultiValueMap<K, V>(map, collectionFactory);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a MultiValueMap based on a <code>HashMap</code> and\n     * storing the multiple values in an <code>ArrayList</code>.\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public MultiValueMap() {\n        this(new HashMap<K, V>(), new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a MultiValueMap which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory which must return a Collection instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected <C extends Collection<V>> MultiValueMap(final Map<K, ? super C> map,\n                                                      final Factory<C> collectionFactory) {\n        super((Map<K, Object>) map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 4.0\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, Object>) in.readObject(); // (1)\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clear the map.\n     */\n    @Override\n    public void clear() {\n        // If you believe that you have GC issues here, try uncommenting this code\n//        Set pairs = getMap().entrySet();\n//        Iterator pairsIterator = pairs.iterator();\n//        while (pairsIterator.hasNext()) {\n//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n//            Collection coll = (Collection) keyValuePair.getValue();\n//            coll.clear();\n//        }\n        decorated().clear();\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, <code>null</code> will be returned\n     * from a subsequent <code>get(key)</code>.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return {@code true} if the mapping was removed, {@code false} otherwise\n     */\n    @Override\n    public boolean removeMapping(final Object key, final Object value) {", "metadata": {"defects4j_task_id": "35e3335c6d6bfe898d1e61d441f137acc4295de807dea874e221371cbe3a65f7", "task_id": "apache_commons-collections/47", "ground_truth": "\n        final Collection<V> valuesForKey = getCollection(key);\n        if (valuesForKey == null) {\n            return false;\n        }\n        final boolean removed = valuesForKey.remove(value);\n        if (removed == false) {\n            return false;\n        }\n        if (valuesForKey.isEmpty()) {\n            remove(key);\n        }\n        return true;\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "map", "MultiValueMap.java"], "context_start_lineno": 0, "function_name": "removeMapping", "left_context": "class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n\n    /** The factory for creating value collections. */\n    private final Factory<? extends Collection<V>> collectionFactory;\n    /** The cached values. */\n    private transient Collection<V> valuesView;\n\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to wrap\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n        return MultiValueMap.<K, V, ArrayList> multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * maps keys to collections of type <code>collectionClass</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to wrap\n     * @param collectionClass  the type of the collection class\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n                                                                                    final Class<C> collectionClass) {\n        return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory (must return a Collection object).\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n            final Factory<C> collectionFactory) {\n        return new MultiValueMap<K, V>(map, collectionFactory);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a MultiValueMap based on a <code>HashMap</code> and\n     * storing the multiple values in an <code>ArrayList</code>.\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public MultiValueMap() {\n        this(new HashMap<K, V>(), new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a MultiValueMap which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory which must return a Collection instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected <C extends Collection<V>> MultiValueMap(final Map<K, ? super C> map,\n                                                      final Factory<C> collectionFactory) {\n        super((Map<K, Object>) map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 4.0\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, Object>) in.readObject(); // (1)\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clear the map.\n     */\n    @Override\n    public void clear() {\n        // If you believe that you have GC issues here, try uncommenting this code\n//        Set pairs = getMap().entrySet();\n//        Iterator pairsIterator = pairs.iterator();\n//        while (pairsIterator.hasNext()) {\n//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n//            Collection coll = (Collection) keyValuePair.getValue();\n//            coll.clear();\n//        }\n        decorated().clear();\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, <code>null</code> will be returned\n     * from a subsequent <code>get(key)</code>.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return {@code true} if the mapping was removed, {@code false} otherwise\n     */\n    @Override\n    public boolean removeMapping(final Object key, final Object value) {", "right_context": "}\n\n}", "class_name": "MultiValueMap", "return_type": "boolean", "parameters": [{"type": "Object", "name": "key"}, {"type": "Object", "name": "value"}]}}
{"prompt": "class StaticBucketMap<K, V> extends AbstractIterableMap<K, V> {\n\n    /** The array of buckets, where the actual data is held */\n    private final Node<K, V>[] buckets;\n    /** The matching array of locks */\n    private final Lock[] locks;\n\n    /**\n     * Initializes the map with the default number of buckets (255).\n     */\n    public StaticBucketMap() {\n        this(DEFAULT_BUCKETS);\n    }\n\n    /**\n     * Initializes the map with a specified number of buckets.  The number\n     * of buckets is never below 17, and is always an odd number (StaticBucketMap\n     * ensures this). The number of buckets is inversely proportional to the\n     * chances for thread contention.  The fewer buckets, the more chances for\n     * thread contention.  The more buckets the fewer chances for thread\n     * contention.\n     *\n     * @param numBuckets  the number of buckets for this map\n     */\n    @SuppressWarnings(\"unchecked\")\n    public StaticBucketMap(final int numBuckets) {\n        int size = Math.max(17, numBuckets);\n\n        // Ensure that bucketSize is never a power of 2 (to ensure maximal distribution)\n        if (size % 2 == 0) {\n            size--;\n        }\n\n        buckets = new Node[size];\n        locks = new Lock[size];\n\n        for (int i = 0; i < size; i++) {\n            locks[i] = new Lock();\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Determine the exact hash entry for the key.  The hash algorithm\n     * is rather simplistic, but it does the job:\n     *\n     * <pre>\n     *   He = |Hk mod n|\n     * </pre>\n     *\n     * <p>\n     *   He is the entry's hashCode, Hk is the key's hashCode, and n is\n     *   the number of buckets.\n     * </p>\n     */\n    private int getHash(final Object key) {", "metadata": {"defects4j_task_id": "399bb0210e79dac615cae3ea878710425a2c4dd6dc7549c477ae6396d021465b", "task_id": "apache_commons-collections/50", "ground_truth": "\n        if (key == null) {\n            return 0;\n        }\n        int hash = key.hashCode();\n        hash += ~(hash << 15);\n        hash ^= (hash >>> 10);\n        hash += (hash << 3);\n        hash ^= (hash >>> 6);\n        hash += ~(hash << 11);\n        hash ^= (hash >>> 16);\n        hash %= buckets.length;\n        return (hash < 0) ? hash * -1 : hash;\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "map", "StaticBucketMap.java"], "context_start_lineno": 0, "function_name": "getHash", "left_context": "class StaticBucketMap<K, V> extends AbstractIterableMap<K, V> {\n\n    /** The array of buckets, where the actual data is held */\n    private final Node<K, V>[] buckets;\n    /** The matching array of locks */\n    private final Lock[] locks;\n\n    /**\n     * Initializes the map with the default number of buckets (255).\n     */\n    public StaticBucketMap() {\n        this(DEFAULT_BUCKETS);\n    }\n\n    /**\n     * Initializes the map with a specified number of buckets.  The number\n     * of buckets is never below 17, and is always an odd number (StaticBucketMap\n     * ensures this). The number of buckets is inversely proportional to the\n     * chances for thread contention.  The fewer buckets, the more chances for\n     * thread contention.  The more buckets the fewer chances for thread\n     * contention.\n     *\n     * @param numBuckets  the number of buckets for this map\n     */\n    @SuppressWarnings(\"unchecked\")\n    public StaticBucketMap(final int numBuckets) {\n        int size = Math.max(17, numBuckets);\n\n        // Ensure that bucketSize is never a power of 2 (to ensure maximal distribution)\n        if (size % 2 == 0) {\n            size--;\n        }\n\n        buckets = new Node[size];\n        locks = new Lock[size];\n\n        for (int i = 0; i < size; i++) {\n            locks[i] = new Lock();\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Determine the exact hash entry for the key.  The hash algorithm\n     * is rather simplistic, but it does the job:\n     *\n     * <pre>\n     *   He = |Hk mod n|\n     * </pre>\n     *\n     * <p>\n     *   He is the entry's hashCode, Hk is the key's hashCode, and n is\n     *   the number of buckets.\n     * </p>\n     */\n    private int getHash(final Object key) {", "right_context": "}\n\n}", "class_name": "StaticBucketMap", "return_type": "int", "parameters": [{"type": "Object", "name": "key"}]}}
{"prompt": "class TransformedMap<K, V>\n        extends AbstractInputCheckedMapDecorator<K, V>\n        implements Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7023152376788900464L;\n\n    /** The transformer to use for the key */\n    protected final Transformer<? super K, ? extends K> keyTransformer;\n    /** The transformer to use for the value */\n    protected final Transformer<? super V, ? extends V> valueTransformer;\n\n    /**\n     * Factory method to create a transforming map.\n     * <p>\n     * If there are any elements already in the map being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n     * @return a new transformed map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n    }\n\n    /**\n     * Factory method to create a transforming map that will transform\n     * existing contents of the specified map.\n     * <p>\n     * If there are any elements already in the map being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n     * @return a new transformed map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        final TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n        if (map.size() > 0) {\n            final Map<K, V> transformed = decorated.transformMap(map);\n            decorated.clear();\n            decorated.decorated().putAll(transformed);  // avoids double transformation\n        }\n        return decorated;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are NOT transformed.\n     *\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n     * @throws NullPointerException if map is null\n     */\n    protected TransformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        super(map);\n        this.keyTransformer = keyTransformer;\n        this.valueTransformer = valueTransformer;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Transforms a key.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object\n     */\n    protected K transformKey(final K object) {\n        if (keyTransformer == null) {\n            return object;\n        }\n        return keyTransformer.transform(object);\n    }\n\n    /**\n     * Transforms a value.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object\n     */\n    protected V transformValue(final V object) {\n        if (valueTransformer == null) {\n            return object;\n        }\n        return valueTransformer.transform(object);\n    }\n\n    /**\n     * Transforms a map.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param map  the map to transform\n     * @return the transformed object\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map) {", "metadata": {"defects4j_task_id": "0b1a88382c234f455384b43e088b05def5c0e70b9bd885123e06c5f9ac4a3848", "task_id": "apache_commons-collections/12", "ground_truth": "\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "map", "TransformedMap.java"], "context_start_lineno": 0, "function_name": "transformMap", "left_context": "class TransformedMap<K, V>\n        extends AbstractInputCheckedMapDecorator<K, V>\n        implements Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7023152376788900464L;\n\n    /** The transformer to use for the key */\n    protected final Transformer<? super K, ? extends K> keyTransformer;\n    /** The transformer to use for the value */\n    protected final Transformer<? super V, ? extends V> valueTransformer;\n\n    /**\n     * Factory method to create a transforming map.\n     * <p>\n     * If there are any elements already in the map being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n     * @return a new transformed map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n    }\n\n    /**\n     * Factory method to create a transforming map that will transform\n     * existing contents of the specified map.\n     * <p>\n     * If there are any elements already in the map being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n     * @return a new transformed map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        final TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n        if (map.size() > 0) {\n            final Map<K, V> transformed = decorated.transformMap(map);\n            decorated.clear();\n            decorated.decorated().putAll(transformed);  // avoids double transformation\n        }\n        return decorated;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are NOT transformed.\n     *\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n     * @throws NullPointerException if map is null\n     */\n    protected TransformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        super(map);\n        this.keyTransformer = keyTransformer;\n        this.valueTransformer = valueTransformer;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Transforms a key.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object\n     */\n    protected K transformKey(final K object) {\n        if (keyTransformer == null) {\n            return object;\n        }\n        return keyTransformer.transform(object);\n    }\n\n    /**\n     * Transforms a value.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object\n     */\n    protected V transformValue(final V object) {\n        if (valueTransformer == null) {\n            return object;\n        }\n        return valueTransformer.transform(object);\n    }\n\n    /**\n     * Transforms a map.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param map  the map to transform\n     * @return the transformed object\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map) {", "right_context": "}\n\n    /**\n     * Override to transform the value when using <code>setValue</code>.\n     *\n     * @param value  the value to transform\n     * @return the transformed value\n     * @since 3.1\n     */\n    @Override\n    protected V checkSetValue(final V value) {\n        return valueTransformer.transform(value);\n    }\n\n    /**\n     * Override to only return true when there is a value transformer.\n     *\n     * @return true if a value transformer is in use\n     * @since 3.1\n     */\n    @Override\n    protected boolean isSetValueChecking() {\n        return valueTransformer != null;\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public V put(K key, V value) {\n        key = transformKey(key);\n        value = transformValue(value);\n        return decorated().put(key, value);\n    }\n\n    @Override\n    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n        mapToCopy = transformMap(mapToCopy);\n        decorated().putAll(mapToCopy);\n    }\n\n}", "class_name": "TransformedMap", "return_type": "Map<K,V>", "parameters": [{"type": "Map<? extends K,? extends V>", "name": "map"}]}}
{"prompt": "class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n\n    /** Internal Set to maintain uniqueness. */\n    private final Set<E> set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one\n     * kept). A <code>HashSet</code> is used for the set behaviour.\n     *\n     * @param <E>  the element type\n     * @param list  the list to decorate, must not be null\n     * @return a new {@link SetUniqueList}\n     * @throws NullPointerException if list is null\n     * @since 4.0\n     */\n    public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {", "metadata": {"defects4j_task_id": "400833213424f1dc9f038565bce145855242462139c65b560eeb2d482c154f4e", "task_id": "apache_commons-collections/57", "ground_truth": "\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList<E>(list, new HashSet<E>());\n        }\n        final List<E> temp = new ArrayList<E>(list);\n        list.clear();\n        final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n        sl.addAll(temp);\n        return sl;\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "list", "SetUniqueList.java"], "context_start_lineno": 0, "function_name": "setUniqueList", "left_context": "class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n\n    /** Internal Set to maintain uniqueness. */\n    private final Set<E> set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one\n     * kept). A <code>HashSet</code> is used for the set behaviour.\n     *\n     * @param <E>  the element type\n     * @param list  the list to decorate, must not be null\n     * @return a new {@link SetUniqueList}\n     * @throws NullPointerException if list is null\n     * @since 4.0\n     */\n    public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {", "right_context": "}\n\n}", "class_name": "SetUniqueList", "return_type": "SetUniqueList<E>", "parameters": [{"type": "List<E>", "name": "list"}]}}
{"prompt": "class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n\n    /** Internal Set to maintain uniqueness. */\n    private final Set<E> set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one\n     * kept). A <code>HashSet</code> is used for the set behaviour.\n     *\n     * @param <E>  the element type\n     * @param list  the list to decorate, must not be null\n     * @return a new {@link SetUniqueList}\n     * @throws NullPointerException if list is null\n     * @since 4.0\n     */\n    public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList<E>(list, new HashSet<E>());\n        }\n        final List<E> temp = new ArrayList<E>(list);\n        list.clear();\n        final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n        sl.addAll(temp);\n        return sl;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws NullPointerException if set or list is null\n     */\n    protected SetUniqueList(final List<E> list, final Set<E> set) {\n        super(list);\n        if (set == null) {\n            throw new NullPointerException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     *\n     * @return an unmodifiable set view\n     */\n    public Set<E> asSet() {\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface requires that this\n     * method returns <code>true</code> always. However this class may return\n     * <code>false</code> because of the <code>Set</code> behaviour.\n     *\n     * @param object  the object to add\n     * @return true if object was added\n     */\n    @Override\n    public boolean add(final E object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already\n     * present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the element is always inserted. This may not happen with this\n     * implementation.\n     *\n     * @param index  the index to insert at\n     * @param object  the object to add\n     */\n    @Override\n    public void add(final int index, final E object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     *\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding\n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     *\n     * @param index  the index to insert at\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {", "metadata": {"defects4j_task_id": "d9d42e2825b749944953199b5904ae8bade541036e66fffa390148261d03e142", "task_id": "apache_commons-collections/178", "ground_truth": "\n        final List<E> temp = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.add(e)) {\n                temp.add(e);\n            }\n        }\n        return super.addAll(index, temp);\n    ", "fpath_tuple": ["apache_commons-collections", "commons-collections", "src", "main", "java", "org", "apache", "commons", "collections4", "list", "SetUniqueList.java"], "context_start_lineno": 0, "function_name": "addAll", "left_context": "class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n\n    /** Internal Set to maintain uniqueness. */\n    private final Set<E> set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one\n     * kept). A <code>HashSet</code> is used for the set behaviour.\n     *\n     * @param <E>  the element type\n     * @param list  the list to decorate, must not be null\n     * @return a new {@link SetUniqueList}\n     * @throws NullPointerException if list is null\n     * @since 4.0\n     */\n    public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList<E>(list, new HashSet<E>());\n        }\n        final List<E> temp = new ArrayList<E>(list);\n        list.clear();\n        final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n        sl.addAll(temp);\n        return sl;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws NullPointerException if set or list is null\n     */\n    protected SetUniqueList(final List<E> list, final Set<E> set) {\n        super(list);\n        if (set == null) {\n            throw new NullPointerException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     *\n     * @return an unmodifiable set view\n     */\n    public Set<E> asSet() {\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface requires that this\n     * method returns <code>true</code> always. However this class may return\n     * <code>false</code> because of the <code>Set</code> behaviour.\n     *\n     * @param object  the object to add\n     * @return true if object was added\n     */\n    @Override\n    public boolean add(final E object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already\n     * present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the element is always inserted. This may not happen with this\n     * implementation.\n     *\n     * @param index  the index to insert at\n     * @param object  the object to add\n     */\n    @Override\n    public void add(final int index, final E object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     *\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding\n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     *\n     * @param index  the index to insert at\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {", "right_context": "}\n\n}", "class_name": "SetUniqueList", "return_type": "boolean", "parameters": [{"type": "int", "name": "index"}, {"type": "Collection<? extends E>", "name": "coll"}]}}
{"prompt": "class CMAESOptimizer\n    extends MultivariateOptimizer {\n    // global search parameters\n    /**\n     * Update of the covariance matrix C.\n     *\n     * @param hsig Flag indicating a small correction.\n     * @param bestArx Fitness-sorted matrix of the argument vectors producing the\n     * current offspring.\n     * @param arz Unsorted matrix containing the gaussian random values of the\n     * current offspring.\n     * @param arindex Indices indicating the fitness-order of the current offspring.\n     * @param xold xmean matrix of the previous generation.\n     */\n    private void updateCovariance(boolean hsig, final RealMatrix bestArx,\n                                  final RealMatrix arz, final int[] arindex,\n                                  final RealMatrix xold) {\n        double negccov = 0;\n        if (ccov1 + ccovmu > 0) {\n            final RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\n                .scalarMultiply(1 / sigma); // mu difference vectors\n            final RealMatrix roneu = pc.multiply(pc.transpose())\n                .scalarMultiply(ccov1); // rank one update\n            // minor correction if hsig==false\n            double oldFac = hsig ? 0 : ccov1 * cc * (2 - cc);\n            oldFac += 1 - ccov1 - ccovmu;\n            if (isActiveCMA) {\n                // Adapt covariance matrix C active CMA\n                negccov = (1 - ccovmu) * 0.25 * mueff /\n                    (Math.pow(dimension + 2, 1.5) + 2 * mueff);\n                // keep at least 0.66 in all directions, small popsize are most\n                // critical\n                final double negminresidualvariance = 0.66;\n                // where to make up for the variance loss\n                final double negalphaold = 0.5;\n                // prepare vectors, compute negative updating matrix Cneg\n                final int[] arReverseIndex = reverse(arindex);\n                RealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\n                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));\n                final int[] idxnorms = sortedIndices(arnorms.getRow(0));\n                final RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\n                final int[] idxReverse = reverse(idxnorms);\n                final RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\n                arnorms = divide(arnormsReverse, arnormsSorted);\n                final int[] idxInv = inverse(idxnorms);\n                final RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\n                // check and set learning rate negccov\n                final double negcovMax = (1 - negminresidualvariance) /\n                    square(arnormsInv).multiply(weights).getEntry(0, 0);\n                if (negccov > negcovMax) {\n                    negccov = negcovMax;\n                }\n                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\n                final RealMatrix artmp = BD.multiply(arzneg);\n                final RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(artmp.transpose());\n                oldFac += negalphaold * negccov;\n                C = C.scalarMultiply(oldFac)\n                    .add(roneu) // regard old matrix\n                    .add(arpos.scalarMultiply( // plus rank one update\n                                              ccovmu + (1 - negalphaold) * negccov) // plus rank mu update\n                         .multiply(times(repmat(weights, 1, dimension),\n                                         arpos.transpose())))\n                    .subtract(Cneg.scalarMultiply(negccov));\n            } else {\n                // Adapt covariance matrix C - nonactive\n                C = C.scalarMultiply(oldFac) // regard old matrix\n                    .add(roneu) // plus rank one update\n                    .add(arpos.scalarMultiply(ccovmu) // plus rank mu update\n                         .multiply(times(repmat(weights, 1, dimension),\n                                         arpos.transpose())));\n            }\n        }\n        updateBD(negccov);\n    }\n\n    /**\n     * Update B and D from C.\n     *\n     * @param negccov Negative covariance factor.\n     */\n    private void updateBD(double negccov) {\n        if (ccov1 + ccovmu + negccov > 0 &&\n            (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1) {\n            // to achieve O(N^2)\n            C = triu(C, 0).add(triu(C, 1).transpose());\n            // enforce symmetry to prevent complex numbers\n            final EigenDecomposition eig = new EigenDecomposition(C);\n            B = eig.getV(); // eigen decomposition, B==normalized eigenvectors\n            D = eig.getD();\n            diagD = diag(D);\n            if (min(diagD) <= 0) {\n                for (int i = 0; i < dimension; i++) {\n                    if (diagD.getEntry(i, 0) < 0) {\n                        diagD.setEntry(i, 0, 0);\n                    }\n                }\n                final double tfac = max(diagD) / 1e14;\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            if (max(diagD) > 1e14 * min(diagD)) {\n                final double tfac = max(diagD) / 1e14 - min(diagD);\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            diagC = diag(C);\n            diagD = sqrt(diagD); // D contains standard deviations now\n            BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)\n        }\n    }\n\n    /**\n     * Pushes the current best fitness value in a history queue.\n     *\n     * @param vals History queue.\n     * @param val Current best fitness value.\n     */\n    private static void push(double[] vals, double val) {\n        for (int i = vals.length-1; i > 0; i--) {\n            vals[i] = vals[i-1];\n        }\n        vals[0] = val;\n    }\n\n    /**\n     * Sorts fitness values.\n     *\n     * @param doubles Array of values to be sorted.\n     * @return a sorted array of indices pointing into doubles.\n     */\n    private int[] sortedIndices(final double[] doubles) {", "metadata": {"defects4j_task_id": "9166ed5327015646cc9c651e63fd7f314188c23112b8da02cf24bfc3ff88a1b1", "task_id": "apache_commons-math/119", "ground_truth": "\n        final DoubleIndex[] dis = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            dis[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(dis);\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            indices[i] = dis[i].index;\n        }\n        return indices;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "optim", "nonlinear", "scalar", "noderiv", "CMAESOptimizer.java"], "context_start_lineno": 0, "function_name": "sortedIndices", "left_context": "class CMAESOptimizer\n    extends MultivariateOptimizer {\n    // global search parameters\n    /**\n     * Update of the covariance matrix C.\n     *\n     * @param hsig Flag indicating a small correction.\n     * @param bestArx Fitness-sorted matrix of the argument vectors producing the\n     * current offspring.\n     * @param arz Unsorted matrix containing the gaussian random values of the\n     * current offspring.\n     * @param arindex Indices indicating the fitness-order of the current offspring.\n     * @param xold xmean matrix of the previous generation.\n     */\n    private void updateCovariance(boolean hsig, final RealMatrix bestArx,\n                                  final RealMatrix arz, final int[] arindex,\n                                  final RealMatrix xold) {\n        double negccov = 0;\n        if (ccov1 + ccovmu > 0) {\n            final RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\n                .scalarMultiply(1 / sigma); // mu difference vectors\n            final RealMatrix roneu = pc.multiply(pc.transpose())\n                .scalarMultiply(ccov1); // rank one update\n            // minor correction if hsig==false\n            double oldFac = hsig ? 0 : ccov1 * cc * (2 - cc);\n            oldFac += 1 - ccov1 - ccovmu;\n            if (isActiveCMA) {\n                // Adapt covariance matrix C active CMA\n                negccov = (1 - ccovmu) * 0.25 * mueff /\n                    (Math.pow(dimension + 2, 1.5) + 2 * mueff);\n                // keep at least 0.66 in all directions, small popsize are most\n                // critical\n                final double negminresidualvariance = 0.66;\n                // where to make up for the variance loss\n                final double negalphaold = 0.5;\n                // prepare vectors, compute negative updating matrix Cneg\n                final int[] arReverseIndex = reverse(arindex);\n                RealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\n                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));\n                final int[] idxnorms = sortedIndices(arnorms.getRow(0));\n                final RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\n                final int[] idxReverse = reverse(idxnorms);\n                final RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\n                arnorms = divide(arnormsReverse, arnormsSorted);\n                final int[] idxInv = inverse(idxnorms);\n                final RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\n                // check and set learning rate negccov\n                final double negcovMax = (1 - negminresidualvariance) /\n                    square(arnormsInv).multiply(weights).getEntry(0, 0);\n                if (negccov > negcovMax) {\n                    negccov = negcovMax;\n                }\n                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\n                final RealMatrix artmp = BD.multiply(arzneg);\n                final RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(artmp.transpose());\n                oldFac += negalphaold * negccov;\n                C = C.scalarMultiply(oldFac)\n                    .add(roneu) // regard old matrix\n                    .add(arpos.scalarMultiply( // plus rank one update\n                                              ccovmu + (1 - negalphaold) * negccov) // plus rank mu update\n                         .multiply(times(repmat(weights, 1, dimension),\n                                         arpos.transpose())))\n                    .subtract(Cneg.scalarMultiply(negccov));\n            } else {\n                // Adapt covariance matrix C - nonactive\n                C = C.scalarMultiply(oldFac) // regard old matrix\n                    .add(roneu) // plus rank one update\n                    .add(arpos.scalarMultiply(ccovmu) // plus rank mu update\n                         .multiply(times(repmat(weights, 1, dimension),\n                                         arpos.transpose())));\n            }\n        }\n        updateBD(negccov);\n    }\n\n    /**\n     * Update B and D from C.\n     *\n     * @param negccov Negative covariance factor.\n     */\n    private void updateBD(double negccov) {\n        if (ccov1 + ccovmu + negccov > 0 &&\n            (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1) {\n            // to achieve O(N^2)\n            C = triu(C, 0).add(triu(C, 1).transpose());\n            // enforce symmetry to prevent complex numbers\n            final EigenDecomposition eig = new EigenDecomposition(C);\n            B = eig.getV(); // eigen decomposition, B==normalized eigenvectors\n            D = eig.getD();\n            diagD = diag(D);\n            if (min(diagD) <= 0) {\n                for (int i = 0; i < dimension; i++) {\n                    if (diagD.getEntry(i, 0) < 0) {\n                        diagD.setEntry(i, 0, 0);\n                    }\n                }\n                final double tfac = max(diagD) / 1e14;\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            if (max(diagD) > 1e14 * min(diagD)) {\n                final double tfac = max(diagD) / 1e14 - min(diagD);\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            diagC = diag(C);\n            diagD = sqrt(diagD); // D contains standard deviations now\n            BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)\n        }\n    }\n\n    /**\n     * Pushes the current best fitness value in a history queue.\n     *\n     * @param vals History queue.\n     * @param val Current best fitness value.\n     */\n    private static void push(double[] vals, double val) {\n        for (int i = vals.length-1; i > 0; i--) {\n            vals[i] = vals[i-1];\n        }\n        vals[0] = val;\n    }\n\n    /**\n     * Sorts fitness values.\n     *\n     * @param doubles Array of values to be sorted.\n     * @return a sorted array of indices pointing into doubles.\n     */\n    private int[] sortedIndices(final double[] doubles) {", "right_context": "}\n}", "class_name": "CMAESOptimizer", "return_type": "int[]", "parameters": [{"type": "double[]", "name": "doubles"}]}}
{"prompt": "class CMAESOptimizer\n    extends MultivariateOptimizer {\n    // global search parameters\n    /**\n     * Pushes the current best fitness value in a history queue.\n     *\n     * @param vals History queue.\n     * @param val Current best fitness value.\n     */\n    private static void push(double[] vals, double val) {\n        for (int i = vals.length-1; i > 0; i--) {\n            vals[i] = vals[i-1];\n        }\n        vals[0] = val;\n    }\n\n    /**\n     * Sorts fitness values.\n     *\n     * @param doubles Array of values to be sorted.\n     * @return a sorted array of indices pointing into doubles.\n     */\n    private int[] sortedIndices(final double[] doubles) {\n        final DoubleIndex[] dis = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            dis[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(dis);\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            indices[i] = dis[i].index;\n        }\n        return indices;\n    }\n\n    /**\n     * Used to sort fitness values. Sorting is always in lower value first\n     * order.\n     */\n    private static class DoubleIndex implements Comparable<DoubleIndex> {\n        /** Value to compare. */\n        private final double value;\n        /** Index into sorted array. */\n        private final int index;\n\n        /**\n         * @param value Value to compare.\n         * @param index Index into sorted array.\n         */\n        DoubleIndex(double value, int index) {\n            this.value = value;\n            this.index = index;\n        }\n\n        /** {@inheritDoc} */\n        public int compareTo(DoubleIndex o) {\n            return Double.compare(value, o.value);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean equals(Object other) {\n\n            if (this == other) {\n                return true;\n            }\n\n            if (other instanceof DoubleIndex) {\n                return Double.compare(value, ((DoubleIndex) other).value) == 0;\n            }\n\n            return false;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int hashCode() {\n            long bits = Double.doubleToLongBits(value);\n            return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff);\n        }\n    }\n\n    /**\n     * Normalizes fitness values to the range [0,1]. Adds a penalty to the\n     * fitness value if out of range. The penalty is adjusted by calling\n     * setValueRange().\n     */\n    private class FitnessFunction {\n        /** Determines the penalty for boundary violations */\n        private double valueRange;\n        /**\n         * Flag indicating whether the objective variables are forced into their\n         * bounds if defined\n         */\n        private final boolean isRepairMode;\n\n        /** Simple constructor.\n         */\n        public FitnessFunction() {\n            valueRange = 1;\n            isRepairMode = true;\n        }\n\n        /**\n         * @param point Normalized objective variables.\n         * @return the objective value + penalty for violated bounds.\n         */\n        public double value(final double[] point) {\n            double value;\n            if (isRepairMode) {\n                double[] repaired = repair(point);\n                value = CMAESOptimizer.this.computeObjectiveValue(repaired) +\n                    penalty(point, repaired);\n            } else {\n                value = CMAESOptimizer.this.computeObjectiveValue(point);\n            }\n            return isMinimize ? value : -value;\n        }\n\n        /**\n         * @param x Normalized objective variables.\n         * @return {@code true} if in bounds.\n         */\n        public boolean isFeasible(final double[] x) {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    return false;\n                }\n                if (x[i] > uB[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        /**\n         * @param valueRange Adjusts the penalty computation.\n         */\n        public void setValueRange(double valueRange) {\n            this.valueRange = valueRange;\n        }\n\n        /**\n         * @param x Normalized objective variables.\n         * @return the repaired (i.e. all in bounds) objective variables.\n         */\n        private double[] repair(final double[] x) {", "metadata": {"defects4j_task_id": "54fa6e19f385a309c98f7729ddd4e48143939085abd371ac6d196a71dca2595c", "task_id": "apache_commons-math/73", "ground_truth": "\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n            final double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "optim", "nonlinear", "scalar", "noderiv", "CMAESOptimizer.java"], "context_start_lineno": 0, "function_name": "repair", "left_context": "class CMAESOptimizer\n    extends MultivariateOptimizer {\n    // global search parameters\n    /**\n     * Pushes the current best fitness value in a history queue.\n     *\n     * @param vals History queue.\n     * @param val Current best fitness value.\n     */\n    private static void push(double[] vals, double val) {\n        for (int i = vals.length-1; i > 0; i--) {\n            vals[i] = vals[i-1];\n        }\n        vals[0] = val;\n    }\n\n    /**\n     * Sorts fitness values.\n     *\n     * @param doubles Array of values to be sorted.\n     * @return a sorted array of indices pointing into doubles.\n     */\n    private int[] sortedIndices(final double[] doubles) {\n        final DoubleIndex[] dis = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            dis[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(dis);\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            indices[i] = dis[i].index;\n        }\n        return indices;\n    }\n\n    /**\n     * Used to sort fitness values. Sorting is always in lower value first\n     * order.\n     */\n    private static class DoubleIndex implements Comparable<DoubleIndex> {\n        /** Value to compare. */\n        private final double value;\n        /** Index into sorted array. */\n        private final int index;\n\n        /**\n         * @param value Value to compare.\n         * @param index Index into sorted array.\n         */\n        DoubleIndex(double value, int index) {\n            this.value = value;\n            this.index = index;\n        }\n\n        /** {@inheritDoc} */\n        public int compareTo(DoubleIndex o) {\n            return Double.compare(value, o.value);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean equals(Object other) {\n\n            if (this == other) {\n                return true;\n            }\n\n            if (other instanceof DoubleIndex) {\n                return Double.compare(value, ((DoubleIndex) other).value) == 0;\n            }\n\n            return false;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int hashCode() {\n            long bits = Double.doubleToLongBits(value);\n            return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff);\n        }\n    }\n\n    /**\n     * Normalizes fitness values to the range [0,1]. Adds a penalty to the\n     * fitness value if out of range. The penalty is adjusted by calling\n     * setValueRange().\n     */\n    private class FitnessFunction {\n        /** Determines the penalty for boundary violations */\n        private double valueRange;\n        /**\n         * Flag indicating whether the objective variables are forced into their\n         * bounds if defined\n         */\n        private final boolean isRepairMode;\n\n        /** Simple constructor.\n         */\n        public FitnessFunction() {\n            valueRange = 1;\n            isRepairMode = true;\n        }\n\n        /**\n         * @param point Normalized objective variables.\n         * @return the objective value + penalty for violated bounds.\n         */\n        public double value(final double[] point) {\n            double value;\n            if (isRepairMode) {\n                double[] repaired = repair(point);\n                value = CMAESOptimizer.this.computeObjectiveValue(repaired) +\n                    penalty(point, repaired);\n            } else {\n                value = CMAESOptimizer.this.computeObjectiveValue(point);\n            }\n            return isMinimize ? value : -value;\n        }\n\n        /**\n         * @param x Normalized objective variables.\n         * @return {@code true} if in bounds.\n         */\n        public boolean isFeasible(final double[] x) {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    return false;\n                }\n                if (x[i] > uB[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        /**\n         * @param valueRange Adjusts the penalty computation.\n         */\n        public void setValueRange(double valueRange) {\n            this.valueRange = valueRange;\n        }\n\n        /**\n         * @param x Normalized objective variables.\n         * @return the repaired (i.e. all in bounds) objective variables.\n         */\n        private double[] repair(final double[] x) {", "right_context": "}\n\n        /**\n         * @param x Normalized objective variables.\n         * @param repaired Repaired objective variables.\n         * @return Penalty value according to the violation of the bounds.\n         */\n        private double penalty(final double[] x, final double[] repaired) {\n            double penalty = 0;\n            for (int i = 0; i < x.length; i++) {\n                double diff = Math.abs(x[i] - repaired[i]);\n                penalty += diff * valueRange;\n            }\n            return isMinimize ? penalty : -penalty;\n        }\n    }\n\n}", "class_name": "CMAESOptimizer", "return_type": "double[]", "parameters": [{"type": "double[]", "name": "x"}]}}
{"prompt": "class CMAESOptimizer\n    extends MultivariateOptimizer {\n    // global search parameters\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return the matrix where the elements of m and n are element-wise multiplied.\n     */\n    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return Matrix where the elements of m and n are element-wise divided.\n     */\n    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param cols Columns to select.\n     * @return Matrix representing the selected columns.\n     */\n    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        final double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param k Diagonal position.\n     * @return Upper triangular part of matrix.\n     */\n    private static RealMatrix triu(final RealMatrix m, int k) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Row matrix representing the sums of the rows.\n     */\n    private static RealMatrix sumRows(final RealMatrix m) {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            double sum = 0;\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                sum += m.getEntry(r, c);\n            }\n            d[0][c] = sum;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return the diagonal n-by-n matrix if m is a column matrix or the column\n     * matrix representing the diagonal if m is a n-by-n matrix.\n     */\n    private static RealMatrix diag(final RealMatrix m) {\n        if (m.getColumnDimension() == 1) {\n            final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            final double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }\n\n    /**\n     * Copies a column from m1 to m2.\n     *\n     * @param m1 Source matrix.\n     * @param col1 Source column.\n     * @param m2 Target matrix.\n     * @param col2 Target column.\n     */\n    private static void copyColumn(final RealMatrix m1, int col1,\n                                   RealMatrix m2, int col2) {\n        for (int i = 0; i < m1.getRowDimension(); i++) {\n            m2.setEntry(i, col2, m1.getEntry(i, col1));\n        }\n    }\n\n    /**\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix filled with 1.\n     */\n    private static RealMatrix ones(int n, int m) {\n        final double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            Arrays.fill(d[r], 1);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix of 0 values out of diagonal, and 1 values on\n     * the diagonal.\n     */\n    private static RealMatrix eye(int n, int m) {\n        final double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            if (r < m) {\n                d[r][r] = 1;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix of zero values.\n     */\n    private static RealMatrix zeros(int n, int m) {\n        return new Array2DRowRealMatrix(n, m);\n    }\n\n    /**\n     * @param mat Input matrix.\n     * @param n Number of row replicates.\n     * @param m Number of column replicates.\n     * @return a matrix which replicates the input matrix in both directions.\n     */\n    private static RealMatrix repmat(final RealMatrix mat, int n, int m) {", "metadata": {"defects4j_task_id": "60fa25f3460e38309dd3bca59ce0b80ba637dca2be9ef64dfb97a4f646ecda83", "task_id": "apache_commons-math/84", "ground_truth": "\n        final int rd = mat.getRowDimension();\n        final int cd = mat.getColumnDimension();\n        final double[][] d = new double[n * rd][m * cd];\n        for (int r = 0; r < n * rd; r++) {\n            for (int c = 0; c < m * cd; c++) {\n                d[r][c] = mat.getEntry(r % rd, c % cd);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "optim", "nonlinear", "scalar", "noderiv", "CMAESOptimizer.java"], "context_start_lineno": 0, "function_name": "repmat", "left_context": "class CMAESOptimizer\n    extends MultivariateOptimizer {\n    // global search parameters\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return the matrix where the elements of m and n are element-wise multiplied.\n     */\n    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return Matrix where the elements of m and n are element-wise divided.\n     */\n    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param cols Columns to select.\n     * @return Matrix representing the selected columns.\n     */\n    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        final double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param k Diagonal position.\n     * @return Upper triangular part of matrix.\n     */\n    private static RealMatrix triu(final RealMatrix m, int k) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Row matrix representing the sums of the rows.\n     */\n    private static RealMatrix sumRows(final RealMatrix m) {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            double sum = 0;\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                sum += m.getEntry(r, c);\n            }\n            d[0][c] = sum;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return the diagonal n-by-n matrix if m is a column matrix or the column\n     * matrix representing the diagonal if m is a n-by-n matrix.\n     */\n    private static RealMatrix diag(final RealMatrix m) {\n        if (m.getColumnDimension() == 1) {\n            final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            final double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }\n\n    /**\n     * Copies a column from m1 to m2.\n     *\n     * @param m1 Source matrix.\n     * @param col1 Source column.\n     * @param m2 Target matrix.\n     * @param col2 Target column.\n     */\n    private static void copyColumn(final RealMatrix m1, int col1,\n                                   RealMatrix m2, int col2) {\n        for (int i = 0; i < m1.getRowDimension(); i++) {\n            m2.setEntry(i, col2, m1.getEntry(i, col1));\n        }\n    }\n\n    /**\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix filled with 1.\n     */\n    private static RealMatrix ones(int n, int m) {\n        final double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            Arrays.fill(d[r], 1);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix of 0 values out of diagonal, and 1 values on\n     * the diagonal.\n     */\n    private static RealMatrix eye(int n, int m) {\n        final double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            if (r < m) {\n                d[r][r] = 1;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix of zero values.\n     */\n    private static RealMatrix zeros(int n, int m) {\n        return new Array2DRowRealMatrix(n, m);\n    }\n\n    /**\n     * @param mat Input matrix.\n     * @param n Number of row replicates.\n     * @param m Number of column replicates.\n     * @return a matrix which replicates the input matrix in both directions.\n     */\n    private static RealMatrix repmat(final RealMatrix mat, int n, int m) {", "right_context": "}\n}", "class_name": "CMAESOptimizer", "return_type": "RealMatrix", "parameters": [{"type": "RealMatrix", "name": "mat"}, {"type": "int", "name": "n"}, {"type": "int", "name": "m"}]}}
{"prompt": "class AbstractLeastSquaresOptimizer\n    extends JacobianMultivariateVectorOptimizer {\n    /** Cost value (square root of the sum of the residuals). */\n    private double cost;\n\n    /**\n     * @param checker Convergence checker.\n     */\n    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }\n\n    /**\n     * Computes the weighted Jacobian matrix.\n     *\n     * @param params Model parameters at which to compute the Jacobian.\n     * @return the weighted Jacobian: W<sup>1/2</sup> J.\n     * @throws DimensionMismatchException if the Jacobian dimension does not\n     * match problem dimension.\n     */\n    protected RealMatrix computeWeightedJacobian(double[] params) {\n        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(computeJacobian(params)));\n    }\n\n    /**\n     * Computes the cost.\n     *\n     * @param residuals Residuals.\n     * @return the cost.\n     * @see #computeResiduals(double[])\n     */\n    protected double computeCost(double[] residuals) {\n        final ArrayRealVector r = new ArrayRealVector(residuals);\n        return FastMath.sqrt(r.dotProduct(getWeight().operate(r)));\n    }\n\n    /**\n     * Gets the root-mean-square (RMS) value.\n     *\n     * The RMS the root of the arithmetic mean of the square of all weighted\n     * residuals.\n     * This is related to the criterion that is minimized by the optimizer\n     * as follows: If <em>c</em> if the criterion, and <em>n</em> is the\n     * number of measurements, then the RMS is <em>sqrt (c/n)</em>.\n     *\n     * @return the RMS value.\n     */\n    public double getRMS() {\n        return FastMath.sqrt(getChiSquare() / getTargetSize());\n    }\n\n    /**\n     * Get a Chi-Square-like value assuming the N residuals follow N\n     * distinct normal distributions centered on 0 and whose variances are\n     * the reciprocal of the weights.\n     * @return chi-square value\n     */\n    public double getChiSquare() {\n        return cost * cost;\n    }\n\n    /**\n     * Gets the square-root of the weight matrix.\n     *\n     * @return the square-root of the weight matrix.\n     */\n    public RealMatrix getWeightSquareRoot() {\n        return weightMatrixSqrt.copy();\n    }\n\n    /**\n     * Sets the cost.\n     *\n     * @param cost Cost value.\n     */\n    protected void setCost(double cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Get the covariance matrix of the optimized parameters.\n     * <br/>\n     * Note that this operation involves the inversion of the\n     * <code>J<sup>T</sup>J</code> matrix, where {@code J} is the\n     * Jacobian matrix.\n     * The {@code threshold} parameter is a way for the caller to specify\n     * that the result of this computation should be considered meaningless,\n     * and thus trigger an exception.\n     *\n     * @param params Model parameters.\n     * @param threshold Singularity threshold.\n     * @return the covariance matrix.\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed (singular problem).\n     */\n    public double[][] computeCovariances(double[] params,\n                                         double threshold) {\n        // Set up the Jacobian.\n        final RealMatrix j = computeWeightedJacobian(params);\n\n        // Compute transpose(J)J.\n        final RealMatrix jTj = j.transpose().multiply(j);\n\n        // Compute the covariances matrix.\n        final DecompositionSolver solver\n            = new QRDecomposition(jTj, threshold).getSolver();\n        return solver.getInverse().getData();\n    }\n\n    /**\n     * Computes an estimate of the standard deviation of the parameters. The\n     * returned values are the square root of the diagonal coefficients of the\n     * covariance matrix, {@code sd(a[i]) ~= sqrt(C[i][i])}, where {@code a[i]}\n     * is the optimized value of the {@code i}-th parameter, and {@code C} is\n     * the covariance matrix.\n     *\n     * @param params Model parameters.\n     * @param covarianceSingularityThreshold Singularity threshold (see\n     * {@link #computeCovariances(double[],double) computeCovariances}).\n     * @return an estimate of the standard deviation of the optimized parameters\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed.\n     */\n    public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold) {", "metadata": {"defects4j_task_id": "0d9b8545180ee76d5cc74eaf450c7c8a6989da89c385943f613b194c1d8d6b90", "task_id": "apache_commons-math/14", "ground_truth": "\n        final int nC = params.length;\n        final double[] sig = new double[nC];\n        final double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < nC; ++i) {\n            sig[i] = FastMath.sqrt(cov[i][i]);\n        }\n        return sig;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "optim", "nonlinear", "vector", "jacobian", "AbstractLeastSquaresOptimizer.java"], "context_start_lineno": 0, "function_name": "computeSigma", "left_context": "class AbstractLeastSquaresOptimizer\n    extends JacobianMultivariateVectorOptimizer {\n    /** Cost value (square root of the sum of the residuals). */\n    private double cost;\n\n    /**\n     * @param checker Convergence checker.\n     */\n    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }\n\n    /**\n     * Computes the weighted Jacobian matrix.\n     *\n     * @param params Model parameters at which to compute the Jacobian.\n     * @return the weighted Jacobian: W<sup>1/2</sup> J.\n     * @throws DimensionMismatchException if the Jacobian dimension does not\n     * match problem dimension.\n     */\n    protected RealMatrix computeWeightedJacobian(double[] params) {\n        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(computeJacobian(params)));\n    }\n\n    /**\n     * Computes the cost.\n     *\n     * @param residuals Residuals.\n     * @return the cost.\n     * @see #computeResiduals(double[])\n     */\n    protected double computeCost(double[] residuals) {\n        final ArrayRealVector r = new ArrayRealVector(residuals);\n        return FastMath.sqrt(r.dotProduct(getWeight().operate(r)));\n    }\n\n    /**\n     * Gets the root-mean-square (RMS) value.\n     *\n     * The RMS the root of the arithmetic mean of the square of all weighted\n     * residuals.\n     * This is related to the criterion that is minimized by the optimizer\n     * as follows: If <em>c</em> if the criterion, and <em>n</em> is the\n     * number of measurements, then the RMS is <em>sqrt (c/n)</em>.\n     *\n     * @return the RMS value.\n     */\n    public double getRMS() {\n        return FastMath.sqrt(getChiSquare() / getTargetSize());\n    }\n\n    /**\n     * Get a Chi-Square-like value assuming the N residuals follow N\n     * distinct normal distributions centered on 0 and whose variances are\n     * the reciprocal of the weights.\n     * @return chi-square value\n     */\n    public double getChiSquare() {\n        return cost * cost;\n    }\n\n    /**\n     * Gets the square-root of the weight matrix.\n     *\n     * @return the square-root of the weight matrix.\n     */\n    public RealMatrix getWeightSquareRoot() {\n        return weightMatrixSqrt.copy();\n    }\n\n    /**\n     * Sets the cost.\n     *\n     * @param cost Cost value.\n     */\n    protected void setCost(double cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Get the covariance matrix of the optimized parameters.\n     * <br/>\n     * Note that this operation involves the inversion of the\n     * <code>J<sup>T</sup>J</code> matrix, where {@code J} is the\n     * Jacobian matrix.\n     * The {@code threshold} parameter is a way for the caller to specify\n     * that the result of this computation should be considered meaningless,\n     * and thus trigger an exception.\n     *\n     * @param params Model parameters.\n     * @param threshold Singularity threshold.\n     * @return the covariance matrix.\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed (singular problem).\n     */\n    public double[][] computeCovariances(double[] params,\n                                         double threshold) {\n        // Set up the Jacobian.\n        final RealMatrix j = computeWeightedJacobian(params);\n\n        // Compute transpose(J)J.\n        final RealMatrix jTj = j.transpose().multiply(j);\n\n        // Compute the covariances matrix.\n        final DecompositionSolver solver\n            = new QRDecomposition(jTj, threshold).getSolver();\n        return solver.getInverse().getData();\n    }\n\n    /**\n     * Computes an estimate of the standard deviation of the parameters. The\n     * returned values are the square root of the diagonal coefficients of the\n     * covariance matrix, {@code sd(a[i]) ~= sqrt(C[i][i])}, where {@code a[i]}\n     * is the optimized value of the {@code i}-th parameter, and {@code C} is\n     * the covariance matrix.\n     *\n     * @param params Model parameters.\n     * @param covarianceSingularityThreshold Singularity threshold (see\n     * {@link #computeCovariances(double[],double) computeCovariances}).\n     * @return an estimate of the standard deviation of the optimized parameters\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed.\n     */\n    public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold) {", "right_context": "}\n}", "class_name": "AbstractLeastSquaresOptimizer", "return_type": "double[]", "parameters": [{"type": "double[]", "name": "params"}, {"type": "double", "name": "covarianceSingularityThreshold"}]}}
{"prompt": "class BracketFinder {\n    /** Tolerance to avoid division by zero. */\n    private static final double EPS_MIN = 1e-21;\n    /**\n     * Golden section.\n     */\n    private static final double GOLD = 1.618034;\n    /**\n     * Factor for expanding the interval.\n     */\n    private final double growLimit;\n    /**\n     * Counter for function evaluations.\n     */\n    private final Incrementor evaluations = new Incrementor();\n    /**\n     * Lower bound of the bracket.\n     */\n    private double lo;\n    /**\n     * Higher bound of the bracket.\n     */\n    private double hi;\n    /**\n     * Point inside the bracket.\n     */\n    private double mid;\n    /**\n     * Function value at {@link #lo}.\n     */\n    private double fLo;\n    /**\n     * Function value at {@link #hi}.\n     */\n    private double fHi;\n    /**\n     * Function value at {@link #mid}.\n     */\n    private double fMid;\n\n    /**\n     * Constructor with default values {@code 100, 50} (see the\n     * {@link #BracketFinder(double,int) other constructor}).\n     */\n    public BracketFinder() {\n        this(100, 50);\n    }\n\n    /**\n     * Create a bracketing interval finder.\n     *\n     * @param growLimit Expanding factor.\n     * @param maxEvaluations Maximum number of evaluations allowed for finding\n     * a bracketing interval.\n     */\n    public BracketFinder(double growLimit,\n                         int maxEvaluations) {\n        if (growLimit <= 0) {\n            throw new NotStrictlyPositiveException(growLimit);\n        }\n        if (maxEvaluations <= 0) {\n            throw new NotStrictlyPositiveException(maxEvaluations);\n        }\n\n        this.growLimit = growLimit;\n        evaluations.setMaximalCount(maxEvaluations);\n    }\n\n    /**\n     * Search new points that bracket a local optimum of the function.\n     *\n     * @param func Function whose optimum should be bracketed.\n     * @param goal {@link GoalType Goal type}.\n     * @param xA Initial point.\n     * @param xB Initial point.\n     * @throws TooManyEvaluationsException if the maximum number of evaluations\n     * is exceeded.\n     */\n    public void search(UnivariateFunction func, GoalType goal, double xA, double xB) {\n        evaluations.resetCount();\n        final boolean isMinim = goal == GoalType.MINIMIZE;\n\n        double fA = eval(func, xA);\n        double fB = eval(func, xB);\n        if (isMinim ?\n            fA < fB :\n            fA > fB) {\n\n            double tmp = xA;\n            xA = xB;\n            xB = tmp;\n\n            tmp = fA;\n            fA = fB;\n            fB = tmp;\n        }\n\n        double xC = xB + GOLD * (xB - xA);\n        double fC = eval(func, xC);\n\n        while (isMinim ? fC < fB : fC > fB) {\n            double tmp1 = (xB - xA) * (fB - fC);\n            double tmp2 = (xB - xC) * (fB - fA);\n\n            double val = tmp2 - tmp1;\n            double denom = Math.abs(val) < EPS_MIN ? 2 * EPS_MIN : 2 * val;\n\n            double w = xB - ((xB - xC) * tmp2 - (xB - xA) * tmp1) / denom;\n            double wLim = xB + growLimit * (xC - xB);\n\n            double fW;\n            if ((w - xC) * (xB - w) > 0) {\n                fW = eval(func, w);\n                if (isMinim ?\n                    fW < fC :\n                    fW > fC) {\n                    xA = xB;\n                    xB = w;\n                    fA = fB;\n                    fB = fW;\n                    break;\n                } else if (isMinim ?\n                           fW > fB :\n                           fW < fB) {\n                    xC = w;\n                    fC = fW;\n                    break;\n                }\n                w = xC + GOLD * (xC - xB);\n                fW = eval(func, w);\n            } else if ((w - wLim) * (wLim - xC) >= 0) {\n                w = wLim;\n                fW = eval(func, w);\n            } else if ((w - wLim) * (xC - w) > 0) {\n                fW = eval(func, w);\n                if (isMinim ?\n                    fW < fC :\n                    fW > fC) {\n                    xB = xC;\n                    xC = w;\n                    w = xC + GOLD * (xC - xB);\n                    fB = fC;\n                    fC =fW;\n                    fW = eval(func, w);\n                }\n            } else {\n                w = xC + GOLD * (xC - xB);\n                fW = eval(func, w);\n            }\n\n            xA = xB;\n            fA = fB;\n            xB = xC;\n            fB = fC;\n            xC = w;\n            fC = fW;\n        }\n\n        lo = xA;\n        fLo = fA;\n        mid = xB;\n        fMid = fB;\n        hi = xC;\n        fHi = fC;\n\n        if (lo > hi) {\n            double tmp = lo;\n            lo = hi;\n            hi = tmp;\n\n            tmp = fLo;\n            fLo = fHi;\n            fHi = tmp;\n        }\n    }\n\n    /**\n     * @return the number of evalutations.\n     */\n    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }\n\n    /**\n     * @return the number of evalutations.\n     */\n    public int getEvaluations() {\n        return evaluations.getCount();\n    }\n\n    /**\n     * @return the lower bound of the bracket.\n     * @see #getFLo()\n     */\n    public double getLo() {\n        return lo;\n    }\n\n    /**\n     * Get function value at {@link #getLo()}.\n     * @return function value at {@link #getLo()}\n     */\n    public double getFLo() {\n        return fLo;\n    }\n\n    /**\n     * @return the higher bound of the bracket.\n     * @see #getFHi()\n     */\n    public double getHi() {\n        return hi;\n    }\n\n    /**\n     * Get function value at {@link #getHi()}.\n     * @return function value at {@link #getHi()}\n     */\n    public double getFHi() {\n        return fHi;\n    }\n\n    /**\n     * @return a point in the middle of the bracket.\n     * @see #getFMid()\n     */\n    public double getMid() {\n        return mid;\n    }\n\n    /**\n     * Get function value at {@link #getMid()}.\n     * @return function value at {@link #getMid()}\n     */\n    public double getFMid() {\n        return fMid;\n    }\n\n    /**\n     * @param f Function.\n     * @param x Argument.\n     * @return {@code f(x)}\n     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n     * exceeded.\n     */\n    private double eval(UnivariateFunction f, double x) {", "metadata": {"defects4j_task_id": "dae1b99140efa0062617646934467faa2bf9a8e6554c5b70a2aa47c432163e79", "task_id": "apache_commons-math/179", "ground_truth": "\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n        return f.value(x);\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "optim", "univariate", "BracketFinder.java"], "context_start_lineno": 0, "function_name": "eval", "left_context": "class BracketFinder {\n    /** Tolerance to avoid division by zero. */\n    private static final double EPS_MIN = 1e-21;\n    /**\n     * Golden section.\n     */\n    private static final double GOLD = 1.618034;\n    /**\n     * Factor for expanding the interval.\n     */\n    private final double growLimit;\n    /**\n     * Counter for function evaluations.\n     */\n    private final Incrementor evaluations = new Incrementor();\n    /**\n     * Lower bound of the bracket.\n     */\n    private double lo;\n    /**\n     * Higher bound of the bracket.\n     */\n    private double hi;\n    /**\n     * Point inside the bracket.\n     */\n    private double mid;\n    /**\n     * Function value at {@link #lo}.\n     */\n    private double fLo;\n    /**\n     * Function value at {@link #hi}.\n     */\n    private double fHi;\n    /**\n     * Function value at {@link #mid}.\n     */\n    private double fMid;\n\n    /**\n     * Constructor with default values {@code 100, 50} (see the\n     * {@link #BracketFinder(double,int) other constructor}).\n     */\n    public BracketFinder() {\n        this(100, 50);\n    }\n\n    /**\n     * Create a bracketing interval finder.\n     *\n     * @param growLimit Expanding factor.\n     * @param maxEvaluations Maximum number of evaluations allowed for finding\n     * a bracketing interval.\n     */\n    public BracketFinder(double growLimit,\n                         int maxEvaluations) {\n        if (growLimit <= 0) {\n            throw new NotStrictlyPositiveException(growLimit);\n        }\n        if (maxEvaluations <= 0) {\n            throw new NotStrictlyPositiveException(maxEvaluations);\n        }\n\n        this.growLimit = growLimit;\n        evaluations.setMaximalCount(maxEvaluations);\n    }\n\n    /**\n     * Search new points that bracket a local optimum of the function.\n     *\n     * @param func Function whose optimum should be bracketed.\n     * @param goal {@link GoalType Goal type}.\n     * @param xA Initial point.\n     * @param xB Initial point.\n     * @throws TooManyEvaluationsException if the maximum number of evaluations\n     * is exceeded.\n     */\n    public void search(UnivariateFunction func, GoalType goal, double xA, double xB) {\n        evaluations.resetCount();\n        final boolean isMinim = goal == GoalType.MINIMIZE;\n\n        double fA = eval(func, xA);\n        double fB = eval(func, xB);\n        if (isMinim ?\n            fA < fB :\n            fA > fB) {\n\n            double tmp = xA;\n            xA = xB;\n            xB = tmp;\n\n            tmp = fA;\n            fA = fB;\n            fB = tmp;\n        }\n\n        double xC = xB + GOLD * (xB - xA);\n        double fC = eval(func, xC);\n\n        while (isMinim ? fC < fB : fC > fB) {\n            double tmp1 = (xB - xA) * (fB - fC);\n            double tmp2 = (xB - xC) * (fB - fA);\n\n            double val = tmp2 - tmp1;\n            double denom = Math.abs(val) < EPS_MIN ? 2 * EPS_MIN : 2 * val;\n\n            double w = xB - ((xB - xC) * tmp2 - (xB - xA) * tmp1) / denom;\n            double wLim = xB + growLimit * (xC - xB);\n\n            double fW;\n            if ((w - xC) * (xB - w) > 0) {\n                fW = eval(func, w);\n                if (isMinim ?\n                    fW < fC :\n                    fW > fC) {\n                    xA = xB;\n                    xB = w;\n                    fA = fB;\n                    fB = fW;\n                    break;\n                } else if (isMinim ?\n                           fW > fB :\n                           fW < fB) {\n                    xC = w;\n                    fC = fW;\n                    break;\n                }\n                w = xC + GOLD * (xC - xB);\n                fW = eval(func, w);\n            } else if ((w - wLim) * (wLim - xC) >= 0) {\n                w = wLim;\n                fW = eval(func, w);\n            } else if ((w - wLim) * (xC - w) > 0) {\n                fW = eval(func, w);\n                if (isMinim ?\n                    fW < fC :\n                    fW > fC) {\n                    xB = xC;\n                    xC = w;\n                    w = xC + GOLD * (xC - xB);\n                    fB = fC;\n                    fC =fW;\n                    fW = eval(func, w);\n                }\n            } else {\n                w = xC + GOLD * (xC - xB);\n                fW = eval(func, w);\n            }\n\n            xA = xB;\n            fA = fB;\n            xB = xC;\n            fB = fC;\n            xC = w;\n            fC = fW;\n        }\n\n        lo = xA;\n        fLo = fA;\n        mid = xB;\n        fMid = fB;\n        hi = xC;\n        fHi = fC;\n\n        if (lo > hi) {\n            double tmp = lo;\n            lo = hi;\n            hi = tmp;\n\n            tmp = fLo;\n            fLo = fHi;\n            fHi = tmp;\n        }\n    }\n\n    /**\n     * @return the number of evalutations.\n     */\n    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }\n\n    /**\n     * @return the number of evalutations.\n     */\n    public int getEvaluations() {\n        return evaluations.getCount();\n    }\n\n    /**\n     * @return the lower bound of the bracket.\n     * @see #getFLo()\n     */\n    public double getLo() {\n        return lo;\n    }\n\n    /**\n     * Get function value at {@link #getLo()}.\n     * @return function value at {@link #getLo()}\n     */\n    public double getFLo() {\n        return fLo;\n    }\n\n    /**\n     * @return the higher bound of the bracket.\n     * @see #getFHi()\n     */\n    public double getHi() {\n        return hi;\n    }\n\n    /**\n     * Get function value at {@link #getHi()}.\n     * @return function value at {@link #getHi()}\n     */\n    public double getFHi() {\n        return fHi;\n    }\n\n    /**\n     * @return a point in the middle of the bracket.\n     * @see #getFMid()\n     */\n    public double getMid() {\n        return mid;\n    }\n\n    /**\n     * Get function value at {@link #getMid()}.\n     * @return function value at {@link #getMid()}\n     */\n    public double getFMid() {\n        return fMid;\n    }\n\n    /**\n     * @param f Function.\n     * @param x Argument.\n     * @return {@code f(x)}\n     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n     * exceeded.\n     */\n    private double eval(UnivariateFunction f, double x) {", "right_context": "}\n}", "class_name": "BracketFinder", "return_type": "double", "parameters": [{"type": "UnivariateFunction", "name": "f"}, {"type": "double", "name": "x"}]}}
{"prompt": "class SimplexTableau implements Serializable {\n\n    /**\n     * Build a tableau for a linear problem.\n     * @param f linear objective function\n     * @param constraints linear constraints\n     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}\n     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n     * @param epsilon amount of error to accept when checking for optimality\n     * @param maxUlps amount of error to accept in floating point comparisons\n     */\n    SimplexTableau(final LinearObjectiveFunction f,\n                   final Collection<LinearConstraint> constraints,\n                   final GoalType goalType,\n                   final boolean restrictToNonNegative,\n                   final double epsilon,\n                   final int maxUlps) {\n        this(f, constraints, goalType, restrictToNonNegative, epsilon, maxUlps, SimplexSolver.DEFAULT_CUT_OFF);\n    }\n\n    /**\n     * Build a tableau for a linear problem.\n     * @param f linear objective function\n     * @param constraints linear constraints\n     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}\n     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n     * @param epsilon amount of error to accept when checking for optimality\n     * @param maxUlps amount of error to accept in floating point comparisons\n     * @param cutOff the cut-off value for tableau entries\n     */\n    SimplexTableau(final LinearObjectiveFunction f,\n                   final Collection<LinearConstraint> constraints,\n                   final GoalType goalType,\n                   final boolean restrictToNonNegative,\n                   final double epsilon,\n                   final int maxUlps,\n                   final double cutOff) {\n        this.f                      = f;\n        this.constraints            = normalizeConstraints(constraints);\n        this.restrictToNonNegative  = restrictToNonNegative;\n        this.epsilon                = epsilon;\n        this.maxUlps                = maxUlps;\n        this.cutOff                 = cutOff;\n        this.numDecisionVariables   = f.getCoefficients().getDimension() +\n                                      (restrictToNonNegative ? 0 : 1);\n        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.tableau = createTableau(goalType == GoalType.MAXIMIZE);\n        initializeColumnLabels();\n    }\n\n    /**\n     * Initialize the labels for the columns.\n     */\n    protected void initializeColumnLabels() {\n      if (getNumObjectiveFunctions() == 2) {\n        columnLabels.add(\"W\");\n      }\n      columnLabels.add(\"Z\");\n      for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {\n        columnLabels.add(\"x\" + i);\n      }\n      if (!restrictToNonNegative) {\n        columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL);\n      }\n      for (int i = 0; i < getNumSlackVariables(); i++) {\n        columnLabels.add(\"s\" + i);\n      }\n      for (int i = 0; i < getNumArtificialVariables(); i++) {\n        columnLabels.add(\"a\" + i);\n      }\n      columnLabels.add(\"RHS\");\n    }\n\n    /**\n     * Create the tableau by itself.\n     * @param maximize if true, goal is to maximize the objective function\n     * @return created tableau\n     */\n    protected RealMatrix createTableau(final boolean maximize) {\n\n        // create a matrix of the correct size\n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n        int height = constraints.size() + getNumObjectiveFunctions();\n        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n\n        // initialize the objective function rows\n        if (getNumObjectiveFunctions() == 2) {\n            matrix.setEntry(0, 0, -1);\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n        copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);\n        matrix.setEntry(zIndex, width - 1,\n            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n\n        if (!restrictToNonNegative) {\n            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n                getInvertedCoefficientSum(objectiveCoefficients));\n        }\n\n        // initialize the constraint rows\n        int slackVar = 0;\n        int artificialVar = 0;\n        for (int i = 0; i < constraints.size(); i++) {\n            LinearConstraint constraint = constraints.get(i);\n            int row = getNumObjectiveFunctions() + i;\n\n            // decision variable coefficients\n            copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);\n\n            // x-\n            if (!restrictToNonNegative) {\n                matrix.setEntry(row, getSlackVariableOffset() - 1,\n                    getInvertedCoefficientSum(constraint.getCoefficients()));\n            }\n\n            // RHS\n            matrix.setEntry(row, width - 1, constraint.getValue());\n\n            // slack variables\n            if (constraint.getRelationship() == Relationship.LEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack\n            } else if (constraint.getRelationship() == Relationship.GEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess\n            }\n\n            // artificial variables\n            if ((constraint.getRelationship() == Relationship.EQ) ||\n                    (constraint.getRelationship() == Relationship.GEQ)) {\n                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\n                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\n                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n            }\n        }\n\n        return matrix;\n    }\n\n    /**\n     * Get new versions of the constraints which have positive right hand sides.\n     * @param originalConstraints original (not normalized) constraints\n     * @return new versions of the constraints\n     */\n    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) {", "metadata": {"defects4j_task_id": "daf3801fef5a5b5438110319b108e6d8b713316c43910f1a6640f8db94326895", "task_id": "apache_commons-math/180", "ground_truth": "\n        List<LinearConstraint> normalized = new ArrayList<LinearConstraint>(originalConstraints.size());\n        for (LinearConstraint constraint : originalConstraints) {\n            normalized.add(normalize(constraint));\n        }\n        return normalized;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "optim", "linear", "SimplexTableau.java"], "context_start_lineno": 0, "function_name": "normalizeConstraints", "left_context": "class SimplexTableau implements Serializable {\n\n    /**\n     * Build a tableau for a linear problem.\n     * @param f linear objective function\n     * @param constraints linear constraints\n     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}\n     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n     * @param epsilon amount of error to accept when checking for optimality\n     * @param maxUlps amount of error to accept in floating point comparisons\n     */\n    SimplexTableau(final LinearObjectiveFunction f,\n                   final Collection<LinearConstraint> constraints,\n                   final GoalType goalType,\n                   final boolean restrictToNonNegative,\n                   final double epsilon,\n                   final int maxUlps) {\n        this(f, constraints, goalType, restrictToNonNegative, epsilon, maxUlps, SimplexSolver.DEFAULT_CUT_OFF);\n    }\n\n    /**\n     * Build a tableau for a linear problem.\n     * @param f linear objective function\n     * @param constraints linear constraints\n     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}\n     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n     * @param epsilon amount of error to accept when checking for optimality\n     * @param maxUlps amount of error to accept in floating point comparisons\n     * @param cutOff the cut-off value for tableau entries\n     */\n    SimplexTableau(final LinearObjectiveFunction f,\n                   final Collection<LinearConstraint> constraints,\n                   final GoalType goalType,\n                   final boolean restrictToNonNegative,\n                   final double epsilon,\n                   final int maxUlps,\n                   final double cutOff) {\n        this.f                      = f;\n        this.constraints            = normalizeConstraints(constraints);\n        this.restrictToNonNegative  = restrictToNonNegative;\n        this.epsilon                = epsilon;\n        this.maxUlps                = maxUlps;\n        this.cutOff                 = cutOff;\n        this.numDecisionVariables   = f.getCoefficients().getDimension() +\n                                      (restrictToNonNegative ? 0 : 1);\n        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.tableau = createTableau(goalType == GoalType.MAXIMIZE);\n        initializeColumnLabels();\n    }\n\n    /**\n     * Initialize the labels for the columns.\n     */\n    protected void initializeColumnLabels() {\n      if (getNumObjectiveFunctions() == 2) {\n        columnLabels.add(\"W\");\n      }\n      columnLabels.add(\"Z\");\n      for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {\n        columnLabels.add(\"x\" + i);\n      }\n      if (!restrictToNonNegative) {\n        columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL);\n      }\n      for (int i = 0; i < getNumSlackVariables(); i++) {\n        columnLabels.add(\"s\" + i);\n      }\n      for (int i = 0; i < getNumArtificialVariables(); i++) {\n        columnLabels.add(\"a\" + i);\n      }\n      columnLabels.add(\"RHS\");\n    }\n\n    /**\n     * Create the tableau by itself.\n     * @param maximize if true, goal is to maximize the objective function\n     * @return created tableau\n     */\n    protected RealMatrix createTableau(final boolean maximize) {\n\n        // create a matrix of the correct size\n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n        int height = constraints.size() + getNumObjectiveFunctions();\n        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n\n        // initialize the objective function rows\n        if (getNumObjectiveFunctions() == 2) {\n            matrix.setEntry(0, 0, -1);\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n        copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);\n        matrix.setEntry(zIndex, width - 1,\n            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n\n        if (!restrictToNonNegative) {\n            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n                getInvertedCoefficientSum(objectiveCoefficients));\n        }\n\n        // initialize the constraint rows\n        int slackVar = 0;\n        int artificialVar = 0;\n        for (int i = 0; i < constraints.size(); i++) {\n            LinearConstraint constraint = constraints.get(i);\n            int row = getNumObjectiveFunctions() + i;\n\n            // decision variable coefficients\n            copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);\n\n            // x-\n            if (!restrictToNonNegative) {\n                matrix.setEntry(row, getSlackVariableOffset() - 1,\n                    getInvertedCoefficientSum(constraint.getCoefficients()));\n            }\n\n            // RHS\n            matrix.setEntry(row, width - 1, constraint.getValue());\n\n            // slack variables\n            if (constraint.getRelationship() == Relationship.LEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack\n            } else if (constraint.getRelationship() == Relationship.GEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess\n            }\n\n            // artificial variables\n            if ((constraint.getRelationship() == Relationship.EQ) ||\n                    (constraint.getRelationship() == Relationship.GEQ)) {\n                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\n                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\n                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n            }\n        }\n\n        return matrix;\n    }\n\n    /**\n     * Get new versions of the constraints which have positive right hand sides.\n     * @param originalConstraints original (not normalized) constraints\n     * @return new versions of the constraints\n     */\n    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) {", "right_context": "}\n}", "class_name": "SimplexTableau", "return_type": "List<LinearConstraint>", "parameters": [{"type": "Collection<LinearConstraint>", "name": "originalConstraints"}]}}
{"prompt": "class EigenDecomposition {\n    /**\n     * Gets the matrix V of the decomposition.\n     * V is an orthogonal matrix, i.e. its transpose is also its inverse.\n     * The columns of V are the eigenvectors of the original matrix.\n     * No assumption is made about the orientation of the system axes formed\n     * by the columns of V (e.g. in a 3-dimension space, V can form a left-\n     * or right-handed system).\n     *\n     * @return the V matrix.\n     */\n    public RealMatrix getV() {\n\n        if (cachedV == null) {\n            final int m = eigenvectors.length;\n            cachedV = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n        }\n        // return the cached matrix\n        return cachedV;\n    }\n\n    /**\n     * Gets the block diagonal matrix D of the decomposition.\n     * D is a block diagonal matrix.\n     * Real eigenvalues are on the diagonal while complex values are on\n     * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.\n     *\n     * @return the D matrix.\n     *\n     * @see #getRealEigenvalues()\n     * @see #getImagEigenvalues()\n     */\n    public RealMatrix getD() {\n\n        if (cachedD == null) {\n            // cache the matrix for subsequent calls\n            cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n\n            for (int i = 0; i < imagEigenvalues.length; i++) {\n                if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) > 0) {\n                    cachedD.setEntry(i, i+1, imagEigenvalues[i]);\n                } else if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\n                    cachedD.setEntry(i, i-1, imagEigenvalues[i]);\n                }\n            }\n        }\n        return cachedD;\n    }\n\n    /**\n     * Gets the transpose of the matrix V of the decomposition.\n     * V is an orthogonal matrix, i.e. its transpose is also its inverse.\n     * The columns of V are the eigenvectors of the original matrix.\n     * No assumption is made about the orientation of the system axes formed\n     * by the columns of V (e.g. in a 3-dimension space, V can form a left-\n     * or right-handed system).\n     *\n     * @return the transpose of the V matrix.\n     */\n    public RealMatrix getVT() {\n\n        if (cachedVt == null) {\n            final int m = eigenvectors.length;\n            cachedVt = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedVt.setRowVector(k, eigenvectors[k]);\n            }\n        }\n\n        // return the cached matrix\n        return cachedVt;\n    }\n\n    /**\n     * Returns whether the calculated eigen values are complex or real.\n     * <p>The method performs a zero check for each element of the\n     * {@link #getImagEigenvalues()} array and returns {@code true} if any\n     * element is not equal to zero.\n     *\n     * @return {@code true} if the eigen values are complex, {@code false} otherwise\n     * @since 3.1\n     */\n    public boolean hasComplexEigenvalues() {\n        for (int i = 0; i < imagEigenvalues.length; i++) {\n            if (!Precision.equals(imagEigenvalues[i], 0.0, EPSILON)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Gets a copy of the real parts of the eigenvalues of the original matrix.\n     *\n     * @return a copy of the real parts of the eigenvalues of the original matrix.\n     *\n     * @see #getD()\n     * @see #getRealEigenvalue(int)\n     * @see #getImagEigenvalues()\n     */\n    public double[] getRealEigenvalues() {\n        return realEigenvalues.clone();\n    }\n\n    /**\n     * Returns the real part of the i<sup>th</sup> eigenvalue of the original\n     * matrix.\n     *\n     * @param i index of the eigenvalue (counting from 0)\n     * @return real part of the i<sup>th</sup> eigenvalue of the original\n     * matrix.\n     *\n     * @see #getD()\n     * @see #getRealEigenvalues()\n     * @see #getImagEigenvalue(int)\n     */\n    public double getRealEigenvalue(final int i) {\n        return realEigenvalues[i];\n    }\n\n    /**\n     * Gets a copy of the imaginary parts of the eigenvalues of the original\n     * matrix.\n     *\n     * @return a copy of the imaginary parts of the eigenvalues of the original\n     * matrix.\n     *\n     * @see #getD()\n     * @see #getImagEigenvalue(int)\n     * @see #getRealEigenvalues()\n     */\n    public double[] getImagEigenvalues() {\n        return imagEigenvalues.clone();\n    }\n\n    /**\n     * Gets the imaginary part of the i<sup>th</sup> eigenvalue of the original\n     * matrix.\n     *\n     * @param i Index of the eigenvalue (counting from 0).\n     * @return the imaginary part of the i<sup>th</sup> eigenvalue of the original\n     * matrix.\n     *\n     * @see #getD()\n     * @see #getImagEigenvalues()\n     * @see #getRealEigenvalue(int)\n     */\n    public double getImagEigenvalue(final int i) {\n        return imagEigenvalues[i];\n    }\n\n    /**\n     * Gets a copy of the i<sup>th</sup> eigenvector of the original matrix.\n     *\n     * @param i Index of the eigenvector (counting from 0).\n     * @return a copy of the i<sup>th</sup> eigenvector of the original matrix.\n     * @see #getD()\n     */\n    public RealVector getEigenvector(final int i) {\n        return eigenvectors[i].copy();\n    }\n\n    /**\n     * Computes the determinant of the matrix.\n     *\n     * @return the determinant of the matrix.\n     */\n    public double getDeterminant() {\n        double determinant = 1;\n        for (double lambda : realEigenvalues) {\n            determinant *= lambda;\n        }\n        return determinant;\n    }\n\n    /**\n     * Computes the square-root of the matrix.\n     * This implementation assumes that the matrix is symmetric and positive\n     * definite.\n     *\n     * @return the square-root of the matrix.\n     * @throws MathUnsupportedOperationException if the matrix is not\n     * symmetric or not positive definite.\n     * @since 3.1\n     */\n    public RealMatrix getSquareRoot() {", "metadata": {"defects4j_task_id": "19395f00aa4ed9e8f063c724cab1926faff716e543af2d935be84817a6f2f496", "task_id": "apache_commons-math/28", "ground_truth": "\n        if (!isSymmetric) {\n            throw new MathUnsupportedOperationException();\n        }\n\n        final double[] sqrtEigenValues = new double[realEigenvalues.length];\n        for (int i = 0; i < realEigenvalues.length; i++) {\n            final double eigen = realEigenvalues[i];\n            if (eigen <= 0) {\n                throw new MathUnsupportedOperationException();\n            }\n            sqrtEigenValues[i] = FastMath.sqrt(eigen);\n        }\n        final RealMatrix sqrtEigen = MatrixUtils.createRealDiagonalMatrix(sqrtEigenValues);\n        final RealMatrix v = getV();\n        final RealMatrix vT = getVT();\n\n        return v.multiply(sqrtEigen).multiply(vT);\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "linear", "EigenDecomposition.java"], "context_start_lineno": 0, "function_name": "getSquareRoot", "left_context": "class EigenDecomposition {\n    /**\n     * Gets the matrix V of the decomposition.\n     * V is an orthogonal matrix, i.e. its transpose is also its inverse.\n     * The columns of V are the eigenvectors of the original matrix.\n     * No assumption is made about the orientation of the system axes formed\n     * by the columns of V (e.g. in a 3-dimension space, V can form a left-\n     * or right-handed system).\n     *\n     * @return the V matrix.\n     */\n    public RealMatrix getV() {\n\n        if (cachedV == null) {\n            final int m = eigenvectors.length;\n            cachedV = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n        }\n        // return the cached matrix\n        return cachedV;\n    }\n\n    /**\n     * Gets the block diagonal matrix D of the decomposition.\n     * D is a block diagonal matrix.\n     * Real eigenvalues are on the diagonal while complex values are on\n     * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.\n     *\n     * @return the D matrix.\n     *\n     * @see #getRealEigenvalues()\n     * @see #getImagEigenvalues()\n     */\n    public RealMatrix getD() {\n\n        if (cachedD == null) {\n            // cache the matrix for subsequent calls\n            cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n\n            for (int i = 0; i < imagEigenvalues.length; i++) {\n                if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) > 0) {\n                    cachedD.setEntry(i, i+1, imagEigenvalues[i]);\n                } else if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\n                    cachedD.setEntry(i, i-1, imagEigenvalues[i]);\n                }\n            }\n        }\n        return cachedD;\n    }\n\n    /**\n     * Gets the transpose of the matrix V of the decomposition.\n     * V is an orthogonal matrix, i.e. its transpose is also its inverse.\n     * The columns of V are the eigenvectors of the original matrix.\n     * No assumption is made about the orientation of the system axes formed\n     * by the columns of V (e.g. in a 3-dimension space, V can form a left-\n     * or right-handed system).\n     *\n     * @return the transpose of the V matrix.\n     */\n    public RealMatrix getVT() {\n\n        if (cachedVt == null) {\n            final int m = eigenvectors.length;\n            cachedVt = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedVt.setRowVector(k, eigenvectors[k]);\n            }\n        }\n\n        // return the cached matrix\n        return cachedVt;\n    }\n\n    /**\n     * Returns whether the calculated eigen values are complex or real.\n     * <p>The method performs a zero check for each element of the\n     * {@link #getImagEigenvalues()} array and returns {@code true} if any\n     * element is not equal to zero.\n     *\n     * @return {@code true} if the eigen values are complex, {@code false} otherwise\n     * @since 3.1\n     */\n    public boolean hasComplexEigenvalues() {\n        for (int i = 0; i < imagEigenvalues.length; i++) {\n            if (!Precision.equals(imagEigenvalues[i], 0.0, EPSILON)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Gets a copy of the real parts of the eigenvalues of the original matrix.\n     *\n     * @return a copy of the real parts of the eigenvalues of the original matrix.\n     *\n     * @see #getD()\n     * @see #getRealEigenvalue(int)\n     * @see #getImagEigenvalues()\n     */\n    public double[] getRealEigenvalues() {\n        return realEigenvalues.clone();\n    }\n\n    /**\n     * Returns the real part of the i<sup>th</sup> eigenvalue of the original\n     * matrix.\n     *\n     * @param i index of the eigenvalue (counting from 0)\n     * @return real part of the i<sup>th</sup> eigenvalue of the original\n     * matrix.\n     *\n     * @see #getD()\n     * @see #getRealEigenvalues()\n     * @see #getImagEigenvalue(int)\n     */\n    public double getRealEigenvalue(final int i) {\n        return realEigenvalues[i];\n    }\n\n    /**\n     * Gets a copy of the imaginary parts of the eigenvalues of the original\n     * matrix.\n     *\n     * @return a copy of the imaginary parts of the eigenvalues of the original\n     * matrix.\n     *\n     * @see #getD()\n     * @see #getImagEigenvalue(int)\n     * @see #getRealEigenvalues()\n     */\n    public double[] getImagEigenvalues() {\n        return imagEigenvalues.clone();\n    }\n\n    /**\n     * Gets the imaginary part of the i<sup>th</sup> eigenvalue of the original\n     * matrix.\n     *\n     * @param i Index of the eigenvalue (counting from 0).\n     * @return the imaginary part of the i<sup>th</sup> eigenvalue of the original\n     * matrix.\n     *\n     * @see #getD()\n     * @see #getImagEigenvalues()\n     * @see #getRealEigenvalue(int)\n     */\n    public double getImagEigenvalue(final int i) {\n        return imagEigenvalues[i];\n    }\n\n    /**\n     * Gets a copy of the i<sup>th</sup> eigenvector of the original matrix.\n     *\n     * @param i Index of the eigenvector (counting from 0).\n     * @return a copy of the i<sup>th</sup> eigenvector of the original matrix.\n     * @see #getD()\n     */\n    public RealVector getEigenvector(final int i) {\n        return eigenvectors[i].copy();\n    }\n\n    /**\n     * Computes the determinant of the matrix.\n     *\n     * @return the determinant of the matrix.\n     */\n    public double getDeterminant() {\n        double determinant = 1;\n        for (double lambda : realEigenvalues) {\n            determinant *= lambda;\n        }\n        return determinant;\n    }\n\n    /**\n     * Computes the square-root of the matrix.\n     * This implementation assumes that the matrix is symmetric and positive\n     * definite.\n     *\n     * @return the square-root of the matrix.\n     * @throws MathUnsupportedOperationException if the matrix is not\n     * symmetric or not positive definite.\n     * @since 3.1\n     */\n    public RealMatrix getSquareRoot() {", "right_context": "}\n}", "class_name": "EigenDecomposition", "return_type": "RealMatrix", "parameters": []}}
{"prompt": "class EigenDecomposition {\n    /**\n     * Transforms the matrix to Schur form and calculates the eigenvalues.\n     *\n     * @param matrix Matrix to transform.\n     * @return the {@link SchurTransformer Shur transform} for this matrix\n     */\n    private SchurTransformer transformToSchur(final RealMatrix matrix) {", "metadata": {"defects4j_task_id": "55bbc8759c99d72a51f7f89f31c847504b24caf9e1fdeeb1068f34d8408f4b40", "task_id": "apache_commons-math/74", "ground_truth": "\n        final SchurTransformer schurTransform = new SchurTransformer(matrix);\n        final double[][] matT = schurTransform.getT().getData();\n\n        realEigenvalues = new double[matT.length];\n        imagEigenvalues = new double[matT.length];\n\n        for (int i = 0; i < realEigenvalues.length; i++) {\n            if (i == (realEigenvalues.length - 1) ||\n                Precision.equals(matT[i + 1][i], 0.0, EPSILON)) {\n                realEigenvalues[i] = matT[i][i];\n            } else {\n                final double x = matT[i + 1][i + 1];\n                final double p = 0.5 * (matT[i][i] - x);\n                final double z = FastMath.sqrt(FastMath.abs(p * p + matT[i + 1][i] * matT[i][i + 1]));\n                realEigenvalues[i] = x + p;\n                imagEigenvalues[i] = z;\n                realEigenvalues[i + 1] = x + p;\n                imagEigenvalues[i + 1] = -z;\n                i++;\n            }\n        }\n        return schurTransform;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "linear", "EigenDecomposition.java"], "context_start_lineno": 0, "function_name": "transformToSchur", "left_context": "class EigenDecomposition {\n    /**\n     * Transforms the matrix to Schur form and calculates the eigenvalues.\n     *\n     * @param matrix Matrix to transform.\n     * @return the {@link SchurTransformer Shur transform} for this matrix\n     */\n    private SchurTransformer transformToSchur(final RealMatrix matrix) {", "right_context": "}\n}", "class_name": "EigenDecomposition", "return_type": "SchurTransformer", "parameters": [{"type": "RealMatrix", "name": "matrix"}]}}
{"prompt": "class MatrixUtils {\n\n    /**\n     * Returns <code>dimension x dimension</code> identity matrix.\n     *\n     * @param dimension dimension of identity matrix to generate\n     * @return identity matrix\n     * @throws IllegalArgumentException if dimension is not positive\n     * @since 1.1\n     */\n    public static RealMatrix createRealIdentityMatrix(int dimension) {\n        final RealMatrix m = createRealMatrix(dimension, dimension);\n        for (int i = 0; i < dimension; ++i) {\n            m.setEntry(i, i, 1.0);\n        }\n        return m;\n    }\n\n    /**\n     * Returns <code>dimension x dimension</code> identity matrix.\n     *\n     * @param <T> the type of the field elements\n     * @param field field to which the elements belong\n     * @param dimension dimension of identity matrix to generate\n     * @return identity matrix\n     * @throws IllegalArgumentException if dimension is not positive\n     * @since 2.0\n     */\n    public static <T extends FieldElement<T>> FieldMatrix<T>\n        createFieldIdentityMatrix(final Field<T> field, final int dimension) {\n        final T zero = field.getZero();\n        final T one  = field.getOne();\n        final T[][] d = MathArrays.buildArray(field, dimension, dimension);\n        for (int row = 0; row < dimension; row++) {\n            final T[] dRow = d[row];\n            Arrays.fill(dRow, zero);\n            dRow[row] = one;\n        }\n        return new Array2DRowFieldMatrix<T>(field, d, false);\n    }\n\n    /**\n     * Returns a diagonal matrix with specified elements.\n     *\n     * @param diagonal diagonal elements of the matrix (the array elements\n     * will be copied)\n     * @return diagonal matrix\n     * @since 2.0\n     */\n    public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n        final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n        for (int i = 0; i < diagonal.length; ++i) {\n            m.setEntry(i, i, diagonal[i]);\n        }\n        return m;\n    }\n\n    /**\n     * Returns a diagonal matrix with specified elements.\n     *\n     * @param <T> the type of the field elements\n     * @param diagonal diagonal elements of the matrix (the array elements\n     * will be copied)\n     * @return diagonal matrix\n     * @since 2.0\n     */\n    public static <T extends FieldElement<T>> FieldMatrix<T>\n        createFieldDiagonalMatrix(final T[] diagonal) {\n        final FieldMatrix<T> m =\n            createFieldMatrix(diagonal[0].getField(), diagonal.length, diagonal.length);\n        for (int i = 0; i < diagonal.length; ++i) {\n            m.setEntry(i, i, diagonal[i]);\n        }\n        return m;\n    }\n\n    /**\n     * Creates a {@link RealVector} using the data from the input array.\n     *\n     * @param data the input data\n     * @return a data.length RealVector\n     * @throws NoDataException if {@code data} is empty.\n     * @throws NullArgumentException if {@code data} is {@code null}.\n     */\n    public static RealVector createRealVector(double[] data)\n        throws NoDataException, NullArgumentException {\n        if (data == null) {\n            throw new NullArgumentException();\n        }\n        return new ArrayRealVector(data, true);\n    }\n\n    /**\n     * Creates a {@link FieldVector} using the data from the input array.\n     *\n     * @param <T> the type of the field elements\n     * @param data the input data\n     * @return a data.length FieldVector\n     * @throws NoDataException if {@code data} is empty.\n     * @throws NullArgumentException if {@code data} is {@code null}.\n     * @throws ZeroException if {@code data} has 0 elements\n     */\n    public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data)\n        throws NoDataException, NullArgumentException, ZeroException {\n        if (data == null) {\n            throw new NullArgumentException();\n        }\n        if (data.length == 0) {\n            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n        }\n        return new ArrayFieldVector<T>(data[0].getField(), data, true);\n    }\n\n    /**\n     * Create a row {@link RealMatrix} using the data from the input\n     * array.\n     *\n     * @param rowData the input row data\n     * @return a 1 x rowData.length RealMatrix\n     * @throws NoDataException if {@code rowData} is empty.\n     * @throws NullArgumentException if {@code rowData} is {@code null}.\n     */\n    public static RealMatrix createRowRealMatrix(double[] rowData)\n        throws NoDataException, NullArgumentException {\n        if (rowData == null) {\n            throw new NullArgumentException();\n        }\n        final int nCols = rowData.length;\n        final RealMatrix m = createRealMatrix(1, nCols);\n        for (int i = 0; i < nCols; ++i) {\n            m.setEntry(0, i, rowData[i]);\n        }\n        return m;\n    }\n\n    /**\n     * Create a row {@link FieldMatrix} using the data from the input\n     * array.\n     *\n     * @param <T> the type of the field elements\n     * @param rowData the input row data\n     * @return a 1 x rowData.length FieldMatrix\n     * @throws NoDataException if {@code rowData} is empty.\n     * @throws NullArgumentException if {@code rowData} is {@code null}.\n     */\n    public static <T extends FieldElement<T>> FieldMatrix<T>\n        createRowFieldMatrix(final T[] rowData)\n        throws NoDataException, NullArgumentException {\n        if (rowData == null) {\n            throw new NullArgumentException();\n        }\n        final int nCols = rowData.length;\n        if (nCols == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n        }\n        final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n        for (int i = 0; i < nCols; ++i) {\n            m.setEntry(0, i, rowData[i]);\n        }\n        return m;\n    }\n\n    /**\n     * Creates a column {@link RealMatrix} using the data from the input\n     * array.\n     *\n     * @param columnData  the input column data\n     * @return a columnData x 1 RealMatrix\n     * @throws NoDataException if {@code columnData} is empty.\n     * @throws NullArgumentException if {@code columnData} is {@code null}.\n     */\n    public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException {", "metadata": {"defects4j_task_id": "a37e5c3e77d68157b07466ebd2e26993f5f8f71ac4af4555bdbbaef6f8bb77ba", "task_id": "apache_commons-math/135", "ground_truth": "\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "linear", "MatrixUtils.java"], "context_start_lineno": 0, "function_name": "createColumnRealMatrix", "left_context": "class MatrixUtils {\n\n    /**\n     * Returns <code>dimension x dimension</code> identity matrix.\n     *\n     * @param dimension dimension of identity matrix to generate\n     * @return identity matrix\n     * @throws IllegalArgumentException if dimension is not positive\n     * @since 1.1\n     */\n    public static RealMatrix createRealIdentityMatrix(int dimension) {\n        final RealMatrix m = createRealMatrix(dimension, dimension);\n        for (int i = 0; i < dimension; ++i) {\n            m.setEntry(i, i, 1.0);\n        }\n        return m;\n    }\n\n    /**\n     * Returns <code>dimension x dimension</code> identity matrix.\n     *\n     * @param <T> the type of the field elements\n     * @param field field to which the elements belong\n     * @param dimension dimension of identity matrix to generate\n     * @return identity matrix\n     * @throws IllegalArgumentException if dimension is not positive\n     * @since 2.0\n     */\n    public static <T extends FieldElement<T>> FieldMatrix<T>\n        createFieldIdentityMatrix(final Field<T> field, final int dimension) {\n        final T zero = field.getZero();\n        final T one  = field.getOne();\n        final T[][] d = MathArrays.buildArray(field, dimension, dimension);\n        for (int row = 0; row < dimension; row++) {\n            final T[] dRow = d[row];\n            Arrays.fill(dRow, zero);\n            dRow[row] = one;\n        }\n        return new Array2DRowFieldMatrix<T>(field, d, false);\n    }\n\n    /**\n     * Returns a diagonal matrix with specified elements.\n     *\n     * @param diagonal diagonal elements of the matrix (the array elements\n     * will be copied)\n     * @return diagonal matrix\n     * @since 2.0\n     */\n    public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n        final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n        for (int i = 0; i < diagonal.length; ++i) {\n            m.setEntry(i, i, diagonal[i]);\n        }\n        return m;\n    }\n\n    /**\n     * Returns a diagonal matrix with specified elements.\n     *\n     * @param <T> the type of the field elements\n     * @param diagonal diagonal elements of the matrix (the array elements\n     * will be copied)\n     * @return diagonal matrix\n     * @since 2.0\n     */\n    public static <T extends FieldElement<T>> FieldMatrix<T>\n        createFieldDiagonalMatrix(final T[] diagonal) {\n        final FieldMatrix<T> m =\n            createFieldMatrix(diagonal[0].getField(), diagonal.length, diagonal.length);\n        for (int i = 0; i < diagonal.length; ++i) {\n            m.setEntry(i, i, diagonal[i]);\n        }\n        return m;\n    }\n\n    /**\n     * Creates a {@link RealVector} using the data from the input array.\n     *\n     * @param data the input data\n     * @return a data.length RealVector\n     * @throws NoDataException if {@code data} is empty.\n     * @throws NullArgumentException if {@code data} is {@code null}.\n     */\n    public static RealVector createRealVector(double[] data)\n        throws NoDataException, NullArgumentException {\n        if (data == null) {\n            throw new NullArgumentException();\n        }\n        return new ArrayRealVector(data, true);\n    }\n\n    /**\n     * Creates a {@link FieldVector} using the data from the input array.\n     *\n     * @param <T> the type of the field elements\n     * @param data the input data\n     * @return a data.length FieldVector\n     * @throws NoDataException if {@code data} is empty.\n     * @throws NullArgumentException if {@code data} is {@code null}.\n     * @throws ZeroException if {@code data} has 0 elements\n     */\n    public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data)\n        throws NoDataException, NullArgumentException, ZeroException {\n        if (data == null) {\n            throw new NullArgumentException();\n        }\n        if (data.length == 0) {\n            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n        }\n        return new ArrayFieldVector<T>(data[0].getField(), data, true);\n    }\n\n    /**\n     * Create a row {@link RealMatrix} using the data from the input\n     * array.\n     *\n     * @param rowData the input row data\n     * @return a 1 x rowData.length RealMatrix\n     * @throws NoDataException if {@code rowData} is empty.\n     * @throws NullArgumentException if {@code rowData} is {@code null}.\n     */\n    public static RealMatrix createRowRealMatrix(double[] rowData)\n        throws NoDataException, NullArgumentException {\n        if (rowData == null) {\n            throw new NullArgumentException();\n        }\n        final int nCols = rowData.length;\n        final RealMatrix m = createRealMatrix(1, nCols);\n        for (int i = 0; i < nCols; ++i) {\n            m.setEntry(0, i, rowData[i]);\n        }\n        return m;\n    }\n\n    /**\n     * Create a row {@link FieldMatrix} using the data from the input\n     * array.\n     *\n     * @param <T> the type of the field elements\n     * @param rowData the input row data\n     * @return a 1 x rowData.length FieldMatrix\n     * @throws NoDataException if {@code rowData} is empty.\n     * @throws NullArgumentException if {@code rowData} is {@code null}.\n     */\n    public static <T extends FieldElement<T>> FieldMatrix<T>\n        createRowFieldMatrix(final T[] rowData)\n        throws NoDataException, NullArgumentException {\n        if (rowData == null) {\n            throw new NullArgumentException();\n        }\n        final int nCols = rowData.length;\n        if (nCols == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n        }\n        final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n        for (int i = 0; i < nCols; ++i) {\n            m.setEntry(0, i, rowData[i]);\n        }\n        return m;\n    }\n\n    /**\n     * Creates a column {@link RealMatrix} using the data from the input\n     * array.\n     *\n     * @param columnData  the input column data\n     * @return a columnData x 1 RealMatrix\n     * @throws NoDataException if {@code columnData} is empty.\n     * @throws NullArgumentException if {@code columnData} is {@code null}.\n     */\n    public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException {", "right_context": "}\n}", "class_name": "MatrixUtils", "return_type": "RealMatrix", "parameters": [{"type": "double[]", "name": "columnData"}]}}
{"prompt": "class ArrayFieldVector<T extends FieldElement<T>> implements FieldVector<T>, Serializable {\n    /** {@inheritDoc} */\n    public FieldVector<T> mapInvToSelf() throws MathArithmeticException {\n        final T one = field.getOne();\n        for (int i = 0; i < data.length; i++) {\n            try {\n                data[i] = one.divide(data[i]);\n            } catch (final MathArithmeticException e) {\n                throw new MathArithmeticException(LocalizedFormats.INDEX, i);\n            }\n        }\n        return this;\n    }\n\n    /** {@inheritDoc} */\n    public FieldVector<T> ebeMultiply(FieldVector<T> v)\n        throws DimensionMismatchException {\n        try {\n            return ebeMultiply((ArrayFieldVector<T>) v);\n        } catch (ClassCastException cce) {\n            checkVectorDimensions(v);\n            T[] out = MathArrays.buildArray(field, data.length);\n            for (int i = 0; i < data.length; i++) {\n                out[i] = data[i].multiply(v.getEntry(i));\n            }\n            return new ArrayFieldVector<T>(field, out, false);\n        }\n    }\n\n    /**\n     * Element-by-element multiplication.\n     * @param v vector by which instance elements must be multiplied\n     * @return a vector containing {@code this[i] * v[i]} for all {@code i}\n     * @throws DimensionMismatchException if {@code v} is not the same size as\n     * {@code this}\n     */\n    public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v)\n        throws DimensionMismatchException {\n        checkVectorDimensions(v.data.length);\n        T[] out = MathArrays.buildArray(field, data.length);\n        for (int i = 0; i < data.length; i++) {\n            out[i] = data[i].multiply(v.data[i]);\n        }\n        return new ArrayFieldVector<T>(field, out, false);\n    }\n\n    /** {@inheritDoc} */\n    public FieldVector<T> ebeDivide(FieldVector<T> v)\n        throws DimensionMismatchException, MathArithmeticException {\n        try {\n            return ebeDivide((ArrayFieldVector<T>) v);\n        } catch (ClassCastException cce) {\n            checkVectorDimensions(v);\n            T[] out = MathArrays.buildArray(field, data.length);\n            for (int i = 0; i < data.length; i++) {\n                try {\n                    out[i] = data[i].divide(v.getEntry(i));\n                } catch (final MathArithmeticException e) {\n                    throw new MathArithmeticException(LocalizedFormats.INDEX, i);\n                }\n            }\n            return new ArrayFieldVector<T>(field, out, false);\n        }\n    }\n\n    /**\n     * Element-by-element division.\n     * @param v vector by which instance elements must be divided\n     * @return a vector containing {@code this[i] / v[i]} for all {@code i}\n     * @throws DimensionMismatchException if {@code v} is not the same size as\n     * {@code this}\n     * @throws MathArithmeticException if one entry of {@code v} is zero.\n     */\n    public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v)\n        throws DimensionMismatchException, MathArithmeticException {\n        checkVectorDimensions(v.data.length);\n        T[] out = MathArrays.buildArray(field, data.length);\n        for (int i = 0; i < data.length; i++) {\n            try {\n                out[i] = data[i].divide(v.data[i]);\n            } catch (final MathArithmeticException e) {\n                throw new MathArithmeticException(LocalizedFormats.INDEX, i);\n            }\n        }\n        return new ArrayFieldVector<T>(field, out, false);\n    }\n\n    /** {@inheritDoc} */\n    public T[] getData() {\n        return data.clone();\n    }\n\n    /**\n     * Returns a reference to the underlying data array.\n     * <p>Does not make a fresh copy of the underlying data.</p>\n     * @return array of entries\n     */\n    public T[] getDataRef() {\n        return data;\n    }\n\n    /** {@inheritDoc} */\n    public T dotProduct(FieldVector<T> v)\n        throws DimensionMismatchException {\n        try {\n            return dotProduct((ArrayFieldVector<T>) v);\n        } catch (ClassCastException cce) {\n            checkVectorDimensions(v);\n            T dot = field.getZero();\n            for (int i = 0; i < data.length; i++) {\n                dot = dot.add(data[i].multiply(v.getEntry(i)));\n            }\n            return dot;\n        }\n    }\n\n    /**\n     * Compute the dot product.\n     * @param v vector with which dot product should be computed\n     * @return the scalar dot product of {@code this} and {@code v}\n     * @throws DimensionMismatchException if {@code v} is not the same size as\n     * {@code this}\n     */\n    public T dotProduct(ArrayFieldVector<T> v)\n        throws DimensionMismatchException {\n        checkVectorDimensions(v.data.length);\n        T dot = field.getZero();\n        for (int i = 0; i < data.length; i++) {\n            dot = dot.add(data[i].multiply(v.data[i]));\n        }\n        return dot;\n    }\n\n    /** {@inheritDoc} */\n    public FieldVector<T> projection(FieldVector<T> v)\n        throws DimensionMismatchException, MathArithmeticException {\n        return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n    }\n\n    /** Find the orthogonal projection of this vector onto another vector.\n     * @param v vector onto which {@code this} must be projected\n     * @return projection of {@code this} onto {@code v}\n     * @throws DimensionMismatchException if {@code v} is not the same size as\n     * {@code this}\n     * @throws MathArithmeticException if {@code v} is the null vector.\n     */\n    public ArrayFieldVector<T> projection(ArrayFieldVector<T> v)\n        throws DimensionMismatchException, MathArithmeticException {\n        return (ArrayFieldVector<T>) v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n    }\n\n    /** {@inheritDoc} */\n    public FieldMatrix<T> outerProduct(FieldVector<T> v) {\n        try {\n            return outerProduct((ArrayFieldVector<T>) v);\n        } catch (ClassCastException cce) {\n            final int m = data.length;\n            final int n = v.getDimension();\n            final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n                }\n            }\n            return out;\n        }\n    }\n\n    /**\n     * Compute the outer product.\n     * @param v vector with which outer product should be computed\n     * @return the matrix outer product between instance and v\n     */\n    public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v) {", "metadata": {"defects4j_task_id": "87db8c2347e9f78321178c2e550048c0b629fc695a6edae8ee0512cad3920656", "task_id": "apache_commons-math/113", "ground_truth": "\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "linear", "ArrayFieldVector.java"], "context_start_lineno": 0, "function_name": "outerProduct", "left_context": "class ArrayFieldVector<T extends FieldElement<T>> implements FieldVector<T>, Serializable {\n    /** {@inheritDoc} */\n    public FieldVector<T> mapInvToSelf() throws MathArithmeticException {\n        final T one = field.getOne();\n        for (int i = 0; i < data.length; i++) {\n            try {\n                data[i] = one.divide(data[i]);\n            } catch (final MathArithmeticException e) {\n                throw new MathArithmeticException(LocalizedFormats.INDEX, i);\n            }\n        }\n        return this;\n    }\n\n    /** {@inheritDoc} */\n    public FieldVector<T> ebeMultiply(FieldVector<T> v)\n        throws DimensionMismatchException {\n        try {\n            return ebeMultiply((ArrayFieldVector<T>) v);\n        } catch (ClassCastException cce) {\n            checkVectorDimensions(v);\n            T[] out = MathArrays.buildArray(field, data.length);\n            for (int i = 0; i < data.length; i++) {\n                out[i] = data[i].multiply(v.getEntry(i));\n            }\n            return new ArrayFieldVector<T>(field, out, false);\n        }\n    }\n\n    /**\n     * Element-by-element multiplication.\n     * @param v vector by which instance elements must be multiplied\n     * @return a vector containing {@code this[i] * v[i]} for all {@code i}\n     * @throws DimensionMismatchException if {@code v} is not the same size as\n     * {@code this}\n     */\n    public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v)\n        throws DimensionMismatchException {\n        checkVectorDimensions(v.data.length);\n        T[] out = MathArrays.buildArray(field, data.length);\n        for (int i = 0; i < data.length; i++) {\n            out[i] = data[i].multiply(v.data[i]);\n        }\n        return new ArrayFieldVector<T>(field, out, false);\n    }\n\n    /** {@inheritDoc} */\n    public FieldVector<T> ebeDivide(FieldVector<T> v)\n        throws DimensionMismatchException, MathArithmeticException {\n        try {\n            return ebeDivide((ArrayFieldVector<T>) v);\n        } catch (ClassCastException cce) {\n            checkVectorDimensions(v);\n            T[] out = MathArrays.buildArray(field, data.length);\n            for (int i = 0; i < data.length; i++) {\n                try {\n                    out[i] = data[i].divide(v.getEntry(i));\n                } catch (final MathArithmeticException e) {\n                    throw new MathArithmeticException(LocalizedFormats.INDEX, i);\n                }\n            }\n            return new ArrayFieldVector<T>(field, out, false);\n        }\n    }\n\n    /**\n     * Element-by-element division.\n     * @param v vector by which instance elements must be divided\n     * @return a vector containing {@code this[i] / v[i]} for all {@code i}\n     * @throws DimensionMismatchException if {@code v} is not the same size as\n     * {@code this}\n     * @throws MathArithmeticException if one entry of {@code v} is zero.\n     */\n    public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v)\n        throws DimensionMismatchException, MathArithmeticException {\n        checkVectorDimensions(v.data.length);\n        T[] out = MathArrays.buildArray(field, data.length);\n        for (int i = 0; i < data.length; i++) {\n            try {\n                out[i] = data[i].divide(v.data[i]);\n            } catch (final MathArithmeticException e) {\n                throw new MathArithmeticException(LocalizedFormats.INDEX, i);\n            }\n        }\n        return new ArrayFieldVector<T>(field, out, false);\n    }\n\n    /** {@inheritDoc} */\n    public T[] getData() {\n        return data.clone();\n    }\n\n    /**\n     * Returns a reference to the underlying data array.\n     * <p>Does not make a fresh copy of the underlying data.</p>\n     * @return array of entries\n     */\n    public T[] getDataRef() {\n        return data;\n    }\n\n    /** {@inheritDoc} */\n    public T dotProduct(FieldVector<T> v)\n        throws DimensionMismatchException {\n        try {\n            return dotProduct((ArrayFieldVector<T>) v);\n        } catch (ClassCastException cce) {\n            checkVectorDimensions(v);\n            T dot = field.getZero();\n            for (int i = 0; i < data.length; i++) {\n                dot = dot.add(data[i].multiply(v.getEntry(i)));\n            }\n            return dot;\n        }\n    }\n\n    /**\n     * Compute the dot product.\n     * @param v vector with which dot product should be computed\n     * @return the scalar dot product of {@code this} and {@code v}\n     * @throws DimensionMismatchException if {@code v} is not the same size as\n     * {@code this}\n     */\n    public T dotProduct(ArrayFieldVector<T> v)\n        throws DimensionMismatchException {\n        checkVectorDimensions(v.data.length);\n        T dot = field.getZero();\n        for (int i = 0; i < data.length; i++) {\n            dot = dot.add(data[i].multiply(v.data[i]));\n        }\n        return dot;\n    }\n\n    /** {@inheritDoc} */\n    public FieldVector<T> projection(FieldVector<T> v)\n        throws DimensionMismatchException, MathArithmeticException {\n        return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n    }\n\n    /** Find the orthogonal projection of this vector onto another vector.\n     * @param v vector onto which {@code this} must be projected\n     * @return projection of {@code this} onto {@code v}\n     * @throws DimensionMismatchException if {@code v} is not the same size as\n     * {@code this}\n     * @throws MathArithmeticException if {@code v} is the null vector.\n     */\n    public ArrayFieldVector<T> projection(ArrayFieldVector<T> v)\n        throws DimensionMismatchException, MathArithmeticException {\n        return (ArrayFieldVector<T>) v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n    }\n\n    /** {@inheritDoc} */\n    public FieldMatrix<T> outerProduct(FieldVector<T> v) {\n        try {\n            return outerProduct((ArrayFieldVector<T>) v);\n        } catch (ClassCastException cce) {\n            final int m = data.length;\n            final int n = v.getDimension();\n            final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n                }\n            }\n            return out;\n        }\n    }\n\n    /**\n     * Compute the outer product.\n     * @param v vector with which outer product should be computed\n     * @return the matrix outer product between instance and v\n     */\n    public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v) {", "right_context": "}\n}", "class_name": "ArrayFieldVector", "return_type": "FieldMatrix<T>", "parameters": [{"type": "ArrayFieldVector<T>", "name": "v"}]}}
{"prompt": "class FieldLUDecomposition<T extends FieldElement<T>> {\n\n    /** Entries of LU decomposition. */\n    private T[][] lu;\n\n    /** Pivot permutation associated with LU decomposition. */\n    private int[] pivot;\n\n    /** Parity of the permutation associated with the LU decomposition. */\n    private boolean even;\n\n    /** Singularity indicator. */\n    private boolean singular;\n\n    /** Cached value of L. */\n    private FieldMatrix<T> cachedL;\n\n    /** Cached value of U. */\n    private FieldMatrix<T> cachedU;\n\n    /** Cached value of P. */\n    private FieldMatrix<T> cachedP;\n\n    /**\n     * Calculates the LU-decomposition of the given matrix.\n     * @param matrix The matrix to decompose.\n     * @throws NonSquareMatrixException if matrix is not square\n     */\n    public FieldLUDecomposition(FieldMatrix<T> matrix) {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getColumnDimension();\n        field = matrix.getField();\n        lu = matrix.getData();\n        pivot = new int[m];\n        cachedL = null;\n        cachedU = null;\n        cachedP = null;\n\n        // Initialize permutation array and parity\n        for (int row = 0; row < m; row++) {\n            pivot[row] = row;\n        }\n        even     = true;\n        singular = false;\n\n        // Loop over columns\n        for (int col = 0; col < m; col++) {\n\n            T sum = field.getZero();\n\n            // upper\n            for (int row = 0; row < col; row++) {\n                final T[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n            }\n\n            // lower\n            int nonZero = col; // permutation row\n            for (int row = col; row < m; row++) {\n                final T[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n\n                if (lu[nonZero][col].equals(field.getZero())) {\n                    // try to select a better permutation choice\n                    ++nonZero;\n                }\n            }\n\n            // Singularity check\n            if (nonZero >= m) {\n                singular = true;\n                return;\n            }\n\n            // Pivot if necessary\n            if (nonZero != col) {\n                T tmp = field.getZero();\n                for (int i = 0; i < m; i++) {\n                    tmp = lu[nonZero][i];\n                    lu[nonZero][i] = lu[col][i];\n                    lu[col][i] = tmp;\n                }\n                int temp = pivot[nonZero];\n                pivot[nonZero] = pivot[col];\n                pivot[col] = temp;\n                even = !even;\n            }\n\n            // Divide the lower elements by the \"winning\" diagonal elt.\n            final T luDiag = lu[col][col];\n            for (int row = col + 1; row < m; row++) {\n                final T[] luRow = lu[row];\n                luRow[col] = luRow[col].divide(luDiag);\n            }\n        }\n\n    }\n\n    /**\n     * Returns the matrix L of the decomposition.\n     * <p>L is a lower-triangular matrix</p>\n     * @return the L matrix (or null if decomposed matrix is singular)\n     */\n    public FieldMatrix<T> getL() {\n        if ((cachedL == null) && !singular) {\n            final int m = pivot.length;\n            cachedL = new Array2DRowFieldMatrix<T>(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                final T[] luI = lu[i];\n                for (int j = 0; j < i; ++j) {\n                    cachedL.setEntry(i, j, luI[j]);\n                }\n                cachedL.setEntry(i, i, field.getOne());\n            }\n        }\n        return cachedL;\n    }\n\n    /**\n     * Returns the matrix U of the decomposition.\n     * <p>U is an upper-triangular matrix</p>\n     * @return the U matrix (or null if decomposed matrix is singular)\n     */\n    public FieldMatrix<T> getU() {\n        if ((cachedU == null) && !singular) {\n            final int m = pivot.length;\n            cachedU = new Array2DRowFieldMatrix<T>(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                final T[] luI = lu[i];\n                for (int j = i; j < m; ++j) {\n                    cachedU.setEntry(i, j, luI[j]);\n                }\n            }\n        }\n        return cachedU;\n    }\n\n    /**\n     * Returns the P rows permutation matrix.\n     * <p>P is a sparse matrix with exactly one element set to 1.0 in\n     * each row and each column, all other elements being set to 0.0.</p>\n     * <p>The positions of the 1 elements are given by the {@link #getPivot()\n     * pivot permutation vector}.</p>\n     * @return the P rows permutation matrix (or null if decomposed matrix is singular)\n     * @see #getPivot()\n     */\n    public FieldMatrix<T> getP() {", "metadata": {"defects4j_task_id": "781c8b155a46026286a9261bf87b7ddb8753e50e85d5aae79dccea1cb4ae88a4", "task_id": "apache_commons-math/100", "ground_truth": "\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "linear", "FieldLUDecomposition.java"], "context_start_lineno": 0, "function_name": "getP", "left_context": "class FieldLUDecomposition<T extends FieldElement<T>> {\n\n    /** Entries of LU decomposition. */\n    private T[][] lu;\n\n    /** Pivot permutation associated with LU decomposition. */\n    private int[] pivot;\n\n    /** Parity of the permutation associated with the LU decomposition. */\n    private boolean even;\n\n    /** Singularity indicator. */\n    private boolean singular;\n\n    /** Cached value of L. */\n    private FieldMatrix<T> cachedL;\n\n    /** Cached value of U. */\n    private FieldMatrix<T> cachedU;\n\n    /** Cached value of P. */\n    private FieldMatrix<T> cachedP;\n\n    /**\n     * Calculates the LU-decomposition of the given matrix.\n     * @param matrix The matrix to decompose.\n     * @throws NonSquareMatrixException if matrix is not square\n     */\n    public FieldLUDecomposition(FieldMatrix<T> matrix) {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getColumnDimension();\n        field = matrix.getField();\n        lu = matrix.getData();\n        pivot = new int[m];\n        cachedL = null;\n        cachedU = null;\n        cachedP = null;\n\n        // Initialize permutation array and parity\n        for (int row = 0; row < m; row++) {\n            pivot[row] = row;\n        }\n        even     = true;\n        singular = false;\n\n        // Loop over columns\n        for (int col = 0; col < m; col++) {\n\n            T sum = field.getZero();\n\n            // upper\n            for (int row = 0; row < col; row++) {\n                final T[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n            }\n\n            // lower\n            int nonZero = col; // permutation row\n            for (int row = col; row < m; row++) {\n                final T[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n\n                if (lu[nonZero][col].equals(field.getZero())) {\n                    // try to select a better permutation choice\n                    ++nonZero;\n                }\n            }\n\n            // Singularity check\n            if (nonZero >= m) {\n                singular = true;\n                return;\n            }\n\n            // Pivot if necessary\n            if (nonZero != col) {\n                T tmp = field.getZero();\n                for (int i = 0; i < m; i++) {\n                    tmp = lu[nonZero][i];\n                    lu[nonZero][i] = lu[col][i];\n                    lu[col][i] = tmp;\n                }\n                int temp = pivot[nonZero];\n                pivot[nonZero] = pivot[col];\n                pivot[col] = temp;\n                even = !even;\n            }\n\n            // Divide the lower elements by the \"winning\" diagonal elt.\n            final T luDiag = lu[col][col];\n            for (int row = col + 1; row < m; row++) {\n                final T[] luRow = lu[row];\n                luRow[col] = luRow[col].divide(luDiag);\n            }\n        }\n\n    }\n\n    /**\n     * Returns the matrix L of the decomposition.\n     * <p>L is a lower-triangular matrix</p>\n     * @return the L matrix (or null if decomposed matrix is singular)\n     */\n    public FieldMatrix<T> getL() {\n        if ((cachedL == null) && !singular) {\n            final int m = pivot.length;\n            cachedL = new Array2DRowFieldMatrix<T>(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                final T[] luI = lu[i];\n                for (int j = 0; j < i; ++j) {\n                    cachedL.setEntry(i, j, luI[j]);\n                }\n                cachedL.setEntry(i, i, field.getOne());\n            }\n        }\n        return cachedL;\n    }\n\n    /**\n     * Returns the matrix U of the decomposition.\n     * <p>U is an upper-triangular matrix</p>\n     * @return the U matrix (or null if decomposed matrix is singular)\n     */\n    public FieldMatrix<T> getU() {\n        if ((cachedU == null) && !singular) {\n            final int m = pivot.length;\n            cachedU = new Array2DRowFieldMatrix<T>(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                final T[] luI = lu[i];\n                for (int j = i; j < m; ++j) {\n                    cachedU.setEntry(i, j, luI[j]);\n                }\n            }\n        }\n        return cachedU;\n    }\n\n    /**\n     * Returns the P rows permutation matrix.\n     * <p>P is a sparse matrix with exactly one element set to 1.0 in\n     * each row and each column, all other elements being set to 0.0.</p>\n     * <p>The positions of the 1 elements are given by the {@link #getPivot()\n     * pivot permutation vector}.</p>\n     * @return the P rows permutation matrix (or null if decomposed matrix is singular)\n     * @see #getPivot()\n     */\n    public FieldMatrix<T> getP() {", "right_context": "}\n}", "class_name": "FieldLUDecomposition", "return_type": "FieldMatrix<T>", "parameters": []}}
{"prompt": "class SchurTransformer {\n    /** P matrix. */\n    private final double matrixP[][];\n    /** T matrix. */\n    private final double matrixT[][];\n    /** Cached value of P. */\n    private RealMatrix cachedP;\n    /** Cached value of T. */\n    private RealMatrix cachedT;\n    /** Cached value of PT. */\n    private RealMatrix cachedPt;\n\n    /** Epsilon criteria taken from JAMA code (originally was 2^-52). */\n    private final double epsilon = Precision.EPSILON;\n\n    /**\n     * Build the transformation to Schur form of a general real matrix.\n     *\n     * @param matrix matrix to transform\n     * @throws NonSquareMatrixException if the matrix is not square\n     */\n    public SchurTransformer(final RealMatrix matrix) {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n        matrixT = transformer.getH().getData();\n        matrixP = transformer.getP().getData();\n        cachedT = null;\n        cachedP = null;\n        cachedPt = null;\n\n        // transform matrix\n        transform();\n    }\n\n    /**\n     * Returns the matrix P of the transform.\n     * <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>\n     *\n     * @return the P matrix\n     */\n    public RealMatrix getP() {\n        if (cachedP == null) {\n            cachedP = MatrixUtils.createRealMatrix(matrixP);\n        }\n        return cachedP;\n    }\n\n    /**\n     * Returns the transpose of the matrix P of the transform.\n     * <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>\n     *\n     * @return the transpose of the P matrix\n     */\n    public RealMatrix getPT() {\n        if (cachedPt == null) {\n            cachedPt = getP().transpose();\n        }\n\n        // return the cached matrix\n        return cachedPt;\n    }\n\n    /**\n     * Returns the quasi-triangular Schur matrix T of the transform.\n     *\n     * @return the T matrix\n     */\n    public RealMatrix getT() {\n        if (cachedT == null) {\n            cachedT = MatrixUtils.createRealMatrix(matrixT);\n        }\n\n        // return the cached matrix\n        return cachedT;\n    }\n\n    /**\n     * Transform original matrix to Schur form.\n     * @throws MaxCountExceededException if the transformation does not converge\n     */\n    private void transform() {\n        final int n = matrixT.length;\n\n        // compute matrix norm\n        final double norm = getNorm();\n\n        // shift information\n        final ShiftInfo shift = new ShiftInfo();\n\n        // Outer loop over eigenvalue index\n        int iteration = 0;\n        int iu = n - 1;\n        while (iu >= 0) {\n\n            // Look for single small sub-diagonal element\n            final int il = findSmallSubDiagonalElement(iu, norm);\n\n            // Check for convergence\n            if (il == iu) {\n                // One root found\n                matrixT[iu][iu] = matrixT[iu][iu] + shift.exShift;\n                iu--;\n                iteration = 0;\n            } else if (il == iu - 1) {\n                // Two roots found\n                double p = (matrixT[iu - 1][iu - 1] - matrixT[iu][iu]) / 2.0;\n                double q = p * p + matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n                matrixT[iu][iu] += shift.exShift;\n                matrixT[iu - 1][iu - 1] += shift.exShift;\n\n                if (q >= 0) {\n                    double z = FastMath.sqrt(FastMath.abs(q));\n                    if (p >= 0) {\n                        z = p + z;\n                    } else {\n                        z = p - z;\n                    }\n                    final double x = matrixT[iu][iu - 1];\n                    final double s = FastMath.abs(x) + FastMath.abs(z);\n                    p = x / s;\n                    q = z / s;\n                    final double r = FastMath.sqrt(p * p + q * q);\n                    p = p / r;\n                    q = q / r;\n\n                    // Row modification\n                    for (int j = iu - 1; j < n; j++) {\n                        z = matrixT[iu - 1][j];\n                        matrixT[iu - 1][j] = q * z + p * matrixT[iu][j];\n                        matrixT[iu][j] = q * matrixT[iu][j] - p * z;\n                    }\n\n                    // Column modification\n                    for (int i = 0; i <= iu; i++) {\n                        z = matrixT[i][iu - 1];\n                        matrixT[i][iu - 1] = q * z + p * matrixT[i][iu];\n                        matrixT[i][iu] = q * matrixT[i][iu] - p * z;\n                    }\n\n                    // Accumulate transformations\n                    for (int i = 0; i <= n - 1; i++) {\n                        z = matrixP[i][iu - 1];\n                        matrixP[i][iu - 1] = q * z + p * matrixP[i][iu];\n                        matrixP[i][iu] = q * matrixP[i][iu] - p * z;\n                    }\n                }\n                iu -= 2;\n                iteration = 0;\n            } else {\n                // No convergence yet\n                computeShift(il, iu, iteration, shift);\n\n                // stop transformation after too many iterations\n                if (++iteration > MAX_ITERATIONS) {\n                    throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n                                                        MAX_ITERATIONS);\n                }\n\n                // the initial houseHolder vector for the QR step\n                final double[] hVec = new double[3];\n\n                final int im = initQRStep(il, iu, shift, hVec);\n                performDoubleQRStep(il, im, iu, shift, hVec);\n            }\n        }\n    }\n\n    /**\n     * Computes the L1 norm of the (quasi-)triangular matrix T.\n     *\n     * @return the L1 norm of matrix T\n     */\n    private double getNorm() {\n        double norm = 0.0;\n        for (int i = 0; i < matrixT.length; i++) {\n            // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n            for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n                norm += FastMath.abs(matrixT[i][j]);\n            }\n        }\n        return norm;\n    }\n\n    /**\n     * Find the first small sub-diagonal element and returns its index.\n     *\n     * @param startIdx the starting index for the search\n     * @param norm the L1 norm of the matrix\n     * @return the index of the first small sub-diagonal element\n     */\n    private int findSmallSubDiagonalElement(final int startIdx, final double norm) {", "metadata": {"defects4j_task_id": "3c40a49a082afbcc72dff0f93d26755abed423f4a16f5a5dca8047401353843b", "task_id": "apache_commons-math/53", "ground_truth": "\n        int l = startIdx;\n        while (l > 0) {\n            double s = FastMath.abs(matrixT[l - 1][l - 1]) + FastMath.abs(matrixT[l][l]);\n            if (s == 0.0) {\n                s = norm;\n            }\n            if (FastMath.abs(matrixT[l][l - 1]) < epsilon * s) {\n                break;\n            }\n            l--;\n        }\n        return l;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "linear", "SchurTransformer.java"], "context_start_lineno": 0, "function_name": "findSmallSubDiagonalElement", "left_context": "class SchurTransformer {\n    /** P matrix. */\n    private final double matrixP[][];\n    /** T matrix. */\n    private final double matrixT[][];\n    /** Cached value of P. */\n    private RealMatrix cachedP;\n    /** Cached value of T. */\n    private RealMatrix cachedT;\n    /** Cached value of PT. */\n    private RealMatrix cachedPt;\n\n    /** Epsilon criteria taken from JAMA code (originally was 2^-52). */\n    private final double epsilon = Precision.EPSILON;\n\n    /**\n     * Build the transformation to Schur form of a general real matrix.\n     *\n     * @param matrix matrix to transform\n     * @throws NonSquareMatrixException if the matrix is not square\n     */\n    public SchurTransformer(final RealMatrix matrix) {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n        matrixT = transformer.getH().getData();\n        matrixP = transformer.getP().getData();\n        cachedT = null;\n        cachedP = null;\n        cachedPt = null;\n\n        // transform matrix\n        transform();\n    }\n\n    /**\n     * Returns the matrix P of the transform.\n     * <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>\n     *\n     * @return the P matrix\n     */\n    public RealMatrix getP() {\n        if (cachedP == null) {\n            cachedP = MatrixUtils.createRealMatrix(matrixP);\n        }\n        return cachedP;\n    }\n\n    /**\n     * Returns the transpose of the matrix P of the transform.\n     * <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>\n     *\n     * @return the transpose of the P matrix\n     */\n    public RealMatrix getPT() {\n        if (cachedPt == null) {\n            cachedPt = getP().transpose();\n        }\n\n        // return the cached matrix\n        return cachedPt;\n    }\n\n    /**\n     * Returns the quasi-triangular Schur matrix T of the transform.\n     *\n     * @return the T matrix\n     */\n    public RealMatrix getT() {\n        if (cachedT == null) {\n            cachedT = MatrixUtils.createRealMatrix(matrixT);\n        }\n\n        // return the cached matrix\n        return cachedT;\n    }\n\n    /**\n     * Transform original matrix to Schur form.\n     * @throws MaxCountExceededException if the transformation does not converge\n     */\n    private void transform() {\n        final int n = matrixT.length;\n\n        // compute matrix norm\n        final double norm = getNorm();\n\n        // shift information\n        final ShiftInfo shift = new ShiftInfo();\n\n        // Outer loop over eigenvalue index\n        int iteration = 0;\n        int iu = n - 1;\n        while (iu >= 0) {\n\n            // Look for single small sub-diagonal element\n            final int il = findSmallSubDiagonalElement(iu, norm);\n\n            // Check for convergence\n            if (il == iu) {\n                // One root found\n                matrixT[iu][iu] = matrixT[iu][iu] + shift.exShift;\n                iu--;\n                iteration = 0;\n            } else if (il == iu - 1) {\n                // Two roots found\n                double p = (matrixT[iu - 1][iu - 1] - matrixT[iu][iu]) / 2.0;\n                double q = p * p + matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n                matrixT[iu][iu] += shift.exShift;\n                matrixT[iu - 1][iu - 1] += shift.exShift;\n\n                if (q >= 0) {\n                    double z = FastMath.sqrt(FastMath.abs(q));\n                    if (p >= 0) {\n                        z = p + z;\n                    } else {\n                        z = p - z;\n                    }\n                    final double x = matrixT[iu][iu - 1];\n                    final double s = FastMath.abs(x) + FastMath.abs(z);\n                    p = x / s;\n                    q = z / s;\n                    final double r = FastMath.sqrt(p * p + q * q);\n                    p = p / r;\n                    q = q / r;\n\n                    // Row modification\n                    for (int j = iu - 1; j < n; j++) {\n                        z = matrixT[iu - 1][j];\n                        matrixT[iu - 1][j] = q * z + p * matrixT[iu][j];\n                        matrixT[iu][j] = q * matrixT[iu][j] - p * z;\n                    }\n\n                    // Column modification\n                    for (int i = 0; i <= iu; i++) {\n                        z = matrixT[i][iu - 1];\n                        matrixT[i][iu - 1] = q * z + p * matrixT[i][iu];\n                        matrixT[i][iu] = q * matrixT[i][iu] - p * z;\n                    }\n\n                    // Accumulate transformations\n                    for (int i = 0; i <= n - 1; i++) {\n                        z = matrixP[i][iu - 1];\n                        matrixP[i][iu - 1] = q * z + p * matrixP[i][iu];\n                        matrixP[i][iu] = q * matrixP[i][iu] - p * z;\n                    }\n                }\n                iu -= 2;\n                iteration = 0;\n            } else {\n                // No convergence yet\n                computeShift(il, iu, iteration, shift);\n\n                // stop transformation after too many iterations\n                if (++iteration > MAX_ITERATIONS) {\n                    throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n                                                        MAX_ITERATIONS);\n                }\n\n                // the initial houseHolder vector for the QR step\n                final double[] hVec = new double[3];\n\n                final int im = initQRStep(il, iu, shift, hVec);\n                performDoubleQRStep(il, im, iu, shift, hVec);\n            }\n        }\n    }\n\n    /**\n     * Computes the L1 norm of the (quasi-)triangular matrix T.\n     *\n     * @return the L1 norm of matrix T\n     */\n    private double getNorm() {\n        double norm = 0.0;\n        for (int i = 0; i < matrixT.length; i++) {\n            // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n            for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n                norm += FastMath.abs(matrixT[i][j]);\n            }\n        }\n        return norm;\n    }\n\n    /**\n     * Find the first small sub-diagonal element and returns its index.\n     *\n     * @param startIdx the starting index for the search\n     * @param norm the L1 norm of the matrix\n     * @return the index of the first small sub-diagonal element\n     */\n    private int findSmallSubDiagonalElement(final int startIdx, final double norm) {", "right_context": "}\n}", "class_name": "SchurTransformer", "return_type": "int", "parameters": [{"type": "int", "name": "startIdx"}, {"type": "double", "name": "norm"}]}}
{"prompt": "class SchurTransformer {\n    /**\n     * Computes the L1 norm of the (quasi-)triangular matrix T.\n     *\n     * @return the L1 norm of matrix T\n     */\n    private double getNorm() {\n        double norm = 0.0;\n        for (int i = 0; i < matrixT.length; i++) {\n            // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n            for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n                norm += FastMath.abs(matrixT[i][j]);\n            }\n        }\n        return norm;\n    }\n\n    /**\n     * Find the first small sub-diagonal element and returns its index.\n     *\n     * @param startIdx the starting index for the search\n     * @param norm the L1 norm of the matrix\n     * @return the index of the first small sub-diagonal element\n     */\n    private int findSmallSubDiagonalElement(final int startIdx, final double norm) {\n        int l = startIdx;\n        while (l > 0) {\n            double s = FastMath.abs(matrixT[l - 1][l - 1]) + FastMath.abs(matrixT[l][l]);\n            if (s == 0.0) {\n                s = norm;\n            }\n            if (FastMath.abs(matrixT[l][l - 1]) < epsilon * s) {\n                break;\n            }\n            l--;\n        }\n        return l;\n    }\n\n    /**\n     * Compute the shift for the current iteration.\n     *\n     * @param l the index of the small sub-diagonal element\n     * @param idx the current eigenvalue index\n     * @param iteration the current iteration\n     * @param shift holder for shift information\n     */\n    private void computeShift(final int l, final int idx, final int iteration, final ShiftInfo shift) {\n        // Form shift\n        shift.x = matrixT[idx][idx];\n        shift.y = shift.w = 0.0;\n        if (l < idx) {\n            shift.y = matrixT[idx - 1][idx - 1];\n            shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];\n        }\n\n        // Wilkinson's original ad hoc shift\n        if (iteration == 10) {\n            shift.exShift += shift.x;\n            for (int i = 0; i <= idx; i++) {\n                matrixT[i][i] -= shift.x;\n            }\n            final double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\n            shift.x = 0.75 * s;\n            shift.y = 0.75 * s;\n            shift.w = -0.4375 * s * s;\n        }\n\n        // MATLAB's new ad hoc shift\n        if (iteration == 30) {\n            double s = (shift.y - shift.x) / 2.0;\n            s = s * s + shift.w;\n            if (s > 0.0) {\n                s = FastMath.sqrt(s);\n                if (shift.y < shift.x) {\n                    s = -s;\n                }\n                s = shift.x - shift.w / ((shift.y - shift.x) / 2.0 + s);\n                for (int i = 0; i <= idx; i++) {\n                    matrixT[i][i] -= s;\n                }\n                shift.exShift += s;\n                shift.x = shift.y = shift.w = 0.964;\n            }\n        }\n    }\n\n    /**\n     * Initialize the householder vectors for the QR step.\n     *\n     * @param il the index of the small sub-diagonal element\n     * @param iu the current eigenvalue index\n     * @param shift shift information holder\n     * @param hVec the initial houseHolder vector\n     * @return the start index for the QR step\n     */\n    private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec) {", "metadata": {"defects4j_task_id": "6be0ad94b3c6a4e240f443b8a5f8e433dd08c2a43f17fba697726e0c239275c0", "task_id": "apache_commons-math/89", "ground_truth": "\n        // Look for two consecutive small sub-diagonal elements\n        int im = iu - 2;\n        while (im >= il) {\n            final double z = matrixT[im][im];\n            final double r = shift.x - z;\n            double s = shift.y - z;\n            hVec[0] = (r * s - shift.w) / matrixT[im + 1][im] + matrixT[im][im + 1];\n            hVec[1] = matrixT[im + 1][im + 1] - z - r - s;\n            hVec[2] = matrixT[im + 2][im + 1];\n\n            if (im == il) {\n                break;\n            }\n\n            final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n            final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                                                        FastMath.abs(z) +\n                                                        FastMath.abs(matrixT[im + 1][im + 1]));\n\n            if (lhs < epsilon * rhs) {\n                break;\n            }\n            im--;\n        }\n\n        return im;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "linear", "SchurTransformer.java"], "context_start_lineno": 0, "function_name": "initQRStep", "left_context": "class SchurTransformer {\n    /**\n     * Computes the L1 norm of the (quasi-)triangular matrix T.\n     *\n     * @return the L1 norm of matrix T\n     */\n    private double getNorm() {\n        double norm = 0.0;\n        for (int i = 0; i < matrixT.length; i++) {\n            // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n            for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n                norm += FastMath.abs(matrixT[i][j]);\n            }\n        }\n        return norm;\n    }\n\n    /**\n     * Find the first small sub-diagonal element and returns its index.\n     *\n     * @param startIdx the starting index for the search\n     * @param norm the L1 norm of the matrix\n     * @return the index of the first small sub-diagonal element\n     */\n    private int findSmallSubDiagonalElement(final int startIdx, final double norm) {\n        int l = startIdx;\n        while (l > 0) {\n            double s = FastMath.abs(matrixT[l - 1][l - 1]) + FastMath.abs(matrixT[l][l]);\n            if (s == 0.0) {\n                s = norm;\n            }\n            if (FastMath.abs(matrixT[l][l - 1]) < epsilon * s) {\n                break;\n            }\n            l--;\n        }\n        return l;\n    }\n\n    /**\n     * Compute the shift for the current iteration.\n     *\n     * @param l the index of the small sub-diagonal element\n     * @param idx the current eigenvalue index\n     * @param iteration the current iteration\n     * @param shift holder for shift information\n     */\n    private void computeShift(final int l, final int idx, final int iteration, final ShiftInfo shift) {\n        // Form shift\n        shift.x = matrixT[idx][idx];\n        shift.y = shift.w = 0.0;\n        if (l < idx) {\n            shift.y = matrixT[idx - 1][idx - 1];\n            shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];\n        }\n\n        // Wilkinson's original ad hoc shift\n        if (iteration == 10) {\n            shift.exShift += shift.x;\n            for (int i = 0; i <= idx; i++) {\n                matrixT[i][i] -= shift.x;\n            }\n            final double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\n            shift.x = 0.75 * s;\n            shift.y = 0.75 * s;\n            shift.w = -0.4375 * s * s;\n        }\n\n        // MATLAB's new ad hoc shift\n        if (iteration == 30) {\n            double s = (shift.y - shift.x) / 2.0;\n            s = s * s + shift.w;\n            if (s > 0.0) {\n                s = FastMath.sqrt(s);\n                if (shift.y < shift.x) {\n                    s = -s;\n                }\n                s = shift.x - shift.w / ((shift.y - shift.x) / 2.0 + s);\n                for (int i = 0; i <= idx; i++) {\n                    matrixT[i][i] -= s;\n                }\n                shift.exShift += s;\n                shift.x = shift.y = shift.w = 0.964;\n            }\n        }\n    }\n\n    /**\n     * Initialize the householder vectors for the QR step.\n     *\n     * @param il the index of the small sub-diagonal element\n     * @param iu the current eigenvalue index\n     * @param shift shift information holder\n     * @param hVec the initial houseHolder vector\n     * @return the start index for the QR step\n     */\n    private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec) {", "right_context": "}\n}", "class_name": "SchurTransformer", "return_type": "int", "parameters": [{"type": "int", "name": "il"}, {"type": "int", "name": "iu"}, {"type": "ShiftInfo", "name": "shift"}, {"type": "double[]", "name": "hVec"}]}}
{"prompt": "class BlockRealMatrix extends AbstractRealMatrix implements Serializable {\n    /**\n     * Create a new dense matrix copying entries from raw layout data.\n     * <p>The input array <em>must</em> already be in raw layout.</p>\n     * <p>Calling this constructor is equivalent to call:\n     * <pre>matrix = new BlockRealMatrix(rawData.length, rawData[0].length,\n     *                                   toBlocksLayout(rawData), false);</pre>\n     * </p>\n     *\n     * @param rawData data for new matrix, in raw layout\n     * @throws DimensionMismatchException if the shape of {@code blockData} is\n     * inconsistent with block layout.\n     * @throws NotStrictlyPositiveException if row or column dimension is not\n     * positive.\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     */\n    public BlockRealMatrix(final double[][] rawData)\n        throws DimensionMismatchException, NotStrictlyPositiveException {\n        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n    }\n\n    /**\n     * Create a new dense matrix copying entries from block layout data.\n     * <p>The input array <em>must</em> already be in blocks layout.</p>\n     *\n     * @param rows Number of rows in the new matrix.\n     * @param columns Number of columns in the new matrix.\n     * @param blockData data for new matrix\n     * @param copyArray Whether the input array will be copied or referenced.\n     * @throws DimensionMismatchException if the shape of {@code blockData} is\n     * inconsistent with block layout.\n     * @throws NotStrictlyPositiveException if row or column dimension is not\n     * positive.\n     * @see #createBlocksLayout(int, int)\n     * @see #toBlocksLayout(double[][])\n     * @see #BlockRealMatrix(double[][])\n     */\n    public BlockRealMatrix(final int rows, final int columns,\n                           final double[][] blockData, final boolean copyArray)\n        throws DimensionMismatchException, NotStrictlyPositiveException {\n        super(rows, columns);\n        this.rows = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        if (copyArray) {\n            // allocate storage blocks, taking care of smaller ones at right and bottom\n            blocks = new double[blockRows * blockColumns][];\n        } else {\n            // reference existing array\n            blocks = blockData;\n        }\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n                    throw new DimensionMismatchException(blockData[index].length,\n                                                         iHeight * blockWidth(jBlock));\n                }\n                if (copyArray) {\n                    blocks[index] = blockData[index].clone();\n                }\n            }\n        }\n    }\n\n    /**\n     * Convert a data array from raw layout to blocks layout.\n     * <p>\n     * Raw layout is the straightforward layout where element at row i and\n     * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n     * is the layout used in {@link BlockRealMatrix} instances, where the matrix\n     * is split in square blocks (except at right and bottom side where blocks may\n     * be rectangular to fit matrix size) and each block is stored in a flattened\n     * one-dimensional array.\n     * </p>\n     * <p>\n     * This method creates an array in blocks layout from an input array in raw layout.\n     * It can be used to provide the array argument of the {@link\n     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n     * </p>\n     * @param rawData Data array in raw layout.\n     * @return a new data array containing the same entries but in blocks layout.\n     * @throws DimensionMismatchException if {@code rawData} is not rectangular.\n     * @see #createBlocksLayout(int, int)\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     */\n    public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException {\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }\n\n    /**\n     * Create a data array in blocks layout.\n     * <p>\n     * This method can be used to create the array argument of the {@link\n     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n     * </p>\n     * @param rows Number of rows in the new matrix.\n     * @param columns Number of columns in the new matrix.\n     * @return a new data array in blocks layout.\n     * @see #toBlocksLayout(double[][])\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     */\n    public static double[][] createBlocksLayout(final int rows, final int columns) {", "metadata": {"defects4j_task_id": "082fa1aa803e996b13544902df4784d48909e5cffd6b2e89f5cf097a9170f7cf", "task_id": "apache_commons-math/8", "ground_truth": "\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "linear", "BlockRealMatrix.java"], "context_start_lineno": 0, "function_name": "createBlocksLayout", "left_context": "class BlockRealMatrix extends AbstractRealMatrix implements Serializable {\n    /**\n     * Create a new dense matrix copying entries from raw layout data.\n     * <p>The input array <em>must</em> already be in raw layout.</p>\n     * <p>Calling this constructor is equivalent to call:\n     * <pre>matrix = new BlockRealMatrix(rawData.length, rawData[0].length,\n     *                                   toBlocksLayout(rawData), false);</pre>\n     * </p>\n     *\n     * @param rawData data for new matrix, in raw layout\n     * @throws DimensionMismatchException if the shape of {@code blockData} is\n     * inconsistent with block layout.\n     * @throws NotStrictlyPositiveException if row or column dimension is not\n     * positive.\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     */\n    public BlockRealMatrix(final double[][] rawData)\n        throws DimensionMismatchException, NotStrictlyPositiveException {\n        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n    }\n\n    /**\n     * Create a new dense matrix copying entries from block layout data.\n     * <p>The input array <em>must</em> already be in blocks layout.</p>\n     *\n     * @param rows Number of rows in the new matrix.\n     * @param columns Number of columns in the new matrix.\n     * @param blockData data for new matrix\n     * @param copyArray Whether the input array will be copied or referenced.\n     * @throws DimensionMismatchException if the shape of {@code blockData} is\n     * inconsistent with block layout.\n     * @throws NotStrictlyPositiveException if row or column dimension is not\n     * positive.\n     * @see #createBlocksLayout(int, int)\n     * @see #toBlocksLayout(double[][])\n     * @see #BlockRealMatrix(double[][])\n     */\n    public BlockRealMatrix(final int rows, final int columns,\n                           final double[][] blockData, final boolean copyArray)\n        throws DimensionMismatchException, NotStrictlyPositiveException {\n        super(rows, columns);\n        this.rows = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        if (copyArray) {\n            // allocate storage blocks, taking care of smaller ones at right and bottom\n            blocks = new double[blockRows * blockColumns][];\n        } else {\n            // reference existing array\n            blocks = blockData;\n        }\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n                    throw new DimensionMismatchException(blockData[index].length,\n                                                         iHeight * blockWidth(jBlock));\n                }\n                if (copyArray) {\n                    blocks[index] = blockData[index].clone();\n                }\n            }\n        }\n    }\n\n    /**\n     * Convert a data array from raw layout to blocks layout.\n     * <p>\n     * Raw layout is the straightforward layout where element at row i and\n     * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n     * is the layout used in {@link BlockRealMatrix} instances, where the matrix\n     * is split in square blocks (except at right and bottom side where blocks may\n     * be rectangular to fit matrix size) and each block is stored in a flattened\n     * one-dimensional array.\n     * </p>\n     * <p>\n     * This method creates an array in blocks layout from an input array in raw layout.\n     * It can be used to provide the array argument of the {@link\n     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n     * </p>\n     * @param rawData Data array in raw layout.\n     * @return a new data array containing the same entries but in blocks layout.\n     * @throws DimensionMismatchException if {@code rawData} is not rectangular.\n     * @see #createBlocksLayout(int, int)\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     */\n    public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException {\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }\n\n    /**\n     * Create a data array in blocks layout.\n     * <p>\n     * This method can be used to create the array argument of the {@link\n     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n     * </p>\n     * @param rows Number of rows in the new matrix.\n     * @param columns Number of columns in the new matrix.\n     * @return a new data array in blocks layout.\n     * @see #toBlocksLayout(double[][])\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     */\n    public static double[][] createBlocksLayout(final int rows, final int columns) {", "right_context": "}\n}", "class_name": "BlockRealMatrix", "return_type": "double[][]", "parameters": [{"type": "int", "name": "rows"}, {"type": "int", "name": "columns"}]}}
{"prompt": "class MultidimensionalCounter implements Iterable<Integer> {\n    /**\n     * Number of dimensions.\n     */\n    private final int dimension;\n    /**\n     * Offset for each dimension.\n     */\n    private final int[] uniCounterOffset;\n    /**\n     * Counter sizes.\n     */\n    private final int[] size;\n    /**\n     * Total number of (one-dimensional) slots.\n     */\n    private final int totalSize;\n    /**\n     * Index of last dimension.\n     */\n    private final int last;\n\n    /**\n     * Perform iteration over the multidimensional counter.\n     */\n    public class Iterator implements java.util.Iterator<Integer> {\n        /**\n         * Multidimensional counter.\n         */\n        private final int[] counter = new int[dimension];\n        /**\n         * Unidimensional counter.\n         */\n        private int count = -1;\n\n        /**\n         * Create an iterator\n         * @see #iterator()\n         */\n        Iterator() {\n            counter[last] = -1;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean hasNext() {\n            for (int i = 0; i < dimension; i++) {\n                if (counter[i] != size[i] - 1) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * @return the unidimensional count after the counter has been\n         * incremented by {@code 1}.\n         */\n        public Integer next() {\n            for (int i = last; i >= 0; i--) {\n                if (counter[i] == size[i] - 1) {\n                    counter[i] = 0;\n                } else {\n                    ++counter[i];\n                    break;\n                }\n            }\n\n            return ++count;\n        }\n\n        /**\n         * Get the current unidimensional counter slot.\n         *\n         * @return the index within the unidimensionl counter.\n         */\n        public int getCount() {\n            return count;\n        }\n        /**\n         * Get the current multidimensional counter slots.\n         *\n         * @return the indices within the multidimensional counter.\n         */\n        public int[] getCounts() {\n            return MathArrays.copyOf(counter);\n        }\n\n        /**\n         * Get the current count in the selected dimension.\n         *\n         * @param dim Dimension index.\n         * @return the count at the corresponding index for the current state\n         * of the iterator.\n         * @throws IndexOutOfBoundsException if {@code index} is not in the\n         * correct interval (as defined by the length of the argument in the\n         * {@link MultidimensionalCounter#MultidimensionalCounter(int[])\n         * constructor of the enclosing class}).\n         */\n        public int getCount(int dim) {\n            return counter[dim];\n        }\n\n        /**\n         * @throws UnsupportedOperationException\n         */\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Create a counter.\n     *\n     * @param size Counter sizes (number of slots in each dimension).\n     * @throws NotStrictlyPositiveException if one of the sizes is\n     * negative or zero.\n     */\n    public MultidimensionalCounter(int ... size) throws NotStrictlyPositiveException {\n        dimension = size.length;\n        this.size = MathArrays.copyOf(size);\n\n        uniCounterOffset = new int[dimension];\n\n        last = dimension - 1;\n        int tS = size[last];\n        for (int i = 0; i < last; i++) {\n            int count = 1;\n            for (int j = i + 1; j < dimension; j++) {\n                count *= size[j];\n            }\n            uniCounterOffset[i] = count;\n            tS *= size[i];\n        }\n        uniCounterOffset[last] = 0;\n\n        if (tS <= 0) {\n            throw new NotStrictlyPositiveException(tS);\n        }\n\n        totalSize = tS;\n    }\n\n    /**\n     * Create an iterator over this counter.\n     *\n     * @return the iterator.\n     */\n    public Iterator iterator() {\n        return new Iterator();\n    }\n\n    /**\n     * Get the number of dimensions of the multidimensional counter.\n     *\n     * @return the number of dimensions.\n     */\n    public int getDimension() {\n        return dimension;\n    }\n\n    /**\n     * Convert to multidimensional counter.\n     *\n     * @param index Index in unidimensional counter.\n     * @return the multidimensional counts.\n     * @throws OutOfRangeException if {@code index} is not between\n     * {@code 0} and the value returned by {@link #getSize()} (excluded).\n     */\n    public int[] getCounts(int index) throws OutOfRangeException {", "metadata": {"defects4j_task_id": "7f93ef5550d3596b81faa6401aeec438430a14ffc6ecd8297c8583dad65e3ceb", "task_id": "apache_commons-math/105", "ground_truth": "\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n\n        int count = 0;\n        for (int i = 0; i < last; i++) {\n            int idx = 0;\n            final int offset = uniCounterOffset[i];\n            while (count <= index) {\n                count += offset;\n                ++idx;\n            }\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n\n        indices[last] = index - count;\n\n        return indices;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "util", "MultidimensionalCounter.java"], "context_start_lineno": 0, "function_name": "getCounts", "left_context": "class MultidimensionalCounter implements Iterable<Integer> {\n    /**\n     * Number of dimensions.\n     */\n    private final int dimension;\n    /**\n     * Offset for each dimension.\n     */\n    private final int[] uniCounterOffset;\n    /**\n     * Counter sizes.\n     */\n    private final int[] size;\n    /**\n     * Total number of (one-dimensional) slots.\n     */\n    private final int totalSize;\n    /**\n     * Index of last dimension.\n     */\n    private final int last;\n\n    /**\n     * Perform iteration over the multidimensional counter.\n     */\n    public class Iterator implements java.util.Iterator<Integer> {\n        /**\n         * Multidimensional counter.\n         */\n        private final int[] counter = new int[dimension];\n        /**\n         * Unidimensional counter.\n         */\n        private int count = -1;\n\n        /**\n         * Create an iterator\n         * @see #iterator()\n         */\n        Iterator() {\n            counter[last] = -1;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean hasNext() {\n            for (int i = 0; i < dimension; i++) {\n                if (counter[i] != size[i] - 1) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * @return the unidimensional count after the counter has been\n         * incremented by {@code 1}.\n         */\n        public Integer next() {\n            for (int i = last; i >= 0; i--) {\n                if (counter[i] == size[i] - 1) {\n                    counter[i] = 0;\n                } else {\n                    ++counter[i];\n                    break;\n                }\n            }\n\n            return ++count;\n        }\n\n        /**\n         * Get the current unidimensional counter slot.\n         *\n         * @return the index within the unidimensionl counter.\n         */\n        public int getCount() {\n            return count;\n        }\n        /**\n         * Get the current multidimensional counter slots.\n         *\n         * @return the indices within the multidimensional counter.\n         */\n        public int[] getCounts() {\n            return MathArrays.copyOf(counter);\n        }\n\n        /**\n         * Get the current count in the selected dimension.\n         *\n         * @param dim Dimension index.\n         * @return the count at the corresponding index for the current state\n         * of the iterator.\n         * @throws IndexOutOfBoundsException if {@code index} is not in the\n         * correct interval (as defined by the length of the argument in the\n         * {@link MultidimensionalCounter#MultidimensionalCounter(int[])\n         * constructor of the enclosing class}).\n         */\n        public int getCount(int dim) {\n            return counter[dim];\n        }\n\n        /**\n         * @throws UnsupportedOperationException\n         */\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Create a counter.\n     *\n     * @param size Counter sizes (number of slots in each dimension).\n     * @throws NotStrictlyPositiveException if one of the sizes is\n     * negative or zero.\n     */\n    public MultidimensionalCounter(int ... size) throws NotStrictlyPositiveException {\n        dimension = size.length;\n        this.size = MathArrays.copyOf(size);\n\n        uniCounterOffset = new int[dimension];\n\n        last = dimension - 1;\n        int tS = size[last];\n        for (int i = 0; i < last; i++) {\n            int count = 1;\n            for (int j = i + 1; j < dimension; j++) {\n                count *= size[j];\n            }\n            uniCounterOffset[i] = count;\n            tS *= size[i];\n        }\n        uniCounterOffset[last] = 0;\n\n        if (tS <= 0) {\n            throw new NotStrictlyPositiveException(tS);\n        }\n\n        totalSize = tS;\n    }\n\n    /**\n     * Create an iterator over this counter.\n     *\n     * @return the iterator.\n     */\n    public Iterator iterator() {\n        return new Iterator();\n    }\n\n    /**\n     * Get the number of dimensions of the multidimensional counter.\n     *\n     * @return the number of dimensions.\n     */\n    public int getDimension() {\n        return dimension;\n    }\n\n    /**\n     * Convert to multidimensional counter.\n     *\n     * @param index Index in unidimensional counter.\n     * @return the multidimensional counts.\n     * @throws OutOfRangeException if {@code index} is not between\n     * {@code 0} and the value returned by {@link #getSize()} (excluded).\n     */\n    public int[] getCounts(int index) throws OutOfRangeException {", "right_context": "}\n\n    /**\n     * Convert to unidimensional counter.\n     *\n     * @param c Indices in multidimensional counter.\n     * @return the index within the unidimensionl counter.\n     * @throws DimensionMismatchException if the size of {@code c}\n     * does not match the size of the array given in the constructor.\n     * @throws OutOfRangeException if a value of {@code c} is not in\n     * the range of the corresponding dimension, as defined in the\n     * {@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.\n     */\n    public int getCount(int ... c)\n        throws OutOfRangeException, DimensionMismatchException {\n        if (c.length != dimension) {\n            throw new DimensionMismatchException(c.length, dimension);\n        }\n        int count = 0;\n        for (int i = 0; i < dimension; i++) {\n            final int index = c[i];\n            if (index < 0 ||\n                index >= size[i]) {\n                throw new OutOfRangeException(index, 0, size[i] - 1);\n            }\n            count += uniCounterOffset[i] * c[i];\n        }\n        return count + c[last];\n    }\n\n    /**\n     * Get the total number of elements.\n     *\n     * @return the total size of the unidimensional counter.\n     */\n    public int getSize() {\n        return totalSize;\n    }\n    /**\n     * Get the number of multidimensional counter slots in each dimension.\n     *\n     * @return the sizes of the multidimensional counter in each dimension.\n     */\n    public int[] getSizes() {\n        return MathArrays.copyOf(size);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < dimension; i++) {\n            sb.append(\"[\").append(getCount(i)).append(\"]\");\n        }\n        return sb.toString();\n    }\n}", "class_name": "MultidimensionalCounter", "return_type": "int[]", "parameters": [{"type": "int", "name": "index"}]}}
{"prompt": "class MathArrays {\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link Precision#equals(float,float)}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension\n     * and equal elements.\n     */\n    public static boolean equals(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension and\n     * equal elements\n     * @since 2.2\n     */\n    public static boolean equalsIncludingNaN(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} iff both arguments are {@code null} or have same\n     * dimensions and all their elements are equal as defined by\n     * {@link Precision#equals(double,double)}.\n     *\n     * @param x First array.\n     * @param y Second array.\n     * @return {@code true} if the values are both {@code null} or have same\n     * dimension and equal elements.\n     */\n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} iff both arguments are {@code null} or have same\n     * dimensions and all their elements are equal as defined by\n     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n     *\n     * @param x First array.\n     * @param y Second array.\n     * @return {@code true} if the values are both {@code null} or have same\n     * dimension and equal elements.\n     * @since 2.2\n     */\n    public static boolean equalsIncludingNaN(double[] x, double[] y) {", "metadata": {"defects4j_task_id": "1660636b038f8af42b927bad97a92cb62471f3ed6a246f9c273b842008cd12fa", "task_id": "apache_commons-math/23", "ground_truth": "\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "util", "MathArrays.java"], "context_start_lineno": 0, "function_name": "equalsIncludingNaN", "left_context": "class MathArrays {\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link Precision#equals(float,float)}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension\n     * and equal elements.\n     */\n    public static boolean equals(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension and\n     * equal elements\n     * @since 2.2\n     */\n    public static boolean equalsIncludingNaN(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} iff both arguments are {@code null} or have same\n     * dimensions and all their elements are equal as defined by\n     * {@link Precision#equals(double,double)}.\n     *\n     * @param x First array.\n     * @param y Second array.\n     * @return {@code true} if the values are both {@code null} or have same\n     * dimension and equal elements.\n     */\n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} iff both arguments are {@code null} or have same\n     * dimensions and all their elements are equal as defined by\n     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n     *\n     * @param x First array.\n     * @param y Second array.\n     * @return {@code true} if the values are both {@code null} or have same\n     * dimension and equal elements.\n     * @since 2.2\n     */\n    public static boolean equalsIncludingNaN(double[] x, double[] y) {", "right_context": "}\n}", "class_name": "MathArrays", "return_type": "boolean", "parameters": [{"type": "double[]", "name": "x"}, {"type": "double[]", "name": "y"}]}}
{"prompt": "class MathArrays {\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link Precision#equals(float,float)}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension\n     * and equal elements.\n     */\n    public static boolean equals(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension and\n     * equal elements\n     * @since 2.2\n     */\n    public static boolean equalsIncludingNaN(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} iff both arguments are {@code null} or have same\n     * dimensions and all their elements are equal as defined by\n     * {@link Precision#equals(double,double)}.\n     *\n     * @param x First array.\n     * @param y Second array.\n     * @return {@code true} if the values are both {@code null} or have same\n     * dimension and equal elements.\n     */\n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} iff both arguments are {@code null} or have same\n     * dimensions and all their elements are equal as defined by\n     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n     *\n     * @param x First array.\n     * @param y Second array.\n     * @return {@code true} if the values are both {@code null} or have same\n     * dimension and equal elements.\n     * @since 2.2\n     */\n    public static boolean equalsIncludingNaN(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n     /**\n      * Normalizes an array to make it sum to a specified value.\n      * Returns the result of the transformation <pre>\n      *    x |-> x * normalizedSum / sum\n      * </pre>\n      * applied to each non-NaN element x of the input array, where sum is the\n      * sum of the non-NaN entries in the input array.</p>\n      *\n      * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite\n      * or NaN and ArithmeticException if the input array contains any infinite elements\n      * or sums to 0.</p>\n      *\n      * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>\n      *\n      * @param values Input array to be normalized\n      * @param normalizedSum Target sum for the normalized array\n      * @return the normalized array.\n      * @throws MathArithmeticException if the input array contains infinite\n      * elements or sums to zero.\n      * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.\n      * @since 2.1\n      */\n     public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException {", "metadata": {"defects4j_task_id": "a45562fdf961ec408daf2fe0a5b1cc1fa77734059490bfd63df33aaa5b9df305", "task_id": "apache_commons-math/136", "ground_truth": "\n         if (Double.isInfinite(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "util", "MathArrays.java"], "context_start_lineno": 0, "function_name": "normalizeArray", "left_context": "class MathArrays {\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link Precision#equals(float,float)}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension\n     * and equal elements.\n     */\n    public static boolean equals(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension and\n     * equal elements\n     * @since 2.2\n     */\n    public static boolean equalsIncludingNaN(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} iff both arguments are {@code null} or have same\n     * dimensions and all their elements are equal as defined by\n     * {@link Precision#equals(double,double)}.\n     *\n     * @param x First array.\n     * @param y Second array.\n     * @return {@code true} if the values are both {@code null} or have same\n     * dimension and equal elements.\n     */\n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} iff both arguments are {@code null} or have same\n     * dimensions and all their elements are equal as defined by\n     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n     *\n     * @param x First array.\n     * @param y Second array.\n     * @return {@code true} if the values are both {@code null} or have same\n     * dimension and equal elements.\n     * @since 2.2\n     */\n    public static boolean equalsIncludingNaN(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n     /**\n      * Normalizes an array to make it sum to a specified value.\n      * Returns the result of the transformation <pre>\n      *    x |-> x * normalizedSum / sum\n      * </pre>\n      * applied to each non-NaN element x of the input array, where sum is the\n      * sum of the non-NaN entries in the input array.</p>\n      *\n      * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite\n      * or NaN and ArithmeticException if the input array contains any infinite elements\n      * or sums to 0.</p>\n      *\n      * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>\n      *\n      * @param values Input array to be normalized\n      * @param normalizedSum Target sum for the normalized array\n      * @return the normalized array.\n      * @throws MathArithmeticException if the input array contains infinite\n      * elements or sums to zero.\n      * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.\n      * @since 2.1\n      */\n     public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException {", "right_context": "}\n}", "class_name": "MathArrays", "return_type": "double[]", "parameters": [{"type": "double[]", "name": "values"}, {"type": "double", "name": "normalizedSum"}]}}
{"prompt": "class DfpMath {\n\n    /**\n     * Private Constructor.\n     */\n    private DfpMath() {\n    }\n\n    /** Breaks a string representation up into two dfp's.\n     * <p>The two dfp are such that the sum of them is equivalent\n     * to the input string, but has higher precision than using a\n     * single dfp. This is useful for improving accuracy of\n     * exponentiation and critical multiplies.\n     * @param field field to which the Dfp must belong\n     * @param a string representation to split\n     * @return an array of two {@link Dfp} which sum is a\n     */\n    protected static Dfp[] split(final DfpField field, final String a) {\n        Dfp result[] = new Dfp[2];\n        char[] buf;\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        buf = new char[a.length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (field.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }\n\n    /** Splits a {@link Dfp} into 2 {@link Dfp}'s such that their sum is equal to the input {@link Dfp}.\n     * @param a number to split\n     * @return two elements array containing the split number\n     */\n    protected static Dfp[] split(final Dfp a) {", "metadata": {"defects4j_task_id": "13eb8d64c155368eab718348e379583e7660a40135a4181d1664d14d26549d14", "task_id": "apache_commons-math/19", "ground_truth": "\n        final Dfp[] result = new Dfp[2];\n        final Dfp shift = a.multiply(a.power10K(a.getRadixDigits() / 2));\n        result[0] = a.add(shift).subtract(shift);\n        result[1] = a.subtract(result[0]);\n        return result;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "dfp", "DfpMath.java"], "context_start_lineno": 0, "function_name": "split", "left_context": "class DfpMath {\n\n    /**\n     * Private Constructor.\n     */\n    private DfpMath() {\n    }\n\n    /** Breaks a string representation up into two dfp's.\n     * <p>The two dfp are such that the sum of them is equivalent\n     * to the input string, but has higher precision than using a\n     * single dfp. This is useful for improving accuracy of\n     * exponentiation and critical multiplies.\n     * @param field field to which the Dfp must belong\n     * @param a string representation to split\n     * @return an array of two {@link Dfp} which sum is a\n     */\n    protected static Dfp[] split(final DfpField field, final String a) {\n        Dfp result[] = new Dfp[2];\n        char[] buf;\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        buf = new char[a.length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (field.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = field.newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = field.newDfp(new String(buf));\n\n        return result;\n    }\n\n    /** Splits a {@link Dfp} into 2 {@link Dfp}'s such that their sum is equal to the input {@link Dfp}.\n     * @param a number to split\n     * @return two elements array containing the split number\n     */\n    protected static Dfp[] split(final Dfp a) {", "right_context": "}\n\n}", "class_name": "DfpMath", "return_type": "Dfp[]", "parameters": [{"type": "Dfp", "name": "a"}]}}
{"prompt": "class DfpMath {\n\n    /** Multiply two numbers that are split in to two pieces that are\n     *  meant to be added together.\n     *  Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1\n     *  Store the first term in result0, the rest in result1\n     *  @param a first factor of the multiplication, in split form\n     *  @param b second factor of the multiplication, in split form\n     *  @return a &times; b, in split form\n     */\n    protected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b) {\n        final Dfp[] result = new Dfp[2];\n\n        result[1] = a[0].getZero();\n        result[0] = a[0].multiply(b[0]);\n\n        /* If result[0] is infinite or zero, don't compute result[1].\n         * Attempting to do so may produce NaNs.\n         */\n\n        if (result[0].classify() == Dfp.INFINITE || result[0].equals(result[1])) {\n            return result;\n        }\n\n        result[1] = a[0].multiply(b[1]).add(a[1].multiply(b[0])).add(a[1].multiply(b[1]));\n\n        return result;\n    }\n\n    /** Divide two numbers that are split in to two pieces that are meant to be added together.\n     * Inverse of split multiply above:\n     *  (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c**2+cd) )\n     *  @param a dividend, in split form\n     *  @param b divisor, in split form\n     *  @return a / b, in split form\n     */\n    protected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b) {\n        final Dfp[] result;\n\n        result = new Dfp[2];\n\n        result[0] = a[0].divide(b[0]);\n        result[1] = a[1].multiply(b[0]).subtract(a[0].multiply(b[1]));\n        result[1] = result[1].divide(b[0].multiply(b[0]).add(b[0].multiply(b[1])));\n\n        return result;\n    }\n\n    /** Raise a split base to the a power.\n     * @param base number to raise\n     * @param a power\n     * @return base<sup>a</sup>\n     */\n    protected static Dfp splitPow(final Dfp[] base, int a) {\n        boolean invert = false;\n\n        Dfp[] r = new Dfp[2];\n\n        Dfp[] result = new Dfp[2];\n        result[0] = base[0].getOne();\n        result[1] = base[0].getZero();\n\n        if (a == 0) {\n            // Special case a = 0\n            return result[0].add(result[1]);\n        }\n\n        if (a < 0) {\n            // If a is less than zero\n            invert = true;\n            a = -a;\n        }\n\n        // Exponentiate by successive squaring\n        do {\n            r[0] = new Dfp(base[0]);\n            r[1] = new Dfp(base[1]);\n            int trial = 1;\n\n            int prevtrial;\n            while (true) {\n                prevtrial = trial;\n                trial = trial * 2;\n                if (trial > a) {\n                    break;\n                }\n                r = splitMult(r, r);\n            }\n\n            trial = prevtrial;\n\n            a -= trial;\n            result = splitMult(result, r);\n\n        } while (a >= 1);\n\n        result[0] = result[0].add(result[1]);\n\n        if (invert) {\n            result[0] = base[0].getOne().divide(result[0]);\n        }\n\n        return result[0];\n\n    }\n\n    /** Raises base to the power a by successive squaring.\n     * @param base number to raise\n     * @param a power\n     * @return base<sup>a</sup>\n     */\n    public static Dfp pow(Dfp base, int a)\n    {\n        boolean invert = false;\n\n        Dfp result = base.getOne();\n\n        if (a == 0) {\n            // Special case\n            return result;\n        }\n\n        if (a < 0) {\n            invert = true;\n            a = -a;\n        }\n\n        // Exponentiate by successive squaring\n        do {\n            Dfp r = new Dfp(base);\n            Dfp prevr;\n            int trial = 1;\n            int prevtrial;\n\n            do {\n                prevr = new Dfp(r);\n                prevtrial = trial;\n                r = r.multiply(r);\n                trial = trial * 2;\n            } while (a>trial);\n\n            r = prevr;\n            trial = prevtrial;\n\n            a = a - trial;\n            result = result.multiply(r);\n\n        } while (a >= 1);\n\n        if (invert) {\n            result = base.getOne().divide(result);\n        }\n\n        return base.newInstance(result);\n\n    }\n\n    /** Computes e to the given power.\n     * a is broken into two parts, such that a = n+m  where n is an integer.\n     * We use pow() to compute e<sup>n</sup> and a Taylor series to compute\n     * e<sup>m</sup>.  We return e*<sup>n</sup> &times; e<sup>m</sup>\n     * @param a power at which e should be raised\n     * @return e<sup>a</sup>\n     */\n    public static Dfp exp(final Dfp a) {\n\n        final Dfp inta = a.rint();\n        final Dfp fraca = a.subtract(inta);\n\n        final int ia = inta.intValue();\n        if (ia > 2147483646) {\n            // return +Infinity\n            return a.newInstance((byte)1, Dfp.INFINITE);\n        }\n\n        if (ia < -2147483646) {\n            // return 0;\n            return a.newInstance();\n        }\n\n        final Dfp einta = splitPow(a.getField().getESplit(), ia);\n        final Dfp efraca = expInternal(fraca);\n\n        return einta.multiply(efraca);\n    }\n\n    /** Computes e to the given power.\n     * Where -1 < a < 1.  Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...\n     * @param a power at which e should be raised\n     * @return e<sup>a</sup>\n     */\n    protected static Dfp expInternal(final Dfp a) {", "metadata": {"defects4j_task_id": "e7649fa731424ab18c2e7b660687cc82cf806d5b3e7d35d270bcb2767e3be47d", "task_id": "apache_commons-math/189", "ground_truth": "\n        Dfp y = a.getOne();\n        Dfp x = a.getOne();\n        Dfp fact = a.getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 1; i < 90; i++) {\n            x = x.multiply(a);\n            fact = fact.divide(i);\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "dfp", "DfpMath.java"], "context_start_lineno": 0, "function_name": "expInternal", "left_context": "class DfpMath {\n\n    /** Multiply two numbers that are split in to two pieces that are\n     *  meant to be added together.\n     *  Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1\n     *  Store the first term in result0, the rest in result1\n     *  @param a first factor of the multiplication, in split form\n     *  @param b second factor of the multiplication, in split form\n     *  @return a &times; b, in split form\n     */\n    protected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b) {\n        final Dfp[] result = new Dfp[2];\n\n        result[1] = a[0].getZero();\n        result[0] = a[0].multiply(b[0]);\n\n        /* If result[0] is infinite or zero, don't compute result[1].\n         * Attempting to do so may produce NaNs.\n         */\n\n        if (result[0].classify() == Dfp.INFINITE || result[0].equals(result[1])) {\n            return result;\n        }\n\n        result[1] = a[0].multiply(b[1]).add(a[1].multiply(b[0])).add(a[1].multiply(b[1]));\n\n        return result;\n    }\n\n    /** Divide two numbers that are split in to two pieces that are meant to be added together.\n     * Inverse of split multiply above:\n     *  (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c**2+cd) )\n     *  @param a dividend, in split form\n     *  @param b divisor, in split form\n     *  @return a / b, in split form\n     */\n    protected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b) {\n        final Dfp[] result;\n\n        result = new Dfp[2];\n\n        result[0] = a[0].divide(b[0]);\n        result[1] = a[1].multiply(b[0]).subtract(a[0].multiply(b[1]));\n        result[1] = result[1].divide(b[0].multiply(b[0]).add(b[0].multiply(b[1])));\n\n        return result;\n    }\n\n    /** Raise a split base to the a power.\n     * @param base number to raise\n     * @param a power\n     * @return base<sup>a</sup>\n     */\n    protected static Dfp splitPow(final Dfp[] base, int a) {\n        boolean invert = false;\n\n        Dfp[] r = new Dfp[2];\n\n        Dfp[] result = new Dfp[2];\n        result[0] = base[0].getOne();\n        result[1] = base[0].getZero();\n\n        if (a == 0) {\n            // Special case a = 0\n            return result[0].add(result[1]);\n        }\n\n        if (a < 0) {\n            // If a is less than zero\n            invert = true;\n            a = -a;\n        }\n\n        // Exponentiate by successive squaring\n        do {\n            r[0] = new Dfp(base[0]);\n            r[1] = new Dfp(base[1]);\n            int trial = 1;\n\n            int prevtrial;\n            while (true) {\n                prevtrial = trial;\n                trial = trial * 2;\n                if (trial > a) {\n                    break;\n                }\n                r = splitMult(r, r);\n            }\n\n            trial = prevtrial;\n\n            a -= trial;\n            result = splitMult(result, r);\n\n        } while (a >= 1);\n\n        result[0] = result[0].add(result[1]);\n\n        if (invert) {\n            result[0] = base[0].getOne().divide(result[0]);\n        }\n\n        return result[0];\n\n    }\n\n    /** Raises base to the power a by successive squaring.\n     * @param base number to raise\n     * @param a power\n     * @return base<sup>a</sup>\n     */\n    public static Dfp pow(Dfp base, int a)\n    {\n        boolean invert = false;\n\n        Dfp result = base.getOne();\n\n        if (a == 0) {\n            // Special case\n            return result;\n        }\n\n        if (a < 0) {\n            invert = true;\n            a = -a;\n        }\n\n        // Exponentiate by successive squaring\n        do {\n            Dfp r = new Dfp(base);\n            Dfp prevr;\n            int trial = 1;\n            int prevtrial;\n\n            do {\n                prevr = new Dfp(r);\n                prevtrial = trial;\n                r = r.multiply(r);\n                trial = trial * 2;\n            } while (a>trial);\n\n            r = prevr;\n            trial = prevtrial;\n\n            a = a - trial;\n            result = result.multiply(r);\n\n        } while (a >= 1);\n\n        if (invert) {\n            result = base.getOne().divide(result);\n        }\n\n        return base.newInstance(result);\n\n    }\n\n    /** Computes e to the given power.\n     * a is broken into two parts, such that a = n+m  where n is an integer.\n     * We use pow() to compute e<sup>n</sup> and a Taylor series to compute\n     * e<sup>m</sup>.  We return e*<sup>n</sup> &times; e<sup>m</sup>\n     * @param a power at which e should be raised\n     * @return e<sup>a</sup>\n     */\n    public static Dfp exp(final Dfp a) {\n\n        final Dfp inta = a.rint();\n        final Dfp fraca = a.subtract(inta);\n\n        final int ia = inta.intValue();\n        if (ia > 2147483646) {\n            // return +Infinity\n            return a.newInstance((byte)1, Dfp.INFINITE);\n        }\n\n        if (ia < -2147483646) {\n            // return 0;\n            return a.newInstance();\n        }\n\n        final Dfp einta = splitPow(a.getField().getESplit(), ia);\n        final Dfp efraca = expInternal(fraca);\n\n        return einta.multiply(efraca);\n    }\n\n    /** Computes e to the given power.\n     * Where -1 < a < 1.  Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...\n     * @param a power at which e should be raised\n     * @return e<sup>a</sup>\n     */\n    protected static Dfp expInternal(final Dfp a) {", "right_context": "}\n\n}", "class_name": "DfpMath", "return_type": "Dfp", "parameters": [{"type": "Dfp", "name": "a"}]}}
{"prompt": "class DfpMath {\n\n    /** Returns the natural logarithm of a.\n     * a is first split into three parts such that  a = (10000^h)(2^j)k.\n     * ln(a) is computed by ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k)\n     * k is in the range 2/3 < k <4/3 and is passed on to a series expansion.\n     * @param a number from which logarithm is requested\n     * @return log(a)\n     */\n    public static Dfp log(Dfp a) {\n        int lr;\n        Dfp x;\n        int ix;\n        int p2 = 0;\n\n        // Check the arguments somewhat here\n        if (a.equals(a.getZero()) || a.lessThan(a.getZero()) || a.isNaN()) {\n            // negative, zero or NaN\n            a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return a.dotrap(DfpField.FLAG_INVALID, \"ln\", a, a.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (a.classify() == Dfp.INFINITE) {\n            return a;\n        }\n\n        x = new Dfp(a);\n        lr = x.log10K();\n\n        x = x.divide(pow(a.newInstance(10000), lr));  /* This puts x in the range 0-10000 */\n        ix = x.floor().intValue();\n\n        while (ix > 2) {\n            ix >>= 1;\n            p2++;\n        }\n\n\n        Dfp[] spx = split(x);\n        Dfp[] spy = new Dfp[2];\n        spy[0] = pow(a.getTwo(), p2);          // use spy[0] temporarily as a divisor\n        spx[0] = spx[0].divide(spy[0]);\n        spx[1] = spx[1].divide(spy[0]);\n\n        spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n        while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n            spx[0] = spx[0].divide(2);\n            spx[1] = spx[1].divide(2);\n            p2++;\n        }\n\n        // X is now in the range of 2/3 < x < 4/3\n        Dfp[] spz = logInternal(spx);\n\n        spx[0] = a.newInstance(new StringBuilder().append(p2+4*lr).toString());\n        spx[1] = a.getZero();\n        spy = splitMult(a.getField().getLn2Split(), spx);\n\n        spz[0] = spz[0].add(spy[0]);\n        spz[1] = spz[1].add(spy[1]);\n\n        spx[0] = a.newInstance(new StringBuilder().append(4*lr).toString());\n        spx[1] = a.getZero();\n        spy = splitMult(a.getField().getLn5Split(), spx);\n\n        spz[0] = spz[0].add(spy[0]);\n        spz[1] = spz[1].add(spy[1]);\n\n        return a.newInstance(spz[0].add(spz[1]));\n\n    }\n\n    /** Computes the natural log of a number between 0 and 2.\n     *  Let f(x) = ln(x),\n     *\n     *  We know that f'(x) = 1/x, thus from Taylor's theorum we have:\n     *\n     *           -----          n+1         n\n     *  f(x) =   \\           (-1)    (x - 1)\n     *           /          ----------------    for 1 <= n <= infinity\n     *           -----             n\n     *\n     *  or\n     *                       2        3       4\n     *                   (x-1)   (x-1)    (x-1)\n     *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n     *                     2       3        4\n     *\n     *  alternatively,\n     *\n     *                  2    3   4\n     *                 x    x   x\n     *  ln(x+1) =  x - -  + - - - + ...\n     *                 2    3   4\n     *\n     *  This series can be used to compute ln(x), but it converges too slowly.\n     *\n     *  If we substitute -x for x above, we get\n     *\n     *                   2    3    4\n     *                  x    x    x\n     *  ln(1-x) =  -x - -  - -  - - + ...\n     *                  2    3    4\n     *\n     *  Note that all terms are now negative.  Because the even powered ones\n     *  absorbed the sign.  Now, subtract the series above from the previous\n     *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n     *  only the odd ones\n     *\n     *                             3     5      7\n     *                           2x    2x     2x\n     *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n     *                            3     5      7\n     *\n     *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n     *\n     *                                3        5        7\n     *      x+1           /          x        x        x          \\\n     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n     *      x-1           \\          3        5        7          /\n     *\n     *  But now we want to find ln(a), so we need to find the value of x\n     *  such that a = (x+1)/(x-1).   This is easily solved to find that\n     *  x = (a-1)/(a+1).\n     * @param a number from which logarithm is requested, in split form\n     * @return log(a)\n     */\n    protected static Dfp[] logInternal(final Dfp a[]) {", "metadata": {"defects4j_task_id": "34c2696aadd1ae910d7946a4f59a093abfa412dbe8e07a1612e59a1acb2c5879", "task_id": "apache_commons-math/46", "ground_truth": "\n\n        /* Now we want to compute x = (a-1)/(a+1) but this is prone to\n         * loss of precision.  So instead, compute x = (a/4 - 1/4) / (a/4 + 1/4)\n         */\n        Dfp t = a[0].divide(4).add(a[1].divide(4));\n        Dfp x = t.add(a[0].newInstance(\"-0.25\")).divide(t.add(a[0].newInstance(\"0.25\")));\n\n        Dfp y = new Dfp(x);\n        Dfp num = new Dfp(x);\n        Dfp py = new Dfp(y);\n        int den = 1;\n        for (int i = 0; i < 10000; i++) {\n            num = num.multiply(x);\n            num = num.multiply(x);\n            den = den + 2;\n            t = num.divide(den);\n            y = y.add(t);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        y = y.multiply(a[0].getTwo());\n\n        return split(y);\n\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "dfp", "DfpMath.java"], "context_start_lineno": 0, "function_name": "logInternal", "left_context": "class DfpMath {\n\n    /** Returns the natural logarithm of a.\n     * a is first split into three parts such that  a = (10000^h)(2^j)k.\n     * ln(a) is computed by ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k)\n     * k is in the range 2/3 < k <4/3 and is passed on to a series expansion.\n     * @param a number from which logarithm is requested\n     * @return log(a)\n     */\n    public static Dfp log(Dfp a) {\n        int lr;\n        Dfp x;\n        int ix;\n        int p2 = 0;\n\n        // Check the arguments somewhat here\n        if (a.equals(a.getZero()) || a.lessThan(a.getZero()) || a.isNaN()) {\n            // negative, zero or NaN\n            a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return a.dotrap(DfpField.FLAG_INVALID, \"ln\", a, a.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (a.classify() == Dfp.INFINITE) {\n            return a;\n        }\n\n        x = new Dfp(a);\n        lr = x.log10K();\n\n        x = x.divide(pow(a.newInstance(10000), lr));  /* This puts x in the range 0-10000 */\n        ix = x.floor().intValue();\n\n        while (ix > 2) {\n            ix >>= 1;\n            p2++;\n        }\n\n\n        Dfp[] spx = split(x);\n        Dfp[] spy = new Dfp[2];\n        spy[0] = pow(a.getTwo(), p2);          // use spy[0] temporarily as a divisor\n        spx[0] = spx[0].divide(spy[0]);\n        spx[1] = spx[1].divide(spy[0]);\n\n        spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n        while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n            spx[0] = spx[0].divide(2);\n            spx[1] = spx[1].divide(2);\n            p2++;\n        }\n\n        // X is now in the range of 2/3 < x < 4/3\n        Dfp[] spz = logInternal(spx);\n\n        spx[0] = a.newInstance(new StringBuilder().append(p2+4*lr).toString());\n        spx[1] = a.getZero();\n        spy = splitMult(a.getField().getLn2Split(), spx);\n\n        spz[0] = spz[0].add(spy[0]);\n        spz[1] = spz[1].add(spy[1]);\n\n        spx[0] = a.newInstance(new StringBuilder().append(4*lr).toString());\n        spx[1] = a.getZero();\n        spy = splitMult(a.getField().getLn5Split(), spx);\n\n        spz[0] = spz[0].add(spy[0]);\n        spz[1] = spz[1].add(spy[1]);\n\n        return a.newInstance(spz[0].add(spz[1]));\n\n    }\n\n    /** Computes the natural log of a number between 0 and 2.\n     *  Let f(x) = ln(x),\n     *\n     *  We know that f'(x) = 1/x, thus from Taylor's theorum we have:\n     *\n     *           -----          n+1         n\n     *  f(x) =   \\           (-1)    (x - 1)\n     *           /          ----------------    for 1 <= n <= infinity\n     *           -----             n\n     *\n     *  or\n     *                       2        3       4\n     *                   (x-1)   (x-1)    (x-1)\n     *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n     *                     2       3        4\n     *\n     *  alternatively,\n     *\n     *                  2    3   4\n     *                 x    x   x\n     *  ln(x+1) =  x - -  + - - - + ...\n     *                 2    3   4\n     *\n     *  This series can be used to compute ln(x), but it converges too slowly.\n     *\n     *  If we substitute -x for x above, we get\n     *\n     *                   2    3    4\n     *                  x    x    x\n     *  ln(1-x) =  -x - -  - -  - - + ...\n     *                  2    3    4\n     *\n     *  Note that all terms are now negative.  Because the even powered ones\n     *  absorbed the sign.  Now, subtract the series above from the previous\n     *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n     *  only the odd ones\n     *\n     *                             3     5      7\n     *                           2x    2x     2x\n     *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n     *                            3     5      7\n     *\n     *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n     *\n     *                                3        5        7\n     *      x+1           /          x        x        x          \\\n     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n     *      x-1           \\          3        5        7          /\n     *\n     *  But now we want to find ln(a), so we need to find the value of x\n     *  such that a = (x+1)/(x-1).   This is easily solved to find that\n     *  x = (a-1)/(a+1).\n     * @param a number from which logarithm is requested, in split form\n     * @return log(a)\n     */\n    protected static Dfp[] logInternal(final Dfp a[]) {", "right_context": "}\n\n}", "class_name": "DfpMath", "return_type": "Dfp[]", "parameters": [{"type": "Dfp", "name": "a"}]}}
{"prompt": "class BigFractionFormat extends AbstractFormat implements Serializable {\n\n    /**\n     * Create an improper formatting instance with the default number format\n     * for the numerator and denominator.\n     */\n    public BigFractionFormat() {\n    }\n\n    /**\n     * Create an improper formatting instance with a custom number format for\n     * both the numerator and denominator.\n     * @param format the custom format for both the numerator and denominator.\n     */\n    public BigFractionFormat(final NumberFormat format) {\n        super(format);\n    }\n\n    /**\n     * Create an improper formatting instance with a custom number format for\n     * the numerator and a custom number format for the denominator.\n     * @param numeratorFormat the custom format for the numerator.\n     * @param denominatorFormat the custom format for the denominator.\n     */\n    public BigFractionFormat(final NumberFormat numeratorFormat,\n                             final NumberFormat denominatorFormat) {\n        super(numeratorFormat, denominatorFormat);\n    }\n\n    /**\n     * Get the set of locales for which complex formats are available.  This\n     * is the same set as the {@link NumberFormat} set.\n     * @return available complex format locales.\n     */\n    public static Locale[] getAvailableLocales() {\n        return NumberFormat.getAvailableLocales();\n    }\n\n    /**\n     * This static method calls formatBigFraction() on a default instance of\n     * BigFractionFormat.\n     *\n     * @param f BigFraction object to format\n     * @return A formatted BigFraction in proper form.\n     */\n    public static String formatBigFraction(final BigFraction f) {\n        return getImproperInstance().format(f);\n    }\n\n    /**\n     * Returns the default complex format for the current locale.\n     * @return the default complex format.\n     */\n    public static BigFractionFormat getImproperInstance() {\n        return getImproperInstance(Locale.getDefault());\n    }\n\n    /**\n     * Returns the default complex format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the complex format specific to the given locale.\n     */\n    public static BigFractionFormat getImproperInstance(final Locale locale) {\n        return new BigFractionFormat(getDefaultNumberFormat(locale));\n    }\n\n    /**\n     * Returns the default complex format for the current locale.\n     * @return the default complex format.\n     */\n    public static BigFractionFormat getProperInstance() {\n        return getProperInstance(Locale.getDefault());\n    }\n\n    /**\n     * Returns the default complex format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the complex format specific to the given locale.\n     */\n    public static BigFractionFormat getProperInstance(final Locale locale) {\n        return new ProperBigFractionFormat(getDefaultNumberFormat(locale));\n    }\n\n    /**\n     * Formats a {@link BigFraction} object to produce a string.  The BigFraction is\n     * output in improper format.\n     *\n     * @param BigFraction the object to format.\n     * @param toAppendTo where the text is to be appended\n     * @param pos On input: an alignment field, if desired. On output: the\n     *            offsets of the alignment field\n     * @return the value passed in as toAppendTo.\n     */\n    public StringBuffer format(final BigFraction BigFraction,\n                               final StringBuffer toAppendTo, final FieldPosition pos) {\n\n        pos.setBeginIndex(0);\n        pos.setEndIndex(0);\n\n        getNumeratorFormat().format(BigFraction.getNumerator(), toAppendTo, pos);\n        toAppendTo.append(\" / \");\n        getDenominatorFormat().format(BigFraction.getDenominator(), toAppendTo, pos);\n\n        return toAppendTo;\n    }\n\n    /**\n     * Formats an object and appends the result to a StringBuffer.\n     * <code>obj</code> must be either a  {@link BigFraction} object or a\n     * {@link BigInteger} object or a {@link Number} object. Any other type of\n     * object will result in an {@link IllegalArgumentException} being thrown.\n     *\n     * @param obj the object to format.\n     * @param toAppendTo where the text is to be appended\n     * @param pos On input: an alignment field, if desired. On output: the\n     *            offsets of the alignment field\n     * @return the value passed in as toAppendTo.\n     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n     * @throws MathIllegalArgumentException if <code>obj</code> is not a valid type.\n     */\n    @Override\n    public StringBuffer format(final Object obj,\n                               final StringBuffer toAppendTo, final FieldPosition pos) {\n\n        final StringBuffer ret;\n        if (obj instanceof BigFraction) {\n            ret = format((BigFraction) obj, toAppendTo, pos);\n        } else if (obj instanceof BigInteger) {\n            ret = format(new BigFraction((BigInteger) obj), toAppendTo, pos);\n        } else if (obj instanceof Number) {\n            ret = format(new BigFraction(((Number) obj).doubleValue()),\n                         toAppendTo, pos);\n        } else {\n            throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION);\n        }\n\n        return ret;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.\n     * @param source the string to parse\n     * @return the parsed {@link BigFraction} object.\n     * @exception MathParseException if the beginning of the specified string\n     *            cannot be parsed.\n     */\n    @Override\n    public BigFraction parse(final String source) throws MathParseException {", "metadata": {"defects4j_task_id": "2fed1de2dae91dbf6dbde1b975514f826dcaa3db69e1d1fc480d4ea973784682", "task_id": "apache_commons-math/41", "ground_truth": "\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "fraction", "BigFractionFormat.java"], "context_start_lineno": 0, "function_name": "parse", "left_context": "class BigFractionFormat extends AbstractFormat implements Serializable {\n\n    /**\n     * Create an improper formatting instance with the default number format\n     * for the numerator and denominator.\n     */\n    public BigFractionFormat() {\n    }\n\n    /**\n     * Create an improper formatting instance with a custom number format for\n     * both the numerator and denominator.\n     * @param format the custom format for both the numerator and denominator.\n     */\n    public BigFractionFormat(final NumberFormat format) {\n        super(format);\n    }\n\n    /**\n     * Create an improper formatting instance with a custom number format for\n     * the numerator and a custom number format for the denominator.\n     * @param numeratorFormat the custom format for the numerator.\n     * @param denominatorFormat the custom format for the denominator.\n     */\n    public BigFractionFormat(final NumberFormat numeratorFormat,\n                             final NumberFormat denominatorFormat) {\n        super(numeratorFormat, denominatorFormat);\n    }\n\n    /**\n     * Get the set of locales for which complex formats are available.  This\n     * is the same set as the {@link NumberFormat} set.\n     * @return available complex format locales.\n     */\n    public static Locale[] getAvailableLocales() {\n        return NumberFormat.getAvailableLocales();\n    }\n\n    /**\n     * This static method calls formatBigFraction() on a default instance of\n     * BigFractionFormat.\n     *\n     * @param f BigFraction object to format\n     * @return A formatted BigFraction in proper form.\n     */\n    public static String formatBigFraction(final BigFraction f) {\n        return getImproperInstance().format(f);\n    }\n\n    /**\n     * Returns the default complex format for the current locale.\n     * @return the default complex format.\n     */\n    public static BigFractionFormat getImproperInstance() {\n        return getImproperInstance(Locale.getDefault());\n    }\n\n    /**\n     * Returns the default complex format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the complex format specific to the given locale.\n     */\n    public static BigFractionFormat getImproperInstance(final Locale locale) {\n        return new BigFractionFormat(getDefaultNumberFormat(locale));\n    }\n\n    /**\n     * Returns the default complex format for the current locale.\n     * @return the default complex format.\n     */\n    public static BigFractionFormat getProperInstance() {\n        return getProperInstance(Locale.getDefault());\n    }\n\n    /**\n     * Returns the default complex format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the complex format specific to the given locale.\n     */\n    public static BigFractionFormat getProperInstance(final Locale locale) {\n        return new ProperBigFractionFormat(getDefaultNumberFormat(locale));\n    }\n\n    /**\n     * Formats a {@link BigFraction} object to produce a string.  The BigFraction is\n     * output in improper format.\n     *\n     * @param BigFraction the object to format.\n     * @param toAppendTo where the text is to be appended\n     * @param pos On input: an alignment field, if desired. On output: the\n     *            offsets of the alignment field\n     * @return the value passed in as toAppendTo.\n     */\n    public StringBuffer format(final BigFraction BigFraction,\n                               final StringBuffer toAppendTo, final FieldPosition pos) {\n\n        pos.setBeginIndex(0);\n        pos.setEndIndex(0);\n\n        getNumeratorFormat().format(BigFraction.getNumerator(), toAppendTo, pos);\n        toAppendTo.append(\" / \");\n        getDenominatorFormat().format(BigFraction.getDenominator(), toAppendTo, pos);\n\n        return toAppendTo;\n    }\n\n    /**\n     * Formats an object and appends the result to a StringBuffer.\n     * <code>obj</code> must be either a  {@link BigFraction} object or a\n     * {@link BigInteger} object or a {@link Number} object. Any other type of\n     * object will result in an {@link IllegalArgumentException} being thrown.\n     *\n     * @param obj the object to format.\n     * @param toAppendTo where the text is to be appended\n     * @param pos On input: an alignment field, if desired. On output: the\n     *            offsets of the alignment field\n     * @return the value passed in as toAppendTo.\n     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n     * @throws MathIllegalArgumentException if <code>obj</code> is not a valid type.\n     */\n    @Override\n    public StringBuffer format(final Object obj,\n                               final StringBuffer toAppendTo, final FieldPosition pos) {\n\n        final StringBuffer ret;\n        if (obj instanceof BigFraction) {\n            ret = format((BigFraction) obj, toAppendTo, pos);\n        } else if (obj instanceof BigInteger) {\n            ret = format(new BigFraction((BigInteger) obj), toAppendTo, pos);\n        } else if (obj instanceof Number) {\n            ret = format(new BigFraction(((Number) obj).doubleValue()),\n                         toAppendTo, pos);\n        } else {\n            throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION);\n        }\n\n        return ret;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.\n     * @param source the string to parse\n     * @return the parsed {@link BigFraction} object.\n     * @exception MathParseException if the beginning of the specified string\n     *            cannot be parsed.\n     */\n    @Override\n    public BigFraction parse(final String source) throws MathParseException {", "right_context": "}\n\n}", "class_name": "BigFractionFormat", "return_type": "BigFraction", "parameters": [{"type": "String", "name": "source"}]}}
{"prompt": "class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> {\n\n    /** Build an intervals set corresponding to a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     */\n    public IntervalsSet(final double lower, final double upper) {\n        super(buildTree(lower, upper));\n    }\n\n    /** Build an intervals set from an inside/outside BSP tree.\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n     * @param tree inside/outside BSP tree representing the intervals set\n     */\n    public IntervalsSet(final BSPTree<Euclidean1D> tree) {\n        super(tree);\n    }\n\n    /** Build an intervals set from a Boundary REPresentation (B-rep).\n     * <p>The boundary is provided as a collection of {@link\n     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n     * interior part of the region on its minus side and the exterior on\n     * its plus side.</p>\n     * <p>The boundary elements can be in any order, and can form\n     * several non-connected sets (like for example polygons with holes\n     * or a set of disjoints polyhedrons considered as a whole). In\n     * fact, the elements do not even need to be connected together\n     * (their topological connections are not used here). However, if the\n     * boundary does not really separate an inside open from an outside\n     * open (open having here its topological meaning), then subsequent\n     * calls to the {@link\n     * org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector)\n     * checkPoint} method will not be meaningful anymore.</p>\n     * <p>If the boundary is empty, the region will represent the whole\n     * space.</p>\n     * @param boundary collection of boundary elements\n     */\n    public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary) {\n        super(boundary);\n    }\n\n    /** Build an inside/outside tree representing a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     * @return the built tree\n     */\n    private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\n        if (Double.isInfinite(lower) && (lower < 0)) {\n            if (Double.isInfinite(upper) && (upper > 0)) {\n                // the tree must cover the whole real line\n                return new BSPTree<Euclidean1D>(Boolean.TRUE);\n            }\n            // the tree must be open on the negative infinity side\n            final SubHyperplane<Euclidean1D> upperCut =\n                new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree<Euclidean1D>(upperCut,\n                               new BSPTree<Euclidean1D>(Boolean.FALSE),\n                               new BSPTree<Euclidean1D>(Boolean.TRUE),\n                               null);\n        }\n        final SubHyperplane<Euclidean1D> lowerCut =\n            new OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\n        if (Double.isInfinite(upper) && (upper > 0)) {\n            // the tree must be open on the positive infinity side\n            return new BSPTree<Euclidean1D>(lowerCut,\n                                            new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                            new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                            null);\n        }\n\n        // the tree must be bounded on the two sides\n        final SubHyperplane<Euclidean1D> upperCut =\n            new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n        return new BSPTree<Euclidean1D>(lowerCut,\n                                        new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                        new BSPTree<Euclidean1D>(upperCut,\n                                                                 new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                 new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                                                 null),\n                                        null);\n\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\n        return new IntervalsSet(tree);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n        if (getTree(false).getCut() == null) {\n            setBarycenter(Vector1D.NaN);\n            setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n        } else {\n            double size = 0.0;\n            double sum = 0.0;\n            for (final Interval interval : asList()) {\n                size += interval.getSize();\n                sum  += interval.getSize() * interval.getBarycenter();\n            }\n            setSize(size);\n            if (Double.isInfinite(size)) {\n                setBarycenter(Vector1D.NaN);\n            } else if (size >= Precision.SAFE_MIN) {\n                setBarycenter(new Vector1D(sum / size));\n            } else {\n                setBarycenter(((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation());\n            }\n        }\n    }\n\n    /** Get the lowest value belonging to the instance.\n     * @return lowest value belonging to the instance\n     * ({@code Double.NEGATIVE_INFINITY} if the instance doesn't\n     * have any low bound, {@code Double.POSITIVE_INFINITY} if the\n     * instance is empty)\n     */\n    public double getInf() {", "metadata": {"defects4j_task_id": "4cc450c803477dee7f30897b232070a486fdd42766cb72bfdfc044fbb9301b69", "task_id": "apache_commons-math/70", "ground_truth": "\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "geometry", "euclidean", "oned", "IntervalsSet.java"], "context_start_lineno": 0, "function_name": "getInf", "left_context": "class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> {\n\n    /** Build an intervals set corresponding to a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     */\n    public IntervalsSet(final double lower, final double upper) {\n        super(buildTree(lower, upper));\n    }\n\n    /** Build an intervals set from an inside/outside BSP tree.\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n     * @param tree inside/outside BSP tree representing the intervals set\n     */\n    public IntervalsSet(final BSPTree<Euclidean1D> tree) {\n        super(tree);\n    }\n\n    /** Build an intervals set from a Boundary REPresentation (B-rep).\n     * <p>The boundary is provided as a collection of {@link\n     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n     * interior part of the region on its minus side and the exterior on\n     * its plus side.</p>\n     * <p>The boundary elements can be in any order, and can form\n     * several non-connected sets (like for example polygons with holes\n     * or a set of disjoints polyhedrons considered as a whole). In\n     * fact, the elements do not even need to be connected together\n     * (their topological connections are not used here). However, if the\n     * boundary does not really separate an inside open from an outside\n     * open (open having here its topological meaning), then subsequent\n     * calls to the {@link\n     * org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector)\n     * checkPoint} method will not be meaningful anymore.</p>\n     * <p>If the boundary is empty, the region will represent the whole\n     * space.</p>\n     * @param boundary collection of boundary elements\n     */\n    public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary) {\n        super(boundary);\n    }\n\n    /** Build an inside/outside tree representing a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     * @return the built tree\n     */\n    private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\n        if (Double.isInfinite(lower) && (lower < 0)) {\n            if (Double.isInfinite(upper) && (upper > 0)) {\n                // the tree must cover the whole real line\n                return new BSPTree<Euclidean1D>(Boolean.TRUE);\n            }\n            // the tree must be open on the negative infinity side\n            final SubHyperplane<Euclidean1D> upperCut =\n                new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree<Euclidean1D>(upperCut,\n                               new BSPTree<Euclidean1D>(Boolean.FALSE),\n                               new BSPTree<Euclidean1D>(Boolean.TRUE),\n                               null);\n        }\n        final SubHyperplane<Euclidean1D> lowerCut =\n            new OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\n        if (Double.isInfinite(upper) && (upper > 0)) {\n            // the tree must be open on the positive infinity side\n            return new BSPTree<Euclidean1D>(lowerCut,\n                                            new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                            new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                            null);\n        }\n\n        // the tree must be bounded on the two sides\n        final SubHyperplane<Euclidean1D> upperCut =\n            new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n        return new BSPTree<Euclidean1D>(lowerCut,\n                                        new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                        new BSPTree<Euclidean1D>(upperCut,\n                                                                 new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                 new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                                                 null),\n                                        null);\n\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\n        return new IntervalsSet(tree);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n        if (getTree(false).getCut() == null) {\n            setBarycenter(Vector1D.NaN);\n            setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n        } else {\n            double size = 0.0;\n            double sum = 0.0;\n            for (final Interval interval : asList()) {\n                size += interval.getSize();\n                sum  += interval.getSize() * interval.getBarycenter();\n            }\n            setSize(size);\n            if (Double.isInfinite(size)) {\n                setBarycenter(Vector1D.NaN);\n            } else if (size >= Precision.SAFE_MIN) {\n                setBarycenter(new Vector1D(sum / size));\n            } else {\n                setBarycenter(((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation());\n            }\n        }\n    }\n\n    /** Get the lowest value belonging to the instance.\n     * @return lowest value belonging to the instance\n     * ({@code Double.NEGATIVE_INFINITY} if the instance doesn't\n     * have any low bound, {@code Double.POSITIVE_INFINITY} if the\n     * instance is empty)\n     */\n    public double getInf() {", "right_context": "}\n\n}", "class_name": "IntervalsSet", "return_type": "double", "parameters": []}}
{"prompt": "class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> {\n\n    /** Build an intervals set corresponding to a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     */\n    public IntervalsSet(final double lower, final double upper) {\n        super(buildTree(lower, upper));\n    }\n\n    /** Build an intervals set from an inside/outside BSP tree.\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n     * @param tree inside/outside BSP tree representing the intervals set\n     */\n    public IntervalsSet(final BSPTree<Euclidean1D> tree) {\n        super(tree);\n    }\n\n    /** Build an intervals set from a Boundary REPresentation (B-rep).\n     * <p>The boundary is provided as a collection of {@link\n     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n     * interior part of the region on its minus side and the exterior on\n     * its plus side.</p>\n     * <p>The boundary elements can be in any order, and can form\n     * several non-connected sets (like for example polygons with holes\n     * or a set of disjoints polyhedrons considered as a whole). In\n     * fact, the elements do not even need to be connected together\n     * (their topological connections are not used here). However, if the\n     * boundary does not really separate an inside open from an outside\n     * open (open having here its topological meaning), then subsequent\n     * calls to the {@link\n     * org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector)\n     * checkPoint} method will not be meaningful anymore.</p>\n     * <p>If the boundary is empty, the region will represent the whole\n     * space.</p>\n     * @param boundary collection of boundary elements\n     */\n    public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary) {\n        super(boundary);\n    }\n\n    /** Build an inside/outside tree representing a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     * @return the built tree\n     */\n    private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\n        if (Double.isInfinite(lower) && (lower < 0)) {\n            if (Double.isInfinite(upper) && (upper > 0)) {\n                // the tree must cover the whole real line\n                return new BSPTree<Euclidean1D>(Boolean.TRUE);\n            }\n            // the tree must be open on the negative infinity side\n            final SubHyperplane<Euclidean1D> upperCut =\n                new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree<Euclidean1D>(upperCut,\n                               new BSPTree<Euclidean1D>(Boolean.FALSE),\n                               new BSPTree<Euclidean1D>(Boolean.TRUE),\n                               null);\n        }\n        final SubHyperplane<Euclidean1D> lowerCut =\n            new OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\n        if (Double.isInfinite(upper) && (upper > 0)) {\n            // the tree must be open on the positive infinity side\n            return new BSPTree<Euclidean1D>(lowerCut,\n                                            new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                            new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                            null);\n        }\n\n        // the tree must be bounded on the two sides\n        final SubHyperplane<Euclidean1D> upperCut =\n            new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n        return new BSPTree<Euclidean1D>(lowerCut,\n                                        new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                        new BSPTree<Euclidean1D>(upperCut,\n                                                                 new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                 new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                                                 null),\n                                        null);\n\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\n        return new IntervalsSet(tree);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n        if (getTree(false).getCut() == null) {\n            setBarycenter(Vector1D.NaN);\n            setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n        } else {\n            double size = 0.0;\n            double sum = 0.0;\n            for (final Interval interval : asList()) {\n                size += interval.getSize();\n                sum  += interval.getSize() * interval.getBarycenter();\n            }\n            setSize(size);\n            if (Double.isInfinite(size)) {\n                setBarycenter(Vector1D.NaN);\n            } else if (size >= Precision.SAFE_MIN) {\n                setBarycenter(new Vector1D(sum / size));\n            } else {\n                setBarycenter(((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation());\n            }\n        }\n    }\n\n    /** Get the lowest value belonging to the instance.\n     * @return lowest value belonging to the instance\n     * ({@code Double.NEGATIVE_INFINITY} if the instance doesn't\n     * have any low bound, {@code Double.POSITIVE_INFINITY} if the\n     * instance is empty)\n     */\n    public double getInf() {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }\n\n    /** Get the highest value belonging to the instance.\n     * @return highest value belonging to the instance\n     * ({@code Double.POSITIVE_INFINITY} if the instance doesn't\n     * have any high bound, {@code Double.NEGATIVE_INFINITY} if the\n     * instance is empty)\n     */\n    public double getSup() {", "metadata": {"defects4j_task_id": "7c7af76cf4ef2de22d1898c8df0533ba0440c1e5a67c804e1deeb2434a6935d4", "task_id": "apache_commons-math/102", "ground_truth": "\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  sup  = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "geometry", "euclidean", "oned", "IntervalsSet.java"], "context_start_lineno": 0, "function_name": "getSup", "left_context": "class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D> {\n\n    /** Build an intervals set corresponding to a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     */\n    public IntervalsSet(final double lower, final double upper) {\n        super(buildTree(lower, upper));\n    }\n\n    /** Build an intervals set from an inside/outside BSP tree.\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n     * @param tree inside/outside BSP tree representing the intervals set\n     */\n    public IntervalsSet(final BSPTree<Euclidean1D> tree) {\n        super(tree);\n    }\n\n    /** Build an intervals set from a Boundary REPresentation (B-rep).\n     * <p>The boundary is provided as a collection of {@link\n     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n     * interior part of the region on its minus side and the exterior on\n     * its plus side.</p>\n     * <p>The boundary elements can be in any order, and can form\n     * several non-connected sets (like for example polygons with holes\n     * or a set of disjoints polyhedrons considered as a whole). In\n     * fact, the elements do not even need to be connected together\n     * (their topological connections are not used here). However, if the\n     * boundary does not really separate an inside open from an outside\n     * open (open having here its topological meaning), then subsequent\n     * calls to the {@link\n     * org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector)\n     * checkPoint} method will not be meaningful anymore.</p>\n     * <p>If the boundary is empty, the region will represent the whole\n     * space.</p>\n     * @param boundary collection of boundary elements\n     */\n    public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary) {\n        super(boundary);\n    }\n\n    /** Build an inside/outside tree representing a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     * @return the built tree\n     */\n    private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\n        if (Double.isInfinite(lower) && (lower < 0)) {\n            if (Double.isInfinite(upper) && (upper > 0)) {\n                // the tree must cover the whole real line\n                return new BSPTree<Euclidean1D>(Boolean.TRUE);\n            }\n            // the tree must be open on the negative infinity side\n            final SubHyperplane<Euclidean1D> upperCut =\n                new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree<Euclidean1D>(upperCut,\n                               new BSPTree<Euclidean1D>(Boolean.FALSE),\n                               new BSPTree<Euclidean1D>(Boolean.TRUE),\n                               null);\n        }\n        final SubHyperplane<Euclidean1D> lowerCut =\n            new OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\n        if (Double.isInfinite(upper) && (upper > 0)) {\n            // the tree must be open on the positive infinity side\n            return new BSPTree<Euclidean1D>(lowerCut,\n                                            new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                            new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                            null);\n        }\n\n        // the tree must be bounded on the two sides\n        final SubHyperplane<Euclidean1D> upperCut =\n            new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n        return new BSPTree<Euclidean1D>(lowerCut,\n                                        new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                        new BSPTree<Euclidean1D>(upperCut,\n                                                                 new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                 new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                                                 null),\n                                        null);\n\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\n        return new IntervalsSet(tree);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n        if (getTree(false).getCut() == null) {\n            setBarycenter(Vector1D.NaN);\n            setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n        } else {\n            double size = 0.0;\n            double sum = 0.0;\n            for (final Interval interval : asList()) {\n                size += interval.getSize();\n                sum  += interval.getSize() * interval.getBarycenter();\n            }\n            setSize(size);\n            if (Double.isInfinite(size)) {\n                setBarycenter(Vector1D.NaN);\n            } else if (size >= Precision.SAFE_MIN) {\n                setBarycenter(new Vector1D(sum / size));\n            } else {\n                setBarycenter(((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation());\n            }\n        }\n    }\n\n    /** Get the lowest value belonging to the instance.\n     * @return lowest value belonging to the instance\n     * ({@code Double.NEGATIVE_INFINITY} if the instance doesn't\n     * have any low bound, {@code Double.POSITIVE_INFINITY} if the\n     * instance is empty)\n     */\n    public double getInf() {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }\n\n    /** Get the highest value belonging to the instance.\n     * @return highest value belonging to the instance\n     * ({@code Double.POSITIVE_INFINITY} if the instance doesn't\n     * have any high bound, {@code Double.NEGATIVE_INFINITY} if the\n     * instance is empty)\n     */\n    public double getSup() {", "right_context": "}\n\n}", "class_name": "IntervalsSet", "return_type": "double", "parameters": []}}
{"prompt": "class Interval {\n\n    /** The lower bound of the interval. */\n    private final double lower;\n\n    /** The upper bound of the interval. */\n    private final double upper;\n\n    /** Simple constructor.\n     * @param lower lower bound of the interval\n     * @param upper upper bound of the interval\n     */\n    public Interval(final double lower, final double upper) {\n        this.lower = lower;\n        this.upper = upper;\n    }\n\n    /** Get the lower bound of the interval.\n     * @return lower bound of the interval\n     * @since 3.1\n     */\n    public double getInf() {\n        return lower;\n    }\n\n    /** Get the lower bound of the interval.\n     * @return lower bound of the interval\n     * @deprecated as of 3.1, replaced by {@link #getInf()}\n     */\n    @Deprecated\n    public double getLower() {\n        return getInf();\n    }\n\n    /** Get the upper bound of the interval.\n     * @return upper bound of the interval\n     * @since 3.1\n     */\n    public double getSup() {\n        return upper;\n    }\n\n    /** Get the upper bound of the interval.\n     * @return upper bound of the interval\n     * @deprecated as of 3.1, replaced by {@link #getSup()}\n     */\n    @Deprecated\n    public double getUpper() {\n        return getSup();\n    }\n\n    /** Get the size of the interval.\n     * @return size of the interval\n     * @since 3.1\n     */\n    public double getSize() {\n        return upper - lower;\n    }\n\n    /** Get the length of the interval.\n     * @return length of the interval\n     * @deprecated as of 3.1, replaced by {@link #getSize()}\n     */\n    @Deprecated\n    public double getLength() {\n        return getSize();\n    }\n\n    /** Get the barycenter of the interval.\n     * @return barycenter of the interval\n     * @since 3.1\n     */\n    public double getBarycenter() {\n        return 0.5 * (lower + upper);\n    }\n\n    /** Get the midpoint of the interval.\n     * @return midpoint of the interval\n     * @deprecated as of 3.1, replaced by {@link #getBarycenter()}\n     */\n    @Deprecated\n    public double getMidPoint() {\n        return getBarycenter();\n    }\n\n    /** Check a point with respect to the interval.\n     * @param point point to check\n     * @param tolerance tolerance below which points are considered to\n     * belong to the boundary\n     * @return a code representing the point status: either {@link\n     * Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\n     * @since 3.1\n     */\n    public Location checkPoint(final double point, final double tolerance) {", "metadata": {"defects4j_task_id": "fe6b18f1b1883c776c5460a88b432d204e708f82741474dac272de8fdcb0ec3d", "task_id": "apache_commons-math/208", "ground_truth": "\n        if (point < lower - tolerance || point > upper + tolerance) {\n            return Location.OUTSIDE;\n        } else if (point > lower + tolerance && point < upper - tolerance) {\n            return Location.INSIDE;\n        } else {\n            return Location.BOUNDARY;\n        }\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "geometry", "euclidean", "oned", "Interval.java"], "context_start_lineno": 0, "function_name": "checkPoint", "left_context": "class Interval {\n\n    /** The lower bound of the interval. */\n    private final double lower;\n\n    /** The upper bound of the interval. */\n    private final double upper;\n\n    /** Simple constructor.\n     * @param lower lower bound of the interval\n     * @param upper upper bound of the interval\n     */\n    public Interval(final double lower, final double upper) {\n        this.lower = lower;\n        this.upper = upper;\n    }\n\n    /** Get the lower bound of the interval.\n     * @return lower bound of the interval\n     * @since 3.1\n     */\n    public double getInf() {\n        return lower;\n    }\n\n    /** Get the lower bound of the interval.\n     * @return lower bound of the interval\n     * @deprecated as of 3.1, replaced by {@link #getInf()}\n     */\n    @Deprecated\n    public double getLower() {\n        return getInf();\n    }\n\n    /** Get the upper bound of the interval.\n     * @return upper bound of the interval\n     * @since 3.1\n     */\n    public double getSup() {\n        return upper;\n    }\n\n    /** Get the upper bound of the interval.\n     * @return upper bound of the interval\n     * @deprecated as of 3.1, replaced by {@link #getSup()}\n     */\n    @Deprecated\n    public double getUpper() {\n        return getSup();\n    }\n\n    /** Get the size of the interval.\n     * @return size of the interval\n     * @since 3.1\n     */\n    public double getSize() {\n        return upper - lower;\n    }\n\n    /** Get the length of the interval.\n     * @return length of the interval\n     * @deprecated as of 3.1, replaced by {@link #getSize()}\n     */\n    @Deprecated\n    public double getLength() {\n        return getSize();\n    }\n\n    /** Get the barycenter of the interval.\n     * @return barycenter of the interval\n     * @since 3.1\n     */\n    public double getBarycenter() {\n        return 0.5 * (lower + upper);\n    }\n\n    /** Get the midpoint of the interval.\n     * @return midpoint of the interval\n     * @deprecated as of 3.1, replaced by {@link #getBarycenter()}\n     */\n    @Deprecated\n    public double getMidPoint() {\n        return getBarycenter();\n    }\n\n    /** Check a point with respect to the interval.\n     * @param point point to check\n     * @param tolerance tolerance below which points are considered to\n     * belong to the boundary\n     * @return a code representing the point status: either {@link\n     * Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\n     * @since 3.1\n     */\n    public Location checkPoint(final double point, final double tolerance) {", "right_context": "}\n\n}", "class_name": "Interval", "return_type": "Location", "parameters": [{"type": "double", "name": "point"}, {"type": "double", "name": "tolerance"}]}}
{"prompt": "class Rotation implements Serializable {\n\n  /** Build a rotation from three Cardan or Euler elementary rotations.\n\n   * <p>Cardan rotations are three successive rotations around the\n   * canonical axes X, Y and Z, each axis being used once. There are\n   * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n   * rotations are three successive rotations around the canonical\n   * axes X, Y and Z, the first and last rotations being around the\n   * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n   * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n   * <p>Beware that many people routinely use the term Euler angles even\n   * for what really are Cardan angles (this confusion is especially\n   * widespread in the aerospace business where Roll, Pitch and Yaw angles\n   * are often wrongly tagged as Euler angles).</p>\n\n   * @param order order of rotations to use\n   * @param alpha1 angle of the first elementary rotation\n   * @param alpha2 angle of the second elementary rotation\n   * @param alpha3 angle of the third elementary rotation\n   */\n  public Rotation(RotationOrder order,\n                  double alpha1, double alpha2, double alpha3) {\n      Rotation r1 = new Rotation(order.getA1(), alpha1);\n      Rotation r2 = new Rotation(order.getA2(), alpha2);\n      Rotation r3 = new Rotation(order.getA3(), alpha3);\n      Rotation composed = r1.applyTo(r2.applyTo(r3));\n      q0 = composed.q0;\n      q1 = composed.q1;\n      q2 = composed.q2;\n      q3 = composed.q3;\n  }\n\n  /** Convert an orthogonal rotation matrix to a quaternion.\n   * @param ort orthogonal rotation matrix\n   * @return quaternion corresponding to the matrix\n   */\n  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\n                  quat[0] = inv * (ort[2][0] - ort[0][2]);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }\n\n  /** Revert a rotation.\n   * Build a rotation which reverse the effect of another\n   * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n   * instance is not changed.\n   * @return a new rotation whose effect is the reverse of the effect\n   * of the instance\n   */\n  public Rotation revert() {\n    return new Rotation(-q0, q1, q2, q3, false);\n  }\n\n  /** Get the scalar coordinate of the quaternion.\n   * @return scalar coordinate of the quaternion\n   */\n  public double getQ0() {\n    return q0;\n  }\n\n  /** Get the first coordinate of the vectorial part of the quaternion.\n   * @return first coordinate of the vectorial part of the quaternion\n   */\n  public double getQ1() {\n    return q1;\n  }\n\n  /** Get the second coordinate of the vectorial part of the quaternion.\n   * @return second coordinate of the vectorial part of the quaternion\n   */\n  public double getQ2() {\n    return q2;\n  }\n\n  /** Get the third coordinate of the vectorial part of the quaternion.\n   * @return third coordinate of the vectorial part of the quaternion\n   */\n  public double getQ3() {\n    return q3;\n  }\n\n  /** Get the normalized axis of the rotation.\n   * @return normalized axis of the rotation\n   * @see #Rotation(Vector3D, double)\n   */\n  public Vector3D getAxis() {", "metadata": {"defects4j_task_id": "424a6cbfe2be8e3baa19fe269604c68713f1f20bea3a069bc5a89c6bb2fe5fb3", "task_id": "apache_commons-math/59", "ground_truth": "\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n      return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n      double inverse = 1 / FastMath.sqrt(squaredSine);\n      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n    double inverse = -1 / FastMath.sqrt(squaredSine);\n    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n  ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "geometry", "euclidean", "threed", "Rotation.java"], "context_start_lineno": 0, "function_name": "getAxis", "left_context": "class Rotation implements Serializable {\n\n  /** Build a rotation from three Cardan or Euler elementary rotations.\n\n   * <p>Cardan rotations are three successive rotations around the\n   * canonical axes X, Y and Z, each axis being used once. There are\n   * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n   * rotations are three successive rotations around the canonical\n   * axes X, Y and Z, the first and last rotations being around the\n   * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n   * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n   * <p>Beware that many people routinely use the term Euler angles even\n   * for what really are Cardan angles (this confusion is especially\n   * widespread in the aerospace business where Roll, Pitch and Yaw angles\n   * are often wrongly tagged as Euler angles).</p>\n\n   * @param order order of rotations to use\n   * @param alpha1 angle of the first elementary rotation\n   * @param alpha2 angle of the second elementary rotation\n   * @param alpha3 angle of the third elementary rotation\n   */\n  public Rotation(RotationOrder order,\n                  double alpha1, double alpha2, double alpha3) {\n      Rotation r1 = new Rotation(order.getA1(), alpha1);\n      Rotation r2 = new Rotation(order.getA2(), alpha2);\n      Rotation r3 = new Rotation(order.getA3(), alpha3);\n      Rotation composed = r1.applyTo(r2.applyTo(r3));\n      q0 = composed.q0;\n      q1 = composed.q1;\n      q2 = composed.q2;\n      q3 = composed.q3;\n  }\n\n  /** Convert an orthogonal rotation matrix to a quaternion.\n   * @param ort orthogonal rotation matrix\n   * @return quaternion corresponding to the matrix\n   */\n  private static double[] mat2quat(final double[][] ort) {\n\n      final double[] quat = new double[4];\n\n      // There are different ways to compute the quaternions elements\n      // from the matrix. They all involve computing one element from\n      // the diagonal of the matrix, and computing the three other ones\n      // using a formula involving a division by the first element,\n      // which unfortunately can be zero. Since the norm of the\n      // quaternion is 1, we know at least one element has an absolute\n      // value greater or equal to 0.5, so it is always possible to\n      // select the right formula and avoid division by zero and even\n      // numerical inaccuracy. Checking the elements in turn and using\n      // the first one greater than 0.45 is safe (this leads to a simple\n      // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n      double s = ort[0][0] + ort[1][1] + ort[2][2];\n      if (s > -0.19) {\n          // compute q0 and deduce q1, q2 and q3\n          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / quat[0];\n          quat[1] = inv * (ort[1][2] - ort[2][1]);\n          quat[2] = inv * (ort[2][0] - ort[0][2]);\n          quat[3] = inv * (ort[0][1] - ort[1][0]);\n      } else {\n          s = ort[0][0] - ort[1][1] - ort[2][2];\n          if (s > -0.19) {\n              // compute q1 and deduce q0, q2 and q3\n              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n              double inv = 0.25 / quat[1];\n              quat[0] = inv * (ort[1][2] - ort[2][1]);\n              quat[2] = inv * (ort[0][1] + ort[1][0]);\n              quat[3] = inv * (ort[0][2] + ort[2][0]);\n          } else {\n              s = ort[1][1] - ort[0][0] - ort[2][2];\n              if (s > -0.19) {\n                  // compute q2 and deduce q0, q1 and q3\n                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[2];\n                  quat[0] = inv * (ort[2][0] - ort[0][2]);\n                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n              } else {\n                  // compute q3 and deduce q0, q1 and q2\n                  s = ort[2][2] - ort[0][0] - ort[1][1];\n                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n                  double inv = 0.25 / quat[3];\n                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n              }\n          }\n      }\n\n      return quat;\n\n  }\n\n  /** Revert a rotation.\n   * Build a rotation which reverse the effect of another\n   * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n   * instance is not changed.\n   * @return a new rotation whose effect is the reverse of the effect\n   * of the instance\n   */\n  public Rotation revert() {\n    return new Rotation(-q0, q1, q2, q3, false);\n  }\n\n  /** Get the scalar coordinate of the quaternion.\n   * @return scalar coordinate of the quaternion\n   */\n  public double getQ0() {\n    return q0;\n  }\n\n  /** Get the first coordinate of the vectorial part of the quaternion.\n   * @return first coordinate of the vectorial part of the quaternion\n   */\n  public double getQ1() {\n    return q1;\n  }\n\n  /** Get the second coordinate of the vectorial part of the quaternion.\n   * @return second coordinate of the vectorial part of the quaternion\n   */\n  public double getQ2() {\n    return q2;\n  }\n\n  /** Get the third coordinate of the vectorial part of the quaternion.\n   * @return third coordinate of the vectorial part of the quaternion\n   */\n  public double getQ3() {\n    return q3;\n  }\n\n  /** Get the normalized axis of the rotation.\n   * @return normalized axis of the rotation\n   * @see #Rotation(Vector3D, double)\n   */\n  public Vector3D getAxis() {", "right_context": "}\n\n}", "class_name": "Rotation", "return_type": "Vector3D", "parameters": []}}
{"prompt": "class FieldVector3D<T extends RealFieldElement<T>> implements Serializable {\n\n    /** Add a vector to the instance.\n     * @param v vector to add\n     * @return a new vector\n     */\n    public FieldVector3D<T> add(final Vector3D v) {\n        return new FieldVector3D<T>(x.add(v.getX()), y.add(v.getY()), z.add(v.getZ()));\n    }\n\n    /** Add a scaled vector to the instance.\n     * @param factor scale factor to apply to v before adding it\n     * @param v vector to add\n     * @return a new vector\n     */\n    public FieldVector3D<T> add(final T factor, final FieldVector3D<T> v) {\n        return new FieldVector3D<T>(x.getField().getOne(), this, factor, v);\n    }\n\n    /** Add a scaled vector to the instance.\n     * @param factor scale factor to apply to v before adding it\n     * @param v vector to add\n     * @return a new vector\n     */\n    public FieldVector3D<T> add(final T factor, final Vector3D v) {\n        return new FieldVector3D<T>(x.add(factor.multiply(v.getX())),\n                                    y.add(factor.multiply(v.getY())),\n                                    z.add(factor.multiply(v.getZ())));\n    }\n\n    /** Add a scaled vector to the instance.\n     * @param factor scale factor to apply to v before adding it\n     * @param v vector to add\n     * @return a new vector\n     */\n    public FieldVector3D<T> add(final double factor, final FieldVector3D<T> v) {\n        return new FieldVector3D<T>(1.0, this, factor, v);\n    }\n\n    /** Add a scaled vector to the instance.\n     * @param factor scale factor to apply to v before adding it\n     * @param v vector to add\n     * @return a new vector\n     */\n    public FieldVector3D<T> add(final double factor, final Vector3D v) {\n        return new FieldVector3D<T>(x.add(factor * v.getX()),\n                                    y.add(factor * v.getY()),\n                                    z.add(factor * v.getZ()));\n    }\n\n    /** Subtract a vector from the instance.\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final FieldVector3D<T> v) {\n        return new FieldVector3D<T>(x.subtract(v.x), y.subtract(v.y), z.subtract(v.z));\n    }\n\n    /** Subtract a vector from the instance.\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final Vector3D v) {\n        return new FieldVector3D<T>(x.subtract(v.getX()), y.subtract(v.getY()), z.subtract(v.getZ()));\n    }\n\n    /** Subtract a scaled vector from the instance.\n     * @param factor scale factor to apply to v before subtracting it\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final T factor, final FieldVector3D<T> v) {\n        return new FieldVector3D<T>(x.getField().getOne(), this, factor.negate(), v);\n    }\n\n    /** Subtract a scaled vector from the instance.\n     * @param factor scale factor to apply to v before subtracting it\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final T factor, final Vector3D v) {\n        return new FieldVector3D<T>(x.subtract(factor.multiply(v.getX())),\n                                    y.subtract(factor.multiply(v.getY())),\n                                    z.subtract(factor.multiply(v.getZ())));\n    }\n\n    /** Subtract a scaled vector from the instance.\n     * @param factor scale factor to apply to v before subtracting it\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final double factor, final FieldVector3D<T> v) {\n        return new FieldVector3D<T>(1.0, this, -factor, v);\n    }\n\n    /** Subtract a scaled vector from the instance.\n     * @param factor scale factor to apply to v before subtracting it\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final double factor, final Vector3D v) {\n        return new FieldVector3D<T>(x.subtract(factor * v.getX()),\n                                    y.subtract(factor * v.getY()),\n                                    z.subtract(factor * v.getZ()));\n    }\n\n    /** Get a normalized vector aligned with the instance.\n     * @return a new normalized vector\n     * @exception MathArithmeticException if the norm is zero\n     */\n    public FieldVector3D<T> normalize() throws MathArithmeticException {\n        final T s = getNorm();\n        if (s.getReal() == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n        }\n        return scalarMultiply(s.reciprocal());\n    }\n\n    /** Get a vector orthogonal to the instance.\n     * <p>There are an infinite number of normalized vectors orthogonal\n     * to the instance. This method picks up one of them almost\n     * arbitrarily. It is useful when one needs to compute a reference\n     * frame with one of the axes in a predefined direction. The\n     * following example shows how to build a frame having the k axis\n     * aligned with the known vector u :\n     * <pre><code>\n     *   Vector3D k = u.normalize();\n     *   Vector3D i = k.orthogonal();\n     *   Vector3D j = Vector3D.crossProduct(k, i);\n     * </code></pre></p>\n     * @return a new normalized vector orthogonal to the instance\n     * @exception MathArithmeticException if the norm of the instance is null\n     */\n    public FieldVector3D<T> orthogonal() throws MathArithmeticException {", "metadata": {"defects4j_task_id": "e7a9c330f4815e5e60824b8ae04f791584f09e38610e148630a60f64a662252b", "task_id": "apache_commons-math/190", "ground_truth": "\n\n        final double threshold = 0.6 * getNorm().getReal();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x.getReal()) <= threshold) {\n            final T inverse  = y.multiply(y).add(z.multiply(z)).sqrt().reciprocal();\n            return new FieldVector3D<T>(inverse.getField().getZero(), inverse.multiply(z), inverse.multiply(y).negate());\n        } else if (FastMath.abs(y.getReal()) <= threshold) {\n            final T inverse  = x.multiply(x).add(z.multiply(z)).sqrt().reciprocal();\n            return new FieldVector3D<T>(inverse.multiply(z).negate(), inverse.getField().getZero(), inverse.multiply(x));\n        } else {\n            final T inverse  = x.multiply(x).add(y.multiply(y)).sqrt().reciprocal();\n            return new FieldVector3D<T>(inverse.multiply(y), inverse.multiply(x).negate(), inverse.getField().getZero());\n        }\n\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "geometry", "euclidean", "threed", "FieldVector3D.java"], "context_start_lineno": 0, "function_name": "orthogonal", "left_context": "class FieldVector3D<T extends RealFieldElement<T>> implements Serializable {\n\n    /** Add a vector to the instance.\n     * @param v vector to add\n     * @return a new vector\n     */\n    public FieldVector3D<T> add(final Vector3D v) {\n        return new FieldVector3D<T>(x.add(v.getX()), y.add(v.getY()), z.add(v.getZ()));\n    }\n\n    /** Add a scaled vector to the instance.\n     * @param factor scale factor to apply to v before adding it\n     * @param v vector to add\n     * @return a new vector\n     */\n    public FieldVector3D<T> add(final T factor, final FieldVector3D<T> v) {\n        return new FieldVector3D<T>(x.getField().getOne(), this, factor, v);\n    }\n\n    /** Add a scaled vector to the instance.\n     * @param factor scale factor to apply to v before adding it\n     * @param v vector to add\n     * @return a new vector\n     */\n    public FieldVector3D<T> add(final T factor, final Vector3D v) {\n        return new FieldVector3D<T>(x.add(factor.multiply(v.getX())),\n                                    y.add(factor.multiply(v.getY())),\n                                    z.add(factor.multiply(v.getZ())));\n    }\n\n    /** Add a scaled vector to the instance.\n     * @param factor scale factor to apply to v before adding it\n     * @param v vector to add\n     * @return a new vector\n     */\n    public FieldVector3D<T> add(final double factor, final FieldVector3D<T> v) {\n        return new FieldVector3D<T>(1.0, this, factor, v);\n    }\n\n    /** Add a scaled vector to the instance.\n     * @param factor scale factor to apply to v before adding it\n     * @param v vector to add\n     * @return a new vector\n     */\n    public FieldVector3D<T> add(final double factor, final Vector3D v) {\n        return new FieldVector3D<T>(x.add(factor * v.getX()),\n                                    y.add(factor * v.getY()),\n                                    z.add(factor * v.getZ()));\n    }\n\n    /** Subtract a vector from the instance.\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final FieldVector3D<T> v) {\n        return new FieldVector3D<T>(x.subtract(v.x), y.subtract(v.y), z.subtract(v.z));\n    }\n\n    /** Subtract a vector from the instance.\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final Vector3D v) {\n        return new FieldVector3D<T>(x.subtract(v.getX()), y.subtract(v.getY()), z.subtract(v.getZ()));\n    }\n\n    /** Subtract a scaled vector from the instance.\n     * @param factor scale factor to apply to v before subtracting it\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final T factor, final FieldVector3D<T> v) {\n        return new FieldVector3D<T>(x.getField().getOne(), this, factor.negate(), v);\n    }\n\n    /** Subtract a scaled vector from the instance.\n     * @param factor scale factor to apply to v before subtracting it\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final T factor, final Vector3D v) {\n        return new FieldVector3D<T>(x.subtract(factor.multiply(v.getX())),\n                                    y.subtract(factor.multiply(v.getY())),\n                                    z.subtract(factor.multiply(v.getZ())));\n    }\n\n    /** Subtract a scaled vector from the instance.\n     * @param factor scale factor to apply to v before subtracting it\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final double factor, final FieldVector3D<T> v) {\n        return new FieldVector3D<T>(1.0, this, -factor, v);\n    }\n\n    /** Subtract a scaled vector from the instance.\n     * @param factor scale factor to apply to v before subtracting it\n     * @param v vector to subtract\n     * @return a new vector\n     */\n    public FieldVector3D<T> subtract(final double factor, final Vector3D v) {\n        return new FieldVector3D<T>(x.subtract(factor * v.getX()),\n                                    y.subtract(factor * v.getY()),\n                                    z.subtract(factor * v.getZ()));\n    }\n\n    /** Get a normalized vector aligned with the instance.\n     * @return a new normalized vector\n     * @exception MathArithmeticException if the norm is zero\n     */\n    public FieldVector3D<T> normalize() throws MathArithmeticException {\n        final T s = getNorm();\n        if (s.getReal() == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n        }\n        return scalarMultiply(s.reciprocal());\n    }\n\n    /** Get a vector orthogonal to the instance.\n     * <p>There are an infinite number of normalized vectors orthogonal\n     * to the instance. This method picks up one of them almost\n     * arbitrarily. It is useful when one needs to compute a reference\n     * frame with one of the axes in a predefined direction. The\n     * following example shows how to build a frame having the k axis\n     * aligned with the known vector u :\n     * <pre><code>\n     *   Vector3D k = u.normalize();\n     *   Vector3D i = k.orthogonal();\n     *   Vector3D j = Vector3D.crossProduct(k, i);\n     * </code></pre></p>\n     * @return a new normalized vector orthogonal to the instance\n     * @exception MathArithmeticException if the norm of the instance is null\n     */\n    public FieldVector3D<T> orthogonal() throws MathArithmeticException {", "right_context": "}\n\n}", "class_name": "FieldVector3D", "return_type": "FieldVector3D<T>", "parameters": []}}
{"prompt": "class AVLTree<T extends Comparable<T>> {\n\n    /** Build an empty tree.\n     */\n    public AVLTree() {\n        top = null;\n    }\n\n    /** Insert an element in the tree.\n     * @param element element to insert (silently ignored if null)\n     */\n    public void insert(final T element) {\n        if (element != null) {\n            if (top == null) {\n                top = new Node(element, null);\n            } else {\n                top.insert(element);\n            }\n        }\n    }\n\n    /** Delete an element from the tree.\n     * <p>The element is deleted only if there is a node {@code n}\n     * containing exactly the element instance specified, i.e. for which\n     * {@code n.getElement() == element}. This is purposely\n     * <em>different</em> from the specification of the\n     * {@code java.util.Set} {@code remove} method (in fact,\n     * this is the reason why a specific class has been developed).</p>\n     * @param element element to delete (silently ignored if null)\n     * @return true if the element was deleted from the tree\n     */\n    public boolean delete(final T element) {\n        if (element != null) {\n            for (Node node = getNotSmaller(element); node != null; node = node.getNext()) {\n                // loop over all elements neither smaller nor larger\n                // than the specified one\n                if (node.element == element) {\n                    node.delete();\n                    return true;\n                } else if (node.element.compareTo(element) > 0) {\n                    // all the remaining elements are known to be larger,\n                    // the element is not in the tree\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n\n    /** Check if the tree is empty.\n     * @return true if the tree is empty\n     */\n    public boolean isEmpty() {\n        return top == null;\n    }\n\n\n    /** Get the number of elements of the tree.\n     * @return number of elements contained in the tree\n     */\n    public int size() {\n        return (top == null) ? 0 : top.size();\n    }\n\n    /** Get the node whose element is the smallest one in the tree.\n     * @return the tree node containing the smallest element in the tree\n     * or null if the tree is empty\n     * @see #getLargest\n     * @see #getNotSmaller\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getSmallest() {\n        return (top == null) ? null : top.getSmallest();\n    }\n\n    /** Get the node whose element is the largest one in the tree.\n     * @return the tree node containing the largest element in the tree\n     * or null if the tree is empty\n     * @see #getSmallest\n     * @see #getNotSmaller\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getLargest() {\n        return (top == null) ? null : top.getLargest();\n    }\n\n    /** Get the node whose element is not smaller than the reference object.\n     * @param reference reference object (may not be in the tree)\n     * @return the tree node containing the smallest element not smaller\n     * than the reference object or null if either the tree is empty or\n     * all its elements are smaller than the reference object\n     * @see #getSmallest\n     * @see #getLargest\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getNotSmaller(final T reference) {", "metadata": {"defects4j_task_id": "3c68d023d7f253a7da1685d12b486e01c593c632a79caa55412ace57a654f4af", "task_id": "apache_commons-math/54", "ground_truth": "\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) < 0) {\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            } else {\n                candidate = node;\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            }\n        }\n        return null;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "geometry", "partitioning", "utilities", "AVLTree.java"], "context_start_lineno": 0, "function_name": "getNotSmaller", "left_context": "class AVLTree<T extends Comparable<T>> {\n\n    /** Build an empty tree.\n     */\n    public AVLTree() {\n        top = null;\n    }\n\n    /** Insert an element in the tree.\n     * @param element element to insert (silently ignored if null)\n     */\n    public void insert(final T element) {\n        if (element != null) {\n            if (top == null) {\n                top = new Node(element, null);\n            } else {\n                top.insert(element);\n            }\n        }\n    }\n\n    /** Delete an element from the tree.\n     * <p>The element is deleted only if there is a node {@code n}\n     * containing exactly the element instance specified, i.e. for which\n     * {@code n.getElement() == element}. This is purposely\n     * <em>different</em> from the specification of the\n     * {@code java.util.Set} {@code remove} method (in fact,\n     * this is the reason why a specific class has been developed).</p>\n     * @param element element to delete (silently ignored if null)\n     * @return true if the element was deleted from the tree\n     */\n    public boolean delete(final T element) {\n        if (element != null) {\n            for (Node node = getNotSmaller(element); node != null; node = node.getNext()) {\n                // loop over all elements neither smaller nor larger\n                // than the specified one\n                if (node.element == element) {\n                    node.delete();\n                    return true;\n                } else if (node.element.compareTo(element) > 0) {\n                    // all the remaining elements are known to be larger,\n                    // the element is not in the tree\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n\n    /** Check if the tree is empty.\n     * @return true if the tree is empty\n     */\n    public boolean isEmpty() {\n        return top == null;\n    }\n\n\n    /** Get the number of elements of the tree.\n     * @return number of elements contained in the tree\n     */\n    public int size() {\n        return (top == null) ? 0 : top.size();\n    }\n\n    /** Get the node whose element is the smallest one in the tree.\n     * @return the tree node containing the smallest element in the tree\n     * or null if the tree is empty\n     * @see #getLargest\n     * @see #getNotSmaller\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getSmallest() {\n        return (top == null) ? null : top.getSmallest();\n    }\n\n    /** Get the node whose element is the largest one in the tree.\n     * @return the tree node containing the largest element in the tree\n     * or null if the tree is empty\n     * @see #getSmallest\n     * @see #getNotSmaller\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getLargest() {\n        return (top == null) ? null : top.getLargest();\n    }\n\n    /** Get the node whose element is not smaller than the reference object.\n     * @param reference reference object (may not be in the tree)\n     * @return the tree node containing the smallest element not smaller\n     * than the reference object or null if either the tree is empty or\n     * all its elements are smaller than the reference object\n     * @see #getSmallest\n     * @see #getLargest\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getNotSmaller(final T reference) {", "right_context": "}\n\n}", "class_name": "AVLTree", "return_type": "Node", "parameters": [{"type": "T", "name": "reference"}]}}
{"prompt": "class AVLTree<T extends Comparable<T>> {\n\n    /** Build an empty tree.\n     */\n    public AVLTree() {\n        top = null;\n    }\n\n    /** Insert an element in the tree.\n     * @param element element to insert (silently ignored if null)\n     */\n    public void insert(final T element) {\n        if (element != null) {\n            if (top == null) {\n                top = new Node(element, null);\n            } else {\n                top.insert(element);\n            }\n        }\n    }\n\n    /** Delete an element from the tree.\n     * <p>The element is deleted only if there is a node {@code n}\n     * containing exactly the element instance specified, i.e. for which\n     * {@code n.getElement() == element}. This is purposely\n     * <em>different</em> from the specification of the\n     * {@code java.util.Set} {@code remove} method (in fact,\n     * this is the reason why a specific class has been developed).</p>\n     * @param element element to delete (silently ignored if null)\n     * @return true if the element was deleted from the tree\n     */\n    public boolean delete(final T element) {\n        if (element != null) {\n            for (Node node = getNotSmaller(element); node != null; node = node.getNext()) {\n                // loop over all elements neither smaller nor larger\n                // than the specified one\n                if (node.element == element) {\n                    node.delete();\n                    return true;\n                } else if (node.element.compareTo(element) > 0) {\n                    // all the remaining elements are known to be larger,\n                    // the element is not in the tree\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n\n    /** Check if the tree is empty.\n     * @return true if the tree is empty\n     */\n    public boolean isEmpty() {\n        return top == null;\n    }\n\n\n    /** Get the number of elements of the tree.\n     * @return number of elements contained in the tree\n     */\n    public int size() {\n        return (top == null) ? 0 : top.size();\n    }\n\n    /** Get the node whose element is the smallest one in the tree.\n     * @return the tree node containing the smallest element in the tree\n     * or null if the tree is empty\n     * @see #getLargest\n     * @see #getNotSmaller\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getSmallest() {\n        return (top == null) ? null : top.getSmallest();\n    }\n\n    /** Get the node whose element is the largest one in the tree.\n     * @return the tree node containing the largest element in the tree\n     * or null if the tree is empty\n     * @see #getSmallest\n     * @see #getNotSmaller\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getLargest() {\n        return (top == null) ? null : top.getLargest();\n    }\n\n    /** Get the node whose element is not smaller than the reference object.\n     * @param reference reference object (may not be in the tree)\n     * @return the tree node containing the smallest element not smaller\n     * than the reference object or null if either the tree is empty or\n     * all its elements are smaller than the reference object\n     * @see #getSmallest\n     * @see #getLargest\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getNotSmaller(final T reference) {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) < 0) {\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            } else {\n                candidate = node;\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            }\n        }\n        return null;\n    }\n\n    /** Get the node whose element is not larger than the reference object.\n     * @param reference reference object (may not be in the tree)\n     * @return the tree node containing the largest element not larger\n     * than the reference object (in which case the node is guaranteed\n     * not to be empty) or null if either the tree is empty or all its\n     * elements are larger than the reference object\n     * @see #getSmallest\n     * @see #getLargest\n     * @see #getNotSmaller\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getNotLarger(final T reference) {", "metadata": {"defects4j_task_id": "623434d38959976f09a66939e17451c11a19bcd0ffef8bbac33dfd896e49967b", "task_id": "apache_commons-math/85", "ground_truth": "\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) > 0) {\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            } else {\n                candidate = node;\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            }\n        }\n        return null;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "geometry", "partitioning", "utilities", "AVLTree.java"], "context_start_lineno": 0, "function_name": "getNotLarger", "left_context": "class AVLTree<T extends Comparable<T>> {\n\n    /** Build an empty tree.\n     */\n    public AVLTree() {\n        top = null;\n    }\n\n    /** Insert an element in the tree.\n     * @param element element to insert (silently ignored if null)\n     */\n    public void insert(final T element) {\n        if (element != null) {\n            if (top == null) {\n                top = new Node(element, null);\n            } else {\n                top.insert(element);\n            }\n        }\n    }\n\n    /** Delete an element from the tree.\n     * <p>The element is deleted only if there is a node {@code n}\n     * containing exactly the element instance specified, i.e. for which\n     * {@code n.getElement() == element}. This is purposely\n     * <em>different</em> from the specification of the\n     * {@code java.util.Set} {@code remove} method (in fact,\n     * this is the reason why a specific class has been developed).</p>\n     * @param element element to delete (silently ignored if null)\n     * @return true if the element was deleted from the tree\n     */\n    public boolean delete(final T element) {\n        if (element != null) {\n            for (Node node = getNotSmaller(element); node != null; node = node.getNext()) {\n                // loop over all elements neither smaller nor larger\n                // than the specified one\n                if (node.element == element) {\n                    node.delete();\n                    return true;\n                } else if (node.element.compareTo(element) > 0) {\n                    // all the remaining elements are known to be larger,\n                    // the element is not in the tree\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n\n    /** Check if the tree is empty.\n     * @return true if the tree is empty\n     */\n    public boolean isEmpty() {\n        return top == null;\n    }\n\n\n    /** Get the number of elements of the tree.\n     * @return number of elements contained in the tree\n     */\n    public int size() {\n        return (top == null) ? 0 : top.size();\n    }\n\n    /** Get the node whose element is the smallest one in the tree.\n     * @return the tree node containing the smallest element in the tree\n     * or null if the tree is empty\n     * @see #getLargest\n     * @see #getNotSmaller\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getSmallest() {\n        return (top == null) ? null : top.getSmallest();\n    }\n\n    /** Get the node whose element is the largest one in the tree.\n     * @return the tree node containing the largest element in the tree\n     * or null if the tree is empty\n     * @see #getSmallest\n     * @see #getNotSmaller\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getLargest() {\n        return (top == null) ? null : top.getLargest();\n    }\n\n    /** Get the node whose element is not smaller than the reference object.\n     * @param reference reference object (may not be in the tree)\n     * @return the tree node containing the smallest element not smaller\n     * than the reference object or null if either the tree is empty or\n     * all its elements are smaller than the reference object\n     * @see #getSmallest\n     * @see #getLargest\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getNotSmaller(final T reference) {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) < 0) {\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            } else {\n                candidate = node;\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            }\n        }\n        return null;\n    }\n\n    /** Get the node whose element is not larger than the reference object.\n     * @param reference reference object (may not be in the tree)\n     * @return the tree node containing the largest element not larger\n     * than the reference object (in which case the node is guaranteed\n     * not to be empty) or null if either the tree is empty or all its\n     * elements are larger than the reference object\n     * @see #getSmallest\n     * @see #getLargest\n     * @see #getNotSmaller\n     * @see Node#getPrevious\n     * @see Node#getNext\n     */\n    public Node getNotLarger(final T reference) {", "right_context": "}\n\n}", "class_name": "AVLTree", "return_type": "Node", "parameters": [{"type": "T", "name": "reference"}]}}
{"prompt": "class KMeansPlusPlusClusterer<T extends Clusterable> extends Clusterer<T> {\n\n    /** Build a clusterer.\n     * <p>\n     * The default strategy for handling empty clusters that may appear during\n     * algorithm iterations is to split the cluster with largest distance variance.\n     * <p>\n     * The euclidean distance will be used as default distance measure.\n     *\n     * @param k the number of clusters to split the data into\n     * @param maxIterations the maximum number of iterations to run the algorithm for.\n     *   If negative, no maximum will be used.\n     */\n    public KMeansPlusPlusClusterer(final int k, final int maxIterations) {\n        this(k, maxIterations, new EuclideanDistance());\n    }\n\n    /** Build a clusterer.\n     * <p>\n     * The default strategy for handling empty clusters that may appear during\n     * algorithm iterations is to split the cluster with largest distance variance.\n     *\n     * @param k the number of clusters to split the data into\n     * @param maxIterations the maximum number of iterations to run the algorithm for.\n     *   If negative, no maximum will be used.\n     * @param measure the distance measure to use\n     */\n    public KMeansPlusPlusClusterer(final int k, final int maxIterations, final DistanceMeasure measure) {\n        this(k, maxIterations, measure, new JDKRandomGenerator());\n    }\n\n    /** Build a clusterer.\n     * <p>\n     * The default strategy for handling empty clusters that may appear during\n     * algorithm iterations is to split the cluster with largest distance variance.\n     *\n     * @param k the number of clusters to split the data into\n     * @param maxIterations the maximum number of iterations to run the algorithm for.\n     *   If negative, no maximum will be used.\n     * @param measure the distance measure to use\n     * @param random random generator to use for choosing initial centers\n     */\n    public KMeansPlusPlusClusterer(final int k, final int maxIterations,\n                                   final DistanceMeasure measure,\n                                   final RandomGenerator random) {\n        this(k, maxIterations, measure, random, EmptyClusterStrategy.LARGEST_VARIANCE);\n    }\n\n    /** Build a clusterer.\n     *\n     * @param k the number of clusters to split the data into\n     * @param maxIterations the maximum number of iterations to run the algorithm for.\n     *   If negative, no maximum will be used.\n     * @param measure the distance measure to use\n     * @param random random generator to use for choosing initial centers\n     * @param emptyStrategy strategy to use for handling empty clusters that\n     * may appear during algorithm iterations\n     */\n    public KMeansPlusPlusClusterer(final int k, final int maxIterations,\n                                   final DistanceMeasure measure,\n                                   final RandomGenerator random,\n                                   final EmptyClusterStrategy emptyStrategy) {\n        super(measure);\n        this.k             = k;\n        this.maxIterations = maxIterations;\n        this.random        = random;\n        this.emptyStrategy = emptyStrategy;\n    }\n\n    /**\n     * Return the number of clusters this instance will use.\n     * @return the number of clusters\n     */\n    public int getK() {\n        return k;\n    }\n\n    /**\n     * Returns the maximum number of iterations this instance will use.\n     * @return the maximum number of iterations, or -1 if no maximum is set\n     */\n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    /**\n     * Returns the random generator this instance will use.\n     * @return the random generator\n     */\n    public RandomGenerator getRandomGenerator() {\n        return random;\n    }\n\n    /**\n     * Returns the {@link EmptyClusterStrategy} used by this instance.\n     * @return the {@link EmptyClusterStrategy}\n     */\n    public EmptyClusterStrategy getEmptyClusterStrategy() {\n        return emptyStrategy;\n    }\n\n    /**\n     * Runs the K-means++ clustering algorithm.\n     *\n     * @param points the points to cluster\n     * @return a list of clusters containing the points\n     * @throws MathIllegalArgumentException if the data points are null or the number\n     *     of clusters is larger than the number of data points\n     * @throws ConvergenceException if an empty cluster is encountered and the\n     * {@link #emptyStrategy} is set to {@code ERROR}\n     */\n    @Override\n    public List<CentroidCluster<T>> cluster(final Collection<T> points)\n        throws MathIllegalArgumentException, ConvergenceException {\n\n        // sanity checks\n        MathUtils.checkNotNull(points);\n\n        // number of clusters has to be smaller or equal the number of data points\n        if (points.size() < k) {\n            throw new NumberIsTooSmallException(points.size(), k, false);\n        }\n\n        // create the initial clusters\n        List<CentroidCluster<T>> clusters = chooseInitialCenters(points);\n\n        // create an array containing the latest assignment of a point to a cluster\n        // no need to initialize the array, as it will be filled with the first assignment\n        int[] assignments = new int[points.size()];\n        assignPointsToClusters(clusters, points, assignments);\n\n        // iterate through updating the centers until we're done\n        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;\n        for (int count = 0; count < max; count++) {\n            boolean emptyCluster = false;\n            List<CentroidCluster<T>> newClusters = new ArrayList<CentroidCluster<T>>();\n            for (final CentroidCluster<T> cluster : clusters) {\n                final Clusterable newCenter;\n                if (cluster.getPoints().isEmpty()) {\n                    switch (emptyStrategy) {\n                        case LARGEST_VARIANCE :\n                            newCenter = getPointFromLargestVarianceCluster(clusters);\n                            break;\n                        case LARGEST_POINTS_NUMBER :\n                            newCenter = getPointFromLargestNumberCluster(clusters);\n                            break;\n                        case FARTHEST_POINT :\n                            newCenter = getFarthestPoint(clusters);\n                            break;\n                        default :\n                            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n                    }\n                    emptyCluster = true;\n                } else {\n                    newCenter = centroidOf(cluster.getPoints(), cluster.getCenter().getPoint().length);\n                }\n                newClusters.add(new CentroidCluster<T>(newCenter));\n            }\n            int changes = assignPointsToClusters(newClusters, points, assignments);\n            clusters = newClusters;\n\n            // if there were no more changes in the point-to-cluster assignment\n            // and there are no empty clusters left, return the current clusters\n            if (changes == 0 && !emptyCluster) {\n                return clusters;\n            }\n        }\n        return clusters;\n    }\n\n    /**\n     * Adds the given points to the closest {@link Cluster}.\n     *\n     * @param clusters the {@link Cluster}s to add the points to\n     * @param points the points to add to the given {@link Cluster}s\n     * @param assignments points assignments to clusters\n     * @return the number of points assigned to different clusters as the iteration before\n     */\n    private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments) {", "metadata": {"defects4j_task_id": "b62fc3ce91567104c5319e044f405eb240c897614fba471c077a870eeb1d0516", "task_id": "apache_commons-math/154", "ground_truth": "\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "ml", "clustering", "KMeansPlusPlusClusterer.java"], "context_start_lineno": 0, "function_name": "assignPointsToClusters", "left_context": "class KMeansPlusPlusClusterer<T extends Clusterable> extends Clusterer<T> {\n\n    /** Build a clusterer.\n     * <p>\n     * The default strategy for handling empty clusters that may appear during\n     * algorithm iterations is to split the cluster with largest distance variance.\n     * <p>\n     * The euclidean distance will be used as default distance measure.\n     *\n     * @param k the number of clusters to split the data into\n     * @param maxIterations the maximum number of iterations to run the algorithm for.\n     *   If negative, no maximum will be used.\n     */\n    public KMeansPlusPlusClusterer(final int k, final int maxIterations) {\n        this(k, maxIterations, new EuclideanDistance());\n    }\n\n    /** Build a clusterer.\n     * <p>\n     * The default strategy for handling empty clusters that may appear during\n     * algorithm iterations is to split the cluster with largest distance variance.\n     *\n     * @param k the number of clusters to split the data into\n     * @param maxIterations the maximum number of iterations to run the algorithm for.\n     *   If negative, no maximum will be used.\n     * @param measure the distance measure to use\n     */\n    public KMeansPlusPlusClusterer(final int k, final int maxIterations, final DistanceMeasure measure) {\n        this(k, maxIterations, measure, new JDKRandomGenerator());\n    }\n\n    /** Build a clusterer.\n     * <p>\n     * The default strategy for handling empty clusters that may appear during\n     * algorithm iterations is to split the cluster with largest distance variance.\n     *\n     * @param k the number of clusters to split the data into\n     * @param maxIterations the maximum number of iterations to run the algorithm for.\n     *   If negative, no maximum will be used.\n     * @param measure the distance measure to use\n     * @param random random generator to use for choosing initial centers\n     */\n    public KMeansPlusPlusClusterer(final int k, final int maxIterations,\n                                   final DistanceMeasure measure,\n                                   final RandomGenerator random) {\n        this(k, maxIterations, measure, random, EmptyClusterStrategy.LARGEST_VARIANCE);\n    }\n\n    /** Build a clusterer.\n     *\n     * @param k the number of clusters to split the data into\n     * @param maxIterations the maximum number of iterations to run the algorithm for.\n     *   If negative, no maximum will be used.\n     * @param measure the distance measure to use\n     * @param random random generator to use for choosing initial centers\n     * @param emptyStrategy strategy to use for handling empty clusters that\n     * may appear during algorithm iterations\n     */\n    public KMeansPlusPlusClusterer(final int k, final int maxIterations,\n                                   final DistanceMeasure measure,\n                                   final RandomGenerator random,\n                                   final EmptyClusterStrategy emptyStrategy) {\n        super(measure);\n        this.k             = k;\n        this.maxIterations = maxIterations;\n        this.random        = random;\n        this.emptyStrategy = emptyStrategy;\n    }\n\n    /**\n     * Return the number of clusters this instance will use.\n     * @return the number of clusters\n     */\n    public int getK() {\n        return k;\n    }\n\n    /**\n     * Returns the maximum number of iterations this instance will use.\n     * @return the maximum number of iterations, or -1 if no maximum is set\n     */\n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    /**\n     * Returns the random generator this instance will use.\n     * @return the random generator\n     */\n    public RandomGenerator getRandomGenerator() {\n        return random;\n    }\n\n    /**\n     * Returns the {@link EmptyClusterStrategy} used by this instance.\n     * @return the {@link EmptyClusterStrategy}\n     */\n    public EmptyClusterStrategy getEmptyClusterStrategy() {\n        return emptyStrategy;\n    }\n\n    /**\n     * Runs the K-means++ clustering algorithm.\n     *\n     * @param points the points to cluster\n     * @return a list of clusters containing the points\n     * @throws MathIllegalArgumentException if the data points are null or the number\n     *     of clusters is larger than the number of data points\n     * @throws ConvergenceException if an empty cluster is encountered and the\n     * {@link #emptyStrategy} is set to {@code ERROR}\n     */\n    @Override\n    public List<CentroidCluster<T>> cluster(final Collection<T> points)\n        throws MathIllegalArgumentException, ConvergenceException {\n\n        // sanity checks\n        MathUtils.checkNotNull(points);\n\n        // number of clusters has to be smaller or equal the number of data points\n        if (points.size() < k) {\n            throw new NumberIsTooSmallException(points.size(), k, false);\n        }\n\n        // create the initial clusters\n        List<CentroidCluster<T>> clusters = chooseInitialCenters(points);\n\n        // create an array containing the latest assignment of a point to a cluster\n        // no need to initialize the array, as it will be filled with the first assignment\n        int[] assignments = new int[points.size()];\n        assignPointsToClusters(clusters, points, assignments);\n\n        // iterate through updating the centers until we're done\n        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;\n        for (int count = 0; count < max; count++) {\n            boolean emptyCluster = false;\n            List<CentroidCluster<T>> newClusters = new ArrayList<CentroidCluster<T>>();\n            for (final CentroidCluster<T> cluster : clusters) {\n                final Clusterable newCenter;\n                if (cluster.getPoints().isEmpty()) {\n                    switch (emptyStrategy) {\n                        case LARGEST_VARIANCE :\n                            newCenter = getPointFromLargestVarianceCluster(clusters);\n                            break;\n                        case LARGEST_POINTS_NUMBER :\n                            newCenter = getPointFromLargestNumberCluster(clusters);\n                            break;\n                        case FARTHEST_POINT :\n                            newCenter = getFarthestPoint(clusters);\n                            break;\n                        default :\n                            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n                    }\n                    emptyCluster = true;\n                } else {\n                    newCenter = centroidOf(cluster.getPoints(), cluster.getCenter().getPoint().length);\n                }\n                newClusters.add(new CentroidCluster<T>(newCenter));\n            }\n            int changes = assignPointsToClusters(newClusters, points, assignments);\n            clusters = newClusters;\n\n            // if there were no more changes in the point-to-cluster assignment\n            // and there are no empty clusters left, return the current clusters\n            if (changes == 0 && !emptyCluster) {\n                return clusters;\n            }\n        }\n        return clusters;\n    }\n\n    /**\n     * Adds the given points to the closest {@link Cluster}.\n     *\n     * @param clusters the {@link Cluster}s to add the points to\n     * @param points the points to add to the given {@link Cluster}s\n     * @param assignments points assignments to clusters\n     * @return the number of points assigned to different clusters as the iteration before\n     */\n    private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments) {", "right_context": "}\n\n}", "class_name": "KMeansPlusPlusClusterer", "return_type": "int", "parameters": [{"type": "List<CentroidCluster<T>>", "name": "clusters"}, {"type": "Collection<T>", "name": "points"}, {"type": "int[]", "name": "assignments"}]}}
{"prompt": "class RandomDataGenerator implements RandomData, Serializable {\n\n    /**\n     * Generates a random value from the {@link BetaDistribution Beta Distribution}.\n     *\n     * @param alpha first distribution shape parameter\n     * @param beta second distribution shape parameter\n     * @return random value sampled from the beta(alpha, beta) distribution\n     */\n    public double nextBeta(double alpha, double beta) {\n        return new BetaDistribution(getRandomGenerator(), alpha, beta,\n                BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n    }\n\n    /**\n     * Generates a random value from the {@link BinomialDistribution Binomial Distribution}.\n     *\n     * @param numberOfTrials number of trials of the Binomial distribution\n     * @param probabilityOfSuccess probability of success of the Binomial distribution\n     * @return random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution\n     */\n    public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) {\n        return new BinomialDistribution(getRandomGenerator(), numberOfTrials, probabilityOfSuccess).sample();\n    }\n\n    /**\n     * Generates a random value from the {@link CauchyDistribution Cauchy Distribution}.\n     *\n     * @param median the median of the Cauchy distribution\n     * @param scale the scale parameter of the Cauchy distribution\n     * @return random value sampled from the Cauchy(median, scale) distribution\n     */\n    public double nextCauchy(double median, double scale) {\n        return new CauchyDistribution(getRandomGenerator(), median, scale,\n                CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n    }\n\n    /**\n     * Generates a random value from the {@link ChiSquaredDistribution ChiSquare Distribution}.\n     *\n     * @param df the degrees of freedom of the ChiSquare distribution\n     * @return random value sampled from the ChiSquare(df) distribution\n     */\n    public double nextChiSquare(double df) {\n        return new ChiSquaredDistribution(getRandomGenerator(), df,\n                ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n    }\n\n    /**\n     * Generates a random value from the {@link FDistribution F Distribution}.\n     *\n     * @param numeratorDf the numerator degrees of freedom of the F distribution\n     * @param denominatorDf the denominator degrees of freedom of the F distribution\n     * @return random value sampled from the F(numeratorDf, denominatorDf) distribution\n     * @throws NotStrictlyPositiveException if\n     * {@code numeratorDf <= 0} or {@code denominatorDf <= 0}.\n     */\n    public double nextF(double numeratorDf, double denominatorDf) throws NotStrictlyPositiveException {\n        return new FDistribution(getRandomGenerator(), numeratorDf, denominatorDf,\n                FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * <strong>Algorithm Description</strong>: scales the output of\n     * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n     * random double if Random.nextDouble() returns 0). This is necessary to\n     * provide a symmetric output interval (both endpoints excluded).\n     * </p>\n     * @throws NumberIsTooLargeException if {@code lower >= upper}\n     * @throws NotFiniteNumberException if one of the bounds is infinite\n     * @throws NotANumberException if one of the bounds is NaN\n     */\n    public double nextUniform(double lower, double upper)\n        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException {\n        return nextUniform(lower, upper, false);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * <strong>Algorithm Description</strong>: if the lower bound is excluded,\n     * scales the output of Random.nextDouble(), but rejects 0 values (i.e.,\n     * will generate another random double if Random.nextDouble() returns 0).\n     * This is necessary to provide a symmetric output interval (both\n     * endpoints excluded).\n     * </p>\n     *\n     * @throws NumberIsTooLargeException if {@code lower >= upper}\n     * @throws NotFiniteNumberException if one of the bounds is infinite\n     * @throws NotANumberException if one of the bounds is NaN\n     */\n    public double nextUniform(double lower, double upper, boolean lowerInclusive)\n        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException {\n\n        if (lower >= upper) {\n            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                lower, upper, false);\n        }\n\n        if (Double.isInfinite(lower)) {\n            throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, lower);\n        }\n        if (Double.isInfinite(upper)) {\n            throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, upper);\n        }\n\n        if (Double.isNaN(lower) || Double.isNaN(upper)) {\n            throw new NotANumberException();\n        }\n\n        final RandomGenerator generator = getRandomGenerator();\n\n        // ensure nextDouble() isn't 0.0\n        double u = generator.nextDouble();\n        while (!lowerInclusive && u <= 0.0) {\n            u = generator.nextDouble();\n        }\n\n        return u * upper + (1.0 - u) * lower;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * This method calls {@link MathArrays#shuffle(int[],RandomGenerator)\n     * MathArrays.shuffle} in order to create a random shuffle of the set\n     * of natural numbers {@code { 0, 1, ..., n - 1 }}.\n     *\n     * @throws NumberIsTooLargeException if {@code k > n}.\n     * @throws NotStrictlyPositiveException if {@code k <= 0}.\n     */\n    public int[] nextPermutation(int n, int k)\n        throws NumberIsTooLargeException, NotStrictlyPositiveException {\n        if (k > n) {\n            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                                k, n, true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                                   k);\n        }\n\n        int[] index = getNatural(n);\n        MathArrays.shuffle(index, getRandomGenerator());\n\n        // Return a new array containing the first \"k\" entries of \"index\".\n        return MathArrays.copyOf(index, k);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * This method calls {@link #nextPermutation(int,int) nextPermutation(c.size(), k)}\n     * in order to sample the collection.\n     */\n    public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException {", "metadata": {"defects4j_task_id": "8ff202bcd3545b87e680b5f56a8e2b0ff405733880ee0e3211d381329b9f3273", "task_id": "apache_commons-math/117", "ground_truth": "\n\n        int len = c.size();\n        if (k > len) {\n            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                                k, len, true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, k);\n        }\n\n        Object[] objects = c.toArray();\n        int[] index = nextPermutation(len, k);\n        Object[] result = new Object[k];\n        for (int i = 0; i < k; i++) {\n            result[i] = objects[index[i]];\n        }\n        return result;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "random", "RandomDataGenerator.java"], "context_start_lineno": 0, "function_name": "nextSample", "left_context": "class RandomDataGenerator implements RandomData, Serializable {\n\n    /**\n     * Generates a random value from the {@link BetaDistribution Beta Distribution}.\n     *\n     * @param alpha first distribution shape parameter\n     * @param beta second distribution shape parameter\n     * @return random value sampled from the beta(alpha, beta) distribution\n     */\n    public double nextBeta(double alpha, double beta) {\n        return new BetaDistribution(getRandomGenerator(), alpha, beta,\n                BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n    }\n\n    /**\n     * Generates a random value from the {@link BinomialDistribution Binomial Distribution}.\n     *\n     * @param numberOfTrials number of trials of the Binomial distribution\n     * @param probabilityOfSuccess probability of success of the Binomial distribution\n     * @return random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution\n     */\n    public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) {\n        return new BinomialDistribution(getRandomGenerator(), numberOfTrials, probabilityOfSuccess).sample();\n    }\n\n    /**\n     * Generates a random value from the {@link CauchyDistribution Cauchy Distribution}.\n     *\n     * @param median the median of the Cauchy distribution\n     * @param scale the scale parameter of the Cauchy distribution\n     * @return random value sampled from the Cauchy(median, scale) distribution\n     */\n    public double nextCauchy(double median, double scale) {\n        return new CauchyDistribution(getRandomGenerator(), median, scale,\n                CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n    }\n\n    /**\n     * Generates a random value from the {@link ChiSquaredDistribution ChiSquare Distribution}.\n     *\n     * @param df the degrees of freedom of the ChiSquare distribution\n     * @return random value sampled from the ChiSquare(df) distribution\n     */\n    public double nextChiSquare(double df) {\n        return new ChiSquaredDistribution(getRandomGenerator(), df,\n                ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n    }\n\n    /**\n     * Generates a random value from the {@link FDistribution F Distribution}.\n     *\n     * @param numeratorDf the numerator degrees of freedom of the F distribution\n     * @param denominatorDf the denominator degrees of freedom of the F distribution\n     * @return random value sampled from the F(numeratorDf, denominatorDf) distribution\n     * @throws NotStrictlyPositiveException if\n     * {@code numeratorDf <= 0} or {@code denominatorDf <= 0}.\n     */\n    public double nextF(double numeratorDf, double denominatorDf) throws NotStrictlyPositiveException {\n        return new FDistribution(getRandomGenerator(), numeratorDf, denominatorDf,\n                FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * <strong>Algorithm Description</strong>: scales the output of\n     * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n     * random double if Random.nextDouble() returns 0). This is necessary to\n     * provide a symmetric output interval (both endpoints excluded).\n     * </p>\n     * @throws NumberIsTooLargeException if {@code lower >= upper}\n     * @throws NotFiniteNumberException if one of the bounds is infinite\n     * @throws NotANumberException if one of the bounds is NaN\n     */\n    public double nextUniform(double lower, double upper)\n        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException {\n        return nextUniform(lower, upper, false);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * <strong>Algorithm Description</strong>: if the lower bound is excluded,\n     * scales the output of Random.nextDouble(), but rejects 0 values (i.e.,\n     * will generate another random double if Random.nextDouble() returns 0).\n     * This is necessary to provide a symmetric output interval (both\n     * endpoints excluded).\n     * </p>\n     *\n     * @throws NumberIsTooLargeException if {@code lower >= upper}\n     * @throws NotFiniteNumberException if one of the bounds is infinite\n     * @throws NotANumberException if one of the bounds is NaN\n     */\n    public double nextUniform(double lower, double upper, boolean lowerInclusive)\n        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException {\n\n        if (lower >= upper) {\n            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                lower, upper, false);\n        }\n\n        if (Double.isInfinite(lower)) {\n            throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, lower);\n        }\n        if (Double.isInfinite(upper)) {\n            throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, upper);\n        }\n\n        if (Double.isNaN(lower) || Double.isNaN(upper)) {\n            throw new NotANumberException();\n        }\n\n        final RandomGenerator generator = getRandomGenerator();\n\n        // ensure nextDouble() isn't 0.0\n        double u = generator.nextDouble();\n        while (!lowerInclusive && u <= 0.0) {\n            u = generator.nextDouble();\n        }\n\n        return u * upper + (1.0 - u) * lower;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * This method calls {@link MathArrays#shuffle(int[],RandomGenerator)\n     * MathArrays.shuffle} in order to create a random shuffle of the set\n     * of natural numbers {@code { 0, 1, ..., n - 1 }}.\n     *\n     * @throws NumberIsTooLargeException if {@code k > n}.\n     * @throws NotStrictlyPositiveException if {@code k <= 0}.\n     */\n    public int[] nextPermutation(int n, int k)\n        throws NumberIsTooLargeException, NotStrictlyPositiveException {\n        if (k > n) {\n            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                                k, n, true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                                   k);\n        }\n\n        int[] index = getNatural(n);\n        MathArrays.shuffle(index, getRandomGenerator());\n\n        // Return a new array containing the first \"k\" entries of \"index\".\n        return MathArrays.copyOf(index, k);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * This method calls {@link #nextPermutation(int,int) nextPermutation(c.size(), k)}\n     * in order to sample the collection.\n     */\n    public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException {", "right_context": "}\n}", "class_name": "RandomDataGenerator", "return_type": "Object[]", "parameters": [{"type": "Collection<?>", "name": "c"}, {"type": "int", "name": "k"}]}}
{"prompt": "class Percentile extends AbstractUnivariateStatistic implements Serializable {\n\n    /**\n     * Select the k<sup>th</sup> smallest element from work array\n     * @param work work array (will be reorganized during the call)\n     * @param pivotsHeap set of pivot index corresponding to elements that\n     * are already at their sorted location, stored as an implicit heap\n     * (i.e. a sorted binary tree stored in a flat array, where the\n     * children of a node at index n are at indices 2n+1 for the left\n     * child and 2n+2 for the right child, with 0-based indices)\n     * @param k index of the desired element\n     * @return k<sup>th</sup> smallest element\n     */\n    private double select(final double[] work, final int[] pivotsHeap, final int k) {\n\n        int begin = 0;\n        int end   = work.length;\n        int node  = 0;\n\n        while (end - begin > MIN_SELECT_SIZE) {\n\n            final int pivot;\n            if ((node < pivotsHeap.length) && (pivotsHeap[node] >= 0)) {\n                // the pivot has already been found in a previous call\n                // and the array has already been partitioned around it\n                pivot = pivotsHeap[node];\n            } else {\n                // select a pivot and partition work array around it\n                pivot = partition(work, begin, end, medianOf3(work, begin, end));\n                if (node < pivotsHeap.length) {\n                    pivotsHeap[node] =  pivot;\n                }\n            }\n\n            if (k == pivot) {\n                // the pivot was exactly the element we wanted\n                return work[k];\n            } else if (k < pivot) {\n                // the element is in the left partition\n                end  = pivot;\n                node = FastMath.min(2 * node + 1, pivotsHeap.length); // the min is here to avoid integer overflow\n            } else {\n                // the element is in the right partition\n                begin = pivot + 1;\n                node  = FastMath.min(2 * node + 2, pivotsHeap.length); // the min is here to avoid integer overflow\n            }\n\n        }\n\n        // the element is somewhere in the small sub-array\n        // sort the sub-array using insertion sort\n        insertionSort(work, begin, end);\n        return work[k];\n\n    }\n\n    /** Select a pivot index as the median of three\n     * @param work data array\n     * @param begin index of the first element of the slice\n     * @param end index after the last element of the slice\n     * @return the index of the median element chosen between the\n     * first, the middle and the last element of the array slice\n     */\n    int medianOf3(final double[] work, final int begin, final int end) {\n\n        final int inclusiveEnd = end - 1;\n        final int    middle    = begin + (inclusiveEnd - begin) / 2;\n        final double wBegin    = work[begin];\n        final double wMiddle   = work[middle];\n        final double wEnd      = work[inclusiveEnd];\n\n        if (wBegin < wMiddle) {\n            if (wMiddle < wEnd) {\n                return middle;\n            } else {\n                return (wBegin < wEnd) ? inclusiveEnd : begin;\n            }\n        } else {\n            if (wBegin < wEnd) {\n                return begin;\n            } else {\n                return (wMiddle < wEnd) ? inclusiveEnd : middle;\n            }\n        }\n\n    }\n\n    /**\n     * Partition an array slice around a pivot\n     * <p>\n     * Partitioning exchanges array elements such that all elements\n     * smaller than pivot are before it and all elements larger than\n     * pivot are after it\n     * </p>\n     * @param work data array\n     * @param begin index of the first element of the slice\n     * @param end index after the last element of the slice\n     * @param pivot initial index of the pivot\n     * @return index of the pivot after partition\n     */\n    private int partition(final double[] work, final int begin, final int end, final int pivot) {", "metadata": {"defects4j_task_id": "a358928a681f5cb3d8028ba98c044bfde4ca6356d11073164c2c3cdfc0d4fca5", "task_id": "apache_commons-math/134", "ground_truth": "\n\n        final double value = work[pivot];\n        work[pivot] = work[begin];\n\n        int i = begin + 1;\n        int j = end - 1;\n        while (i < j) {\n            while ((i < j) && (work[j] > value)) {\n                --j;\n            }\n            while ((i < j) && (work[i] < value)) {\n                ++i;\n            }\n\n            if (i < j) {\n                final double tmp = work[i];\n                work[i++] = work[j];\n                work[j--] = tmp;\n            }\n        }\n\n        if ((i >= end) || (work[i] > value)) {\n            --i;\n        }\n        work[begin] = work[i];\n        work[i]     = value;\n        return i;\n\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "stat", "descriptive", "rank", "Percentile.java"], "context_start_lineno": 0, "function_name": "partition", "left_context": "class Percentile extends AbstractUnivariateStatistic implements Serializable {\n\n    /**\n     * Select the k<sup>th</sup> smallest element from work array\n     * @param work work array (will be reorganized during the call)\n     * @param pivotsHeap set of pivot index corresponding to elements that\n     * are already at their sorted location, stored as an implicit heap\n     * (i.e. a sorted binary tree stored in a flat array, where the\n     * children of a node at index n are at indices 2n+1 for the left\n     * child and 2n+2 for the right child, with 0-based indices)\n     * @param k index of the desired element\n     * @return k<sup>th</sup> smallest element\n     */\n    private double select(final double[] work, final int[] pivotsHeap, final int k) {\n\n        int begin = 0;\n        int end   = work.length;\n        int node  = 0;\n\n        while (end - begin > MIN_SELECT_SIZE) {\n\n            final int pivot;\n            if ((node < pivotsHeap.length) && (pivotsHeap[node] >= 0)) {\n                // the pivot has already been found in a previous call\n                // and the array has already been partitioned around it\n                pivot = pivotsHeap[node];\n            } else {\n                // select a pivot and partition work array around it\n                pivot = partition(work, begin, end, medianOf3(work, begin, end));\n                if (node < pivotsHeap.length) {\n                    pivotsHeap[node] =  pivot;\n                }\n            }\n\n            if (k == pivot) {\n                // the pivot was exactly the element we wanted\n                return work[k];\n            } else if (k < pivot) {\n                // the element is in the left partition\n                end  = pivot;\n                node = FastMath.min(2 * node + 1, pivotsHeap.length); // the min is here to avoid integer overflow\n            } else {\n                // the element is in the right partition\n                begin = pivot + 1;\n                node  = FastMath.min(2 * node + 2, pivotsHeap.length); // the min is here to avoid integer overflow\n            }\n\n        }\n\n        // the element is somewhere in the small sub-array\n        // sort the sub-array using insertion sort\n        insertionSort(work, begin, end);\n        return work[k];\n\n    }\n\n    /** Select a pivot index as the median of three\n     * @param work data array\n     * @param begin index of the first element of the slice\n     * @param end index after the last element of the slice\n     * @return the index of the median element chosen between the\n     * first, the middle and the last element of the array slice\n     */\n    int medianOf3(final double[] work, final int begin, final int end) {\n\n        final int inclusiveEnd = end - 1;\n        final int    middle    = begin + (inclusiveEnd - begin) / 2;\n        final double wBegin    = work[begin];\n        final double wMiddle   = work[middle];\n        final double wEnd      = work[inclusiveEnd];\n\n        if (wBegin < wMiddle) {\n            if (wMiddle < wEnd) {\n                return middle;\n            } else {\n                return (wBegin < wEnd) ? inclusiveEnd : begin;\n            }\n        } else {\n            if (wBegin < wEnd) {\n                return begin;\n            } else {\n                return (wMiddle < wEnd) ? inclusiveEnd : middle;\n            }\n        }\n\n    }\n\n    /**\n     * Partition an array slice around a pivot\n     * <p>\n     * Partitioning exchanges array elements such that all elements\n     * smaller than pivot are before it and all elements larger than\n     * pivot are after it\n     * </p>\n     * @param work data array\n     * @param begin index of the first element of the slice\n     * @param end index after the last element of the slice\n     * @param pivot initial index of the pivot\n     * @return index of the pivot after partition\n     */\n    private int partition(final double[] work, final int begin, final int end, final int pivot) {", "right_context": "}\n\n}", "class_name": "Percentile", "return_type": "int", "parameters": [{"type": "double[]", "name": "work"}, {"type": "int", "name": "begin"}, {"type": "int", "name": "end"}, {"type": "int", "name": "pivot"}]}}
{"prompt": "class AggregateSummaryStatistics implements StatisticalSummary,\n        Serializable {\n\n\n    /**\n     * {@inheritDoc}.  This version returns the maximum over all the aggregated\n     * data.\n     *\n     * @see StatisticalSummary#getMax()\n     */\n    public double getMax() {\n        synchronized (statistics) {\n            return statistics.getMax();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns the mean of all the aggregated data.\n     *\n     * @see StatisticalSummary#getMean()\n     */\n    public double getMean() {\n        synchronized (statistics) {\n            return statistics.getMean();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns the minimum over all the aggregated\n     * data.\n     *\n     * @see StatisticalSummary#getMin()\n     */\n    public double getMin() {\n        synchronized (statistics) {\n            return statistics.getMin();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns a count of all the aggregated data.\n     *\n     * @see StatisticalSummary#getN()\n     */\n    public long getN() {\n        synchronized (statistics) {\n            return statistics.getN();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns the standard deviation of all the\n     * aggregated data.\n     *\n     * @see StatisticalSummary#getStandardDeviation()\n     */\n    public double getStandardDeviation() {\n        synchronized (statistics) {\n            return statistics.getStandardDeviation();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns a sum of all the aggregated data.\n     *\n     * @see StatisticalSummary#getSum()\n     */\n    public double getSum() {\n        synchronized (statistics) {\n            return statistics.getSum();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns the variance of all the aggregated\n     * data.\n     *\n     * @see StatisticalSummary#getVariance()\n     */\n    public double getVariance() {\n        synchronized (statistics) {\n            return statistics.getVariance();\n        }\n    }\n\n    /**\n     * Returns the sum of the logs of all the aggregated data.\n     *\n     * @return the sum of logs\n     * @see SummaryStatistics#getSumOfLogs()\n     */\n    public double getSumOfLogs() {\n        synchronized (statistics) {\n            return statistics.getSumOfLogs();\n        }\n    }\n\n    /**\n     * Returns the geometric mean of all the aggregated data.\n     *\n     * @return the geometric mean\n     * @see SummaryStatistics#getGeometricMean()\n     */\n    public double getGeometricMean() {\n        synchronized (statistics) {\n            return statistics.getGeometricMean();\n        }\n    }\n\n    /**\n     * Returns the sum of the squares of all the aggregated data.\n     *\n     * @return The sum of squares\n     * @see SummaryStatistics#getSumsq()\n     */\n    public double getSumsq() {\n        synchronized (statistics) {\n            return statistics.getSumsq();\n        }\n    }\n\n    /**\n     * Returns a statistic related to the Second Central Moment.  Specifically,\n     * what is returned is the sum of squared deviations from the sample mean\n     * among the all of the aggregated data.\n     *\n     * @return second central moment statistic\n     * @see SummaryStatistics#getSecondMoment()\n     */\n    public double getSecondMoment() {\n        synchronized (statistics) {\n            return statistics.getSecondMoment();\n        }\n    }\n\n    /**\n     * Return a {@link StatisticalSummaryValues} instance reporting current\n     * aggregate statistics.\n     *\n     * @return Current values of aggregate statistics\n     */\n    public StatisticalSummary getSummary() {\n        synchronized (statistics) {\n            return new StatisticalSummaryValues(getMean(), getVariance(), getN(),\n                    getMax(), getMin(), getSum());\n        }\n    }\n\n    /**\n     * Creates and returns a {@code SummaryStatistics} whose data will be\n     * aggregated with those of this {@code AggregateSummaryStatistics}.\n     *\n     * @return a {@code SummaryStatistics} whose data will be aggregated with\n     *      those of this {@code AggregateSummaryStatistics}.  The initial state\n     *      is a copy of the configured prototype statistics.\n     */\n    public SummaryStatistics createContributingStatistics() {\n        SummaryStatistics contributingStatistics\n                = new AggregatingSummaryStatistics(statistics);\n\n        // No try - catch or advertising NAE because neither argument will ever be null\n        SummaryStatistics.copy(statisticsPrototype, contributingStatistics);\n\n        return contributingStatistics;\n    }\n\n    /**\n     * Computes aggregate summary statistics. This method can be used to combine statistics\n     * computed over partitions or subsamples - i.e., the StatisticalSummaryValues returned\n     * should contain the same values that would have been obtained by computing a single\n     * StatisticalSummary over the combined dataset.\n     * <p>\n     * Returns null if the collection is empty or null.\n     * </p>\n     *\n     * @param statistics collection of SummaryStatistics to aggregate\n     * @return summary statistics for the combined dataset\n     */\n    public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics) {", "metadata": {"defects4j_task_id": "f22fc8d4c608a2606f396d7bb5ab88424fafc567d290f62a154d383ef58802d4", "task_id": "apache_commons-math/198", "ground_truth": "\n        if (statistics == null) {\n            return null;\n        }\n        Iterator<SummaryStatistics> iterator = statistics.iterator();\n        if (!iterator.hasNext()) {\n            return null;\n        }\n        SummaryStatistics current = iterator.next();\n        long n = current.getN();\n        double min = current.getMin();\n        double sum = current.getSum();\n        double max = current.getMax();\n        double m2 = current.getSecondMoment();\n        double mean = current.getMean();\n        while (iterator.hasNext()) {\n            current = iterator.next();\n            if (current.getMin() < min || Double.isNaN(min)) {\n                min = current.getMin();\n            }\n            if (current.getMax() > max || Double.isNaN(max)) {\n                max = current.getMax();\n            }\n            sum += current.getSum();\n            final double oldN = n;\n            final double curN = current.getN();\n            n += curN;\n            final double meanDiff = current.getMean() - mean;\n            mean = sum / n;\n            m2 = m2 + current.getSecondMoment() + meanDiff * meanDiff * oldN * curN / n;\n        }\n        final double variance;\n        if (n == 0) {\n            variance = Double.NaN;\n        } else if (n == 1) {\n            variance = 0d;\n        } else {\n            variance = m2 / (n - 1);\n        }\n        return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "stat", "descriptive", "AggregateSummaryStatistics.java"], "context_start_lineno": 0, "function_name": "aggregate", "left_context": "class AggregateSummaryStatistics implements StatisticalSummary,\n        Serializable {\n\n\n    /**\n     * {@inheritDoc}.  This version returns the maximum over all the aggregated\n     * data.\n     *\n     * @see StatisticalSummary#getMax()\n     */\n    public double getMax() {\n        synchronized (statistics) {\n            return statistics.getMax();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns the mean of all the aggregated data.\n     *\n     * @see StatisticalSummary#getMean()\n     */\n    public double getMean() {\n        synchronized (statistics) {\n            return statistics.getMean();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns the minimum over all the aggregated\n     * data.\n     *\n     * @see StatisticalSummary#getMin()\n     */\n    public double getMin() {\n        synchronized (statistics) {\n            return statistics.getMin();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns a count of all the aggregated data.\n     *\n     * @see StatisticalSummary#getN()\n     */\n    public long getN() {\n        synchronized (statistics) {\n            return statistics.getN();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns the standard deviation of all the\n     * aggregated data.\n     *\n     * @see StatisticalSummary#getStandardDeviation()\n     */\n    public double getStandardDeviation() {\n        synchronized (statistics) {\n            return statistics.getStandardDeviation();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns a sum of all the aggregated data.\n     *\n     * @see StatisticalSummary#getSum()\n     */\n    public double getSum() {\n        synchronized (statistics) {\n            return statistics.getSum();\n        }\n    }\n\n    /**\n     * {@inheritDoc}.  This version returns the variance of all the aggregated\n     * data.\n     *\n     * @see StatisticalSummary#getVariance()\n     */\n    public double getVariance() {\n        synchronized (statistics) {\n            return statistics.getVariance();\n        }\n    }\n\n    /**\n     * Returns the sum of the logs of all the aggregated data.\n     *\n     * @return the sum of logs\n     * @see SummaryStatistics#getSumOfLogs()\n     */\n    public double getSumOfLogs() {\n        synchronized (statistics) {\n            return statistics.getSumOfLogs();\n        }\n    }\n\n    /**\n     * Returns the geometric mean of all the aggregated data.\n     *\n     * @return the geometric mean\n     * @see SummaryStatistics#getGeometricMean()\n     */\n    public double getGeometricMean() {\n        synchronized (statistics) {\n            return statistics.getGeometricMean();\n        }\n    }\n\n    /**\n     * Returns the sum of the squares of all the aggregated data.\n     *\n     * @return The sum of squares\n     * @see SummaryStatistics#getSumsq()\n     */\n    public double getSumsq() {\n        synchronized (statistics) {\n            return statistics.getSumsq();\n        }\n    }\n\n    /**\n     * Returns a statistic related to the Second Central Moment.  Specifically,\n     * what is returned is the sum of squared deviations from the sample mean\n     * among the all of the aggregated data.\n     *\n     * @return second central moment statistic\n     * @see SummaryStatistics#getSecondMoment()\n     */\n    public double getSecondMoment() {\n        synchronized (statistics) {\n            return statistics.getSecondMoment();\n        }\n    }\n\n    /**\n     * Return a {@link StatisticalSummaryValues} instance reporting current\n     * aggregate statistics.\n     *\n     * @return Current values of aggregate statistics\n     */\n    public StatisticalSummary getSummary() {\n        synchronized (statistics) {\n            return new StatisticalSummaryValues(getMean(), getVariance(), getN(),\n                    getMax(), getMin(), getSum());\n        }\n    }\n\n    /**\n     * Creates and returns a {@code SummaryStatistics} whose data will be\n     * aggregated with those of this {@code AggregateSummaryStatistics}.\n     *\n     * @return a {@code SummaryStatistics} whose data will be aggregated with\n     *      those of this {@code AggregateSummaryStatistics}.  The initial state\n     *      is a copy of the configured prototype statistics.\n     */\n    public SummaryStatistics createContributingStatistics() {\n        SummaryStatistics contributingStatistics\n                = new AggregatingSummaryStatistics(statistics);\n\n        // No try - catch or advertising NAE because neither argument will ever be null\n        SummaryStatistics.copy(statisticsPrototype, contributingStatistics);\n\n        return contributingStatistics;\n    }\n\n    /**\n     * Computes aggregate summary statistics. This method can be used to combine statistics\n     * computed over partitions or subsamples - i.e., the StatisticalSummaryValues returned\n     * should contain the same values that would have been obtained by computing a single\n     * StatisticalSummary over the combined dataset.\n     * <p>\n     * Returns null if the collection is empty or null.\n     * </p>\n     *\n     * @param statistics collection of SummaryStatistics to aggregate\n     * @return summary statistics for the combined dataset\n     */\n    public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics) {", "right_context": "}\n}", "class_name": "AggregateSummaryStatistics", "return_type": "StatisticalSummaryValues", "parameters": [{"type": "Collection<SummaryStatistics>", "name": "statistics"}]}}
{"prompt": "class StatUtils {\n\n    /**\n     * Returns an estimate of the <code>p</code>th percentile of the values\n     * in the <code>values</code> array.\n     * <p>\n     * <ul>\n     * <li>Returns <code>Double.NaN</code> if <code>values</code> has length\n     * <code>0</code></li></p>\n     * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n     *  if <code>values</code> has length <code>1</code></li>\n     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n     * is null  or p is not a valid quantile value (p must be greater than 0\n     * and less than or equal to 100)</li>\n     * </ul></p>\n     * <p>\n     * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n     * a description of the percentile estimation algorithm used.</p>\n     *\n     * @param values input array of values\n     * @param p the percentile value to compute\n     * @return the percentile value or Double.NaN if the array is empty\n     * @throws MathIllegalArgumentException if <code>values</code> is null\n     * or p is invalid\n     */\n    public static double percentile(final double[] values, final double p)\n    throws MathIllegalArgumentException {\n            return PERCENTILE.evaluate(values,p);\n    }\n\n     /**\n     * Returns an estimate of the <code>p</code>th percentile of the values\n     * in the <code>values</code> array, starting with the element in (0-based)\n     * position <code>begin</code> in the array and including <code>length</code>\n     * values.\n     * <p>\n     * <ul>\n     * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n     * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n     *  if <code>length = 1 </code></li>\n     * <li>Throws <code>MathIllegalArgumentException</code> if <code>values</code>\n     *  is null , <code>begin</code> or <code>length</code> is invalid, or\n     * <code>p</code> is not a valid quantile value (p must be greater than 0\n     * and less than or equal to 100)</li>\n     * </ul></p>\n     * <p>\n     * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n     * a description of the percentile estimation algorithm used.</p>\n     *\n     * @param values array of input values\n     * @param p  the percentile to compute\n     * @param begin  the first (0-based) element to include in the computation\n     * @param length  the number of array elements to include\n     * @return  the percentile value\n     * @throws MathIllegalArgumentException if the parameters are not valid or the\n     * input array is null\n     */\n    public static double percentile(final double[] values, final int begin,\n            final int length, final double p) throws MathIllegalArgumentException {\n        return PERCENTILE.evaluate(values, begin, length, p);\n    }\n\n    /**\n     * Returns the sum of the (signed) differences between corresponding elements of the\n     * input arrays -- i.e., sum(sample1[i] - sample2[i]).\n     *\n     * @param sample1  the first array\n     * @param sample2  the second array\n     * @return sum of paired differences\n     * @throws DimensionMismatchException if the arrays do not have the same\n     * (positive) length.\n     * @throws NoDataException if the sample arrays are empty.\n     */\n    public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 0) {\n            throw new NoDataException(LocalizedFormats.INSUFFICIENT_DIMENSION);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += sample1[i] - sample2[i];\n        }\n        return result;\n    }\n\n    /**\n     * Returns the mean of the (signed) differences between corresponding elements of the\n     * input arrays -- i.e., sum(sample1[i] - sample2[i]) / sample1.length.\n     *\n     * @param sample1  the first array\n     * @param sample2  the second array\n     * @return mean of paired differences\n     * @throws DimensionMismatchException if the arrays do not have the same\n     * (positive) length.\n     * @throws NoDataException if the sample arrays are empty.\n     */\n    public static double meanDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException{\n        return sumDifference(sample1, sample2) / sample1.length;\n    }\n\n    /**\n     * Returns the variance of the (signed) differences between corresponding elements of the\n     * input arrays -- i.e., var(sample1[i] - sample2[i]).\n     *\n     * @param sample1  the first array\n     * @param sample2  the second array\n     * @param meanDifference   the mean difference between corresponding entries\n     * @see #meanDifference(double[],double[])\n     * @return variance of paired differences\n     * @throws DimensionMismatchException if the arrays do not have the same\n     * length.\n     * @throws NumberIsTooSmallException if the arrays length is less than 2.\n     */\n    public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException {", "metadata": {"defects4j_task_id": "f35920cd05f23d07e01831a70bc26b90969ea3b8869e1e5be3177d22b8c48d38", "task_id": "apache_commons-math/199", "ground_truth": "\n        double sum1 = 0d;\n        double sum2 = 0d;\n        double diff = 0d;\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        for (int i = 0; i < n; i++) {\n            diff = sample1[i] - sample2[i];\n            sum1 += (diff - meanDifference) *(diff - meanDifference);\n            sum2 += diff - meanDifference;\n        }\n        return (sum1 - (sum2 * sum2 / n)) / (n - 1);\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "stat", "StatUtils.java"], "context_start_lineno": 0, "function_name": "varianceDifference", "left_context": "class StatUtils {\n\n    /**\n     * Returns an estimate of the <code>p</code>th percentile of the values\n     * in the <code>values</code> array.\n     * <p>\n     * <ul>\n     * <li>Returns <code>Double.NaN</code> if <code>values</code> has length\n     * <code>0</code></li></p>\n     * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n     *  if <code>values</code> has length <code>1</code></li>\n     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n     * is null  or p is not a valid quantile value (p must be greater than 0\n     * and less than or equal to 100)</li>\n     * </ul></p>\n     * <p>\n     * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n     * a description of the percentile estimation algorithm used.</p>\n     *\n     * @param values input array of values\n     * @param p the percentile value to compute\n     * @return the percentile value or Double.NaN if the array is empty\n     * @throws MathIllegalArgumentException if <code>values</code> is null\n     * or p is invalid\n     */\n    public static double percentile(final double[] values, final double p)\n    throws MathIllegalArgumentException {\n            return PERCENTILE.evaluate(values,p);\n    }\n\n     /**\n     * Returns an estimate of the <code>p</code>th percentile of the values\n     * in the <code>values</code> array, starting with the element in (0-based)\n     * position <code>begin</code> in the array and including <code>length</code>\n     * values.\n     * <p>\n     * <ul>\n     * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n     * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n     *  if <code>length = 1 </code></li>\n     * <li>Throws <code>MathIllegalArgumentException</code> if <code>values</code>\n     *  is null , <code>begin</code> or <code>length</code> is invalid, or\n     * <code>p</code> is not a valid quantile value (p must be greater than 0\n     * and less than or equal to 100)</li>\n     * </ul></p>\n     * <p>\n     * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n     * a description of the percentile estimation algorithm used.</p>\n     *\n     * @param values array of input values\n     * @param p  the percentile to compute\n     * @param begin  the first (0-based) element to include in the computation\n     * @param length  the number of array elements to include\n     * @return  the percentile value\n     * @throws MathIllegalArgumentException if the parameters are not valid or the\n     * input array is null\n     */\n    public static double percentile(final double[] values, final int begin,\n            final int length, final double p) throws MathIllegalArgumentException {\n        return PERCENTILE.evaluate(values, begin, length, p);\n    }\n\n    /**\n     * Returns the sum of the (signed) differences between corresponding elements of the\n     * input arrays -- i.e., sum(sample1[i] - sample2[i]).\n     *\n     * @param sample1  the first array\n     * @param sample2  the second array\n     * @return sum of paired differences\n     * @throws DimensionMismatchException if the arrays do not have the same\n     * (positive) length.\n     * @throws NoDataException if the sample arrays are empty.\n     */\n    public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 0) {\n            throw new NoDataException(LocalizedFormats.INSUFFICIENT_DIMENSION);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += sample1[i] - sample2[i];\n        }\n        return result;\n    }\n\n    /**\n     * Returns the mean of the (signed) differences between corresponding elements of the\n     * input arrays -- i.e., sum(sample1[i] - sample2[i]) / sample1.length.\n     *\n     * @param sample1  the first array\n     * @param sample2  the second array\n     * @return mean of paired differences\n     * @throws DimensionMismatchException if the arrays do not have the same\n     * (positive) length.\n     * @throws NoDataException if the sample arrays are empty.\n     */\n    public static double meanDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException{\n        return sumDifference(sample1, sample2) / sample1.length;\n    }\n\n    /**\n     * Returns the variance of the (signed) differences between corresponding elements of the\n     * input arrays -- i.e., var(sample1[i] - sample2[i]).\n     *\n     * @param sample1  the first array\n     * @param sample2  the second array\n     * @param meanDifference   the mean difference between corresponding entries\n     * @see #meanDifference(double[],double[])\n     * @return variance of paired differences\n     * @throws DimensionMismatchException if the arrays do not have the same\n     * length.\n     * @throws NumberIsTooSmallException if the arrays length is less than 2.\n     */\n    public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException {", "right_context": "}\n\n}", "class_name": "StatUtils", "return_type": "double", "parameters": [{"type": "double[]", "name": "sample1"}, {"type": "double[]", "name": "sample2"}, {"type": "double", "name": "meanDifference"}]}}
{"prompt": "class NaturalRanking implements RankingAlgorithm {\n\n    /**\n     * Returns an array that is a copy of the input array with IntDoublePairs\n     * having NaN values removed.\n     *\n     * @param ranks input array\n     * @return array with NaN-valued entries removed\n     */\n    private IntDoublePair[] removeNaNs(IntDoublePair[] ranks) {\n        if (!containsNaNs(ranks)) {\n            return ranks;\n        }\n        IntDoublePair[] outRanks = new IntDoublePair[ranks.length];\n        int j = 0;\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                // drop, but adjust original ranks of later elements\n                for (int k = i + 1; k < ranks.length; k++) {\n                    ranks[k] = new IntDoublePair(\n                            ranks[k].getValue(), ranks[k].getPosition() - 1);\n                }\n            } else {\n                outRanks[j] = new IntDoublePair(\n                        ranks[i].getValue(), ranks[i].getPosition());\n                j++;\n            }\n        }\n        IntDoublePair[] returnRanks = new IntDoublePair[j];\n        System.arraycopy(outRanks, 0, returnRanks, 0, j);\n        return returnRanks;\n    }\n\n    /**\n     * Recodes NaN values to the given value.\n     *\n     * @param ranks array to recode\n     * @param value the value to replace NaNs with\n     */\n    private void recodeNaNs(IntDoublePair[] ranks, double value) {\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                ranks[i] = new IntDoublePair(\n                        value, ranks[i].getPosition());\n            }\n        }\n    }\n\n    /**\n     * Checks for presence of NaNs in <code>ranks.</code>\n     *\n     * @param ranks array to be searched for NaNs\n     * @return true iff ranks contains one or more NaNs\n     */\n    private boolean containsNaNs(IntDoublePair[] ranks) {\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Resolve a sequence of ties, using the configured {@link TiesStrategy}.\n     * The input <code>ranks</code> array is expected to take the same value\n     * for all indices in <code>tiesTrace</code>.  The common value is recoded\n     * according to the tiesStrategy. For example, if ranks = <5,8,2,6,2,7,1,2>,\n     * tiesTrace = <2,4,7> and tiesStrategy is MINIMUM, ranks will be unchanged.\n     * The same array and trace with tiesStrategy AVERAGE will come out\n     * <5,8,3,6,3,7,1,3>.\n     *\n     * @param ranks array of ranks\n     * @param tiesTrace list of indices where <code>ranks</code> is constant\n     * -- that is, for any i and j in TiesTrace, <code> ranks[i] == ranks[j]\n     * </code>\n     */\n    private void resolveTie(double[] ranks, List<Integer> tiesTrace) {\n\n        // constant value of ranks over tiesTrace\n        final double c = ranks[tiesTrace.get(0)];\n\n        // length of sequence of tied ranks\n        final int length = tiesTrace.size();\n\n        switch (tiesStrategy) {\n            case  AVERAGE:  // Replace ranks with average\n                fill(ranks, tiesTrace, (2 * c + length - 1) / 2d);\n                break;\n            case MAXIMUM:   // Replace ranks with maximum values\n                fill(ranks, tiesTrace, c + length - 1);\n                break;\n            case MINIMUM:   // Replace ties with minimum\n                fill(ranks, tiesTrace, c);\n                break;\n            case RANDOM:    // Fill with random integral values in [c, c + length - 1]\n                Iterator<Integer> iterator = tiesTrace.iterator();\n                long f = FastMath.round(c);\n                while (iterator.hasNext()) {\n                    // No advertised exception because args are guaranteed valid\n                    ranks[iterator.next()] =\n                        randomData.nextLong(f, f + length - 1);\n                }\n                break;\n            case SEQUENTIAL:  // Fill sequentially from c to c + length - 1\n                // walk and fill\n                iterator = tiesTrace.iterator();\n                f = FastMath.round(c);\n                int i = 0;\n                while (iterator.hasNext()) {\n                    ranks[iterator.next()] = f + i++;\n                }\n                break;\n            default: // this should not happen unless TiesStrategy enum is changed\n                throw new MathInternalError();\n        }\n    }\n\n    /**\n     * Sets<code>data[i] = value</code> for each i in <code>tiesTrace.</code>\n     *\n     * @param data array to modify\n     * @param tiesTrace list of index values to set\n     * @param value value to set\n     */\n    private void fill(double[] data, List<Integer> tiesTrace, double value) {\n        Iterator<Integer> iterator = tiesTrace.iterator();\n        while (iterator.hasNext()) {\n            data[iterator.next()] = value;\n        }\n    }\n\n    /**\n     * Set <code>ranks[i] = Double.NaN</code> for each i in <code>nanPositions.</code>\n     *\n     * @param ranks array to modify\n     * @param nanPositions list of index values to set to <code>Double.NaN</code>\n     */\n    private void restoreNaNs(double[] ranks, List<Integer> nanPositions) {\n        if (nanPositions.size() == 0) {\n            return;\n        }\n        Iterator<Integer> iterator = nanPositions.iterator();\n        while (iterator.hasNext()) {\n            ranks[iterator.next().intValue()] = Double.NaN;\n        }\n\n    }\n\n    /**\n     * Returns a list of indexes where <code>ranks</code> is <code>NaN.</code>\n     *\n     * @param ranks array to search for <code>NaNs</code>\n     * @return list of indexes i such that <code>ranks[i] = NaN</code>\n     */\n    private List<Integer> getNanPositions(IntDoublePair[] ranks) {", "metadata": {"defects4j_task_id": "ae142d614c3b745fe06ce33cbe6584a669afaa5cf45ecca916b85ca1b0d8458d", "task_id": "apache_commons-math/147", "ground_truth": "\n        ArrayList<Integer> out = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                out.add(Integer.valueOf(i));\n            }\n        }\n        return out;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "stat", "ranking", "NaturalRanking.java"], "context_start_lineno": 0, "function_name": "getNanPositions", "left_context": "class NaturalRanking implements RankingAlgorithm {\n\n    /**\n     * Returns an array that is a copy of the input array with IntDoublePairs\n     * having NaN values removed.\n     *\n     * @param ranks input array\n     * @return array with NaN-valued entries removed\n     */\n    private IntDoublePair[] removeNaNs(IntDoublePair[] ranks) {\n        if (!containsNaNs(ranks)) {\n            return ranks;\n        }\n        IntDoublePair[] outRanks = new IntDoublePair[ranks.length];\n        int j = 0;\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                // drop, but adjust original ranks of later elements\n                for (int k = i + 1; k < ranks.length; k++) {\n                    ranks[k] = new IntDoublePair(\n                            ranks[k].getValue(), ranks[k].getPosition() - 1);\n                }\n            } else {\n                outRanks[j] = new IntDoublePair(\n                        ranks[i].getValue(), ranks[i].getPosition());\n                j++;\n            }\n        }\n        IntDoublePair[] returnRanks = new IntDoublePair[j];\n        System.arraycopy(outRanks, 0, returnRanks, 0, j);\n        return returnRanks;\n    }\n\n    /**\n     * Recodes NaN values to the given value.\n     *\n     * @param ranks array to recode\n     * @param value the value to replace NaNs with\n     */\n    private void recodeNaNs(IntDoublePair[] ranks, double value) {\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                ranks[i] = new IntDoublePair(\n                        value, ranks[i].getPosition());\n            }\n        }\n    }\n\n    /**\n     * Checks for presence of NaNs in <code>ranks.</code>\n     *\n     * @param ranks array to be searched for NaNs\n     * @return true iff ranks contains one or more NaNs\n     */\n    private boolean containsNaNs(IntDoublePair[] ranks) {\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Resolve a sequence of ties, using the configured {@link TiesStrategy}.\n     * The input <code>ranks</code> array is expected to take the same value\n     * for all indices in <code>tiesTrace</code>.  The common value is recoded\n     * according to the tiesStrategy. For example, if ranks = <5,8,2,6,2,7,1,2>,\n     * tiesTrace = <2,4,7> and tiesStrategy is MINIMUM, ranks will be unchanged.\n     * The same array and trace with tiesStrategy AVERAGE will come out\n     * <5,8,3,6,3,7,1,3>.\n     *\n     * @param ranks array of ranks\n     * @param tiesTrace list of indices where <code>ranks</code> is constant\n     * -- that is, for any i and j in TiesTrace, <code> ranks[i] == ranks[j]\n     * </code>\n     */\n    private void resolveTie(double[] ranks, List<Integer> tiesTrace) {\n\n        // constant value of ranks over tiesTrace\n        final double c = ranks[tiesTrace.get(0)];\n\n        // length of sequence of tied ranks\n        final int length = tiesTrace.size();\n\n        switch (tiesStrategy) {\n            case  AVERAGE:  // Replace ranks with average\n                fill(ranks, tiesTrace, (2 * c + length - 1) / 2d);\n                break;\n            case MAXIMUM:   // Replace ranks with maximum values\n                fill(ranks, tiesTrace, c + length - 1);\n                break;\n            case MINIMUM:   // Replace ties with minimum\n                fill(ranks, tiesTrace, c);\n                break;\n            case RANDOM:    // Fill with random integral values in [c, c + length - 1]\n                Iterator<Integer> iterator = tiesTrace.iterator();\n                long f = FastMath.round(c);\n                while (iterator.hasNext()) {\n                    // No advertised exception because args are guaranteed valid\n                    ranks[iterator.next()] =\n                        randomData.nextLong(f, f + length - 1);\n                }\n                break;\n            case SEQUENTIAL:  // Fill sequentially from c to c + length - 1\n                // walk and fill\n                iterator = tiesTrace.iterator();\n                f = FastMath.round(c);\n                int i = 0;\n                while (iterator.hasNext()) {\n                    ranks[iterator.next()] = f + i++;\n                }\n                break;\n            default: // this should not happen unless TiesStrategy enum is changed\n                throw new MathInternalError();\n        }\n    }\n\n    /**\n     * Sets<code>data[i] = value</code> for each i in <code>tiesTrace.</code>\n     *\n     * @param data array to modify\n     * @param tiesTrace list of index values to set\n     * @param value value to set\n     */\n    private void fill(double[] data, List<Integer> tiesTrace, double value) {\n        Iterator<Integer> iterator = tiesTrace.iterator();\n        while (iterator.hasNext()) {\n            data[iterator.next()] = value;\n        }\n    }\n\n    /**\n     * Set <code>ranks[i] = Double.NaN</code> for each i in <code>nanPositions.</code>\n     *\n     * @param ranks array to modify\n     * @param nanPositions list of index values to set to <code>Double.NaN</code>\n     */\n    private void restoreNaNs(double[] ranks, List<Integer> nanPositions) {\n        if (nanPositions.size() == 0) {\n            return;\n        }\n        Iterator<Integer> iterator = nanPositions.iterator();\n        while (iterator.hasNext()) {\n            ranks[iterator.next().intValue()] = Double.NaN;\n        }\n\n    }\n\n    /**\n     * Returns a list of indexes where <code>ranks</code> is <code>NaN.</code>\n     *\n     * @param ranks array to search for <code>NaNs</code>\n     * @return list of indexes i such that <code>ranks[i] = NaN</code>\n     */\n    private List<Integer> getNanPositions(IntDoublePair[] ranks) {", "right_context": "}\n}", "class_name": "NaturalRanking", "return_type": "List<Integer>", "parameters": [{"type": "IntDoublePair[]", "name": "ranks"}]}}
{"prompt": "class Covariance {\n\n    /** Number of observations (length of covariate vectors) */\n    private final int n;\n\n    /**\n     * Create a Covariance with no data\n     */\n    public Covariance() {\n        super();\n        covarianceMatrix = null;\n        n = 0;\n    }\n\n    /**\n     * Create a Covariance matrix from a rectangular array\n     * whose columns represent covariates.\n     *\n     * <p>The <code>biasCorrected</code> parameter determines whether or not\n     * covariance estimates are bias-corrected.</p>\n     *\n     * <p>The input array must be rectangular with at least one column\n     * and two rows.</p>\n     *\n     * @param data rectangular array with columns representing covariates\n     * @param biasCorrected true means covariances are bias-corrected\n     * @throws MathIllegalArgumentException if the input data array is not\n     * rectangular with at least two rows and one column.\n     * @throws NotStrictlyPositiveException if the input data array is not\n     * rectangular with at least one row and one column.\n     */\n    public Covariance(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n        this(new BlockRealMatrix(data), biasCorrected);\n    }\n\n    /**\n     * Create a Covariance matrix from a rectangular array\n     * whose columns represent covariates.\n     *\n     * <p>The input array must be rectangular with at least one column\n     * and two rows</p>\n     *\n     * @param data rectangular array with columns representing covariates\n     * @throws MathIllegalArgumentException if the input data array is not\n     * rectangular with at least two rows and one column.\n     * @throws NotStrictlyPositiveException if the input data array is not\n     * rectangular with at least one row and one column.\n     */\n    public Covariance(double[][] data)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n        this(data, true);\n    }\n\n    /**\n     * Create a covariance matrix from a matrix whose columns\n     * represent covariates.\n     *\n     * <p>The <code>biasCorrected</code> parameter determines whether or not\n     * covariance estimates are bias-corrected.</p>\n     *\n     * <p>The matrix must have at least one column and two rows</p>\n     *\n     * @param matrix matrix with columns representing covariates\n     * @param biasCorrected true means covariances are bias-corrected\n     * @throws MathIllegalArgumentException if the input matrix does not have\n     * at least two rows and one column\n     */\n    public Covariance(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException {\n       checkSufficientData(matrix);\n       n = matrix.getRowDimension();\n       covarianceMatrix = computeCovarianceMatrix(matrix, biasCorrected);\n    }\n\n    /**\n     * Create a covariance matrix from a matrix whose columns\n     * represent covariates.\n     *\n     * <p>The matrix must have at least one column and two rows</p>\n     *\n     * @param matrix matrix with columns representing covariates\n     * @throws MathIllegalArgumentException if the input matrix does not have\n     * at least two rows and one column\n     */\n    public Covariance(RealMatrix matrix) throws MathIllegalArgumentException {\n        this(matrix, true);\n    }\n\n    /**\n     * Returns the covariance matrix\n     *\n     * @return covariance matrix\n     */\n    public RealMatrix getCovarianceMatrix() {\n        return covarianceMatrix;\n    }\n\n    /**\n     * Returns the number of observations (length of covariate vectors)\n     *\n     * @return number of observations\n     */\n    public int getN() {\n        return n;\n    }\n\n    /**\n     * Compute a covariance matrix from a matrix whose columns represent\n     * covariates.\n     * @param matrix input matrix (must have at least one column and two rows)\n     * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n     * @return covariance matrix\n     * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n     */\n    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException {", "metadata": {"defects4j_task_id": "869a9afc9a9f5d2b433d47a68c9979a114ec11bf22195a04b19cbae5e339c310", "task_id": "apache_commons-math/111", "ground_truth": "\n        int dimension = matrix.getColumnDimension();\n        Variance variance = new Variance(biasCorrected);\n        RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);\n        for (int i = 0; i < dimension; i++) {\n            for (int j = 0; j < i; j++) {\n              double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n              outMatrix.setEntry(i, j, cov);\n              outMatrix.setEntry(j, i, cov);\n            }\n            outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));\n        }\n        return outMatrix;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "stat", "correlation", "Covariance.java"], "context_start_lineno": 0, "function_name": "computeCovarianceMatrix", "left_context": "class Covariance {\n\n    /** Number of observations (length of covariate vectors) */\n    private final int n;\n\n    /**\n     * Create a Covariance with no data\n     */\n    public Covariance() {\n        super();\n        covarianceMatrix = null;\n        n = 0;\n    }\n\n    /**\n     * Create a Covariance matrix from a rectangular array\n     * whose columns represent covariates.\n     *\n     * <p>The <code>biasCorrected</code> parameter determines whether or not\n     * covariance estimates are bias-corrected.</p>\n     *\n     * <p>The input array must be rectangular with at least one column\n     * and two rows.</p>\n     *\n     * @param data rectangular array with columns representing covariates\n     * @param biasCorrected true means covariances are bias-corrected\n     * @throws MathIllegalArgumentException if the input data array is not\n     * rectangular with at least two rows and one column.\n     * @throws NotStrictlyPositiveException if the input data array is not\n     * rectangular with at least one row and one column.\n     */\n    public Covariance(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n        this(new BlockRealMatrix(data), biasCorrected);\n    }\n\n    /**\n     * Create a Covariance matrix from a rectangular array\n     * whose columns represent covariates.\n     *\n     * <p>The input array must be rectangular with at least one column\n     * and two rows</p>\n     *\n     * @param data rectangular array with columns representing covariates\n     * @throws MathIllegalArgumentException if the input data array is not\n     * rectangular with at least two rows and one column.\n     * @throws NotStrictlyPositiveException if the input data array is not\n     * rectangular with at least one row and one column.\n     */\n    public Covariance(double[][] data)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n        this(data, true);\n    }\n\n    /**\n     * Create a covariance matrix from a matrix whose columns\n     * represent covariates.\n     *\n     * <p>The <code>biasCorrected</code> parameter determines whether or not\n     * covariance estimates are bias-corrected.</p>\n     *\n     * <p>The matrix must have at least one column and two rows</p>\n     *\n     * @param matrix matrix with columns representing covariates\n     * @param biasCorrected true means covariances are bias-corrected\n     * @throws MathIllegalArgumentException if the input matrix does not have\n     * at least two rows and one column\n     */\n    public Covariance(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException {\n       checkSufficientData(matrix);\n       n = matrix.getRowDimension();\n       covarianceMatrix = computeCovarianceMatrix(matrix, biasCorrected);\n    }\n\n    /**\n     * Create a covariance matrix from a matrix whose columns\n     * represent covariates.\n     *\n     * <p>The matrix must have at least one column and two rows</p>\n     *\n     * @param matrix matrix with columns representing covariates\n     * @throws MathIllegalArgumentException if the input matrix does not have\n     * at least two rows and one column\n     */\n    public Covariance(RealMatrix matrix) throws MathIllegalArgumentException {\n        this(matrix, true);\n    }\n\n    /**\n     * Returns the covariance matrix\n     *\n     * @return covariance matrix\n     */\n    public RealMatrix getCovarianceMatrix() {\n        return covarianceMatrix;\n    }\n\n    /**\n     * Returns the number of observations (length of covariate vectors)\n     *\n     * @return number of observations\n     */\n    public int getN() {\n        return n;\n    }\n\n    /**\n     * Compute a covariance matrix from a matrix whose columns represent\n     * covariates.\n     * @param matrix input matrix (must have at least one column and two rows)\n     * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n     * @return covariance matrix\n     * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n     */\n    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException {", "right_context": "}\n}", "class_name": "Covariance", "return_type": "RealMatrix", "parameters": [{"type": "RealMatrix", "name": "matrix"}, {"type": "boolean", "name": "biasCorrected"}]}}
{"prompt": "class Covariance {\n\n    /**\n     * Create a Covariance matrix from a rectangular array\n     * whose columns represent covariates.\n     *\n     * <p>The input array must be rectangular with at least one column\n     * and two rows</p>\n     *\n     * @param data rectangular array with columns representing covariates\n     * @throws MathIllegalArgumentException if the input data array is not\n     * rectangular with at least two rows and one column.\n     * @throws NotStrictlyPositiveException if the input data array is not\n     * rectangular with at least one row and one column.\n     */\n    public Covariance(double[][] data)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n        this(data, true);\n    }\n\n    /**\n     * Create a covariance matrix from a matrix whose columns\n     * represent covariates.\n     *\n     * <p>The <code>biasCorrected</code> parameter determines whether or not\n     * covariance estimates are bias-corrected.</p>\n     *\n     * <p>The matrix must have at least one column and two rows</p>\n     *\n     * @param matrix matrix with columns representing covariates\n     * @param biasCorrected true means covariances are bias-corrected\n     * @throws MathIllegalArgumentException if the input matrix does not have\n     * at least two rows and one column\n     */\n    public Covariance(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException {\n       checkSufficientData(matrix);\n       n = matrix.getRowDimension();\n       covarianceMatrix = computeCovarianceMatrix(matrix, biasCorrected);\n    }\n\n    /**\n     * Create a covariance matrix from a matrix whose columns\n     * represent covariates.\n     *\n     * <p>The matrix must have at least one column and two rows</p>\n     *\n     * @param matrix matrix with columns representing covariates\n     * @throws MathIllegalArgumentException if the input matrix does not have\n     * at least two rows and one column\n     */\n    public Covariance(RealMatrix matrix) throws MathIllegalArgumentException {\n        this(matrix, true);\n    }\n\n    /**\n     * Returns the covariance matrix\n     *\n     * @return covariance matrix\n     */\n    public RealMatrix getCovarianceMatrix() {\n        return covarianceMatrix;\n    }\n\n    /**\n     * Returns the number of observations (length of covariate vectors)\n     *\n     * @return number of observations\n     */\n    public int getN() {\n        return n;\n    }\n\n    /**\n     * Compute a covariance matrix from a matrix whose columns represent\n     * covariates.\n     * @param matrix input matrix (must have at least one column and two rows)\n     * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n     * @return covariance matrix\n     * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n     */\n    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException {\n        int dimension = matrix.getColumnDimension();\n        Variance variance = new Variance(biasCorrected);\n        RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);\n        for (int i = 0; i < dimension; i++) {\n            for (int j = 0; j < i; j++) {\n              double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n              outMatrix.setEntry(i, j, cov);\n              outMatrix.setEntry(j, i, cov);\n            }\n            outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));\n        }\n        return outMatrix;\n    }\n\n    /**\n     * Create a covariance matrix from a matrix whose columns represent\n     * covariates. Covariances are computed using the bias-corrected formula.\n     * @param matrix input matrix (must have at least one column and two rows)\n     * @return covariance matrix\n     * @throws MathIllegalArgumentException if matrix does not contain sufficient data\n     * @see #Covariance\n     */\n    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix)\n    throws MathIllegalArgumentException {\n        return computeCovarianceMatrix(matrix, true);\n    }\n\n    /**\n     * Compute a covariance matrix from a rectangular array whose columns represent\n     * covariates.\n     * @param data input array (must have at least one column and two rows)\n     * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n     * @return covariance matrix\n     * @throws MathIllegalArgumentException if the data array does not contain sufficient\n     * data\n     * @throws NotStrictlyPositiveException if the input data array is not\n     * rectangular with at least one row and one column.\n     */\n    protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n        return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\n    }\n\n    /**\n     * Create a covariance matrix from a rectangular array whose columns represent\n     * covariates. Covariances are computed using the bias-corrected formula.\n     * @param data input array (must have at least one column and two rows)\n     * @return covariance matrix\n     * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n     * @throws NotStrictlyPositiveException if the input data array is not\n     * rectangular with at least one row and one column.\n     * @see #Covariance\n     */\n    protected RealMatrix computeCovarianceMatrix(double[][] data)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n        return computeCovarianceMatrix(data, true);\n    }\n\n    /**\n     * Computes the covariance between the two arrays.\n     *\n     * <p>Array lengths must match and the common length must be at least 2.</p>\n     *\n     * @param xArray first data array\n     * @param yArray second data array\n     * @param biasCorrected if true, returned value will be bias-corrected\n     * @return returns the covariance for the two arrays\n     * @throws  MathIllegalArgumentException if the arrays lengths do not match or\n     * there is insufficient data\n     */\n    public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException {", "metadata": {"defects4j_task_id": "b735b9586f967bd62ae22356a6dda97c94a21d0529afda18893cf1d3a0325c53", "task_id": "apache_commons-math/155", "ground_truth": "\n        Mean mean = new Mean();\n        double result = 0d;\n        int length = xArray.length;\n        if (length != yArray.length) {\n            throw new MathIllegalArgumentException(\n                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, length, yArray.length);\n        } else if (length < 2) {\n            throw new MathIllegalArgumentException(\n                  LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE, length, 2);\n        } else {\n            double xMean = mean.evaluate(xArray);\n            double yMean = mean.evaluate(yArray);\n            for (int i = 0; i < length; i++) {\n                double xDev = xArray[i] - xMean;\n                double yDev = yArray[i] - yMean;\n                result += (xDev * yDev - result) / (i + 1);\n            }\n        }\n        return biasCorrected ? result * ((double) length / (double)(length - 1)) : result;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "stat", "correlation", "Covariance.java"], "context_start_lineno": 0, "function_name": "covariance", "left_context": "class Covariance {\n\n    /**\n     * Create a Covariance matrix from a rectangular array\n     * whose columns represent covariates.\n     *\n     * <p>The input array must be rectangular with at least one column\n     * and two rows</p>\n     *\n     * @param data rectangular array with columns representing covariates\n     * @throws MathIllegalArgumentException if the input data array is not\n     * rectangular with at least two rows and one column.\n     * @throws NotStrictlyPositiveException if the input data array is not\n     * rectangular with at least one row and one column.\n     */\n    public Covariance(double[][] data)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n        this(data, true);\n    }\n\n    /**\n     * Create a covariance matrix from a matrix whose columns\n     * represent covariates.\n     *\n     * <p>The <code>biasCorrected</code> parameter determines whether or not\n     * covariance estimates are bias-corrected.</p>\n     *\n     * <p>The matrix must have at least one column and two rows</p>\n     *\n     * @param matrix matrix with columns representing covariates\n     * @param biasCorrected true means covariances are bias-corrected\n     * @throws MathIllegalArgumentException if the input matrix does not have\n     * at least two rows and one column\n     */\n    public Covariance(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException {\n       checkSufficientData(matrix);\n       n = matrix.getRowDimension();\n       covarianceMatrix = computeCovarianceMatrix(matrix, biasCorrected);\n    }\n\n    /**\n     * Create a covariance matrix from a matrix whose columns\n     * represent covariates.\n     *\n     * <p>The matrix must have at least one column and two rows</p>\n     *\n     * @param matrix matrix with columns representing covariates\n     * @throws MathIllegalArgumentException if the input matrix does not have\n     * at least two rows and one column\n     */\n    public Covariance(RealMatrix matrix) throws MathIllegalArgumentException {\n        this(matrix, true);\n    }\n\n    /**\n     * Returns the covariance matrix\n     *\n     * @return covariance matrix\n     */\n    public RealMatrix getCovarianceMatrix() {\n        return covarianceMatrix;\n    }\n\n    /**\n     * Returns the number of observations (length of covariate vectors)\n     *\n     * @return number of observations\n     */\n    public int getN() {\n        return n;\n    }\n\n    /**\n     * Compute a covariance matrix from a matrix whose columns represent\n     * covariates.\n     * @param matrix input matrix (must have at least one column and two rows)\n     * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n     * @return covariance matrix\n     * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n     */\n    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException {\n        int dimension = matrix.getColumnDimension();\n        Variance variance = new Variance(biasCorrected);\n        RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);\n        for (int i = 0; i < dimension; i++) {\n            for (int j = 0; j < i; j++) {\n              double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n              outMatrix.setEntry(i, j, cov);\n              outMatrix.setEntry(j, i, cov);\n            }\n            outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));\n        }\n        return outMatrix;\n    }\n\n    /**\n     * Create a covariance matrix from a matrix whose columns represent\n     * covariates. Covariances are computed using the bias-corrected formula.\n     * @param matrix input matrix (must have at least one column and two rows)\n     * @return covariance matrix\n     * @throws MathIllegalArgumentException if matrix does not contain sufficient data\n     * @see #Covariance\n     */\n    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix)\n    throws MathIllegalArgumentException {\n        return computeCovarianceMatrix(matrix, true);\n    }\n\n    /**\n     * Compute a covariance matrix from a rectangular array whose columns represent\n     * covariates.\n     * @param data input array (must have at least one column and two rows)\n     * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n     * @return covariance matrix\n     * @throws MathIllegalArgumentException if the data array does not contain sufficient\n     * data\n     * @throws NotStrictlyPositiveException if the input data array is not\n     * rectangular with at least one row and one column.\n     */\n    protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n        return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\n    }\n\n    /**\n     * Create a covariance matrix from a rectangular array whose columns represent\n     * covariates. Covariances are computed using the bias-corrected formula.\n     * @param data input array (must have at least one column and two rows)\n     * @return covariance matrix\n     * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n     * @throws NotStrictlyPositiveException if the input data array is not\n     * rectangular with at least one row and one column.\n     * @see #Covariance\n     */\n    protected RealMatrix computeCovarianceMatrix(double[][] data)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n        return computeCovarianceMatrix(data, true);\n    }\n\n    /**\n     * Computes the covariance between the two arrays.\n     *\n     * <p>Array lengths must match and the common length must be at least 2.</p>\n     *\n     * @param xArray first data array\n     * @param yArray second data array\n     * @param biasCorrected if true, returned value will be bias-corrected\n     * @return returns the covariance for the two arrays\n     * @throws  MathIllegalArgumentException if the arrays lengths do not match or\n     * there is insufficient data\n     */\n    public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException {", "right_context": "}\n}", "class_name": "Covariance", "return_type": "double", "parameters": [{"type": "double[]", "name": "xArray"}, {"type": "double[]", "name": "yArray"}, {"type": "boolean", "name": "biasCorrected"}]}}
{"prompt": "class OLSMultipleLinearRegression extends AbstractMultipleLinearRegression {\n\n    /**\n     * <p>Returns the sum of squared deviations of Y from its mean.</p>\n     *\n     * <p>If the model has no intercept term, <code>0</code> is used for the\n     * mean of Y - i.e., what is returned is the sum of the squared Y values.</p>\n     *\n     * <p>The value returned by this method is the SSTO value used in\n     * the {@link #calculateRSquared() R-squared} computation.</p>\n     *\n     * @return SSTO - the total sum of squares\n     * @throws MathIllegalArgumentException if the sample has not been set or does\n     * not contain at least 3 observations\n     * @see #isNoIntercept()\n     * @since 2.2\n     */\n    public double calculateTotalSumOfSquares() throws MathIllegalArgumentException {\n        if (isNoIntercept()) {\n            return StatUtils.sumSq(getY().toArray());\n        } else {\n            return new SecondMoment().evaluate(getY().toArray());\n        }\n    }\n\n    /**\n     * Returns the sum of squared residuals.\n     *\n     * @return residual sum of squares\n     * @since 2.2\n     */\n    public double calculateResidualSumOfSquares() {\n        final RealVector residuals = calculateResiduals();\n        // No advertised DME, args are valid\n        return residuals.dotProduct(residuals);\n    }\n\n    /**\n     * Returns the R-Squared statistic, defined by the formula <pre>\n     * R<sup>2</sup> = 1 - SSR / SSTO\n     * </pre>\n     * where SSR is the {@link #calculateResidualSumOfSquares() sum of squared residuals}\n     * and SSTO is the {@link #calculateTotalSumOfSquares() total sum of squares}\n     *\n     * @return R-square statistic\n     * @throws MathIllegalArgumentException if the sample has not been set or does\n     * not contain at least 3 observations\n     * @since 2.2\n     */\n    public double calculateRSquared() throws MathIllegalArgumentException {\n        return 1 - calculateResidualSumOfSquares() / calculateTotalSumOfSquares();\n    }\n\n    /**\n     * <p>Returns the adjusted R-squared statistic, defined by the formula <pre>\n     * R<sup>2</sup><sub>adj</sub> = 1 - [SSR (n - 1)] / [SSTO (n - p)]\n     * </pre>\n     * where SSR is the {@link #calculateResidualSumOfSquares() sum of squared residuals},\n     * SSTO is the {@link #calculateTotalSumOfSquares() total sum of squares}, n is the number\n     * of observations and p is the number of parameters estimated (including the intercept).</p>\n     *\n     * <p>If the regression is estimated without an intercept term, what is returned is <pre>\n     * <code> 1 - (1 - {@link #calculateRSquared()}) * (n / (n - p)) </code>\n     * </pre></p>\n     *\n     * @return adjusted R-Squared statistic\n     * @throws MathIllegalArgumentException if the sample has not been set or does\n     * not contain at least 3 observations\n     * @see #isNoIntercept()\n     * @since 2.2\n     */\n    public double calculateAdjustedRSquared() throws MathIllegalArgumentException {\n        final double n = getX().getRowDimension();\n        if (isNoIntercept()) {\n            return 1 - (1 - calculateRSquared()) * (n / (n - getX().getColumnDimension()));\n        } else {\n            return 1 - (calculateResidualSumOfSquares() * (n - 1)) /\n                (calculateTotalSumOfSquares() * (n - getX().getColumnDimension()));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>This implementation computes and caches the QR decomposition of the X matrix\n     * once it is successfully loaded.</p>\n     */\n    @Override\n    protected void newXSampleData(double[][] x) {\n        super.newXSampleData(x);\n        qr = new QRDecomposition(getX());\n    }\n\n    /**\n     * Calculates the regression coefficients using OLS.\n     *\n     * <p>Data for the model must have been successfully loaded using one of\n     * the {@code newSampleData} methods before invoking this method; otherwise\n     * a {@code NullPointerException} will be thrown.</p>\n     *\n     * @return beta\n     */\n    @Override\n    protected RealVector calculateBeta() {\n        return qr.getSolver().solve(getY());\n    }\n\n    /**\n     * <p>Calculates the variance-covariance matrix of the regression parameters.\n     * </p>\n     * <p>Var(b) = (X<sup>T</sup>X)<sup>-1</sup>\n     * </p>\n     * <p>Uses QR decomposition to reduce (X<sup>T</sup>X)<sup>-1</sup>\n     * to (R<sup>T</sup>R)<sup>-1</sup>, with only the top p rows of\n     * R included, where p = the length of the beta vector.</p>\n     *\n     * <p>Data for the model must have been successfully loaded using one of\n     * the {@code newSampleData} methods before invoking this method; otherwise\n     * a {@code NullPointerException} will be thrown.</p>\n     *\n     * @return The beta variance-covariance matrix\n     */\n    @Override\n    protected RealMatrix calculateBetaVariance() {", "metadata": {"defects4j_task_id": "9de8e59276409f2e8b2d3d1aa48bb193e92ba1ba744e48fa0955ee201df4b2bc", "task_id": "apache_commons-math/128", "ground_truth": "\n        int p = getX().getColumnDimension();\n        RealMatrix Raug = qr.getR().getSubMatrix(0, p - 1 , 0, p - 1);\n        RealMatrix Rinv = new LUDecomposition(Raug).getSolver().getInverse();\n        return Rinv.multiply(Rinv.transpose());\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "stat", "regression", "OLSMultipleLinearRegression.java"], "context_start_lineno": 0, "function_name": "calculateBetaVariance", "left_context": "class OLSMultipleLinearRegression extends AbstractMultipleLinearRegression {\n\n    /**\n     * <p>Returns the sum of squared deviations of Y from its mean.</p>\n     *\n     * <p>If the model has no intercept term, <code>0</code> is used for the\n     * mean of Y - i.e., what is returned is the sum of the squared Y values.</p>\n     *\n     * <p>The value returned by this method is the SSTO value used in\n     * the {@link #calculateRSquared() R-squared} computation.</p>\n     *\n     * @return SSTO - the total sum of squares\n     * @throws MathIllegalArgumentException if the sample has not been set or does\n     * not contain at least 3 observations\n     * @see #isNoIntercept()\n     * @since 2.2\n     */\n    public double calculateTotalSumOfSquares() throws MathIllegalArgumentException {\n        if (isNoIntercept()) {\n            return StatUtils.sumSq(getY().toArray());\n        } else {\n            return new SecondMoment().evaluate(getY().toArray());\n        }\n    }\n\n    /**\n     * Returns the sum of squared residuals.\n     *\n     * @return residual sum of squares\n     * @since 2.2\n     */\n    public double calculateResidualSumOfSquares() {\n        final RealVector residuals = calculateResiduals();\n        // No advertised DME, args are valid\n        return residuals.dotProduct(residuals);\n    }\n\n    /**\n     * Returns the R-Squared statistic, defined by the formula <pre>\n     * R<sup>2</sup> = 1 - SSR / SSTO\n     * </pre>\n     * where SSR is the {@link #calculateResidualSumOfSquares() sum of squared residuals}\n     * and SSTO is the {@link #calculateTotalSumOfSquares() total sum of squares}\n     *\n     * @return R-square statistic\n     * @throws MathIllegalArgumentException if the sample has not been set or does\n     * not contain at least 3 observations\n     * @since 2.2\n     */\n    public double calculateRSquared() throws MathIllegalArgumentException {\n        return 1 - calculateResidualSumOfSquares() / calculateTotalSumOfSquares();\n    }\n\n    /**\n     * <p>Returns the adjusted R-squared statistic, defined by the formula <pre>\n     * R<sup>2</sup><sub>adj</sub> = 1 - [SSR (n - 1)] / [SSTO (n - p)]\n     * </pre>\n     * where SSR is the {@link #calculateResidualSumOfSquares() sum of squared residuals},\n     * SSTO is the {@link #calculateTotalSumOfSquares() total sum of squares}, n is the number\n     * of observations and p is the number of parameters estimated (including the intercept).</p>\n     *\n     * <p>If the regression is estimated without an intercept term, what is returned is <pre>\n     * <code> 1 - (1 - {@link #calculateRSquared()}) * (n / (n - p)) </code>\n     * </pre></p>\n     *\n     * @return adjusted R-Squared statistic\n     * @throws MathIllegalArgumentException if the sample has not been set or does\n     * not contain at least 3 observations\n     * @see #isNoIntercept()\n     * @since 2.2\n     */\n    public double calculateAdjustedRSquared() throws MathIllegalArgumentException {\n        final double n = getX().getRowDimension();\n        if (isNoIntercept()) {\n            return 1 - (1 - calculateRSquared()) * (n / (n - getX().getColumnDimension()));\n        } else {\n            return 1 - (calculateResidualSumOfSquares() * (n - 1)) /\n                (calculateTotalSumOfSquares() * (n - getX().getColumnDimension()));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>This implementation computes and caches the QR decomposition of the X matrix\n     * once it is successfully loaded.</p>\n     */\n    @Override\n    protected void newXSampleData(double[][] x) {\n        super.newXSampleData(x);\n        qr = new QRDecomposition(getX());\n    }\n\n    /**\n     * Calculates the regression coefficients using OLS.\n     *\n     * <p>Data for the model must have been successfully loaded using one of\n     * the {@code newSampleData} methods before invoking this method; otherwise\n     * a {@code NullPointerException} will be thrown.</p>\n     *\n     * @return beta\n     */\n    @Override\n    protected RealVector calculateBeta() {\n        return qr.getSolver().solve(getY());\n    }\n\n    /**\n     * <p>Calculates the variance-covariance matrix of the regression parameters.\n     * </p>\n     * <p>Var(b) = (X<sup>T</sup>X)<sup>-1</sup>\n     * </p>\n     * <p>Uses QR decomposition to reduce (X<sup>T</sup>X)<sup>-1</sup>\n     * to (R<sup>T</sup>R)<sup>-1</sup>, with only the top p rows of\n     * R included, where p = the length of the beta vector.</p>\n     *\n     * <p>Data for the model must have been successfully loaded using one of\n     * the {@code newSampleData} methods before invoking this method; otherwise\n     * a {@code NullPointerException} will be thrown.</p>\n     *\n     * @return The beta variance-covariance matrix\n     */\n    @Override\n    protected RealMatrix calculateBetaVariance() {", "right_context": "}}\n\n}", "class_name": "OLSMultipleLinearRegression", "return_type": "RealMatrix", "parameters": []}}
{"prompt": "class GLSMultipleLinearRegression extends AbstractMultipleLinearRegression {\n\n    /** Covariance matrix. */\n    private RealMatrix Omega;\n\n    /** Inverse of covariance matrix. */\n    private RealMatrix OmegaInverse;\n\n    /** Replace sample data, overriding any previous sample.\n     * @param y y values of the sample\n     * @param x x values of the sample\n     * @param covariance array representing the covariance matrix\n     */\n    public void newSampleData(double[] y, double[][] x, double[][] covariance) {\n        validateSampleData(x, y);\n        newYSampleData(y);\n        newXSampleData(x);\n        validateCovarianceData(x, covariance);\n        newCovarianceData(covariance);\n    }\n\n    /**\n     * Add the covariance data.\n     *\n     * @param omega the [n,n] array representing the covariance\n     */\n    protected void newCovarianceData(double[][] omega){\n        this.Omega = new Array2DRowRealMatrix(omega);\n        this.OmegaInverse = null;\n    }\n\n    /**\n     * Get the inverse of the covariance.\n     * <p>The inverse of the covariance matrix is lazily evaluated and cached.</p>\n     * @return inverse of the covariance\n     */\n    protected RealMatrix getOmegaInverse() {\n        if (OmegaInverse == null) {\n            OmegaInverse = new LUDecomposition(Omega).getSolver().getInverse();\n        }\n        return OmegaInverse;\n    }\n\n    /**\n     * Calculates beta by GLS.\n     * <pre>\n     *  b=(X' Omega^-1 X)^-1X'Omega^-1 y\n     * </pre>\n     * @return beta\n     */\n    @Override\n    protected RealVector calculateBeta() {", "metadata": {"defects4j_task_id": "a7318d4434fb14e162a0390b5b43571e49717911e4885cd7a254fd313ec44d0b", "task_id": "apache_commons-math/139", "ground_truth": "\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOIX = XT.multiply(OI).multiply(getX());\n        RealMatrix inverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return inverse.multiply(XT).multiply(OI).operate(getY());\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "stat", "regression", "GLSMultipleLinearRegression.java"], "context_start_lineno": 0, "function_name": "calculateBeta", "left_context": "class GLSMultipleLinearRegression extends AbstractMultipleLinearRegression {\n\n    /** Covariance matrix. */\n    private RealMatrix Omega;\n\n    /** Inverse of covariance matrix. */\n    private RealMatrix OmegaInverse;\n\n    /** Replace sample data, overriding any previous sample.\n     * @param y y values of the sample\n     * @param x x values of the sample\n     * @param covariance array representing the covariance matrix\n     */\n    public void newSampleData(double[] y, double[][] x, double[][] covariance) {\n        validateSampleData(x, y);\n        newYSampleData(y);\n        newXSampleData(x);\n        validateCovarianceData(x, covariance);\n        newCovarianceData(covariance);\n    }\n\n    /**\n     * Add the covariance data.\n     *\n     * @param omega the [n,n] array representing the covariance\n     */\n    protected void newCovarianceData(double[][] omega){\n        this.Omega = new Array2DRowRealMatrix(omega);\n        this.OmegaInverse = null;\n    }\n\n    /**\n     * Get the inverse of the covariance.\n     * <p>The inverse of the covariance matrix is lazily evaluated and cached.</p>\n     * @return inverse of the covariance\n     */\n    protected RealMatrix getOmegaInverse() {\n        if (OmegaInverse == null) {\n            OmegaInverse = new LUDecomposition(Omega).getSolver().getInverse();\n        }\n        return OmegaInverse;\n    }\n\n    /**\n     * Calculates beta by GLS.\n     * <pre>\n     *  b=(X' Omega^-1 X)^-1X'Omega^-1 y\n     * </pre>\n     * @return beta\n     */\n    @Override\n    protected RealVector calculateBeta() {", "right_context": "}\n\n    /**\n     * Calculates the variance on the beta.\n     * <pre>\n     *  Var(b)=(X' Omega^-1 X)^-1\n     * </pre>\n     * @return The beta variance matrix\n     */\n    @Override\n    protected RealMatrix calculateBetaVariance() {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        return new LUDecomposition(XTOIX).getSolver().getInverse();\n    }\n\n\n    /**\n     * Calculates the estimated variance of the error term using the formula\n     * <pre>\n     *  Var(u) = Tr(u' Omega^-1 u)/(n-k)\n     * </pre>\n     * where n and k are the row and column dimensions of the design\n     * matrix X.\n     *\n     * @return error variance\n     * @since 2.2\n     */\n    @Override\n    protected double calculateErrorVariance() {\n        RealVector residuals = calculateResiduals();\n        double t = residuals.dotProduct(getOmegaInverse().operate(residuals));\n        return t / (getX().getRowDimension() - getX().getColumnDimension());\n\n    }\n\n}", "class_name": "GLSMultipleLinearRegression", "return_type": "RealVector", "parameters": []}}
{"prompt": "class PolynomialFunctionNewtonForm implements UnivariateDifferentiableFunction {\n\n    /**\n     * The coefficients of the polynomial, ordered by degree -- i.e.\n     * coefficients[0] is the constant term and coefficients[n] is the\n     * coefficient of x^n where n is the degree of the polynomial.\n     */\n    private double coefficients[];\n\n    /**\n     * Centers of the Newton polynomial.\n     */\n    private final double c[];\n\n    /**\n     * When all c[i] = 0, a[] becomes normal polynomial coefficients,\n     * i.e. a[i] = coefficients[i].\n     */\n    private final double a[];\n\n    /**\n     * Whether the polynomial coefficients are available.\n     */\n    private boolean coefficientsComputed;\n\n    /**\n     * Construct a Newton polynomial with the given a[] and c[]. The order of\n     * centers are important in that if c[] shuffle, then values of a[] would\n     * completely change, not just a permutation of old a[].\n     * <p>\n     * The constructor makes copy of the input arrays and assigns them.</p>\n     *\n     * @param a Coefficients in Newton form formula.\n     * @param c Centers.\n     * @throws NullArgumentException if any argument is {@code null}.\n     * @throws NoDataException if any array has zero length.\n     * @throws DimensionMismatchException if the size difference between\n     * {@code a} and {@code c} is not equal to 1.\n     */\n    public PolynomialFunctionNewtonForm(double a[], double c[])\n        throws NullArgumentException, NoDataException, DimensionMismatchException {\n\n        verifyInputArray(a, c);\n        this.a = new double[a.length];\n        this.c = new double[c.length];\n        System.arraycopy(a, 0, this.a, 0, a.length);\n        System.arraycopy(c, 0, this.c, 0, c.length);\n        coefficientsComputed = false;\n    }\n\n    /**\n     * Calculate the function value at the given point.\n     *\n     * @param z Point at which the function value is to be computed.\n     * @return the function value.\n     */\n    public double value(double z) {\n       return evaluate(a, c, z);\n    }\n\n    /**\n     * {@inheritDoc}\n     * @since 3.1\n     */\n    public DerivativeStructure value(final DerivativeStructure t) {\n        verifyInputArray(a, c);\n\n        final int n = c.length;\n        DerivativeStructure value = new DerivativeStructure(t.getFreeParameters(), t.getOrder(), a[n]);\n        for (int i = n - 1; i >= 0; i--) {\n            value = t.subtract(c[i]).multiply(value).add(a[i]);\n        }\n\n        return value;\n\n    }\n\n    /**\n     * Returns the degree of the polynomial.\n     *\n     * @return the degree of the polynomial\n     */\n    public int degree() {\n        return c.length;\n    }\n\n    /**\n     * Returns a copy of coefficients in Newton form formula.\n     * <p>\n     * Changes made to the returned copy will not affect the polynomial.</p>\n     *\n     * @return a fresh copy of coefficients in Newton form formula\n     */\n    public double[] getNewtonCoefficients() {\n        double[] out = new double[a.length];\n        System.arraycopy(a, 0, out, 0, a.length);\n        return out;\n    }\n\n    /**\n     * Returns a copy of the centers array.\n     * <p>\n     * Changes made to the returned copy will not affect the polynomial.</p>\n     *\n     * @return a fresh copy of the centers array.\n     */\n    public double[] getCenters() {\n        double[] out = new double[c.length];\n        System.arraycopy(c, 0, out, 0, c.length);\n        return out;\n    }\n\n    /**\n     * Returns a copy of the coefficients array.\n     * <p>\n     * Changes made to the returned copy will not affect the polynomial.</p>\n     *\n     * @return a fresh copy of the coefficients array.\n     */\n    public double[] getCoefficients() {", "metadata": {"defects4j_task_id": "b3a78689d4c9a526ef203ad97511a084a601b9321d018e16cc578b52e8b8bd24", "task_id": "apache_commons-math/152", "ground_truth": "\n        if (!coefficientsComputed) {\n            computeCoefficients();\n        }\n        double[] out = new double[coefficients.length];\n        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n        return out;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "analysis", "polynomials", "PolynomialFunctionNewtonForm.java"], "context_start_lineno": 0, "function_name": "getCoefficients", "left_context": "class PolynomialFunctionNewtonForm implements UnivariateDifferentiableFunction {\n\n    /**\n     * The coefficients of the polynomial, ordered by degree -- i.e.\n     * coefficients[0] is the constant term and coefficients[n] is the\n     * coefficient of x^n where n is the degree of the polynomial.\n     */\n    private double coefficients[];\n\n    /**\n     * Centers of the Newton polynomial.\n     */\n    private final double c[];\n\n    /**\n     * When all c[i] = 0, a[] becomes normal polynomial coefficients,\n     * i.e. a[i] = coefficients[i].\n     */\n    private final double a[];\n\n    /**\n     * Whether the polynomial coefficients are available.\n     */\n    private boolean coefficientsComputed;\n\n    /**\n     * Construct a Newton polynomial with the given a[] and c[]. The order of\n     * centers are important in that if c[] shuffle, then values of a[] would\n     * completely change, not just a permutation of old a[].\n     * <p>\n     * The constructor makes copy of the input arrays and assigns them.</p>\n     *\n     * @param a Coefficients in Newton form formula.\n     * @param c Centers.\n     * @throws NullArgumentException if any argument is {@code null}.\n     * @throws NoDataException if any array has zero length.\n     * @throws DimensionMismatchException if the size difference between\n     * {@code a} and {@code c} is not equal to 1.\n     */\n    public PolynomialFunctionNewtonForm(double a[], double c[])\n        throws NullArgumentException, NoDataException, DimensionMismatchException {\n\n        verifyInputArray(a, c);\n        this.a = new double[a.length];\n        this.c = new double[c.length];\n        System.arraycopy(a, 0, this.a, 0, a.length);\n        System.arraycopy(c, 0, this.c, 0, c.length);\n        coefficientsComputed = false;\n    }\n\n    /**\n     * Calculate the function value at the given point.\n     *\n     * @param z Point at which the function value is to be computed.\n     * @return the function value.\n     */\n    public double value(double z) {\n       return evaluate(a, c, z);\n    }\n\n    /**\n     * {@inheritDoc}\n     * @since 3.1\n     */\n    public DerivativeStructure value(final DerivativeStructure t) {\n        verifyInputArray(a, c);\n\n        final int n = c.length;\n        DerivativeStructure value = new DerivativeStructure(t.getFreeParameters(), t.getOrder(), a[n]);\n        for (int i = n - 1; i >= 0; i--) {\n            value = t.subtract(c[i]).multiply(value).add(a[i]);\n        }\n\n        return value;\n\n    }\n\n    /**\n     * Returns the degree of the polynomial.\n     *\n     * @return the degree of the polynomial\n     */\n    public int degree() {\n        return c.length;\n    }\n\n    /**\n     * Returns a copy of coefficients in Newton form formula.\n     * <p>\n     * Changes made to the returned copy will not affect the polynomial.</p>\n     *\n     * @return a fresh copy of coefficients in Newton form formula\n     */\n    public double[] getNewtonCoefficients() {\n        double[] out = new double[a.length];\n        System.arraycopy(a, 0, out, 0, a.length);\n        return out;\n    }\n\n    /**\n     * Returns a copy of the centers array.\n     * <p>\n     * Changes made to the returned copy will not affect the polynomial.</p>\n     *\n     * @return a fresh copy of the centers array.\n     */\n    public double[] getCenters() {\n        double[] out = new double[c.length];\n        System.arraycopy(c, 0, out, 0, c.length);\n        return out;\n    }\n\n    /**\n     * Returns a copy of the coefficients array.\n     * <p>\n     * Changes made to the returned copy will not affect the polynomial.</p>\n     *\n     * @return a fresh copy of the coefficients array.\n     */\n    public double[] getCoefficients() {", "right_context": "}\n\n    /**\n     * Evaluate the Newton polynomial using nested multiplication. It is\n     * also called <a href=\"http://mathworld.wolfram.com/HornersRule.html\">\n     * Horner's Rule</a> and takes O(N) time.\n     *\n     * @param a Coefficients in Newton form formula.\n     * @param c Centers.\n     * @param z Point at which the function value is to be computed.\n     * @return the function value.\n     * @throws NullArgumentException if any argument is {@code null}.\n     * @throws NoDataException if any array has zero length.\n     * @throws DimensionMismatchException if the size difference between\n     * {@code a} and {@code c} is not equal to 1.\n     */\n    public static double evaluate(double a[], double c[], double z)\n        throws NullArgumentException, DimensionMismatchException, NoDataException {\n        verifyInputArray(a, c);\n\n        final int n = c.length;\n        double value = a[n];\n        for (int i = n - 1; i >= 0; i--) {\n            value = a[i] + (z - c[i]) * value;\n        }\n\n        return value;\n    }\n\n    /**\n     * Calculate the normal polynomial coefficients given the Newton form.\n     * It also uses nested multiplication but takes O(N^2) time.\n     */\n    protected void computeCoefficients() {\n        final int n = degree();\n\n        coefficients = new double[n+1];\n        for (int i = 0; i <= n; i++) {\n            coefficients[i] = 0.0;\n        }\n\n        coefficients[0] = a[n];\n        for (int i = n-1; i >= 0; i--) {\n            for (int j = n-i; j > 0; j--) {\n                coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];\n            }\n            coefficients[0] = a[i] - c[i] * coefficients[0];\n        }\n\n        coefficientsComputed = true;\n    }\n\n    /**\n     * Verifies that the input arrays are valid.\n     * <p>\n     * The centers must be distinct for interpolation purposes, but not\n     * for general use. Thus it is not verified here.</p>\n     *\n     * @param a the coefficients in Newton form formula\n     * @param c the centers\n     * @throws NullArgumentException if any argument is {@code null}.\n     * @throws NoDataException if any array has zero length.\n     * @throws DimensionMismatchException if the size difference between\n     * {@code a} and {@code c} is not equal to 1.\n     * @see org.apache.commons.math3.analysis.interpolation.DividedDifferenceInterpolator#computeDividedDifference(double[],\n     * double[])\n     */\n    protected static void verifyInputArray(double a[], double c[])\n        throws NullArgumentException, NoDataException, DimensionMismatchException {\n        MathUtils.checkNotNull(a);\n        MathUtils.checkNotNull(c);\n        if (a.length == 0 || c.length == 0) {\n            throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n        }\n        if (a.length != c.length + 1) {\n            throw new DimensionMismatchException(LocalizedFormats.ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1,\n                                                 a.length, c.length);\n        }\n    }\n\n}", "class_name": "PolynomialFunctionNewtonForm", "return_type": "double[]", "parameters": []}}
{"prompt": "class GaussIntegrator {\n    /** Nodes. */\n    private final double[] points;\n    /** Nodes weights. */\n    private final double[] weights;\n\n    /**\n     * Creates an integrator from the given {@code points} and {@code weights}.\n     * The integration interval is defined by the first and last value of\n     * {@code points} which must be sorted in increasing order.\n     *\n     * @param points Integration points.\n     * @param weights Weights of the corresponding integration nodes.\n     * @throws NonMonotonicSequenceException if the {@code points} are not\n     * sorted in increasing order.\n     * @throws DimensionMismatchException if points and weights don't have the same length\n     */\n    public GaussIntegrator(double[] points,\n                           double[] weights)\n        throws NonMonotonicSequenceException, DimensionMismatchException {\n        if (points.length != weights.length) {\n            throw new DimensionMismatchException(points.length,\n                                                 weights.length);\n        }\n\n        MathArrays.checkOrder(points, MathArrays.OrderDirection.INCREASING, true, true);\n\n        this.points = points.clone();\n        this.weights = weights.clone();\n    }\n\n    /**\n     * Creates an integrator from the given pair of points (first element of\n     * the pair) and weights (second element of the pair.\n     *\n     * @param pointsAndWeights Integration points and corresponding weights.\n     * @throws NonMonotonicSequenceException if the {@code points} are not\n     * sorted in increasing order.\n     *\n     * @see #GaussIntegrator(double[], double[])\n     */\n    public GaussIntegrator(Pair<double[], double[]> pointsAndWeights)\n        throws NonMonotonicSequenceException {\n        this(pointsAndWeights.getFirst(), pointsAndWeights.getSecond());\n    }\n\n    /**\n     * Returns an estimate of the integral of {@code f(x) * w(x)},\n     * where {@code w} is a weight function that depends on the actual\n     * flavor of the Gauss integration scheme.\n     * The algorithm uses the points and associated weights, as passed\n     * to the {@link #GaussIntegrator(double[],double[]) constructor}.\n     *\n     * @param f Function to integrate.\n     * @return the integral of the weighted function.\n     */\n    public double integrate(UnivariateFunction f) {", "metadata": {"defects4j_task_id": "ae42d9c93959042f04422ba12812e3c0632ad8b0cfbc6a2a28beba0447654cb5", "task_id": "apache_commons-math/148", "ground_truth": "\n        double s = 0;\n        double c = 0;\n        for (int i = 0; i < points.length; i++) {\n            final double x = points[i];\n            final double w = weights[i];\n            final double y = w * f.value(x) - c;\n            final double t = s + y;\n            c = (t - s) - y;\n            s = t;\n        }\n        return s;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "analysis", "integration", "gauss", "GaussIntegrator.java"], "context_start_lineno": 0, "function_name": "integrate", "left_context": "class GaussIntegrator {\n    /** Nodes. */\n    private final double[] points;\n    /** Nodes weights. */\n    private final double[] weights;\n\n    /**\n     * Creates an integrator from the given {@code points} and {@code weights}.\n     * The integration interval is defined by the first and last value of\n     * {@code points} which must be sorted in increasing order.\n     *\n     * @param points Integration points.\n     * @param weights Weights of the corresponding integration nodes.\n     * @throws NonMonotonicSequenceException if the {@code points} are not\n     * sorted in increasing order.\n     * @throws DimensionMismatchException if points and weights don't have the same length\n     */\n    public GaussIntegrator(double[] points,\n                           double[] weights)\n        throws NonMonotonicSequenceException, DimensionMismatchException {\n        if (points.length != weights.length) {\n            throw new DimensionMismatchException(points.length,\n                                                 weights.length);\n        }\n\n        MathArrays.checkOrder(points, MathArrays.OrderDirection.INCREASING, true, true);\n\n        this.points = points.clone();\n        this.weights = weights.clone();\n    }\n\n    /**\n     * Creates an integrator from the given pair of points (first element of\n     * the pair) and weights (second element of the pair.\n     *\n     * @param pointsAndWeights Integration points and corresponding weights.\n     * @throws NonMonotonicSequenceException if the {@code points} are not\n     * sorted in increasing order.\n     *\n     * @see #GaussIntegrator(double[], double[])\n     */\n    public GaussIntegrator(Pair<double[], double[]> pointsAndWeights)\n        throws NonMonotonicSequenceException {\n        this(pointsAndWeights.getFirst(), pointsAndWeights.getSecond());\n    }\n\n    /**\n     * Returns an estimate of the integral of {@code f(x) * w(x)},\n     * where {@code w} is a weight function that depends on the actual\n     * flavor of the Gauss integration scheme.\n     * The algorithm uses the points and associated weights, as passed\n     * to the {@link #GaussIntegrator(double[],double[]) constructor}.\n     *\n     * @param f Function to integrate.\n     * @return the integral of the weighted function.\n     */\n    public double integrate(UnivariateFunction f) {", "right_context": "}\n\n    /**\n     * @return the order of the integration rule (the number of integration\n     * points).\n     */\n    public int getNumberOfPoints() {\n        return points.length;\n    }\n\n    /**\n     * Gets the integration point at the given index.\n     * The index must be in the valid range but no check is performed.\n     * @param index index of the integration point\n     * @return the integration point.\n     */\n    public double getPoint(int index) {\n        return points[index];\n    }\n\n    /**\n     * Gets the weight of the integration point at the given index.\n     * The index must be in the valid range but no check is performed.\n     * @param index index of the integration point\n     * @return the weight.\n     */\n    public double getWeight(int index) {\n        return weights[index];\n    }\n}", "class_name": "GaussIntegrator", "return_type": "double", "parameters": [{"type": "UnivariateFunction", "name": "f"}]}}
{"prompt": "class SimplexSolver extends AbstractLinearOptimizer {\n\n    /** Default amount of error to accept in floating point comparisons (as ulps). */\n    private static final int DEFAULT_ULPS = 10;\n\n    /** Amount of error to accept for algorithm convergence. */\n    private final double epsilon;\n\n    /** Amount of error to accept in floating point comparisons (as ulps). */\n    private final int maxUlps;\n\n    /**\n     * Build a simplex solver with default settings.\n     */\n    public SimplexSolver() {\n        this(DEFAULT_EPSILON, DEFAULT_ULPS);\n    }\n\n    /**\n     * Build a simplex solver with a specified accepted amount of error\n     * @param epsilon the amount of error to accept for algorithm convergence\n     * @param maxUlps amount of error to accept in floating point comparisons\n     */\n    public SimplexSolver(final double epsilon, final int maxUlps) {\n        this.epsilon = epsilon;\n        this.maxUlps = maxUlps;\n    }\n\n    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {", "metadata": {"defects4j_task_id": "ffd5deabfd1450a4f52c964160858273920d936b2a6ba9e522f108e2f1928de2", "task_id": "apache_commons-math/210", "ground_truth": "\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            final double entry = tableau.getEntry(0, i);\n            // check if the entry is strictly smaller than the current minimum\n            // do not use a ulp/epsilon check\n            if (entry < minValue) {\n                minValue = entry;\n                minPos = i;\n            }\n        }\n        return minPos;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "optimization", "linear", "SimplexSolver.java"], "context_start_lineno": 0, "function_name": "getPivotColumn", "left_context": "class SimplexSolver extends AbstractLinearOptimizer {\n\n    /** Default amount of error to accept in floating point comparisons (as ulps). */\n    private static final int DEFAULT_ULPS = 10;\n\n    /** Amount of error to accept for algorithm convergence. */\n    private final double epsilon;\n\n    /** Amount of error to accept in floating point comparisons (as ulps). */\n    private final int maxUlps;\n\n    /**\n     * Build a simplex solver with default settings.\n     */\n    public SimplexSolver() {\n        this(DEFAULT_EPSILON, DEFAULT_ULPS);\n    }\n\n    /**\n     * Build a simplex solver with a specified accepted amount of error\n     * @param epsilon the amount of error to accept for algorithm convergence\n     * @param maxUlps amount of error to accept in floating point comparisons\n     */\n    public SimplexSolver(final double epsilon, final int maxUlps) {\n        this.epsilon = epsilon;\n        this.maxUlps = maxUlps;\n    }\n\n    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {", "right_context": "}\n\n}", "class_name": "SimplexSolver", "return_type": "Integer", "parameters": [{"type": "SimplexTableau", "name": "tableau"}]}}
{"prompt": "class CMAESOptimizer\n    extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction>\n    implements MultivariateOptimizer {\n    /**\n     * @param m Input matrix\n     * @return Matrix representing the element-wise logarithm of m.\n     */\n    private static RealMatrix log(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Matrix representing the element-wise square root of m.\n     */\n    private static RealMatrix sqrt(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.sqrt(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Matrix representing the element-wise square of m.\n     */\n    private static RealMatrix square(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return the matrix where the elements of m and n are element-wise multiplied.\n     */\n    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return Matrix where the elements of m and n are element-wise divided.\n     */\n    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param cols Columns to select.\n     * @return Matrix representing the selected columns.\n     */\n    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        final double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param k Diagonal position.\n     * @return Upper triangular part of matrix.\n     */\n    private static RealMatrix triu(final RealMatrix m, int k) {", "metadata": {"defects4j_task_id": "3a7243101a31c152289482671a2ac983195e363610e512d4f35ba9e39584e533", "task_id": "apache_commons-math/52", "ground_truth": "\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "optimization", "direct", "CMAESOptimizer.java"], "context_start_lineno": 0, "function_name": "triu", "left_context": "class CMAESOptimizer\n    extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction>\n    implements MultivariateOptimizer {\n    /**\n     * @param m Input matrix\n     * @return Matrix representing the element-wise logarithm of m.\n     */\n    private static RealMatrix log(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Matrix representing the element-wise square root of m.\n     */\n    private static RealMatrix sqrt(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.sqrt(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Matrix representing the element-wise square of m.\n     */\n    private static RealMatrix square(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return the matrix where the elements of m and n are element-wise multiplied.\n     */\n    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return Matrix where the elements of m and n are element-wise divided.\n     */\n    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param cols Columns to select.\n     * @return Matrix representing the selected columns.\n     */\n    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        final double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param k Diagonal position.\n     * @return Upper triangular part of matrix.\n     */\n    private static RealMatrix triu(final RealMatrix m, int k) {", "right_context": "}\n}", "class_name": "CMAESOptimizer", "return_type": "RealMatrix", "parameters": [{"type": "RealMatrix", "name": "m"}, {"type": "int", "name": "k"}]}}
{"prompt": "class CMAESOptimizer\n    extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction>\n    implements MultivariateOptimizer {\n    /**\n     * @param m Input matrix\n     * @return Matrix representing the element-wise logarithm of m.\n     */\n    private static RealMatrix log(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Matrix representing the element-wise square root of m.\n     */\n    private static RealMatrix sqrt(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.sqrt(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Matrix representing the element-wise square of m.\n     */\n    private static RealMatrix square(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return the matrix where the elements of m and n are element-wise multiplied.\n     */\n    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return Matrix where the elements of m and n are element-wise divided.\n     */\n    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param cols Columns to select.\n     * @return Matrix representing the selected columns.\n     */\n    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        final double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param k Diagonal position.\n     * @return Upper triangular part of matrix.\n     */\n    private static RealMatrix triu(final RealMatrix m, int k) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Row matrix representing the sums of the rows.\n     */\n    private static RealMatrix sumRows(final RealMatrix m) {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            double sum = 0;\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                sum += m.getEntry(r, c);\n            }\n            d[0][c] = sum;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return the diagonal n-by-n matrix if m is a column matrix or the column\n     * matrix representing the diagonal if m is a n-by-n matrix.\n     */\n    private static RealMatrix diag(final RealMatrix m) {", "metadata": {"defects4j_task_id": "04eba5a210e670ef3bd02de904f75255cf47e262de7050691488cc2543447418", "task_id": "apache_commons-math/6", "ground_truth": "\n        if (m.getColumnDimension() == 1) {\n            final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            final double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "optimization", "direct", "CMAESOptimizer.java"], "context_start_lineno": 0, "function_name": "diag", "left_context": "class CMAESOptimizer\n    extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction>\n    implements MultivariateOptimizer {\n    /**\n     * @param m Input matrix\n     * @return Matrix representing the element-wise logarithm of m.\n     */\n    private static RealMatrix log(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Matrix representing the element-wise square root of m.\n     */\n    private static RealMatrix sqrt(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.sqrt(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Matrix representing the element-wise square of m.\n     */\n    private static RealMatrix square(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return the matrix where the elements of m and n are element-wise multiplied.\n     */\n    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return Matrix where the elements of m and n are element-wise divided.\n     */\n    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param cols Columns to select.\n     * @return Matrix representing the selected columns.\n     */\n    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        final double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @param k Diagonal position.\n     * @return Upper triangular part of matrix.\n     */\n    private static RealMatrix triu(final RealMatrix m, int k) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return Row matrix representing the sums of the rows.\n     */\n    private static RealMatrix sumRows(final RealMatrix m) {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            double sum = 0;\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                sum += m.getEntry(r, c);\n            }\n            d[0][c] = sum;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n\n    /**\n     * @param m Input matrix.\n     * @return the diagonal n-by-n matrix if m is a column matrix or the column\n     * matrix representing the diagonal if m is a n-by-n matrix.\n     */\n    private static RealMatrix diag(final RealMatrix m) {", "right_context": "}\n}", "class_name": "CMAESOptimizer", "return_type": "RealMatrix", "parameters": [{"type": "RealMatrix", "name": "m"}]}}
{"prompt": "class PowellOptimizer\n    extends BaseAbstractMultivariateOptimizer<MultivariateFunction>\n    implements MultivariateOptimizer {\n    /**\n     * This constructor allows to specify a user-defined convergence checker,\n     * in addition to the parameters that control the default convergence\n     * checking procedure and the line search tolerances.\n     *\n     * @param rel Relative threshold for this optimizer.\n     * @param abs Absolute threshold for this optimizer.\n     * @param lineRel Relative threshold for the internal line search optimizer.\n     * @param lineAbs Absolute threshold for the internal line search optimizer.\n     * @param checker Convergence checker.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     */\n    public PowellOptimizer(double rel,\n                           double abs,\n                           double lineRel,\n                           double lineAbs,\n                           ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n\n        // Create the line search optimizer.\n        line = new LineSearch(lineRel,\n                              lineAbs);\n    }\n\n    /**\n     * The parameters control the default convergence checking procedure.\n     * <br/>\n     * The internal line search tolerances are set to the square-root of their\n     * corresponding value in the multivariate optimizer.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     */\n    public PowellOptimizer(double rel,\n                           double abs) {\n        this(rel, abs, null);\n    }\n\n    /**\n     * Builds an instance with the default convergence checking procedure.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @param lineRel Relative threshold for the internal line search optimizer.\n     * @param lineAbs Absolute threshold for the internal line search optimizer.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     * @since 3.1\n     */\n    public PowellOptimizer(double rel,\n                           double abs,\n                           double lineRel,\n                           double lineAbs) {\n        this(rel, abs, lineRel, lineAbs, null);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected PointValuePair doOptimize() {\n        final GoalType goal = getGoalType();\n        final double[] guess = getStartPoint();\n        final int n = guess.length;\n\n        final double[][] direc = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            direc[i][i] = 1;\n        }\n\n        final ConvergenceChecker<PointValuePair> checker\n            = getConvergenceChecker();\n\n        double[] x = guess;\n        double fVal = computeObjectiveValue(x);\n        double[] x1 = x.clone();\n        int iter = 0;\n        while (true) {\n            ++iter;\n\n            double fX = fVal;\n            double fX2 = 0;\n            double delta = 0;\n            int bigInd = 0;\n            double alphaMin = 0;\n\n            for (int i = 0; i < n; i++) {\n                final double[] d = MathArrays.copyOf(direc[i]);\n\n                fX2 = fVal;\n\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n\n                if ((fX2 - fVal) > delta) {\n                    delta = fX2 - fVal;\n                    bigInd = i;\n                }\n            }\n\n            // Default convergence check.\n            boolean stop = 2 * (fX - fVal) <=\n                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n                 absoluteThreshold);\n\n            final PointValuePair previous = new PointValuePair(x1, fX);\n            final PointValuePair current = new PointValuePair(x, fVal);\n            if (!stop && checker != null) {\n                stop = checker.converged(iter, previous, current);\n            }\n            if (stop) {\n                if (goal == GoalType.MINIMIZE) {\n                    return (fVal < fX) ? current : previous;\n                } else {\n                    return (fVal > fX) ? current : previous;\n                }\n            }\n\n            final double[] d = new double[n];\n            final double[] x2 = new double[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = x[i] - x1[i];\n                x2[i] = 2 * x[i] - x1[i];\n            }\n\n            x1 = x.clone();\n            fX2 = computeObjectiveValue(x2);\n\n            if (fX > fX2) {\n                double t = 2 * (fX + fX2 - 2 * fVal);\n                double temp = fX - fVal - delta;\n                t *= temp * temp;\n                temp = fX - fX2;\n                t -= delta * temp * temp;\n\n                if (t < 0.0) {\n                    final UnivariatePointValuePair optimum = line.search(x, d);\n                    fVal = optimum.getValue();\n                    alphaMin = optimum.getPoint();\n                    final double[][] result = newPointAndDirection(x, d, alphaMin);\n                    x = result[0];\n\n                    final int lastInd = n - 1;\n                    direc[bigInd] = direc[lastInd];\n                    direc[lastInd] = result[1];\n                }\n            }\n        }\n    }\n\n    /**\n     * Compute a new point (in the original space) and a new direction\n     * vector, resulting from the line search.\n     *\n     * @param p Point used in the line search.\n     * @param d Direction used in the line search.\n     * @param optimum Optimum found by the line search.\n     * @return a 2-element array containing the new point (at index 0) and\n     * the new direction (at index 1).\n     */\n    private double[][] newPointAndDirection(double[] p,\n                                            double[] d,\n                                            double optimum) {", "metadata": {"defects4j_task_id": "82f7a9f78e757dc42c92c71e82da0cebf7ab29355aca4858e1be691c9ab48709", "task_id": "apache_commons-math/107", "ground_truth": "\n        final int n = p.length;\n        final double[] nP = new double[n];\n        final double[] nD = new double[n];\n        for (int i = 0; i < n; i++) {\n            nD[i] = d[i] * optimum;\n            nP[i] = p[i] + nD[i];\n        }\n\n        final double[][] result = new double[2][];\n        result[0] = nP;\n        result[1] = nD;\n\n        return result;\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "optimization", "direct", "PowellOptimizer.java"], "context_start_lineno": 0, "function_name": "newPointAndDirection", "left_context": "class PowellOptimizer\n    extends BaseAbstractMultivariateOptimizer<MultivariateFunction>\n    implements MultivariateOptimizer {\n    /**\n     * This constructor allows to specify a user-defined convergence checker,\n     * in addition to the parameters that control the default convergence\n     * checking procedure and the line search tolerances.\n     *\n     * @param rel Relative threshold for this optimizer.\n     * @param abs Absolute threshold for this optimizer.\n     * @param lineRel Relative threshold for the internal line search optimizer.\n     * @param lineAbs Absolute threshold for the internal line search optimizer.\n     * @param checker Convergence checker.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     */\n    public PowellOptimizer(double rel,\n                           double abs,\n                           double lineRel,\n                           double lineAbs,\n                           ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n\n        // Create the line search optimizer.\n        line = new LineSearch(lineRel,\n                              lineAbs);\n    }\n\n    /**\n     * The parameters control the default convergence checking procedure.\n     * <br/>\n     * The internal line search tolerances are set to the square-root of their\n     * corresponding value in the multivariate optimizer.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     */\n    public PowellOptimizer(double rel,\n                           double abs) {\n        this(rel, abs, null);\n    }\n\n    /**\n     * Builds an instance with the default convergence checking procedure.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @param lineRel Relative threshold for the internal line search optimizer.\n     * @param lineAbs Absolute threshold for the internal line search optimizer.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     * @since 3.1\n     */\n    public PowellOptimizer(double rel,\n                           double abs,\n                           double lineRel,\n                           double lineAbs) {\n        this(rel, abs, lineRel, lineAbs, null);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected PointValuePair doOptimize() {\n        final GoalType goal = getGoalType();\n        final double[] guess = getStartPoint();\n        final int n = guess.length;\n\n        final double[][] direc = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            direc[i][i] = 1;\n        }\n\n        final ConvergenceChecker<PointValuePair> checker\n            = getConvergenceChecker();\n\n        double[] x = guess;\n        double fVal = computeObjectiveValue(x);\n        double[] x1 = x.clone();\n        int iter = 0;\n        while (true) {\n            ++iter;\n\n            double fX = fVal;\n            double fX2 = 0;\n            double delta = 0;\n            int bigInd = 0;\n            double alphaMin = 0;\n\n            for (int i = 0; i < n; i++) {\n                final double[] d = MathArrays.copyOf(direc[i]);\n\n                fX2 = fVal;\n\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n\n                if ((fX2 - fVal) > delta) {\n                    delta = fX2 - fVal;\n                    bigInd = i;\n                }\n            }\n\n            // Default convergence check.\n            boolean stop = 2 * (fX - fVal) <=\n                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n                 absoluteThreshold);\n\n            final PointValuePair previous = new PointValuePair(x1, fX);\n            final PointValuePair current = new PointValuePair(x, fVal);\n            if (!stop && checker != null) {\n                stop = checker.converged(iter, previous, current);\n            }\n            if (stop) {\n                if (goal == GoalType.MINIMIZE) {\n                    return (fVal < fX) ? current : previous;\n                } else {\n                    return (fVal > fX) ? current : previous;\n                }\n            }\n\n            final double[] d = new double[n];\n            final double[] x2 = new double[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = x[i] - x1[i];\n                x2[i] = 2 * x[i] - x1[i];\n            }\n\n            x1 = x.clone();\n            fX2 = computeObjectiveValue(x2);\n\n            if (fX > fX2) {\n                double t = 2 * (fX + fX2 - 2 * fVal);\n                double temp = fX - fVal - delta;\n                t *= temp * temp;\n                temp = fX - fX2;\n                t -= delta * temp * temp;\n\n                if (t < 0.0) {\n                    final UnivariatePointValuePair optimum = line.search(x, d);\n                    fVal = optimum.getValue();\n                    alphaMin = optimum.getPoint();\n                    final double[][] result = newPointAndDirection(x, d, alphaMin);\n                    x = result[0];\n\n                    final int lastInd = n - 1;\n                    direc[bigInd] = direc[lastInd];\n                    direc[lastInd] = result[1];\n                }\n            }\n        }\n    }\n\n    /**\n     * Compute a new point (in the original space) and a new direction\n     * vector, resulting from the line search.\n     *\n     * @param p Point used in the line search.\n     * @param d Direction used in the line search.\n     * @param optimum Optimum found by the line search.\n     * @return a 2-element array containing the new point (at index 0) and\n     * the new direction (at index 1).\n     */\n    private double[][] newPointAndDirection(double[] p,\n                                            double[] d,\n                                            double optimum) {", "right_context": "}\n}", "class_name": "PowellOptimizer", "return_type": "double[][]", "parameters": [{"type": "double[]", "name": "p"}, {"type": "double[]", "name": "d"}, {"type": "double", "name": "optimum"}]}}
{"prompt": "class AbstractLeastSquaresOptimizer\n    extends BaseAbstractMultivariateVectorOptimizer<DifferentiableMultivariateVectorFunction>\n    implements DifferentiableMultivariateVectorOptimizer {\n    /**\n     * Jacobian matrix of the weighted residuals.\n     * This matrix is in canonical form just after the calls to\n     * {@link #updateJacobian()}, but may be modified by the solver\n     * in the derived class (the {@link LevenbergMarquardtOptimizer\n     * Levenberg-Marquardt optimizer} does this).\n     * @deprecated As of 3.1. To be removed in 4.0. Please use\n     * {@link #computeWeightedJacobian(double[])} instead.\n     */\n    @Deprecated\n    protected double[][] weightedResidualJacobian;\n    /** Number of columns of the jacobian matrix.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected int cols;\n    /** Number of rows of the jacobian matrix.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected int rows;\n    /** Current point.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] point;\n    /** Current objective function value.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] objective;\n    /** Weighted residuals\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] weightedResiduals;\n    /** Cost value (square root of the sum of the residuals).\n     * @deprecated As of 3.1. Field to become \"private\" in 4.0.\n     * Please use {@link #setCost(double)}.\n     */\n    @Deprecated\n    protected double cost;\n    /** Objective function derivatives. */\n    private MultivariateDifferentiableVectorFunction jF;\n    /** Number of evaluations of the Jacobian. */\n    private int jacobianEvaluations;\n    /** Square-root of the weight matrix. */\n    private RealMatrix weightMatrixSqrt;\n\n    /**\n     * Simple constructor with default settings.\n     * The convergence check is set to a {@link\n     * org.apache.commons.math3.optimization.SimpleVectorValueChecker}.\n     * @deprecated See {@link org.apache.commons.math3.optimization.SimpleValueChecker#SimpleValueChecker()}\n     */\n    @Deprecated\n    protected AbstractLeastSquaresOptimizer() {}\n\n    /**\n     * @param checker Convergence checker.\n     */\n    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }\n\n    /**\n     * @return the number of evaluations of the Jacobian function.\n     */\n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    /**\n     * Update the jacobian matrix.\n     *\n     * @throws DimensionMismatchException if the Jacobian dimension does not\n     * match problem dimension.\n     * @deprecated As of 3.1. Please use {@link #computeWeightedJacobian(double[])}\n     * instead.\n     */\n    @Deprecated\n    protected void updateJacobian() {\n        final RealMatrix weightedJacobian = computeWeightedJacobian(point);\n        weightedResidualJacobian = weightedJacobian.scalarMultiply(-1).getData();\n    }\n\n    /**\n     * Computes the Jacobian matrix.\n     *\n     * @param params Model parameters at which to compute the Jacobian.\n     * @return the weighted Jacobian: W<sup>1/2</sup> J.\n     * @throws DimensionMismatchException if the Jacobian dimension does not\n     * match problem dimension.\n     * @since 3.1\n     */\n    protected RealMatrix computeWeightedJacobian(double[] params) {", "metadata": {"defects4j_task_id": "4c051b99ac043326025e327d82dee7b85ac36b4bad1809ed98ad370a8cfcf133", "task_id": "apache_commons-math/67", "ground_truth": "\n        ++jacobianEvaluations;\n\n        final DerivativeStructure[] dsPoint = new DerivativeStructure[params.length];\n        final int nC = params.length;\n        for (int i = 0; i < nC; ++i) {\n            dsPoint[i] = new DerivativeStructure(nC, 1, i, params[i]);\n        }\n        final DerivativeStructure[] dsValue = jF.value(dsPoint);\n        final int nR = getTarget().length;\n        if (dsValue.length != nR) {\n            throw new DimensionMismatchException(dsValue.length, nR);\n        }\n        final double[][] jacobianData = new double[nR][nC];\n        for (int i = 0; i < nR; ++i) {\n            int[] orders = new int[nC];\n            for (int j = 0; j < nC; ++j) {\n                orders[j] = 1;\n                jacobianData[i][j] = dsValue[i].getPartialDerivative(orders);\n                orders[j] = 0;\n            }\n        }\n\n        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(jacobianData));\n    ", "fpath_tuple": ["apache_commons-math", "commons-math", "src", "main", "java", "org", "apache", "commons", "math3", "optimization", "general", "AbstractLeastSquaresOptimizer.java"], "context_start_lineno": 0, "function_name": "computeWeightedJacobian", "left_context": "class AbstractLeastSquaresOptimizer\n    extends BaseAbstractMultivariateVectorOptimizer<DifferentiableMultivariateVectorFunction>\n    implements DifferentiableMultivariateVectorOptimizer {\n    /**\n     * Jacobian matrix of the weighted residuals.\n     * This matrix is in canonical form just after the calls to\n     * {@link #updateJacobian()}, but may be modified by the solver\n     * in the derived class (the {@link LevenbergMarquardtOptimizer\n     * Levenberg-Marquardt optimizer} does this).\n     * @deprecated As of 3.1. To be removed in 4.0. Please use\n     * {@link #computeWeightedJacobian(double[])} instead.\n     */\n    @Deprecated\n    protected double[][] weightedResidualJacobian;\n    /** Number of columns of the jacobian matrix.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected int cols;\n    /** Number of rows of the jacobian matrix.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected int rows;\n    /** Current point.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] point;\n    /** Current objective function value.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] objective;\n    /** Weighted residuals\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] weightedResiduals;\n    /** Cost value (square root of the sum of the residuals).\n     * @deprecated As of 3.1. Field to become \"private\" in 4.0.\n     * Please use {@link #setCost(double)}.\n     */\n    @Deprecated\n    protected double cost;\n    /** Objective function derivatives. */\n    private MultivariateDifferentiableVectorFunction jF;\n    /** Number of evaluations of the Jacobian. */\n    private int jacobianEvaluations;\n    /** Square-root of the weight matrix. */\n    private RealMatrix weightMatrixSqrt;\n\n    /**\n     * Simple constructor with default settings.\n     * The convergence check is set to a {@link\n     * org.apache.commons.math3.optimization.SimpleVectorValueChecker}.\n     * @deprecated See {@link org.apache.commons.math3.optimization.SimpleValueChecker#SimpleValueChecker()}\n     */\n    @Deprecated\n    protected AbstractLeastSquaresOptimizer() {}\n\n    /**\n     * @param checker Convergence checker.\n     */\n    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }\n\n    /**\n     * @return the number of evaluations of the Jacobian function.\n     */\n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    /**\n     * Update the jacobian matrix.\n     *\n     * @throws DimensionMismatchException if the Jacobian dimension does not\n     * match problem dimension.\n     * @deprecated As of 3.1. Please use {@link #computeWeightedJacobian(double[])}\n     * instead.\n     */\n    @Deprecated\n    protected void updateJacobian() {\n        final RealMatrix weightedJacobian = computeWeightedJacobian(point);\n        weightedResidualJacobian = weightedJacobian.scalarMultiply(-1).getData();\n    }\n\n    /**\n     * Computes the Jacobian matrix.\n     *\n     * @param params Model parameters at which to compute the Jacobian.\n     * @return the weighted Jacobian: W<sup>1/2</sup> J.\n     * @throws DimensionMismatchException if the Jacobian dimension does not\n     * match problem dimension.\n     * @since 3.1\n     */\n    protected RealMatrix computeWeightedJacobian(double[] params) {", "right_context": "}\n}", "class_name": "AbstractLeastSquaresOptimizer", "return_type": "RealMatrix", "parameters": [{"type": "double[]", "name": "params"}]}}
{"prompt": "class FieldUtils {\n\n    /**\n     * Negates the input throwing an exception if it can't negate it.\n     * \n     * @param value  the value to negate\n     * @return the negated value\n     * @throws ArithmeticException if the value is Integer.MIN_VALUE\n     * @since 1.1\n     */\n    public static int safeNegate(int value) {\n        if (value == Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"Integer.MIN_VALUE cannot be negated\");\n        }\n        return -value;\n    }\n    \n    /**\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeAdd(int val1, int val2) {\n        int sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n    \n    /**\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeAdd(long val1, long val2) {\n        long sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n    \n    /**\n     * Subtracts two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value, to be taken away from\n     * @param val2  the second value, the amount to take away\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeSubtract(long val1, long val2) {\n        long diff = val1 - val2;\n        // If there is a sign change, but the two values have different signs...\n        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n        }\n        return diff;\n    }\n    \n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static int safeMultiply(int val1, int val2) {\n        long total = (long) val1 * (long) val2;\n        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\n          throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        return (int) total;\n    }\n\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n                if (val1 == Long.MIN_VALUE) {\n                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n                }\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n\n    /**\n     * Divides the dividend by the divisor throwing an exception if \n     * overflow occurs or the divisor is zero.\n     * \n     * @param dividend  the dividend\n     * @param divisor  the divisor\n     * @return the new total\n     * @throws ArithmeticException if the operation overflows or the divisor is zero\n     */\n    public static long safeDivide(long dividend, long divisor) {", "metadata": {"defects4j_task_id": "99d06da5eae7722b7eca40833ccc0a6aa394d3094df8e293408c019fdd104b8d", "task_id": "JodaOrg_joda-time/126", "ground_truth": "\n        if (dividend == Long.MIN_VALUE && divisor == -1L) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + dividend + \" / \" + divisor);\n        }\n        return dividend / divisor;\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "field", "FieldUtils.java"], "context_start_lineno": 0, "function_name": "safeDivide", "left_context": "class FieldUtils {\n\n    /**\n     * Negates the input throwing an exception if it can't negate it.\n     * \n     * @param value  the value to negate\n     * @return the negated value\n     * @throws ArithmeticException if the value is Integer.MIN_VALUE\n     * @since 1.1\n     */\n    public static int safeNegate(int value) {\n        if (value == Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"Integer.MIN_VALUE cannot be negated\");\n        }\n        return -value;\n    }\n    \n    /**\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeAdd(int val1, int val2) {\n        int sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n    \n    /**\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeAdd(long val1, long val2) {\n        long sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n    \n    /**\n     * Subtracts two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value, to be taken away from\n     * @param val2  the second value, the amount to take away\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeSubtract(long val1, long val2) {\n        long diff = val1 - val2;\n        // If there is a sign change, but the two values have different signs...\n        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n        }\n        return diff;\n    }\n    \n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static int safeMultiply(int val1, int val2) {\n        long total = (long) val1 * (long) val2;\n        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\n          throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        return (int) total;\n    }\n\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n                if (val1 == Long.MIN_VALUE) {\n                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n                }\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n\n    /**\n     * Divides the dividend by the divisor throwing an exception if \n     * overflow occurs or the divisor is zero.\n     * \n     * @param dividend  the dividend\n     * @param divisor  the divisor\n     * @return the new total\n     * @throws ArithmeticException if the operation overflows or the divisor is zero\n     */\n    public static long safeDivide(long dividend, long divisor) {", "right_context": "}\n\n}", "class_name": "FieldUtils", "return_type": "long", "parameters": [{"type": "long", "name": "dividend"}, {"type": "long", "name": "divisor"}]}}
{"prompt": "class DateTimeZone implements Serializable {\n    \n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n    /** Maximum offset. */\n    private static final int MAX_MILLIS = (86400 * 1000) - 1;\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {", "metadata": {"defects4j_task_id": "09af5747dff82733b2c8928a8108f6229a19a1f8a02ddcd9b1cdb3710acaa233", "task_id": "JodaOrg_joda-time/10", "ground_truth": "\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "DateTimeZone.java"], "context_start_lineno": 0, "function_name": "forID", "left_context": "class DateTimeZone implements Serializable {\n    \n    /** The time zone for Universal Coordinated Time */\n    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n    /** Maximum offset. */\n    private static final int MAX_MILLIS = (86400 * 1000) - 1;\n\n    /** The instance that is providing time zones. */\n    private static Provider cProvider;\n    /** The instance that is providing time zone names. */\n    private static NameProvider cNameProvider;\n    /** The set of ID strings. */\n    private static Set<String> cAvailableIDs;\n    /** The default time zone. */\n    private static volatile DateTimeZone cDefault;\n    /** A formatter for printing and parsing zones. */\n    private static DateTimeFormatter cOffsetFormatter;\n\n    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n\n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {", "right_context": "}\n\n}", "class_name": "DateTimeZone", "return_type": "DateTimeZone", "parameters": [{"type": "String", "name": "id"}]}}
{"prompt": "class DateTimeZone implements Serializable {\n    \n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The hours value must be in the range -23 to +23.\n     * The minutes value must be in the range -59 to +59.\n     * The following combinations of sign for the hour and minute are possible:\n     * <pre>\n     *  Hour    Minute    Example    Result\n     * \n     *  +ve     +ve       (2, 15)    +02:15\n     *  +ve     zero      (2, 0)     +02:00\n     *  +ve     -ve       (2, -15)   IllegalArgumentException\n     * \n     *  zero    +ve       (0, 15)    +00:15\n     *  zero    zero      (0, 0)     +00:00\n     *  zero    -ve       (0, -15)   -00:15\n     * \n     *  -ve     +ve       (-2, 15)   -02:15\n     *  -ve     zero      (-2, 0)    -02:00\n     *  -ve     -ve       (-2, -15)  -02:15\n     * </pre>\n     * Note that in versions before 2.3, the minutes had to be zero or positive.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if any value is out of range, the minutes are negative\n     *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {", "metadata": {"defects4j_task_id": "971ddb5b36dc62d598683bb575ee239a602b5e0bb178ca0c7997c24af1067c2a", "task_id": "JodaOrg_joda-time/124", "ground_truth": "\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "DateTimeZone.java"], "context_start_lineno": 0, "function_name": "forOffsetHoursMinutes", "left_context": "class DateTimeZone implements Serializable {\n    \n    /** Cache of old zone IDs to new zone IDs */\n    private static Map<String, String> cZoneIdConversion;\n\n    static {\n        setProvider0(null);\n        setNameProvider0(null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     */\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n\n    /**\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     */\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     */\n    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     */\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The hours value must be in the range -23 to +23.\n     * The minutes value must be in the range -59 to +59.\n     * The following combinations of sign for the hour and minute are possible:\n     * <pre>\n     *  Hour    Minute    Example    Result\n     * \n     *  +ve     +ve       (2, 15)    +02:15\n     *  +ve     zero      (2, 0)     +02:00\n     *  +ve     -ve       (2, -15)   IllegalArgumentException\n     * \n     *  zero    +ve       (0, 15)    +00:15\n     *  zero    zero      (0, 0)     +00:00\n     *  zero    -ve       (0, -15)   -00:15\n     * \n     *  -ve     +ve       (-2, 15)   -02:15\n     *  -ve     zero      (-2, 0)    -02:00\n     *  -ve     -ve       (-2, -15)  -02:15\n     * </pre>\n     * Note that in versions before 2.3, the minutes had to be zero or positive.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if any value is out of range, the minutes are negative\n     *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {", "right_context": "}\n\n}", "class_name": "DateTimeZone", "return_type": "DateTimeZone", "parameters": [{"type": "int", "name": "hoursOffset"}, {"type": "int", "name": "minutesOffset"}]}}
{"prompt": "class DateTimeZone implements Serializable {\n    \n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            private static final long serialVersionUID = -3128740902654445468L;\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {", "metadata": {"defects4j_task_id": "9eddd6d6ded914b792612de27b13f06100729c39ca1feabce1bf9961cff64d00", "task_id": "JodaOrg_joda-time/129", "ground_truth": "\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "DateTimeZone.java"], "context_start_lineno": 0, "function_name": "printOffset", "left_context": "class DateTimeZone implements Serializable {\n    \n    /**\n     * Gets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @return the provider\n     */\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }\n\n    /**\n     * Sets the name provider factory.\n     * <p>\n     * The name provider is a pluggable instance factory that supplies the\n     * names of each DateTimeZone.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }\n\n    /**\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     */\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n\n    /**\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     */\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            private static final long serialVersionUID = -3128740902654445468L;\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }\n\n    /**\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     */\n    private static String printOffset(int offset) {", "right_context": "}\n\n}", "class_name": "DateTimeZone", "return_type": "String", "parameters": [{"type": "int", "name": "offset"}]}}
{"prompt": "class DateTimeZone implements Serializable {\n    \n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalInstantException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalInstantException(instantLocal, getID());\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {", "metadata": {"defects4j_task_id": "571dd62e240d1501e5d3d565254371e8e297aef204b63578b8ff7fb2db3e0208", "task_id": "JodaOrg_joda-time/77", "ground_truth": "\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "DateTimeZone.java"], "context_start_lineno": 0, "function_name": "getMillisKeepLocal", "left_context": "class DateTimeZone implements Serializable {\n    \n    /**\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     */\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n\n    /**\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalInstantException if the zone has no equivalent local time\n     * @since 1.5\n     */\n    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalInstantException(instantLocal, getID());\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n\n    /**\n     * Gets the millisecond instant in another zone keeping the same local time.\n     * <p>\n     * The conversion is performed by converting the specified UTC millis to local\n     * millis in this zone, then converting back to UTC millis in the new zone.\n     *\n     * @param newZone  the new zone, null means default\n     * @param oldInstant  the UTC millisecond instant to convert\n     * @return the UTC millisecond instant with the same local time in the new zone\n     */\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {", "right_context": "}\n\n}", "class_name": "DateTimeZone", "return_type": "long", "parameters": [{"type": "DateTimeZone", "name": "newZone"}, {"type": "long", "name": "oldInstant"}]}}
{"prompt": "class BaseSingleFieldPeriod\n        implements ReadablePeriod, Comparable<BaseSingleFieldPeriod>, Serializable {\n\n    /** The start of 1972. */\n    private static final long START_1972 = 2L * 365L * 86400L * 1000L;\n\n    /** The period in the units of this period. */\n    private volatile int iPeriod;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the number of whole units between the two specified datetimes.\n     *\n     * @param start  the start instant, validated to not be null\n     * @param end  the end instant, validated to not be null\n     * @param field  the field type to use, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the instants are null or invalid\n     */\n    protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadableInstant objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the number of whole units between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, validated to not be null\n     * @param end  the end partial date, validated to not be null\n     * @param zeroInstance  the zero instance constant, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */\n    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {", "metadata": {"defects4j_task_id": "6e132fc516a44da007cc41640da32da49370ec9a75f617c792167f8cedf2b03d", "task_id": "JodaOrg_joda-time/92", "ground_truth": "\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n        }\n        if (DateTimeUtils.isContiguous(start) == false) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));\n        return values[0];\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "base", "BaseSingleFieldPeriod.java"], "context_start_lineno": 0, "function_name": "between", "left_context": "class BaseSingleFieldPeriod\n        implements ReadablePeriod, Comparable<BaseSingleFieldPeriod>, Serializable {\n\n    /** The start of 1972. */\n    private static final long START_1972 = 2L * 365L * 86400L * 1000L;\n\n    /** The period in the units of this period. */\n    private volatile int iPeriod;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the number of whole units between the two specified datetimes.\n     *\n     * @param start  the start instant, validated to not be null\n     * @param end  the end instant, validated to not be null\n     * @param field  the field type to use, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the instants are null or invalid\n     */\n    protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadableInstant objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the number of whole units between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, validated to not be null\n     * @param end  the end partial date, validated to not be null\n     * @param zeroInstance  the zero instance constant, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */\n    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {", "right_context": "}\n\n}", "class_name": "BaseSingleFieldPeriod", "return_type": "int", "parameters": [{"type": "ReadablePartial", "name": "start"}, {"type": "ReadablePartial", "name": "end"}, {"type": "ReadablePeriod", "name": "zeroInstance"}]}}
{"prompt": "class ConverterManager {\n\n    public static ConverterManager getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = new ConverterManager();\n        }\n        return INSTANCE;\n    }\n    \n    private ConverterSet iInstantConverters;\n    private ConverterSet iPartialConverters;\n    private ConverterSet iDurationConverters;\n    private ConverterSet iPeriodConverters;\n    private ConverterSet iIntervalConverters;\n    \n    /**\n     * Restricted constructor.\n     */\n    protected ConverterManager() {\n        super();\n\n        iInstantConverters = new ConverterSet(new Converter[] {\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPartialConverters = new ConverterSet(new Converter[] {\n            ReadablePartialConverter.INSTANCE,\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iDurationConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPeriodConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadablePeriodConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iIntervalConverters = new ConverterSet(new Converter[] {\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public InstantConverter getInstantConverter(Object object) {\n        InstantConverter converter =\n            (InstantConverter)iInstantConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No instant converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public InstantConverter[] getInstantConverters() {\n        ConverterSet set = iInstantConverters;\n        InstantConverter[] converters = new InstantConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter addInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException {", "metadata": {"defects4j_task_id": "a903abcc9ee51ade40bc32c88d7dafa3f9e57330ae24bb6f896969a920338581", "task_id": "JodaOrg_joda-time/142", "ground_truth": "\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "convert", "ConverterManager.java"], "context_start_lineno": 0, "function_name": "removeInstantConverter", "left_context": "class ConverterManager {\n\n    public static ConverterManager getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = new ConverterManager();\n        }\n        return INSTANCE;\n    }\n    \n    private ConverterSet iInstantConverters;\n    private ConverterSet iPartialConverters;\n    private ConverterSet iDurationConverters;\n    private ConverterSet iPeriodConverters;\n    private ConverterSet iIntervalConverters;\n    \n    /**\n     * Restricted constructor.\n     */\n    protected ConverterManager() {\n        super();\n\n        iInstantConverters = new ConverterSet(new Converter[] {\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPartialConverters = new ConverterSet(new Converter[] {\n            ReadablePartialConverter.INSTANCE,\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iDurationConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPeriodConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadablePeriodConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iIntervalConverters = new ConverterSet(new Converter[] {\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public InstantConverter getInstantConverter(Object object) {\n        InstantConverter converter =\n            (InstantConverter)iInstantConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No instant converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public InstantConverter[] getInstantConverters() {\n        ConverterSet set = iInstantConverters;\n        InstantConverter[] converters = new InstantConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter addInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException {", "right_context": "}\n\n}", "class_name": "ConverterManager", "return_type": "InstantConverter", "parameters": [{"type": "InstantConverter", "name": "converter"}]}}
{"prompt": "class ConverterManager {\n\n    public static ConverterManager getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = new ConverterManager();\n        }\n        return INSTANCE;\n    }\n    \n    private ConverterSet iInstantConverters;\n    private ConverterSet iPartialConverters;\n    private ConverterSet iDurationConverters;\n    private ConverterSet iPeriodConverters;\n    private ConverterSet iIntervalConverters;\n    \n    /**\n     * Restricted constructor.\n     */\n    protected ConverterManager() {\n        super();\n\n        iInstantConverters = new ConverterSet(new Converter[] {\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPartialConverters = new ConverterSet(new Converter[] {\n            ReadablePartialConverter.INSTANCE,\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iDurationConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPeriodConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadablePeriodConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iIntervalConverters = new ConverterSet(new Converter[] {\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public InstantConverter getInstantConverter(Object object) {\n        InstantConverter converter =\n            (InstantConverter)iInstantConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No instant converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public InstantConverter[] getInstantConverters() {\n        ConverterSet set = iInstantConverters;\n        InstantConverter[] converters = new InstantConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter addInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterInstantConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterInstantConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterInstantConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public PartialConverter getPartialConverter(Object object) {\n        PartialConverter converter =\n            (PartialConverter)iPartialConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No partial converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public PartialConverter[] getPartialConverters() {\n        ConverterSet set = iPartialConverters;\n        PartialConverter[] converters = new PartialConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException {", "metadata": {"defects4j_task_id": "e4bc15d103669267e49b6a1d051f1faeccb4d2546a0a7633725c2d002b16fa69", "task_id": "JodaOrg_joda-time/186", "ground_truth": "\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "convert", "ConverterManager.java"], "context_start_lineno": 0, "function_name": "addPartialConverter", "left_context": "class ConverterManager {\n\n    public static ConverterManager getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = new ConverterManager();\n        }\n        return INSTANCE;\n    }\n    \n    private ConverterSet iInstantConverters;\n    private ConverterSet iPartialConverters;\n    private ConverterSet iDurationConverters;\n    private ConverterSet iPeriodConverters;\n    private ConverterSet iIntervalConverters;\n    \n    /**\n     * Restricted constructor.\n     */\n    protected ConverterManager() {\n        super();\n\n        iInstantConverters = new ConverterSet(new Converter[] {\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPartialConverters = new ConverterSet(new Converter[] {\n            ReadablePartialConverter.INSTANCE,\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iDurationConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPeriodConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadablePeriodConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iIntervalConverters = new ConverterSet(new Converter[] {\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public InstantConverter getInstantConverter(Object object) {\n        InstantConverter converter =\n            (InstantConverter)iInstantConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No instant converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public InstantConverter[] getInstantConverters() {\n        ConverterSet set = iInstantConverters;\n        InstantConverter[] converters = new InstantConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter addInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterInstantConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterInstantConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterInstantConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public PartialConverter getPartialConverter(Object object) {\n        PartialConverter converter =\n            (PartialConverter)iPartialConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No partial converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public PartialConverter[] getPartialConverters() {\n        ConverterSet set = iPartialConverters;\n        PartialConverter[] converters = new PartialConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException {", "right_context": "}\n\n}", "class_name": "ConverterManager", "return_type": "PartialConverter", "parameters": [{"type": "PartialConverter", "name": "converter"}]}}
{"prompt": "class ConverterManager {\n\n    public static ConverterManager getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = new ConverterManager();\n        }\n        return INSTANCE;\n    }\n    \n    private ConverterSet iInstantConverters;\n    private ConverterSet iPartialConverters;\n    private ConverterSet iDurationConverters;\n    private ConverterSet iPeriodConverters;\n    private ConverterSet iIntervalConverters;\n    \n    /**\n     * Restricted constructor.\n     */\n    protected ConverterManager() {\n        super();\n\n        iInstantConverters = new ConverterSet(new Converter[] {\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPartialConverters = new ConverterSet(new Converter[] {\n            ReadablePartialConverter.INSTANCE,\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iDurationConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPeriodConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadablePeriodConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iIntervalConverters = new ConverterSet(new Converter[] {\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public InstantConverter getInstantConverter(Object object) {\n        InstantConverter converter =\n            (InstantConverter)iInstantConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No instant converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public InstantConverter[] getInstantConverters() {\n        ConverterSet set = iInstantConverters;\n        InstantConverter[] converters = new InstantConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter addInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterInstantConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterInstantConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterInstantConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public PartialConverter getPartialConverter(Object object) {\n        PartialConverter converter =\n            (PartialConverter)iPartialConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No partial converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public PartialConverter[] getPartialConverters() {\n        ConverterSet set = iPartialConverters;\n        PartialConverter[] converters = new PartialConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException {", "metadata": {"defects4j_task_id": "c834c6624ac3d94dd94c12cd74278de1d64d29266fa8984e494004e5bbf205c1", "task_id": "JodaOrg_joda-time/162", "ground_truth": "\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "convert", "ConverterManager.java"], "context_start_lineno": 0, "function_name": "removePartialConverter", "left_context": "class ConverterManager {\n\n    public static ConverterManager getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = new ConverterManager();\n        }\n        return INSTANCE;\n    }\n    \n    private ConverterSet iInstantConverters;\n    private ConverterSet iPartialConverters;\n    private ConverterSet iDurationConverters;\n    private ConverterSet iPeriodConverters;\n    private ConverterSet iIntervalConverters;\n    \n    /**\n     * Restricted constructor.\n     */\n    protected ConverterManager() {\n        super();\n\n        iInstantConverters = new ConverterSet(new Converter[] {\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPartialConverters = new ConverterSet(new Converter[] {\n            ReadablePartialConverter.INSTANCE,\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iDurationConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPeriodConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadablePeriodConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iIntervalConverters = new ConverterSet(new Converter[] {\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public InstantConverter getInstantConverter(Object object) {\n        InstantConverter converter =\n            (InstantConverter)iInstantConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No instant converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public InstantConverter[] getInstantConverters() {\n        ConverterSet set = iInstantConverters;\n        InstantConverter[] converters = new InstantConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter addInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterInstantConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterInstantConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterInstantConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public PartialConverter getPartialConverter(Object object) {\n        PartialConverter converter =\n            (PartialConverter)iPartialConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No partial converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public PartialConverter[] getPartialConverters() {\n        ConverterSet set = iPartialConverters;\n        PartialConverter[] converters = new PartialConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException {", "right_context": "}\n\n}", "class_name": "ConverterManager", "return_type": "PartialConverter", "parameters": [{"type": "PartialConverter", "name": "converter"}]}}
{"prompt": "class ConverterManager {\n\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public PartialConverter[] getPartialConverters() {\n        ConverterSet set = iPartialConverters;\n        PartialConverter[] converters = new PartialConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterPartialConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterPartialConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPartialConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public DurationConverter getDurationConverter(Object object) {\n        DurationConverter converter =\n            (DurationConverter)iDurationConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No duration converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the list of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public DurationConverter[] getDurationConverters() {\n        ConverterSet set = iDurationConverters;\n        DurationConverter[] converters = new DurationConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public DurationConverter addDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public DurationConverter removeDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterDurationConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterDurationConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterDurationConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public PeriodConverter getPeriodConverter(Object object) {\n        PeriodConverter converter =\n            (PeriodConverter)iPeriodConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No period converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the list of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public PeriodConverter[] getPeriodConverters() {\n        ConverterSet set = iPeriodConverters;\n        PeriodConverter[] converters = new PeriodConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException {", "metadata": {"defects4j_task_id": "aad72ecaa62a5c38618d87b340adc2fb701159638d4a451c938590c3c99ee9d7", "task_id": "JodaOrg_joda-time/144", "ground_truth": "\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "convert", "ConverterManager.java"], "context_start_lineno": 0, "function_name": "addPeriodConverter", "left_context": "class ConverterManager {\n\n    /**\n     * Gets a copy of the set of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public PartialConverter[] getPartialConverters() {\n        ConverterSet set = iPartialConverters;\n        PartialConverter[] converters = new PartialConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterPartialConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterPartialConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPartialConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public DurationConverter getDurationConverter(Object object) {\n        DurationConverter converter =\n            (DurationConverter)iDurationConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No duration converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the list of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public DurationConverter[] getDurationConverters() {\n        ConverterSet set = iDurationConverters;\n        DurationConverter[] converters = new DurationConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public DurationConverter addDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public DurationConverter removeDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterDurationConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterDurationConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterDurationConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public PeriodConverter getPeriodConverter(Object object) {\n        PeriodConverter converter =\n            (PeriodConverter)iPeriodConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No period converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the list of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public PeriodConverter[] getPeriodConverters() {\n        ConverterSet set = iPeriodConverters;\n        PeriodConverter[] converters = new PeriodConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException {", "right_context": "}\n\n}", "class_name": "ConverterManager", "return_type": "PeriodConverter", "parameters": [{"type": "PeriodConverter", "name": "converter"}]}}
{"prompt": "class ConverterManager {\n\n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterPartialConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterPartialConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPartialConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public DurationConverter getDurationConverter(Object object) {\n        DurationConverter converter =\n            (DurationConverter)iDurationConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No duration converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the list of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public DurationConverter[] getDurationConverters() {\n        ConverterSet set = iDurationConverters;\n        DurationConverter[] converters = new DurationConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public DurationConverter addDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public DurationConverter removeDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterDurationConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterDurationConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterDurationConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public PeriodConverter getPeriodConverter(Object object) {\n        PeriodConverter converter =\n            (PeriodConverter)iPeriodConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No period converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the list of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public PeriodConverter[] getPeriodConverters() {\n        ConverterSet set = iPeriodConverters;\n        PeriodConverter[] converters = new PeriodConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException {", "metadata": {"defects4j_task_id": "43a1818604b351e9a187b44c06b85ddc4e1d092e29d8c0a71e3e64677e5d7b68", "task_id": "JodaOrg_joda-time/61", "ground_truth": "\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "convert", "ConverterManager.java"], "context_start_lineno": 0, "function_name": "removePeriodConverter", "left_context": "class ConverterManager {\n\n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterPartialConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterPartialConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPartialConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public DurationConverter getDurationConverter(Object object) {\n        DurationConverter converter =\n            (DurationConverter)iDurationConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No duration converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the list of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public DurationConverter[] getDurationConverters() {\n        ConverterSet set = iDurationConverters;\n        DurationConverter[] converters = new DurationConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public DurationConverter addDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public DurationConverter removeDurationConverter(DurationConverter converter)\n            throws SecurityException {\n        \n        checkAlterDurationConverters();\n        if (converter == null) {\n            return null;\n        }\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.remove(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Checks whether the user has permission 'ConverterManager.alterDurationConverters'.\n     * \n     * @throws SecurityException if the user does not have the permission\n     */\n    private void checkAlterDurationConverters() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterDurationConverters\"));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the best converter for the object specified.\n     * \n     * @param object  the object to convert\n     * @return the converter to use\n     * @throws IllegalArgumentException if no suitable converter\n     * @throws IllegalStateException if multiple converters match the type\n     * equally well\n     */\n    public PeriodConverter getPeriodConverter(Object object) {\n        PeriodConverter converter =\n            (PeriodConverter)iPeriodConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No period converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a copy of the list of converters.\n     * \n     * @return the converters, a copy of the real data, never null\n     */\n    public PeriodConverter[] getPeriodConverters() {\n        ConverterSet set = iPeriodConverters;\n        PeriodConverter[] converters = new PeriodConverter[set.size()];\n        set.copyInto(converters);\n        return converters;\n    }\n    \n    /**\n     * Adds a converter to the set of converters. If a matching converter is\n     * already in the set, the given converter replaces it. If the converter is\n     * exactly the same as one already in the set, no changes are made.\n     * <p>\n     * The order in which converters are added is not relevent. The best\n     * converter is selected by examining the object hierarchy.\n     * \n     * @param converter  the converter to add, null ignored\n     * @return replaced converter, or null\n     */\n    public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null\n     */\n    public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException {", "right_context": "}\n\n}", "class_name": "ConverterManager", "return_type": "PeriodConverter", "parameters": [{"type": "PeriodConverter", "name": "converter"}]}}
{"prompt": "class DateTimeUtils {\n\n    /**\n     * Gets the chronology from the specified instant object handling null.\n     * <p>\n     * If the instant object is <code>null</code>, or the instant's chronology is\n     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n     * Otherwise, the chronology from the object is returned.\n     * \n     * @param instant  the instant to examine, null means ISO in the default zone\n     * @return the chronology, never null\n     */\n    public static final Chronology getInstantChronology(ReadableInstant instant) {\n        if (instant == null) {\n            return ISOChronology.getInstance();\n        }\n        Chronology chrono = instant.getChronology();\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology from the specified instant based interval handling null.\n     * <p>\n     * The chronology is obtained from the start if that is not null, or from the\n     * end if the start is null. The result is additionally checked, and if still\n     * null then {@link ISOChronology#getInstance()} will be returned.\n     * \n     * @param start  the instant to examine and use as the primary source of the chronology\n     * @param end  the instant to examine and use as the secondary source of the chronology\n     * @return the chronology, never null\n     */\n    public static final Chronology getIntervalChronology(ReadableInstant start, ReadableInstant end) {\n        Chronology chrono = null;\n        if (start != null) {\n            chrono = start.getChronology();\n        } else if (end != null) {\n            chrono = end.getChronology();\n        }\n        if (chrono == null) {\n            chrono = ISOChronology.getInstance();\n        }\n        return chrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology from the specified interval object handling null.\n     * <p>\n     * If the interval object is <code>null</code>, or the interval's chronology is\n     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n     * Otherwise, the chronology from the object is returned.\n     * \n     * @param interval  the interval to examine, null means ISO in the default zone\n     * @return the chronology, never null\n     */\n    public static final Chronology getIntervalChronology(ReadableInterval interval) {\n        if (interval == null) {\n            return ISOChronology.getInstance();\n        }\n        Chronology chrono = interval.getChronology();\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the interval handling null.\n     * <p>\n     * If the interval is <code>null</code>, an interval representing now\n     * to now in the {@link ISOChronology#getInstance() ISOChronology}\n     * will be returned. Otherwise, the interval specified is returned.\n     * \n     * @param interval  the interval to use, null means now to now\n     * @return the interval, never null\n     * @since 1.1\n     */\n    public static final ReadableInterval getReadableInterval(ReadableInterval interval) {\n        if (interval == null) {\n            long now = DateTimeUtils.currentTimeMillis();\n            interval = new Interval(now, now);\n        }\n        return interval;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology handling null.\n     * <p>\n     * If the chronology is <code>null</code>, {@link ISOChronology#getInstance()}\n     * will be returned. Otherwise, the chronology is returned.\n     * \n     * @param chrono  the chronology to use, null means ISO in the default zone\n     * @return the chronology, never null\n     */\n    public static final Chronology getChronology(Chronology chrono) {\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone handling null.\n     * <p>\n     * If the zone is <code>null</code>, {@link DateTimeZone#getDefault()}\n     * will be returned. Otherwise, the zone specified is returned.\n     * \n     * @param zone  the time zone to use, null means the default zone\n     * @return the time zone, never null\n     */\n    public static final DateTimeZone getZone(DateTimeZone zone) {\n        if (zone == null) {\n            return DateTimeZone.getDefault();\n        }\n        return zone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the period type handling null.\n     * <p>\n     * If the zone is <code>null</code>, {@link PeriodType#standard()}\n     * will be returned. Otherwise, the type specified is returned.\n     * \n     * @param type  the time zone to use, null means the standard type\n     * @return the type to use, never null\n     */\n    public static final PeriodType getPeriodType(PeriodType type) {\n        if (type == null) {\n            return PeriodType.standard();\n        }\n        return type;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the millisecond duration from the specified duration object handling null.\n     * <p>\n     * If the duration object is <code>null</code>, zero will be returned.\n     * Otherwise, the millis from the object are returned.\n     * \n     * @param duration  the duration to examine, null means zero\n     * @return the duration in milliseconds\n     */\n    public static final long getDurationMillis(ReadableDuration duration) {\n        if (duration == null) {\n            return 0L;\n        }\n        return duration.getMillis();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether the partial is contiguous.\n     * <p>\n     * A partial is contiguous if one field starts where another ends.\n     * <p>\n     * For example <code>LocalDate</code> is contiguous because DayOfMonth has\n     * the same range (Month) as the unit of the next field (MonthOfYear), and\n     * MonthOfYear has the same range (Year) as the unit of the next field (Year).\n     * <p>\n     * Similarly, <code>LocalTime</code> is contiguous, as it consists of\n     * MillisOfSecond, SecondOfMinute, MinuteOfHour and HourOfDay (note how\n     * the names of each field 'join up').\n     * <p>\n     * However, a Year/HourOfDay partial is not contiguous because the range\n     * field Day is not equal to the next field Year.\n     * Similarly, a DayOfWeek/DayOfMonth partial is not contiguous because\n     * the range Month is not equal to the next field Day.\n     * \n     * @param partial  the partial to check\n     * @return true if the partial is contiguous\n     * @throws IllegalArgumentException if the partial is null\n     * @since 1.1\n     */\n    public static final boolean isContiguous(ReadablePartial partial) {", "metadata": {"defects4j_task_id": "46785c61bf6073b5b3fe45ac81d9e44da30d344585f20e707bbecc4ea94d28f2", "task_id": "JodaOrg_joda-time/62", "ground_truth": "\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial must not be null\");\n        }\n        DurationFieldType lastType = null;\n        for (int i = 0; i < partial.size(); i++) {\n            DateTimeField loopField = partial.getField(i);\n            if (i > 0) {\n                if (loopField.getRangeDurationField() == null || loopField.getRangeDurationField().getType() != lastType) {\n                    return false;\n                }\n            }\n            lastType = loopField.getDurationField().getType();\n        }\n        return true;\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "DateTimeUtils.java"], "context_start_lineno": 0, "function_name": "isContiguous", "left_context": "class DateTimeUtils {\n\n    /**\n     * Gets the chronology from the specified instant object handling null.\n     * <p>\n     * If the instant object is <code>null</code>, or the instant's chronology is\n     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n     * Otherwise, the chronology from the object is returned.\n     * \n     * @param instant  the instant to examine, null means ISO in the default zone\n     * @return the chronology, never null\n     */\n    public static final Chronology getInstantChronology(ReadableInstant instant) {\n        if (instant == null) {\n            return ISOChronology.getInstance();\n        }\n        Chronology chrono = instant.getChronology();\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology from the specified instant based interval handling null.\n     * <p>\n     * The chronology is obtained from the start if that is not null, or from the\n     * end if the start is null. The result is additionally checked, and if still\n     * null then {@link ISOChronology#getInstance()} will be returned.\n     * \n     * @param start  the instant to examine and use as the primary source of the chronology\n     * @param end  the instant to examine and use as the secondary source of the chronology\n     * @return the chronology, never null\n     */\n    public static final Chronology getIntervalChronology(ReadableInstant start, ReadableInstant end) {\n        Chronology chrono = null;\n        if (start != null) {\n            chrono = start.getChronology();\n        } else if (end != null) {\n            chrono = end.getChronology();\n        }\n        if (chrono == null) {\n            chrono = ISOChronology.getInstance();\n        }\n        return chrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology from the specified interval object handling null.\n     * <p>\n     * If the interval object is <code>null</code>, or the interval's chronology is\n     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n     * Otherwise, the chronology from the object is returned.\n     * \n     * @param interval  the interval to examine, null means ISO in the default zone\n     * @return the chronology, never null\n     */\n    public static final Chronology getIntervalChronology(ReadableInterval interval) {\n        if (interval == null) {\n            return ISOChronology.getInstance();\n        }\n        Chronology chrono = interval.getChronology();\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the interval handling null.\n     * <p>\n     * If the interval is <code>null</code>, an interval representing now\n     * to now in the {@link ISOChronology#getInstance() ISOChronology}\n     * will be returned. Otherwise, the interval specified is returned.\n     * \n     * @param interval  the interval to use, null means now to now\n     * @return the interval, never null\n     * @since 1.1\n     */\n    public static final ReadableInterval getReadableInterval(ReadableInterval interval) {\n        if (interval == null) {\n            long now = DateTimeUtils.currentTimeMillis();\n            interval = new Interval(now, now);\n        }\n        return interval;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology handling null.\n     * <p>\n     * If the chronology is <code>null</code>, {@link ISOChronology#getInstance()}\n     * will be returned. Otherwise, the chronology is returned.\n     * \n     * @param chrono  the chronology to use, null means ISO in the default zone\n     * @return the chronology, never null\n     */\n    public static final Chronology getChronology(Chronology chrono) {\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone handling null.\n     * <p>\n     * If the zone is <code>null</code>, {@link DateTimeZone#getDefault()}\n     * will be returned. Otherwise, the zone specified is returned.\n     * \n     * @param zone  the time zone to use, null means the default zone\n     * @return the time zone, never null\n     */\n    public static final DateTimeZone getZone(DateTimeZone zone) {\n        if (zone == null) {\n            return DateTimeZone.getDefault();\n        }\n        return zone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the period type handling null.\n     * <p>\n     * If the zone is <code>null</code>, {@link PeriodType#standard()}\n     * will be returned. Otherwise, the type specified is returned.\n     * \n     * @param type  the time zone to use, null means the standard type\n     * @return the type to use, never null\n     */\n    public static final PeriodType getPeriodType(PeriodType type) {\n        if (type == null) {\n            return PeriodType.standard();\n        }\n        return type;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the millisecond duration from the specified duration object handling null.\n     * <p>\n     * If the duration object is <code>null</code>, zero will be returned.\n     * Otherwise, the millis from the object are returned.\n     * \n     * @param duration  the duration to examine, null means zero\n     * @return the duration in milliseconds\n     */\n    public static final long getDurationMillis(ReadableDuration duration) {\n        if (duration == null) {\n            return 0L;\n        }\n        return duration.getMillis();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether the partial is contiguous.\n     * <p>\n     * A partial is contiguous if one field starts where another ends.\n     * <p>\n     * For example <code>LocalDate</code> is contiguous because DayOfMonth has\n     * the same range (Month) as the unit of the next field (MonthOfYear), and\n     * MonthOfYear has the same range (Year) as the unit of the next field (Year).\n     * <p>\n     * Similarly, <code>LocalTime</code> is contiguous, as it consists of\n     * MillisOfSecond, SecondOfMinute, MinuteOfHour and HourOfDay (note how\n     * the names of each field 'join up').\n     * <p>\n     * However, a Year/HourOfDay partial is not contiguous because the range\n     * field Day is not equal to the next field Year.\n     * Similarly, a DayOfWeek/DayOfMonth partial is not contiguous because\n     * the range Month is not equal to the next field Day.\n     * \n     * @param partial  the partial to check\n     * @return true if the partial is contiguous\n     * @throws IllegalArgumentException if the partial is null\n     * @since 1.1\n     */\n    public static final boolean isContiguous(ReadablePartial partial) {", "right_context": "}\n\n}", "class_name": "DateTimeUtils", "return_type": "boolean", "parameters": [{"type": "ReadablePartial", "name": "partial"}]}}
{"prompt": "class PiePlot extends Plot implements Selectable, Cloneable,\n        Serializable {\n\n    /**\n     * Returns the interior gap, measured as a percentage of the available\n     * drawing space.\n     *\n     * @return The gap (as a percentage of the available drawing space).\n     *\n     * @see #setInteriorGap(double)\n     */\n    public double getInteriorGap() {\n        return this.interiorGap;\n    }\n\n    /**\n     * Sets the interior gap and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  This controls the space between the edges of the\n     * pie plot and the plot area itself (the region where the section labels\n     * appear).\n     *\n     * @param percent  the gap (as a percentage of the available drawing space).\n     *\n     * @see #getInteriorGap()\n     */\n    public void setInteriorGap(double percent) {\n\n        if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {\n            throw new IllegalArgumentException(\n                \"Invalid 'percent' (\" + percent + \") argument.\");\n        }\n\n        if (this.interiorGap != percent) {\n            this.interiorGap = percent;\n            fireChangeEvent();\n        }\n\n    }\n\n    /**\n     * Returns a flag indicating whether the pie chart is circular, or\n     * stretched into an elliptical shape.\n     *\n     * @return A flag indicating whether the pie chart is circular.\n     *\n     * @see #setCircular(boolean)\n     */\n    public boolean isCircular() {\n        return this.circular;\n    }\n\n    /**\n     * A flag indicating whether the pie chart is circular, or stretched into\n     * an elliptical shape.\n     *\n     * @param flag  the new value.\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean flag) {\n        setCircular(flag, true);\n    }\n\n    /**\n     * Sets the circular attribute and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param circular  the new value of the flag.\n     * @param notify  notify listeners?\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean circular, boolean notify) {\n        this.circular = circular;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the flag that controls whether <code>null</code> values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public boolean getIgnoreNullValues() {\n        return this.ignoreNullValues;\n    }\n\n    /**\n     * Sets a flag that controls whether <code>null</code> values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  At\n     * present, this only affects whether or not the key is presented in the\n     * legend.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreNullValues()\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public void setIgnoreNullValues(boolean flag) {\n        this.ignoreNullValues = flag;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether zero values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public boolean getIgnoreZeroValues() {\n        return this.ignoreZeroValues;\n    }\n\n    /**\n     * Sets a flag that controls whether zero values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  This\n     * only affects whether or not a label appears for the non-visible\n     * pie section.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreZeroValues()\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public void setIgnoreZeroValues(boolean flag) {\n        this.ignoreZeroValues = flag;\n        fireChangeEvent();\n    }\n\n    //// SECTION PAINT ////////////////////////////////////////////////////////\n\n    /**\n     * Returns the paint for the specified section.  This is equivalent to\n     * <code>lookupSectionPaint(section, getAutoPopulateSectionPaint())</code>.\n     *\n     * @param key  the section key.\n     * @param selected  is the section selected?\n     *\n     * @return The paint for the specified section.\n     *\n     * @since 1.2.0\n     *\n     * @see #lookupSectionPaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected) {\n        Paint result = null;\n        if (selected) {\n            result = this.selectedItemAttributes.lookupSectionPaint(key);\n        }\n        if (result == null) {\n            result = lookupSectionPaint(key, selected,\n                    getAutoPopulateSectionPaint());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the paint for the specified section.  The lookup involves these\n     * steps:\n     * <ul>\n     * <li>if {@link #getSectionPaint(Comparable)} is non-<code>null</code>\n     *         return it;</li>\n     * <li>if {@link #getSectionPaint(Comparable)} is <code>null</code> but\n     *         <code>autoPopulate</code> is <code>true</code>, attempt to fetch\n     *         a new paint from the drawing supplier\n     *         ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionPaint()}.\n     * </ul>\n     *\n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier\n     *     is used to auto-populate the section paint settings.\n     *\n     * @return The paint.\n     *\n     * @since 1.2.0\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected, \n            boolean autoPopulate) {\n\n        if (selected) {\n          //  return Color.WHITE;\n        }\n        Paint result = null;\n\n        // is a paint defined for the specified key\n        result = this.sectionPaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n\n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextPaint();\n                this.sectionPaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionPaint;\n            }\n        }\n        else {\n            result = this.baseSectionPaint;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a key for the specified section.  If there is no such section\n     * in the dataset, we generate a key.  This is to provide some backward\n     * compatibility for the (now deprecated) methods that get/set attributes\n     * based on section indices.  The preferred way of doing this now is to\n     * link the attributes directly to the section key (there are new methods\n     * for this, starting from version 1.0.3).\n     *\n     * @param section  the section index.\n     *\n     * @return The key.\n     *\n     * @since 1.0.3\n     */\n    protected Comparable getSectionKey(int section) {", "metadata": {"defects4j_task_id": "cca1fe2017686735e48e23576404d10dde66cfc5926280308f0f99fab1377f0c", "task_id": "JodaOrg_joda-time/167", "ground_truth": "\n            int limit = Math.min(text.length() - position, amount);\n            amount = 0;\n            for (; limit > 0; limit--) {\n                char c = text.charAt(position + amount);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                amount++;\n            }\n            return amount;\n        ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "format", "DateTimeFormatterBuilder.java"], "context_start_lineno": 0, "function_name": "digitCount", "left_context": "class PiePlot extends Plot implements Selectable, Cloneable,\n        Serializable {\n\n    /**\n     * Returns the interior gap, measured as a percentage of the available\n     * drawing space.\n     *\n     * @return The gap (as a percentage of the available drawing space).\n     *\n     * @see #setInteriorGap(double)\n     */\n    public double getInteriorGap() {\n        return this.interiorGap;\n    }\n\n    /**\n     * Sets the interior gap and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  This controls the space between the edges of the\n     * pie plot and the plot area itself (the region where the section labels\n     * appear).\n     *\n     * @param percent  the gap (as a percentage of the available drawing space).\n     *\n     * @see #getInteriorGap()\n     */\n    public void setInteriorGap(double percent) {\n\n        if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {\n            throw new IllegalArgumentException(\n                \"Invalid 'percent' (\" + percent + \") argument.\");\n        }\n\n        if (this.interiorGap != percent) {\n            this.interiorGap = percent;\n            fireChangeEvent();\n        }\n\n    }\n\n    /**\n     * Returns a flag indicating whether the pie chart is circular, or\n     * stretched into an elliptical shape.\n     *\n     * @return A flag indicating whether the pie chart is circular.\n     *\n     * @see #setCircular(boolean)\n     */\n    public boolean isCircular() {\n        return this.circular;\n    }\n\n    /**\n     * A flag indicating whether the pie chart is circular, or stretched into\n     * an elliptical shape.\n     *\n     * @param flag  the new value.\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean flag) {\n        setCircular(flag, true);\n    }\n\n    /**\n     * Sets the circular attribute and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param circular  the new value of the flag.\n     * @param notify  notify listeners?\n     *\n     * @see #isCircular()\n     */\n    public void setCircular(boolean circular, boolean notify) {\n        this.circular = circular;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the flag that controls whether <code>null</code> values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public boolean getIgnoreNullValues() {\n        return this.ignoreNullValues;\n    }\n\n    /**\n     * Sets a flag that controls whether <code>null</code> values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  At\n     * present, this only affects whether or not the key is presented in the\n     * legend.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreNullValues()\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public void setIgnoreNullValues(boolean flag) {\n        this.ignoreNullValues = flag;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether zero values in the\n     * dataset are ignored.\n     *\n     * @return A boolean.\n     *\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public boolean getIgnoreZeroValues() {\n        return this.ignoreZeroValues;\n    }\n\n    /**\n     * Sets a flag that controls whether zero values are ignored,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.  This\n     * only affects whether or not a label appears for the non-visible\n     * pie section.\n     *\n     * @param flag  the flag.\n     *\n     * @see #getIgnoreZeroValues()\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public void setIgnoreZeroValues(boolean flag) {\n        this.ignoreZeroValues = flag;\n        fireChangeEvent();\n    }\n\n    //// SECTION PAINT ////////////////////////////////////////////////////////\n\n    /**\n     * Returns the paint for the specified section.  This is equivalent to\n     * <code>lookupSectionPaint(section, getAutoPopulateSectionPaint())</code>.\n     *\n     * @param key  the section key.\n     * @param selected  is the section selected?\n     *\n     * @return The paint for the specified section.\n     *\n     * @since 1.2.0\n     *\n     * @see #lookupSectionPaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected) {\n        Paint result = null;\n        if (selected) {\n            result = this.selectedItemAttributes.lookupSectionPaint(key);\n        }\n        if (result == null) {\n            result = lookupSectionPaint(key, selected,\n                    getAutoPopulateSectionPaint());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the paint for the specified section.  The lookup involves these\n     * steps:\n     * <ul>\n     * <li>if {@link #getSectionPaint(Comparable)} is non-<code>null</code>\n     *         return it;</li>\n     * <li>if {@link #getSectionPaint(Comparable)} is <code>null</code> but\n     *         <code>autoPopulate</code> is <code>true</code>, attempt to fetch\n     *         a new paint from the drawing supplier\n     *         ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionPaint()}.\n     * </ul>\n     *\n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier\n     *     is used to auto-populate the section paint settings.\n     *\n     * @return The paint.\n     *\n     * @since 1.2.0\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean selected, \n            boolean autoPopulate) {\n\n        if (selected) {\n          //  return Color.WHITE;\n        }\n        Paint result = null;\n\n        // is a paint defined for the specified key\n        result = this.sectionPaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n\n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextPaint();\n                this.sectionPaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionPaint;\n            }\n        }\n        else {\n            result = this.baseSectionPaint;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a key for the specified section.  If there is no such section\n     * in the dataset, we generate a key.  This is to provide some backward\n     * compatibility for the (now deprecated) methods that get/set attributes\n     * based on section indices.  The preferred way of doing this now is to\n     * link the attributes directly to the section key (there are new methods\n     * for this, starting from version 1.0.3).\n     *\n     * @param section  the section index.\n     *\n     * @return The key.\n     *\n     * @since 1.0.3\n     */\n    protected Comparable getSectionKey(int section) {", "right_context": "}\n}", "class_name": "DateTimeFormatterBuilder", "return_type": "int", "parameters": [{"type": "String", "name": "text"}, {"type": "int", "name": "position"}, {"type": "int", "name": "amount"}]}}
{"prompt": "class DateTimeFormatter {\n\n    /**\n     * Prints a millisecond instant to a String.\n     * <p>\n     * This method will use the override zone and the override chronololgy if\n     * they are set. Otherwise it will use the ISO chronology and default zone.\n     *\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     * @return the printed result\n     */\n    public String print(long instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    /**\n     * Prints a ReadablePartial to a new String.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param partial  partial to format\n     * @return the printed result\n     */\n    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }\n\n    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    /**\n     * Checks whether printing is supported.\n     * \n     * @throws UnsupportedOperationException if printing is not supported\n     */\n    private DateTimePrinter requirePrinter() {\n        DateTimePrinter printer = iPrinter;\n        if (printer == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return printer;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant based on the chronology\n     * and time-zone of the supplied instant.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n\n    /**\n     * Parses a datetime from the given text, returning the number of\n     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n     * <p>\n     * The parse will use the ISO chronology, and the default time zone.\n     * If the text contains a time zone string then that will be taken into account.\n     *\n     * @param text  text to parse\n     * @return parsed value expressed in milliseconds since the epoch\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public long parseMillis(String text) {", "metadata": {"defects4j_task_id": "dda3dfc169f950d10004a3eb9e35f408ef72cf60ba81cd159c379f334416b8fa", "task_id": "JodaOrg_joda-time/183", "ground_truth": "\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(iChrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                return bucket.computeMillis(true, text);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "format", "DateTimeFormatter.java"], "context_start_lineno": 0, "function_name": "parseMillis", "left_context": "class DateTimeFormatter {\n\n    /**\n     * Prints a millisecond instant to a String.\n     * <p>\n     * This method will use the override zone and the override chronololgy if\n     * they are set. Otherwise it will use the ISO chronology and default zone.\n     *\n     * @param instant  millis since 1970-01-01T00:00:00Z\n     * @return the printed result\n     */\n    public String print(long instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n\n    /**\n     * Prints a ReadablePartial to a new String.\n     * <p>\n     * Neither the override chronology nor the override zone are used\n     * by this method.\n     *\n     * @param partial  partial to format\n     * @return the printed result\n     */\n    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }\n\n    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n\n    /**\n     * Checks whether printing is supported.\n     * \n     * @throws UnsupportedOperationException if printing is not supported\n     */\n    private DateTimePrinter requirePrinter() {\n        DateTimePrinter printer = iPrinter;\n        if (printer == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return printer;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant based on the chronology\n     * and time-zone of the supplied instant.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n\n    /**\n     * Parses a datetime from the given text, returning the number of\n     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n     * <p>\n     * The parse will use the ISO chronology, and the default time zone.\n     * If the text contains a time zone string then that will be taken into account.\n     *\n     * @param text  text to parse\n     * @return parsed value expressed in milliseconds since the epoch\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public long parseMillis(String text) {", "right_context": "}\n\n}", "class_name": "DateTimeFormatter", "return_type": "long", "parameters": [{"type": "String", "name": "text"}]}}
{"prompt": "class DateTimeFormatter {\n\n    /**\n     * Parses only the local date from the given text, returning a new LocalDate.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date will be used.\n     * This means that any parsed time, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDate parseLocalDate(String text) {\n        return parseLocalDateTime(text).toLocalDate();\n    }\n\n    /**\n     * Parses only the local time from the given text, returning a new LocalTime.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local time will be used.\n     * This means that any parsed date, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalTime parseLocalTime(String text) {\n        return parseLocalDateTime(text).toLocalTime();\n    }\n\n    /**\n     * Parses only the local date-time from the given text, returning a new LocalDateTime.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date-time will be used.\n     * This means that any parsed time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDateTime parseLocalDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return new LocalDateTime(millis, chrono);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new DateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public DateTime parseDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                DateTime dt = new DateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new MutableDateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public MutableDateTime parseMutableDateTime(String text) {", "metadata": {"defects4j_task_id": "a504efa3ba844528eea7e2e66d2bedf246a2eb6a7e3dd0015b9f351381f2269d", "task_id": "JodaOrg_joda-time/138", "ground_truth": "\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt.setZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "format", "DateTimeFormatter.java"], "context_start_lineno": 0, "function_name": "parseMutableDateTime", "left_context": "class DateTimeFormatter {\n\n    /**\n     * Parses only the local date from the given text, returning a new LocalDate.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date will be used.\n     * This means that any parsed time, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDate parseLocalDate(String text) {\n        return parseLocalDateTime(text).toLocalDate();\n    }\n\n    /**\n     * Parses only the local time from the given text, returning a new LocalTime.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local time will be used.\n     * This means that any parsed date, time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalTime parseLocalTime(String text) {\n        return parseLocalDateTime(text).toLocalTime();\n    }\n\n    /**\n     * Parses only the local date-time from the given text, returning a new LocalDateTime.\n     * <p>\n     * This will parse the text fully according to the formatter, using the UTC zone.\n     * Once parsed, only the local date-time will be used.\n     * This means that any parsed time-zone or offset field is completely ignored.\n     * It also means that the zone and offset-parsed settings are ignored.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     * @since 2.0\n     */\n    public LocalDateTime parseLocalDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return new LocalDateTime(millis, chrono);\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new DateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public DateTime parseDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                DateTime dt = new DateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n\n    /**\n     * Parses a date-time from the given text, returning a new MutableDateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public MutableDateTime parseMutableDateTime(String text) {", "right_context": "}\n\n}", "class_name": "DateTimeFormatter", "return_type": "MutableDateTime", "parameters": [{"type": "String", "name": "text"}]}}
{"prompt": "class DateTimeFormat {\n\n    /**\n     * Parses an individual token.\n     * \n     * @param pattern  the pattern string\n     * @param indexRef  a single element array, where the input is the start\n     *  location and the output is the location after parsing the token\n     * @return the parsed token\n     */\n    private static String parseToken(String pattern, int[] indexRef) {\n        StringBuilder buf = new StringBuilder();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            // Scan a run of the same character, which indicates a time\n            // pattern.\n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            // This will identify token as text.\n            buf.append('\\'');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n                \n                if (c == '\\'') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                        // '' is treated as escaped '\n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }\n\n    /**\n     * Returns true if token should be parsed as a numeric field.\n     * \n     * @param token  the token to parse\n     * @return true if numeric field\n     */\n    private static boolean isNumericToken(String token) {\n        int tokenLen = token.length();\n        if (tokenLen > 0) {\n            char c = token.charAt(0);\n            switch (c) {\n            case 'c': // century (number)\n            case 'C': // century of era (number)\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n            case 'd': // day of month (number)\n            case 'h': // hour of day (number, 1..12)\n            case 'H': // hour of day (number, 0..23)\n            case 'm': // minute of hour (number)\n            case 's': // second of minute (number)\n            case 'S': // fraction of second (number)\n            case 'e': // day of week (number)\n            case 'D': // day of year (number)\n            case 'F': // day of week in month (number)\n            case 'w': // week of year (number)\n            case 'W': // week of month (number)\n            case 'k': // hour of day (1..24)\n            case 'K': // hour of day (0..11)\n                return true;\n            case 'M': // month of year (text and number)\n                if (tokenLen <= 2) {\n                    return true;\n                }\n            }\n        }\n            \n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Select a format from a custom pattern.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see #appendPatternTo\n     */\n    private static DateTimeFormatter createFormatterForPattern(String pattern) {", "metadata": {"defects4j_task_id": "24a92011080898c9a632b1d40af97b0f2ed954404f234a9e1a66b797ea41abac", "task_id": "JodaOrg_joda-time/33", "ground_truth": "\n        if (pattern == null || pattern.length() == 0) {\n            throw new IllegalArgumentException(\"Invalid pattern specification\");\n        }\n        DateTimeFormatter formatter = null;\n        synchronized (PATTERN_CACHE) {\n            formatter = PATTERN_CACHE.get(pattern);\n            if (formatter == null) {\n                DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n                parsePatternTo(builder, pattern);\n                formatter = builder.toFormatter();\n\n                PATTERN_CACHE.put(pattern, formatter);\n            }\n        }\n        return formatter;\n    ", "fpath_tuple": ["JodaOrg_joda-time", "joda-time", "src", "main", "java", "org", "joda", "time", "format", "DateTimeFormat.java"], "context_start_lineno": 0, "function_name": "createFormatterForPattern", "left_context": "class DateTimeFormat {\n\n    /**\n     * Parses an individual token.\n     * \n     * @param pattern  the pattern string\n     * @param indexRef  a single element array, where the input is the start\n     *  location and the output is the location after parsing the token\n     * @return the parsed token\n     */\n    private static String parseToken(String pattern, int[] indexRef) {\n        StringBuilder buf = new StringBuilder();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            // Scan a run of the same character, which indicates a time\n            // pattern.\n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            // This will identify token as text.\n            buf.append('\\'');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n                \n                if (c == '\\'') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                        // '' is treated as escaped '\n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }\n\n    /**\n     * Returns true if token should be parsed as a numeric field.\n     * \n     * @param token  the token to parse\n     * @return true if numeric field\n     */\n    private static boolean isNumericToken(String token) {\n        int tokenLen = token.length();\n        if (tokenLen > 0) {\n            char c = token.charAt(0);\n            switch (c) {\n            case 'c': // century (number)\n            case 'C': // century of era (number)\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n            case 'd': // day of month (number)\n            case 'h': // hour of day (number, 1..12)\n            case 'H': // hour of day (number, 0..23)\n            case 'm': // minute of hour (number)\n            case 's': // second of minute (number)\n            case 'S': // fraction of second (number)\n            case 'e': // day of week (number)\n            case 'D': // day of year (number)\n            case 'F': // day of week in month (number)\n            case 'w': // week of year (number)\n            case 'W': // week of month (number)\n            case 'k': // hour of day (1..24)\n            case 'K': // hour of day (0..11)\n                return true;\n            case 'M': // month of year (text and number)\n                if (tokenLen <= 2) {\n                    return true;\n                }\n            }\n        }\n            \n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Select a format from a custom pattern.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see #appendPatternTo\n     */\n    private static DateTimeFormatter createFormatterForPattern(String pattern) {", "right_context": "}\n\n}", "class_name": "DateTimeFormat", "return_type": "DateTimeFormatter", "parameters": [{"type": "String", "name": "pattern"}]}}
{"prompt": "class JsonPointer\n{\n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to the matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n\n    /**\n     * Reference from currently matching segment (if any) to node\n     * before leaf.\n     * Lazily constructed if/as needed.\n     *<p>\n     * NOTE: we'll use `volatile` here assuming that this is unlikely to\n     * become a performance bottleneck. If it becomes one we can probably\n     * just drop it and things still should work (despite warnings as per JMM\n     * regarding visibility (and lack thereof) of unguarded changes).\n     * \n     * @since 2.5\n     */\n    protected volatile JsonPointer _head;\n\n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Construction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        // but could be an index, if parsable\n        _matchingElementIndex = _parseIndex(segment);\n    }\n\n    /**\n     * @since 2.5\n     */\n    protected JsonPointer(String fullString, String segment, int matchIndex, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        _matchingPropertyName = segment;\n        _matchingElementIndex = matchIndex;\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /**\n     * Factory method that will construct a pointer instance that describes\n     * path to location given {@link JsonStreamContext} points to.\n     *\n     * @param context Context to build pointer expression fot\n     * @param includeRoot Whether to include number offset for virtual \"root context\"\n     *    or not.\n     *\n     * @since 2.9\n     */\n    public static JsonPointer forPath(JsonStreamContext context,\n            boolean includeRoot)\n    {\n        // First things first: last segment may be for START_ARRAY/START_OBJECT,\n        // in which case it does not yet point to anything, and should be skipped\n        if (context == null) {\n            return EMPTY;\n        }\n        if (!context.hasPathSegment()) {\n            // one special case; do not prune root if we need it\n            if (!(includeRoot && context.inRoot() && context.hasCurrentIndex())) {\n                context = context.getParent();\n            }\n        }\n        JsonPointer tail = null;\n\n        for (; context != null; context = context.getParent()) {\n            if (context.inObject()) {\n                String seg = context.getCurrentName();\n                if (seg == null) { // is this legal?\n                    seg = \"\";\n                }\n                tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n            } else if (context.inArray() || includeRoot) {\n                int ix = context.getCurrentIndex();\n                String ixStr = String.valueOf(ix);\n                tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n            }\n            // NOTE: this effectively drops ROOT node(s); should have 1 such node,\n            // as the last one, but we don't have to care (probably some paths have\n            // no root, for example)\n        }\n        if (tail == null) {\n            return EMPTY;\n        }\n        return tail;\n    }\n\n    private static String _fullPath(JsonPointer tail, String segment)\n    {\n        if (tail == null) {\n            StringBuilder sb = new StringBuilder(segment.length()+1);\n            sb.append('/');\n            _appendEscaped(sb, segment);\n            return sb.toString();\n        }\n        String tailDesc = tail._asString;\n        StringBuilder sb = new StringBuilder(segment.length() + 1 + tailDesc.length());\n        sb.append('/');\n        _appendEscaped(sb, segment);\n        sb.append(tailDesc);\n        return sb.toString();\n    }\n\n    private static void _appendEscaped(StringBuilder sb, String segment)\n    {\n        for (int i = 0, end = segment.length(); i < end; ++i) {\n            char c = segment.charAt(i);\n           if (c == '/') {\n               sb.append(\"~1\");\n               continue;\n           }\n           if (c == '~') {\n               sb.append(\"~0\");\n               continue;\n           }\n           sb.append(c);\n        }\n    }\n    \n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    /**\n     * Returns the leaf of current JSON Pointer expression.\n     * Leaf is the last non-null segment of current JSON Pointer.\n     * \n     * @since 2.5\n     */\n    public JsonPointer last() {", "metadata": {"defects4j_task_id": "7ffe6f13b9d9f00ae6552f9c3bf3a022b67c6c630b614a6c107dc061896def7e", "task_id": "FasterXML_jackson-core/106", "ground_truth": "\n        JsonPointer current = this;\n        if (current == EMPTY) {\n            return null;\n        }\n        JsonPointer next;\n        while ((next = current._nextSegment) != JsonPointer.EMPTY) {\n            current = next;\n        }\n        return current;\n    ", "fpath_tuple": ["FasterXML_jackson-core", "jackson-core", "src", "main", "java", "com", "fasterxml", "jackson", "core", "JsonPointer.java"], "context_start_lineno": 0, "function_name": "last", "left_context": "class JsonPointer\n{\n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to the matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n\n    /**\n     * Reference from currently matching segment (if any) to node\n     * before leaf.\n     * Lazily constructed if/as needed.\n     *<p>\n     * NOTE: we'll use `volatile` here assuming that this is unlikely to\n     * become a performance bottleneck. If it becomes one we can probably\n     * just drop it and things still should work (despite warnings as per JMM\n     * regarding visibility (and lack thereof) of unguarded changes).\n     * \n     * @since 2.5\n     */\n    protected volatile JsonPointer _head;\n\n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Construction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        // but could be an index, if parsable\n        _matchingElementIndex = _parseIndex(segment);\n    }\n\n    /**\n     * @since 2.5\n     */\n    protected JsonPointer(String fullString, String segment, int matchIndex, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        _matchingPropertyName = segment;\n        _matchingElementIndex = matchIndex;\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /**\n     * Factory method that will construct a pointer instance that describes\n     * path to location given {@link JsonStreamContext} points to.\n     *\n     * @param context Context to build pointer expression fot\n     * @param includeRoot Whether to include number offset for virtual \"root context\"\n     *    or not.\n     *\n     * @since 2.9\n     */\n    public static JsonPointer forPath(JsonStreamContext context,\n            boolean includeRoot)\n    {\n        // First things first: last segment may be for START_ARRAY/START_OBJECT,\n        // in which case it does not yet point to anything, and should be skipped\n        if (context == null) {\n            return EMPTY;\n        }\n        if (!context.hasPathSegment()) {\n            // one special case; do not prune root if we need it\n            if (!(includeRoot && context.inRoot() && context.hasCurrentIndex())) {\n                context = context.getParent();\n            }\n        }\n        JsonPointer tail = null;\n\n        for (; context != null; context = context.getParent()) {\n            if (context.inObject()) {\n                String seg = context.getCurrentName();\n                if (seg == null) { // is this legal?\n                    seg = \"\";\n                }\n                tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n            } else if (context.inArray() || includeRoot) {\n                int ix = context.getCurrentIndex();\n                String ixStr = String.valueOf(ix);\n                tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n            }\n            // NOTE: this effectively drops ROOT node(s); should have 1 such node,\n            // as the last one, but we don't have to care (probably some paths have\n            // no root, for example)\n        }\n        if (tail == null) {\n            return EMPTY;\n        }\n        return tail;\n    }\n\n    private static String _fullPath(JsonPointer tail, String segment)\n    {\n        if (tail == null) {\n            StringBuilder sb = new StringBuilder(segment.length()+1);\n            sb.append('/');\n            _appendEscaped(sb, segment);\n            return sb.toString();\n        }\n        String tailDesc = tail._asString;\n        StringBuilder sb = new StringBuilder(segment.length() + 1 + tailDesc.length());\n        sb.append('/');\n        _appendEscaped(sb, segment);\n        sb.append(tailDesc);\n        return sb.toString();\n    }\n\n    private static void _appendEscaped(StringBuilder sb, String segment)\n    {\n        for (int i = 0, end = segment.length(); i < end; ++i) {\n            char c = segment.charAt(i);\n           if (c == '/') {\n               sb.append(\"~1\");\n               continue;\n           }\n           if (c == '~') {\n               sb.append(\"~0\");\n               continue;\n           }\n           sb.append(c);\n        }\n    }\n    \n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    /**\n     * Returns the leaf of current JSON Pointer expression.\n     * Leaf is the last non-null segment of current JSON Pointer.\n     * \n     * @since 2.5\n     */\n    public JsonPointer last() {", "right_context": "}\n}", "class_name": "JsonPointer", "return_type": "JsonPointer", "parameters": []}}
{"prompt": "class JsonPointer\n{\n    private static String _fullPath(JsonPointer tail, String segment)\n    {\n        if (tail == null) {\n            StringBuilder sb = new StringBuilder(segment.length()+1);\n            sb.append('/');\n            _appendEscaped(sb, segment);\n            return sb.toString();\n        }\n        String tailDesc = tail._asString;\n        StringBuilder sb = new StringBuilder(segment.length() + 1 + tailDesc.length());\n        sb.append('/');\n        _appendEscaped(sb, segment);\n        sb.append(tailDesc);\n        return sb.toString();\n    }\n\n    private static void _appendEscaped(StringBuilder sb, String segment)\n    {\n        for (int i = 0, end = segment.length(); i < end; ++i) {\n            char c = segment.charAt(i);\n           if (c == '/') {\n               sb.append(\"~1\");\n               continue;\n           }\n           if (c == '~') {\n               sb.append(\"~0\");\n               continue;\n           }\n           sb.append(c);\n        }\n    }\n    \n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    /**\n     * Returns the leaf of current JSON Pointer expression.\n     * Leaf is the last non-null segment of current JSON Pointer.\n     * \n     * @since 2.5\n     */\n    public JsonPointer last() {\n        JsonPointer current = this;\n        if (current == EMPTY) {\n            return null;\n        }\n        JsonPointer next;\n        while ((next = current._nextSegment) != JsonPointer.EMPTY) {\n            current = next;\n        }\n        return current;\n    }\n\n    /**\n     * Mutant factory method that will return\n     *<ul>\n     * <li>`tail` if `this` instance is \"empty\" pointer, OR\n     *  </li>\n     * <li>`this` instance if `tail` is \"empty\" pointer, OR\n     *  </li>\n     * <li>Newly constructed {@link JsonPointer} instance that starts with all segments\n     *    of `this`, followed by all segments of `tail`.\n     *  </li>\n     *</ul>\n     * \n     * @param tail {@link JsonPointer} instance to append to this one, to create a new pointer instance\n     *\n     * @return Either `this` instance, `tail`, or a newly created combination, as per description above.\n     */\n    public JsonPointer append(JsonPointer tail) {\n        if (this == EMPTY) {\n            return tail;\n        }\n        if (tail == EMPTY) {\n            return this;\n        }\n        // 21-Mar-2017, tatu: Not superbly efficient; could probably improve by not concatenating,\n        //    re-decoding -- by stitching together segments -- but for now should be fine.\n\n        String currentJsonPointer = _asString;\n        if (currentJsonPointer.endsWith(\"/\")) {\n            //removes final slash\n            currentJsonPointer = currentJsonPointer.substring(0, currentJsonPointer.length()-1);\n        }\n        return compile(currentJsonPointer + tail._asString);\n    }\n\n    /**\n     * Method that may be called to see if the pointer would match property\n     * (of a JSON Object) with given name.\n     * \n     * @since 2.5\n     */\n    public boolean matchesProperty(String name) {\n        return (_nextSegment != null) && _matchingPropertyName.equals(name);\n    }\n    \n    public JsonPointer matchProperty(String name) {\n        if ((_nextSegment != null) && _matchingPropertyName.equals(name)) {\n            return _nextSegment;\n        }\n        return null;\n    }\n\n    /**\n     * Method that may be called to see if the pointer would match\n     * array element (of a JSON Array) with given index.\n     * \n     * @since 2.5\n     */\n    public boolean matchesElement(int index) {\n        return (index == _matchingElementIndex) && (index >= 0);\n    }\n\n    /**\n     * @since 2.6\n     */\n    public JsonPointer matchElement(int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments.\n     * For matching state, will return null.\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a pointer instance that is identical to this\n     * instance except that the last segment has been dropped.\n     * For example, for JSON Point \"/root/branch/leaf\", this method would\n     * return pointer \"/root/branch\" (compared to {@link #tail()} that\n     * would return \"/branch/leaf\").\n     * For leaf \n     *\n     * @since 2.5\n     */\n    public JsonPointer head() {\n        JsonPointer h = _head;\n        if (h == null) {\n            if (this != EMPTY) {\n                h = _constructHead();\n            }\n            _head = h;\n        }\n        return h;\n    }\n\n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {", "metadata": {"defects4j_task_id": "8c976eac3b4a56c1d698df53725da73ea07dd29279bb7115410a83b9c31226e8", "task_id": "FasterXML_jackson-core/116", "ground_truth": "\n        final int len = str.length();\n        // [core#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        // [core#176]: no leading zeroes allowed\n        char c = str.charAt(0);\n        if (c <= '0') {\n            return (len == 1 && c == '0') ? 0 : -1;\n        }\n        if (c > '9') {\n            return -1;\n        }\n        for (int i = 1; i < len; ++i) {\n            c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    ", "fpath_tuple": ["FasterXML_jackson-core", "jackson-core", "src", "main", "java", "com", "fasterxml", "jackson", "core", "JsonPointer.java"], "context_start_lineno": 0, "function_name": "_parseIndex", "left_context": "class JsonPointer\n{\n    private static String _fullPath(JsonPointer tail, String segment)\n    {\n        if (tail == null) {\n            StringBuilder sb = new StringBuilder(segment.length()+1);\n            sb.append('/');\n            _appendEscaped(sb, segment);\n            return sb.toString();\n        }\n        String tailDesc = tail._asString;\n        StringBuilder sb = new StringBuilder(segment.length() + 1 + tailDesc.length());\n        sb.append('/');\n        _appendEscaped(sb, segment);\n        sb.append(tailDesc);\n        return sb.toString();\n    }\n\n    private static void _appendEscaped(StringBuilder sb, String segment)\n    {\n        for (int i = 0, end = segment.length(); i < end; ++i) {\n            char c = segment.charAt(i);\n           if (c == '/') {\n               sb.append(\"~1\");\n               continue;\n           }\n           if (c == '~') {\n               sb.append(\"~0\");\n               continue;\n           }\n           sb.append(c);\n        }\n    }\n    \n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    /**\n     * Returns the leaf of current JSON Pointer expression.\n     * Leaf is the last non-null segment of current JSON Pointer.\n     * \n     * @since 2.5\n     */\n    public JsonPointer last() {\n        JsonPointer current = this;\n        if (current == EMPTY) {\n            return null;\n        }\n        JsonPointer next;\n        while ((next = current._nextSegment) != JsonPointer.EMPTY) {\n            current = next;\n        }\n        return current;\n    }\n\n    /**\n     * Mutant factory method that will return\n     *<ul>\n     * <li>`tail` if `this` instance is \"empty\" pointer, OR\n     *  </li>\n     * <li>`this` instance if `tail` is \"empty\" pointer, OR\n     *  </li>\n     * <li>Newly constructed {@link JsonPointer} instance that starts with all segments\n     *    of `this`, followed by all segments of `tail`.\n     *  </li>\n     *</ul>\n     * \n     * @param tail {@link JsonPointer} instance to append to this one, to create a new pointer instance\n     *\n     * @return Either `this` instance, `tail`, or a newly created combination, as per description above.\n     */\n    public JsonPointer append(JsonPointer tail) {\n        if (this == EMPTY) {\n            return tail;\n        }\n        if (tail == EMPTY) {\n            return this;\n        }\n        // 21-Mar-2017, tatu: Not superbly efficient; could probably improve by not concatenating,\n        //    re-decoding -- by stitching together segments -- but for now should be fine.\n\n        String currentJsonPointer = _asString;\n        if (currentJsonPointer.endsWith(\"/\")) {\n            //removes final slash\n            currentJsonPointer = currentJsonPointer.substring(0, currentJsonPointer.length()-1);\n        }\n        return compile(currentJsonPointer + tail._asString);\n    }\n\n    /**\n     * Method that may be called to see if the pointer would match property\n     * (of a JSON Object) with given name.\n     * \n     * @since 2.5\n     */\n    public boolean matchesProperty(String name) {\n        return (_nextSegment != null) && _matchingPropertyName.equals(name);\n    }\n    \n    public JsonPointer matchProperty(String name) {\n        if ((_nextSegment != null) && _matchingPropertyName.equals(name)) {\n            return _nextSegment;\n        }\n        return null;\n    }\n\n    /**\n     * Method that may be called to see if the pointer would match\n     * array element (of a JSON Array) with given index.\n     * \n     * @since 2.5\n     */\n    public boolean matchesElement(int index) {\n        return (index == _matchingElementIndex) && (index >= 0);\n    }\n\n    /**\n     * @since 2.6\n     */\n    public JsonPointer matchElement(int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments.\n     * For matching state, will return null.\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a pointer instance that is identical to this\n     * instance except that the last segment has been dropped.\n     * For example, for JSON Point \"/root/branch/leaf\", this method would\n     * return pointer \"/root/branch\" (compared to {@link #tail()} that\n     * would return \"/branch/leaf\").\n     * For leaf \n     *\n     * @since 2.5\n     */\n    public JsonPointer head() {\n        JsonPointer h = _head;\n        if (h == null) {\n            if (this != EMPTY) {\n                h = _constructHead();\n            }\n            _head = h;\n        }\n        return h;\n    }\n\n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {", "right_context": "}\n}", "class_name": "JsonPointer", "return_type": "int", "parameters": [{"type": "String", "name": "str"}]}}
{"prompt": "class DataFormatMatcher\n{\n    protected final InputStream _originalStream;\n\n    /**\n     * Content read during format matching process\n     */\n    protected final byte[] _bufferedData;\n\n    /**\n     * Pointer to the first byte in buffer available for reading\n     */\n    protected final int _bufferedStart;\n    \n    /**\n     * Number of bytes available in buffer.\n     */\n    protected final int _bufferedLength;\n\n    /**\n     * Factory that produced sufficient match (if any)\n     */\n    protected final JsonFactory _match;\n\n    /**\n     * Strength of match with {@link #_match}\n     */\n    protected final MatchStrength _matchStrength;\n    \n    protected DataFormatMatcher(InputStream in, byte[] buffered,\n            int bufferedStart, int bufferedLength,\n            JsonFactory match, MatchStrength strength)\n    {\n        _originalStream = in;\n        _bufferedData = buffered;\n        _bufferedStart = bufferedStart;\n        _bufferedLength = bufferedLength;\n        _match = match;\n        _matchStrength = strength;\n\n        // can't have negative offset or length\n        if ((bufferedStart | bufferedLength) < 0\n                || (bufferedStart + bufferedLength) > buffered.length) {\n            throw new IllegalArgumentException(String.format(\"Illegal start/length (%d/%d) wrt input array of %d bytes\",\n                    bufferedStart, bufferedLength, buffered.length));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, simple accessors\n    /**********************************************************\n     */\n\n    /**\n     * Accessor to use to see if any formats matched well enough with\n     * the input data.\n     */\n    public boolean hasMatch() { return _match != null; }\n\n    /**\n     * Method for accessing strength of the match, if any; if no match,\n     * will return {@link MatchStrength#INCONCLUSIVE}.\n     */\n    public MatchStrength getMatchStrength() {\n        return (_matchStrength == null) ? MatchStrength.INCONCLUSIVE : _matchStrength;\n    }\n\n    /**\n     * Accessor for {@link JsonFactory} that represents format that data matched.\n     */\n    public JsonFactory getMatch() { return _match; }\n\n    /**\n     * Accessor for getting brief textual name of matched format if any (null\n     * if none). Equivalent to:\n     *<pre>\n     *   return hasMatch() ? getMatch().getFormatName() : null;\n     *</pre>\n     */\n    public String getMatchedFormatName() {\n        return _match.getFormatName();\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Convenience method for trying to construct a {@link JsonParser} for\n     * parsing content which is assumed to be in detected data format.\n     * If no match was found, returns null.\n     */\n    public JsonParser createParserWithMatch() throws IOException {\n        if (_match == null) {\n            return null;\n        }\n        if (_originalStream == null) {\n            return _match.createParser(_bufferedData, _bufferedStart, _bufferedLength);\n        }\n        return _match.createParser(getDataStream());\n    }\n    \n    /**\n     * Method to use for accessing input for which format detection has been done.\n     * This <b>must</b> be used instead of using stream passed to detector\n     * unless given stream itself can do buffering.\n     * Stream will return all content that was read during matching process, as well\n     * as remaining contents of the underlying stream.\n     */\n    public InputStream getDataStream() {", "metadata": {"defects4j_task_id": "c97e98c66c8fc5bcbee73315143390cf091aee545624517ccc0eba615acf44e2", "task_id": "FasterXML_jackson-core/163", "ground_truth": "\n        if (_originalStream == null) {\n            return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n        }\n        return new MergedStream(null, _originalStream, _bufferedData, _bufferedStart, _bufferedLength);\n    ", "fpath_tuple": ["FasterXML_jackson-core", "jackson-core", "src", "main", "java", "com", "fasterxml", "jackson", "core", "format", "DataFormatMatcher.java"], "context_start_lineno": 0, "function_name": "getDataStream", "left_context": "class DataFormatMatcher\n{\n    protected final InputStream _originalStream;\n\n    /**\n     * Content read during format matching process\n     */\n    protected final byte[] _bufferedData;\n\n    /**\n     * Pointer to the first byte in buffer available for reading\n     */\n    protected final int _bufferedStart;\n    \n    /**\n     * Number of bytes available in buffer.\n     */\n    protected final int _bufferedLength;\n\n    /**\n     * Factory that produced sufficient match (if any)\n     */\n    protected final JsonFactory _match;\n\n    /**\n     * Strength of match with {@link #_match}\n     */\n    protected final MatchStrength _matchStrength;\n    \n    protected DataFormatMatcher(InputStream in, byte[] buffered,\n            int bufferedStart, int bufferedLength,\n            JsonFactory match, MatchStrength strength)\n    {\n        _originalStream = in;\n        _bufferedData = buffered;\n        _bufferedStart = bufferedStart;\n        _bufferedLength = bufferedLength;\n        _match = match;\n        _matchStrength = strength;\n\n        // can't have negative offset or length\n        if ((bufferedStart | bufferedLength) < 0\n                || (bufferedStart + bufferedLength) > buffered.length) {\n            throw new IllegalArgumentException(String.format(\"Illegal start/length (%d/%d) wrt input array of %d bytes\",\n                    bufferedStart, bufferedLength, buffered.length));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, simple accessors\n    /**********************************************************\n     */\n\n    /**\n     * Accessor to use to see if any formats matched well enough with\n     * the input data.\n     */\n    public boolean hasMatch() { return _match != null; }\n\n    /**\n     * Method for accessing strength of the match, if any; if no match,\n     * will return {@link MatchStrength#INCONCLUSIVE}.\n     */\n    public MatchStrength getMatchStrength() {\n        return (_matchStrength == null) ? MatchStrength.INCONCLUSIVE : _matchStrength;\n    }\n\n    /**\n     * Accessor for {@link JsonFactory} that represents format that data matched.\n     */\n    public JsonFactory getMatch() { return _match; }\n\n    /**\n     * Accessor for getting brief textual name of matched format if any (null\n     * if none). Equivalent to:\n     *<pre>\n     *   return hasMatch() ? getMatch().getFormatName() : null;\n     *</pre>\n     */\n    public String getMatchedFormatName() {\n        return _match.getFormatName();\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Convenience method for trying to construct a {@link JsonParser} for\n     * parsing content which is assumed to be in detected data format.\n     * If no match was found, returns null.\n     */\n    public JsonParser createParserWithMatch() throws IOException {\n        if (_match == null) {\n            return null;\n        }\n        if (_originalStream == null) {\n            return _match.createParser(_bufferedData, _bufferedStart, _bufferedLength);\n        }\n        return _match.createParser(getDataStream());\n    }\n    \n    /**\n     * Method to use for accessing input for which format detection has been done.\n     * This <b>must</b> be used instead of using stream passed to detector\n     * unless given stream itself can do buffering.\n     * Stream will return all content that was read during matching process, as well\n     * as remaining contents of the underlying stream.\n     */\n    public InputStream getDataStream() {", "right_context": "}\n}", "class_name": "DataFormatMatcher", "return_type": "InputStream", "parameters": []}}
{"prompt": "class JsonFactory\n    extends TokenStreamFactory\n    implements Versioned,\n        java.io.Serializable // since 2.1 (for Android, mostly)\n{\n    /**\n     * Method for constructing JSON generator for writing JSON content\n     * using specified Writer.\n     *<p>\n     * Underlying stream <b>is NOT owned</b> by the generator constructed,\n     * so that generator will NOT close the Reader when\n     * {@link JsonGenerator#close} is called (unless auto-closing\n     * feature,\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#AUTO_CLOSE_TARGET} is enabled).\n     * Using application needs to close it explicitly.\n     *\n     * @param out Writer to use for writing JSON content \n     * \n     * @deprecated Since 2.2, use {@link #createGenerator(Writer)} instead.\n     */\n    @Deprecated\n    public JsonGenerator createJsonGenerator(Writer out) throws IOException {\n        return createGenerator(out);\n    }\n\n    /**\n     * Convenience method for constructing generator that uses default\n     * encoding of the format (UTF-8 for JSON and most other data formats).\n     *<p>\n     * Note: there are formats that use fixed encoding (like most binary data formats).\n     * \n     * @deprecated Since 2.2, use {@link #createGenerator(OutputStream)} instead.\n     */\n    @Deprecated\n    public JsonGenerator createJsonGenerator(OutputStream out) throws IOException {\n        return createGenerator(out, JsonEncoding.UTF8);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods used by factory for creating parser instances,\n    /* overridable by sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Overridable factory method that actually instantiates desired parser\n     * given {@link InputStream} and context object.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     * \n     * @since 2.1\n     */\n    protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException {\n        // As per [JACKSON-259], may want to fully disable canonicalization:\n        return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures,\n                _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\n    }\n\n    /**\n     * Overridable factory method that actually instantiates parser\n     * using given {@link Reader} object for reading content.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     * \n     * @since 2.1\n     */\n    protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException {\n        return new ReaderBasedJsonParser(ctxt, _parserFeatures, r, _objectCodec,\n                _rootCharSymbols.makeChild(_factoryFeatures));\n    }\n\n    /**\n     * Overridable factory method that actually instantiates parser\n     * using given <code>char[]</code> object for accessing content.\n     * \n     * @since 2.4\n     */\n    protected JsonParser _createParser(char[] data, int offset, int len, IOContext ctxt,\n            boolean recyclable) throws IOException {\n        return new ReaderBasedJsonParser(ctxt, _parserFeatures, null, _objectCodec,\n                _rootCharSymbols.makeChild(_factoryFeatures),\n                        data, offset, offset+len, recyclable);\n    }\n\n    /**\n     * Overridable factory method that actually instantiates parser\n     * using given {@link Reader} object for reading content\n     * passed as raw byte array.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     */\n    protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n    {\n        return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures,\n                _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\n    }\n\n    /**\n     * Optional factory method, expected to be overridden\n     *\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input.\n        _requireJSONFactory(\"InputData source not (yet?) supported for this format (%s)\");\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods used by factory for creating generator instances,\n    /* overridable by sub-classes\n    /**********************************************************\n     */\n    \n    /**\n     * Overridable factory method that actually instantiates generator for\n     * given {@link Writer} and context object.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     */\n    protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException\n    {\n        WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n                _generatorFeatures, _objectCodec, out);\n        if (_maximumNonEscapedChar > 0) {\n            gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n        }\n        if (_characterEscapes != null) {\n            gen.setCharacterEscapes(_characterEscapes);\n        }\n        SerializableString rootSep = _rootValueSeparator;\n        if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n            gen.setRootValueSeparator(rootSep);\n        }\n        return gen;\n    }\n\n    /**\n     * Overridable factory method that actually instantiates generator for\n     * given {@link OutputStream} and context object, using UTF-8 encoding.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     */\n    protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException {", "metadata": {"defects4j_task_id": "eb23636612777d78b8363b4a1827716c94bfcaea54b048b094214abddaf9795f", "task_id": "FasterXML_jackson-core/193", "ground_truth": "\n        UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt,\n                _generatorFeatures, _objectCodec, out);\n        if (_maximumNonEscapedChar > 0) {\n            gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n        }\n        if (_characterEscapes != null) {\n            gen.setCharacterEscapes(_characterEscapes);\n        }\n        SerializableString rootSep = _rootValueSeparator;\n        if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n            gen.setRootValueSeparator(rootSep);\n        }\n        return gen;\n    ", "fpath_tuple": ["FasterXML_jackson-core", "jackson-core", "src", "main", "java", "com", "fasterxml", "jackson", "core", "JsonFactory.java"], "context_start_lineno": 0, "function_name": "_createUTF8Generator", "left_context": "class JsonFactory\n    extends TokenStreamFactory\n    implements Versioned,\n        java.io.Serializable // since 2.1 (for Android, mostly)\n{\n    /**\n     * Method for constructing JSON generator for writing JSON content\n     * using specified Writer.\n     *<p>\n     * Underlying stream <b>is NOT owned</b> by the generator constructed,\n     * so that generator will NOT close the Reader when\n     * {@link JsonGenerator#close} is called (unless auto-closing\n     * feature,\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#AUTO_CLOSE_TARGET} is enabled).\n     * Using application needs to close it explicitly.\n     *\n     * @param out Writer to use for writing JSON content \n     * \n     * @deprecated Since 2.2, use {@link #createGenerator(Writer)} instead.\n     */\n    @Deprecated\n    public JsonGenerator createJsonGenerator(Writer out) throws IOException {\n        return createGenerator(out);\n    }\n\n    /**\n     * Convenience method for constructing generator that uses default\n     * encoding of the format (UTF-8 for JSON and most other data formats).\n     *<p>\n     * Note: there are formats that use fixed encoding (like most binary data formats).\n     * \n     * @deprecated Since 2.2, use {@link #createGenerator(OutputStream)} instead.\n     */\n    @Deprecated\n    public JsonGenerator createJsonGenerator(OutputStream out) throws IOException {\n        return createGenerator(out, JsonEncoding.UTF8);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods used by factory for creating parser instances,\n    /* overridable by sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Overridable factory method that actually instantiates desired parser\n     * given {@link InputStream} and context object.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     * \n     * @since 2.1\n     */\n    protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException {\n        // As per [JACKSON-259], may want to fully disable canonicalization:\n        return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures,\n                _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\n    }\n\n    /**\n     * Overridable factory method that actually instantiates parser\n     * using given {@link Reader} object for reading content.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     * \n     * @since 2.1\n     */\n    protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException {\n        return new ReaderBasedJsonParser(ctxt, _parserFeatures, r, _objectCodec,\n                _rootCharSymbols.makeChild(_factoryFeatures));\n    }\n\n    /**\n     * Overridable factory method that actually instantiates parser\n     * using given <code>char[]</code> object for accessing content.\n     * \n     * @since 2.4\n     */\n    protected JsonParser _createParser(char[] data, int offset, int len, IOContext ctxt,\n            boolean recyclable) throws IOException {\n        return new ReaderBasedJsonParser(ctxt, _parserFeatures, null, _objectCodec,\n                _rootCharSymbols.makeChild(_factoryFeatures),\n                        data, offset, offset+len, recyclable);\n    }\n\n    /**\n     * Overridable factory method that actually instantiates parser\n     * using given {@link Reader} object for reading content\n     * passed as raw byte array.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     */\n    protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n    {\n        return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures,\n                _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\n    }\n\n    /**\n     * Optional factory method, expected to be overridden\n     *\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input.\n        _requireJSONFactory(\"InputData source not (yet?) supported for this format (%s)\");\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n\n    /*\n    /**********************************************************\n    /* Factory methods used by factory for creating generator instances,\n    /* overridable by sub-classes\n    /**********************************************************\n     */\n    \n    /**\n     * Overridable factory method that actually instantiates generator for\n     * given {@link Writer} and context object.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     */\n    protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException\n    {\n        WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n                _generatorFeatures, _objectCodec, out);\n        if (_maximumNonEscapedChar > 0) {\n            gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n        }\n        if (_characterEscapes != null) {\n            gen.setCharacterEscapes(_characterEscapes);\n        }\n        SerializableString rootSep = _rootValueSeparator;\n        if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n            gen.setRootValueSeparator(rootSep);\n        }\n        return gen;\n    }\n\n    /**\n     * Overridable factory method that actually instantiates generator for\n     * given {@link OutputStream} and context object, using UTF-8 encoding.\n     *<p>\n     * This method is specifically designed to remain\n     * compatible between minor versions so that sub-classes can count\n     * on it being called as expected. That is, it is part of official\n     * interface from sub-class perspective, although not a public\n     * method available to users of factory implementations.\n     */\n    protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException {", "right_context": "}\n}", "class_name": "JsonFactory", "return_type": "JsonGenerator", "parameters": [{"type": "OutputStream", "name": "out"}, {"type": "IOContext", "name": "ctxt"}]}}
{"prompt": "class SourceMapGeneratorV2 implements SourceMapGenerator {\n\n  /**\n   * Writes out the source map in the following format (line numbers are for\n   * reference only and are not part of the format):\n   *\n   * 1.  {\n   * 2.    version: 2,\n   * 3.    file: \"out.js\"\n   * 4.    lineCount: 2\n   * 5.    lineMaps: [\n   * 6.        \"ABAAA\",\n   * 7.        \"ABAA\"\n   * 8.     ],\n   * 9.    sourceRoot: \"\",\n   * 10.   sources: [\"foo.js\", \"bar.js\"],\n   * 11.   names: [\"src\", \"maps\", \"are\", \"fun\"],\n   * 12.   mappings: [\n   * 13.       [1, 1, 2, 4],\n   * 14.       [2, 1, 2, \"yack\"],\n   * 15.   ],\n   * 16.  }\n   *\n   * Line 1: The entire file is a single JSON object\n   * Line 2: File revision (always the first entry in the object)\n   * Line 3: The name of the file that this source map is associated with.\n   * Line 4: The number of lines represented in the source map.\n   * Line 5: \"lineMaps\" field is a JSON array, where each entry represents a\n   *     line in the generated text.\n   * Line 6: A line entry, representing a series of line segments, where each\n   *     segment encodes an mappings-id and repetition count.\n   * Line 9: An optional source root, useful for relocating source files on a\n   *     server or removing repeated prefix values in the \"sources\" entry.\n   * Line 10: A list of sources used by the \"mappings\" entry relative to the\n   *     sourceRoot.\n   * Line 11: A list of symbol names used by the \"mapping\" entry.  This list\n   *     may be incomplete.\n   * Line 12: The mappings field.\n   * Line 13: Each entry represent a block of text in the original source, and\n   *     consists four fields:\n   *     The source file name\n   *     The line in the source file the text begins\n   *     The column in the line that the text begins\n   *     An optional name (from the original source) that this entry represents.\n   *     This can either be an string or index into the \"names\" field.\n   */\n  @Override\n  public void appendTo(Appendable out, String name) throws IOException {\n    int maxLine = prepMappings();\n\n    // Add the header fields.\n    out.append(\"{\\n\");\n    appendFirstField(out, \"version\", \"2\");\n    appendField(out, \"file\", escapeString(name));\n    appendField(out, \"lineCount\", String.valueOf(maxLine + 1));\n\n    // Add the line character maps.\n    appendFieldStart(out, \"lineMaps\");\n    out.append(\"[\");\n    (new LineMapper(out)).appendLineMappings();\n    out.append(\"]\");\n    appendFieldEnd(out);\n\n    // Add the mappings themselves.\n    appendFieldStart(out, \"mappings\");\n    out.append(\"[\");\n    (new MappingWriter()).appendMappings(out);\n    out.append(\"]\");\n    appendFieldEnd(out);\n\n    // Files names\n    appendFieldStart(out, \"sources\");\n    out.append(\"[\");\n    addSourceNameMap(out);\n    out.append(\"]\");\n    appendFieldEnd(out);\n\n    // Files names\n    appendFieldStart(out, \"names\");\n    out.append(\"[\");\n    addOriginalNameMap(out);\n    out.append(\"]\");\n    appendFieldEnd(out);\n\n    out.append(\"\\n}\\n\");\n  }\n\n  /**\n   * Writes the source name map to 'out'.\n   */\n  private void addSourceNameMap(Appendable out) throws IOException {\n    addMap(out, sourceFileMap);\n  }\n\n  /**\n   * Writes the original name map to 'out'.\n   */\n  private void addOriginalNameMap(Appendable out) throws IOException {\n    addMap(out, originalNameMap);\n  }\n\n  /**\n   * Writes the source name map to 'out'.\n   */\n  private void addMap(Appendable out, Map<String, Integer> map)\n      throws IOException {\n    int i = 0;\n    for (Entry<String, Integer> entry : map.entrySet()) {\n      String key = entry.getKey();\n      if (i != 0) {\n        out.append(\",\");\n      }\n      out.append(escapeString(key));\n      i++;\n    }\n  }\n\n  /**\n   * Escapes the given string for JSON.\n   */\n  private static String escapeString(String value) {\n    return Util.escapeString(value);\n  }\n\n  // Source map field helpers.\n\n  private static void appendFirstField(\n      Appendable out, String name, CharSequence value)\n      throws IOException {\n    out.append(\"\\\"\");\n    out.append(name);\n    out.append(\"\\\"\");\n    out.append(\":\");\n    out.append(value);\n  }\n\n  private static void appendField(\n      Appendable out, String name, CharSequence value)\n      throws IOException {\n    out.append(\",\\n\");\n    out.append(\"\\\"\");\n    out.append(name);\n    out.append(\"\\\"\");\n    out.append(\":\");\n    out.append(value);\n  }\n\n  private static void appendFieldStart(Appendable out, String name)\n      throws IOException {\n    appendField(out, name, \"\");\n  }\n\n  @SuppressWarnings(\"unused\")\n  private static void appendFieldEnd(Appendable out)\n     throws IOException {\n  }\n\n  /**\n   * Assigns sequential ids to used mappings, and returns the last line mapped.\n   */\n  private int prepMappings() throws IOException {\n    // Mark any unused mappings.\n    (new MappingTraversal()).traverse(new UsedMappingCheck());\n\n    // Renumber used mappings and keep track of the last line.\n    int id = 0;\n    int maxLine = 0;\n    for (Mapping m : mappings) {\n      if (m.used) {\n        m.id = id++;\n        int endPositionLine = m.endPosition.getLine();\n        maxLine = Math.max(maxLine, endPositionLine);\n      }\n    }\n\n    // Adjust for the prefix.\n    return maxLine + prefixPosition.getLine();\n  }\n\n  /**\n   * Pools source names.\n   * @param sourceName The source location to index.\n   * @return The id to represent the source name in the output.\n   */\n  private int getSourceId(String sourceName) {\n    if (sourceName != lastSourceFile) {\n      lastSourceFile = sourceName;\n      Integer index = sourceFileMap.get(sourceName);\n      if (index != null) {\n        lastSourceFileIndex = index;\n      } else {\n        lastSourceFileIndex = sourceFileMap.size();\n        sourceFileMap.put(sourceName, lastSourceFileIndex);\n      }\n    }\n    return lastSourceFileIndex;\n  }\n\n  /**\n   * Pools symbol names\n   * @param symbolName The symbol name to index.\n   * @return The id to represent the symbol name in the output.\n   */\n  private int getNameId(String symbolName) {", "metadata": {"defects4j_task_id": "d33bafcc2daca4eee268e4af309f76afebaf5084e3247924557858d02670f325", "task_id": "google_closure-compiler/172", "ground_truth": "\n    int originalNameIndex;\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) {\n      originalNameIndex = index;\n    } else {\n      originalNameIndex = originalNameMap.size();\n      originalNameMap.put(symbolName, originalNameIndex);\n    }\n    return originalNameIndex;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "debugging", "sourcemap", "SourceMapGeneratorV2.java"], "context_start_lineno": 0, "function_name": "getNameId", "left_context": "class SourceMapGeneratorV2 implements SourceMapGenerator {\n\n  /**\n   * Writes out the source map in the following format (line numbers are for\n   * reference only and are not part of the format):\n   *\n   * 1.  {\n   * 2.    version: 2,\n   * 3.    file: \"out.js\"\n   * 4.    lineCount: 2\n   * 5.    lineMaps: [\n   * 6.        \"ABAAA\",\n   * 7.        \"ABAA\"\n   * 8.     ],\n   * 9.    sourceRoot: \"\",\n   * 10.   sources: [\"foo.js\", \"bar.js\"],\n   * 11.   names: [\"src\", \"maps\", \"are\", \"fun\"],\n   * 12.   mappings: [\n   * 13.       [1, 1, 2, 4],\n   * 14.       [2, 1, 2, \"yack\"],\n   * 15.   ],\n   * 16.  }\n   *\n   * Line 1: The entire file is a single JSON object\n   * Line 2: File revision (always the first entry in the object)\n   * Line 3: The name of the file that this source map is associated with.\n   * Line 4: The number of lines represented in the source map.\n   * Line 5: \"lineMaps\" field is a JSON array, where each entry represents a\n   *     line in the generated text.\n   * Line 6: A line entry, representing a series of line segments, where each\n   *     segment encodes an mappings-id and repetition count.\n   * Line 9: An optional source root, useful for relocating source files on a\n   *     server or removing repeated prefix values in the \"sources\" entry.\n   * Line 10: A list of sources used by the \"mappings\" entry relative to the\n   *     sourceRoot.\n   * Line 11: A list of symbol names used by the \"mapping\" entry.  This list\n   *     may be incomplete.\n   * Line 12: The mappings field.\n   * Line 13: Each entry represent a block of text in the original source, and\n   *     consists four fields:\n   *     The source file name\n   *     The line in the source file the text begins\n   *     The column in the line that the text begins\n   *     An optional name (from the original source) that this entry represents.\n   *     This can either be an string or index into the \"names\" field.\n   */\n  @Override\n  public void appendTo(Appendable out, String name) throws IOException {\n    int maxLine = prepMappings();\n\n    // Add the header fields.\n    out.append(\"{\\n\");\n    appendFirstField(out, \"version\", \"2\");\n    appendField(out, \"file\", escapeString(name));\n    appendField(out, \"lineCount\", String.valueOf(maxLine + 1));\n\n    // Add the line character maps.\n    appendFieldStart(out, \"lineMaps\");\n    out.append(\"[\");\n    (new LineMapper(out)).appendLineMappings();\n    out.append(\"]\");\n    appendFieldEnd(out);\n\n    // Add the mappings themselves.\n    appendFieldStart(out, \"mappings\");\n    out.append(\"[\");\n    (new MappingWriter()).appendMappings(out);\n    out.append(\"]\");\n    appendFieldEnd(out);\n\n    // Files names\n    appendFieldStart(out, \"sources\");\n    out.append(\"[\");\n    addSourceNameMap(out);\n    out.append(\"]\");\n    appendFieldEnd(out);\n\n    // Files names\n    appendFieldStart(out, \"names\");\n    out.append(\"[\");\n    addOriginalNameMap(out);\n    out.append(\"]\");\n    appendFieldEnd(out);\n\n    out.append(\"\\n}\\n\");\n  }\n\n  /**\n   * Writes the source name map to 'out'.\n   */\n  private void addSourceNameMap(Appendable out) throws IOException {\n    addMap(out, sourceFileMap);\n  }\n\n  /**\n   * Writes the original name map to 'out'.\n   */\n  private void addOriginalNameMap(Appendable out) throws IOException {\n    addMap(out, originalNameMap);\n  }\n\n  /**\n   * Writes the source name map to 'out'.\n   */\n  private void addMap(Appendable out, Map<String, Integer> map)\n      throws IOException {\n    int i = 0;\n    for (Entry<String, Integer> entry : map.entrySet()) {\n      String key = entry.getKey();\n      if (i != 0) {\n        out.append(\",\");\n      }\n      out.append(escapeString(key));\n      i++;\n    }\n  }\n\n  /**\n   * Escapes the given string for JSON.\n   */\n  private static String escapeString(String value) {\n    return Util.escapeString(value);\n  }\n\n  // Source map field helpers.\n\n  private static void appendFirstField(\n      Appendable out, String name, CharSequence value)\n      throws IOException {\n    out.append(\"\\\"\");\n    out.append(name);\n    out.append(\"\\\"\");\n    out.append(\":\");\n    out.append(value);\n  }\n\n  private static void appendField(\n      Appendable out, String name, CharSequence value)\n      throws IOException {\n    out.append(\",\\n\");\n    out.append(\"\\\"\");\n    out.append(name);\n    out.append(\"\\\"\");\n    out.append(\":\");\n    out.append(value);\n  }\n\n  private static void appendFieldStart(Appendable out, String name)\n      throws IOException {\n    appendField(out, name, \"\");\n  }\n\n  @SuppressWarnings(\"unused\")\n  private static void appendFieldEnd(Appendable out)\n     throws IOException {\n  }\n\n  /**\n   * Assigns sequential ids to used mappings, and returns the last line mapped.\n   */\n  private int prepMappings() throws IOException {\n    // Mark any unused mappings.\n    (new MappingTraversal()).traverse(new UsedMappingCheck());\n\n    // Renumber used mappings and keep track of the last line.\n    int id = 0;\n    int maxLine = 0;\n    for (Mapping m : mappings) {\n      if (m.used) {\n        m.id = id++;\n        int endPositionLine = m.endPosition.getLine();\n        maxLine = Math.max(maxLine, endPositionLine);\n      }\n    }\n\n    // Adjust for the prefix.\n    return maxLine + prefixPosition.getLine();\n  }\n\n  /**\n   * Pools source names.\n   * @param sourceName The source location to index.\n   * @return The id to represent the source name in the output.\n   */\n  private int getSourceId(String sourceName) {\n    if (sourceName != lastSourceFile) {\n      lastSourceFile = sourceName;\n      Integer index = sourceFileMap.get(sourceName);\n      if (index != null) {\n        lastSourceFileIndex = index;\n      } else {\n        lastSourceFileIndex = sourceFileMap.size();\n        sourceFileMap.put(sourceName, lastSourceFileIndex);\n      }\n    }\n    return lastSourceFileIndex;\n  }\n\n  /**\n   * Pools symbol names\n   * @param symbolName The symbol name to index.\n   * @return The id to represent the symbol name in the output.\n   */\n  private int getNameId(String symbolName) {", "right_context": "}\n}", "class_name": "SourceMapGeneratorV2", "return_type": "int", "parameters": [{"type": "String", "name": "symbolName"}]}}
{"prompt": "class JSType implements Serializable {\n  /**\n   * Tests whether this type is nullable.\n   */\n  public boolean isNullable() {\n    return isSubtype(getNativeType(JSTypeNative.NULL_TYPE));\n  }\n\n  /**\n   * Gets the least supertype of this that's not a union.\n   */\n  public JSType collapseUnion() {\n    return this;\n  }\n\n  /**\n   * Gets the least supertype of {@code this} and {@code that}.\n   * The least supertype is the join (&#8744;) or supremum of both types in the\n   * type lattice.<p>\n   * Examples:\n   * <ul>\n   * <li>{@code number &#8744; *} = {@code *}</li>\n   * <li>{@code number &#8744; Object} = {@code (number, Object)}</li>\n   * <li>{@code Number &#8744; Object} = {@code Object}</li>\n   * </ul>\n   * @return {@code this &#8744; that}\n   */\n  public JSType getLeastSupertype(JSType that) {\n    if (that.isUnionType()) {\n      // Union types have their own implementation of getLeastSupertype.\n      return that.toMaybeUnionType().getLeastSupertype(this);\n    }\n    return getLeastSupertype(this, that);\n  }\n\n  /**\n   * A generic implementation meant to be used as a helper for common\n   * getLeastSupertype implementations.\n   */\n  static JSType getLeastSupertype(JSType thisType, JSType thatType) {\n    boolean areEquivalent = thisType.isEquivalentTo(thatType);\n    return areEquivalent ? thisType :\n        filterNoResolvedType(\n            thisType.registry.createUnionType(thisType, thatType));\n  }\n\n  /**\n   * Gets the greatest subtype of {@code this} and {@code that}.\n   * The greatest subtype is the meet (&#8743;) or infimum of both types in the\n   * type lattice.<p>\n   * Examples\n   * <ul>\n   * <li>{@code Number &#8743; Any} = {@code Any}</li>\n   * <li>{@code number &#8743; Object} = {@code Any}</li>\n   * <li>{@code Number &#8743; Object} = {@code Number}</li>\n   * </ul>\n   * @return {@code this &#8744; that}\n   */\n  public JSType getGreatestSubtype(JSType that) {\n    return getGreatestSubtype(this, that);\n  }\n\n  /**\n   * A generic implementation meant to be used as a helper for common\n   * getGreatestSubtype implementations.\n   */\n  static JSType getGreatestSubtype(JSType thisType, JSType thatType) {\n    if (thisType.isFunctionType() && thatType.isFunctionType()) {\n      // The FunctionType sub-lattice is not well-defined. i.e., the\n      // proposition\n      // A < B => sup(A, B) == B\n      // does not hold because of unknown parameters and return types.\n      // See the comment in supAndInfHelper for more info on this.\n      return thisType.toMaybeFunctionType().supAndInfHelper(\n          thatType.toMaybeFunctionType(), false);\n    } else if (thisType.isEquivalentTo(thatType)) {\n      return thisType;\n    } else if (thisType.isUnknownType() || thatType.isUnknownType()) {\n      // The greatest subtype with any unknown type is the universal\n      // unknown type, unless the two types are equal.\n      return thisType.isEquivalentTo(thatType) ? thisType :\n          thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    } else if (thisType.isUnionType()) {\n      return thisType.toMaybeUnionType().meet(thatType);\n    } else if (thatType.isUnionType()) {\n      return thatType.toMaybeUnionType().meet(thisType);\n    } else if (thisType.isTemplatizedType()) {\n      return thisType.toMaybeTemplatizedType().getGreatestSubtypeHelper(\n          thatType);\n    }  else if (thatType.isTemplatizedType()) {\n      return thatType.toMaybeTemplatizedType().getGreatestSubtypeHelper(\n          thisType);\n    } else if (thisType.isSubtype(thatType)) {\n      return filterNoResolvedType(thisType);\n    } else if (thatType.isSubtype(thisType)) {\n      return filterNoResolvedType(thatType);\n    } else if (thisType.isRecordType()) {\n      return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);\n    } else if (thatType.isRecordType()) {\n      return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);\n    }\n\n    if (thisType.isEnumElementType()) {\n      JSType inf = thisType.toMaybeEnumElementType().meet(thatType);\n      if (inf != null) {\n        return inf;\n      }\n    } else if (thatType.isEnumElementType()) {\n      JSType inf = thatType.toMaybeEnumElementType().meet(thisType);\n      if (inf != null) {\n        return inf;\n      }\n    }\n\n    if (thisType.isObject() && thatType.isObject()) {\n      return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    }\n    return thisType.getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  /**\n   * When computing infima, we may get a situation like\n   * inf(Type1, Type2)\n   * where both types are unresolved, so they're technically\n   * subtypes of one another.\n   *\n   * If this happens, filter them down to NoResolvedType.\n   */\n  static JSType filterNoResolvedType(JSType type) {", "metadata": {"defects4j_task_id": "ecd6bbdb20a332981547aa1bd15c2452d5de276f16ff51b577b4c78274de1e18", "task_id": "google_closure-compiler/195", "ground_truth": "\n    if (type.isNoResolvedType()) {\n      // inf(UnresolvedType1, UnresolvedType2) needs to resolve\n      // to the base unresolved type, so that the relation is symmetric.\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    } else if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      boolean needsFiltering = false;\n      for (JSType alt : unionType.getAlternates()) {\n        if (alt.isNoResolvedType()) {\n          needsFiltering = true;\n          break;\n        }\n      }\n\n      if (needsFiltering) {\n        UnionTypeBuilder builder = new UnionTypeBuilder(type.registry);\n        builder.addAlternate(type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE));\n        for (JSType alt : unionType.getAlternates()) {\n          if (!alt.isNoResolvedType()) {\n            builder.addAlternate(alt);\n          }\n        }\n        return builder.build();\n      }\n    }\n    return type;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "rhino", "jstype", "JSType.java"], "context_start_lineno": 0, "function_name": "filterNoResolvedType", "left_context": "class JSType implements Serializable {\n  /**\n   * Tests whether this type is nullable.\n   */\n  public boolean isNullable() {\n    return isSubtype(getNativeType(JSTypeNative.NULL_TYPE));\n  }\n\n  /**\n   * Gets the least supertype of this that's not a union.\n   */\n  public JSType collapseUnion() {\n    return this;\n  }\n\n  /**\n   * Gets the least supertype of {@code this} and {@code that}.\n   * The least supertype is the join (&#8744;) or supremum of both types in the\n   * type lattice.<p>\n   * Examples:\n   * <ul>\n   * <li>{@code number &#8744; *} = {@code *}</li>\n   * <li>{@code number &#8744; Object} = {@code (number, Object)}</li>\n   * <li>{@code Number &#8744; Object} = {@code Object}</li>\n   * </ul>\n   * @return {@code this &#8744; that}\n   */\n  public JSType getLeastSupertype(JSType that) {\n    if (that.isUnionType()) {\n      // Union types have their own implementation of getLeastSupertype.\n      return that.toMaybeUnionType().getLeastSupertype(this);\n    }\n    return getLeastSupertype(this, that);\n  }\n\n  /**\n   * A generic implementation meant to be used as a helper for common\n   * getLeastSupertype implementations.\n   */\n  static JSType getLeastSupertype(JSType thisType, JSType thatType) {\n    boolean areEquivalent = thisType.isEquivalentTo(thatType);\n    return areEquivalent ? thisType :\n        filterNoResolvedType(\n            thisType.registry.createUnionType(thisType, thatType));\n  }\n\n  /**\n   * Gets the greatest subtype of {@code this} and {@code that}.\n   * The greatest subtype is the meet (&#8743;) or infimum of both types in the\n   * type lattice.<p>\n   * Examples\n   * <ul>\n   * <li>{@code Number &#8743; Any} = {@code Any}</li>\n   * <li>{@code number &#8743; Object} = {@code Any}</li>\n   * <li>{@code Number &#8743; Object} = {@code Number}</li>\n   * </ul>\n   * @return {@code this &#8744; that}\n   */\n  public JSType getGreatestSubtype(JSType that) {\n    return getGreatestSubtype(this, that);\n  }\n\n  /**\n   * A generic implementation meant to be used as a helper for common\n   * getGreatestSubtype implementations.\n   */\n  static JSType getGreatestSubtype(JSType thisType, JSType thatType) {\n    if (thisType.isFunctionType() && thatType.isFunctionType()) {\n      // The FunctionType sub-lattice is not well-defined. i.e., the\n      // proposition\n      // A < B => sup(A, B) == B\n      // does not hold because of unknown parameters and return types.\n      // See the comment in supAndInfHelper for more info on this.\n      return thisType.toMaybeFunctionType().supAndInfHelper(\n          thatType.toMaybeFunctionType(), false);\n    } else if (thisType.isEquivalentTo(thatType)) {\n      return thisType;\n    } else if (thisType.isUnknownType() || thatType.isUnknownType()) {\n      // The greatest subtype with any unknown type is the universal\n      // unknown type, unless the two types are equal.\n      return thisType.isEquivalentTo(thatType) ? thisType :\n          thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    } else if (thisType.isUnionType()) {\n      return thisType.toMaybeUnionType().meet(thatType);\n    } else if (thatType.isUnionType()) {\n      return thatType.toMaybeUnionType().meet(thisType);\n    } else if (thisType.isTemplatizedType()) {\n      return thisType.toMaybeTemplatizedType().getGreatestSubtypeHelper(\n          thatType);\n    }  else if (thatType.isTemplatizedType()) {\n      return thatType.toMaybeTemplatizedType().getGreatestSubtypeHelper(\n          thisType);\n    } else if (thisType.isSubtype(thatType)) {\n      return filterNoResolvedType(thisType);\n    } else if (thatType.isSubtype(thisType)) {\n      return filterNoResolvedType(thatType);\n    } else if (thisType.isRecordType()) {\n      return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);\n    } else if (thatType.isRecordType()) {\n      return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);\n    }\n\n    if (thisType.isEnumElementType()) {\n      JSType inf = thisType.toMaybeEnumElementType().meet(thatType);\n      if (inf != null) {\n        return inf;\n      }\n    } else if (thatType.isEnumElementType()) {\n      JSType inf = thatType.toMaybeEnumElementType().meet(thisType);\n      if (inf != null) {\n        return inf;\n      }\n    }\n\n    if (thisType.isObject() && thatType.isObject()) {\n      return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    }\n    return thisType.getNativeType(JSTypeNative.NO_TYPE);\n  }\n\n  /**\n   * When computing infima, we may get a situation like\n   * inf(Type1, Type2)\n   * where both types are unresolved, so they're technically\n   * subtypes of one another.\n   *\n   * If this happens, filter them down to NoResolvedType.\n   */\n  static JSType filterNoResolvedType(JSType type) {", "right_context": "}\n}", "class_name": "JSType", "return_type": "JSType", "parameters": [{"type": "JSType", "name": "type"}]}}
{"prompt": "class Node implements Cloneable, Serializable {\n\n  /**\n   * Extracts the line number and character number from a merged line char\n   * number (see {@link #mergeLineCharNo(int, int)}).\n   */\n  protected static int extractLineno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo >>> COLUMN_BITS;\n    }\n  }\n\n  /**\n   * Extracts the character number and character number from a merged line\n   * char number (see {@link #mergeLineCharNo(int, int)}).\n   */\n  protected static int extractCharno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo & COLUMN_MASK;\n    }\n  }\n\n  //==========================================================================\n  // Iteration\n\n  /**\n   * <p>Return an iterable object that iterates over this node's children.\n   * The iterator does not support the optional operation\n   * {@link Iterator#remove()}.</p>\n   *\n   * <p>To iterate over a node's children, one can write</p>\n   * <pre>Node n = ...;\n   * for (Node child : n.children()) { ...</pre>\n   */\n  public Iterable<Node> children() {\n    if (first == null) {\n      return Collections.emptySet();\n    } else {\n      return new SiblingNodeIterable(first);\n    }\n  }\n\n  /**\n   * <p>Return an iterable object that iterates over this node's siblings.\n   * The iterator does not support the optional operation\n   * {@link Iterator#remove()}.</p>\n   *\n   * <p>To iterate over a node's siblings, one can write</p>\n   * <pre>Node n = ...;\n   * for (Node sibling : n.siblings()) { ...</pre>\n   */\n  public Iterable<Node> siblings() {\n    return new SiblingNodeIterable(this);\n  }\n\n  /**\n   * @see Node#siblings()\n   */\n  private static final class SiblingNodeIterable\n      implements Iterable<Node>, Iterator<Node> {\n    private final Node start;\n    private Node current;\n    private boolean used;\n\n    SiblingNodeIterable(Node start) {\n      this.start = start;\n      this.current = start;\n      this.used = false;\n    }\n\n    @Override\n    public Iterator<Node> iterator() {\n      if (!used) {\n        used = true;\n        return this;\n      } else {\n        // We have already used the current object as an iterator;\n        // we must create a new SiblingNodeIterable based on this\n        // iterable's start node.\n        //\n        // Since the primary use case for Node.children is in for\n        // loops, this branch is extremely unlikely.\n        return (new SiblingNodeIterable(start)).iterator();\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      return current != null;\n    }\n\n    @Override\n    public Node next() {\n      if (current == null) {\n        throw new NoSuchElementException();\n      }\n      try {\n        return current;\n      } finally {\n        current = current.getNext();\n      }\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // ==========================================================================\n  // Accessors\n\n  PropListItem getPropListHeadForTesting() {\n    return propListHead;\n  }\n\n  public Node getParent() {\n    return parent;\n  }\n\n  /**\n   * Gets the ancestor node relative to this.\n   *\n   * @param level 0 = this, 1 = the parent, etc.\n   */\n  public Node getAncestor(int level) {\n    Preconditions.checkArgument(level >= 0);\n    Node node = this;\n    while (node != null && level-- > 0) {\n      node = node.getParent();\n    }\n    return node;\n  }\n\n  /**\n   * Iterates all of the node's ancestors excluding itself.\n   */\n  public AncestorIterable getAncestors() {\n    return new AncestorIterable(this.getParent());\n  }\n\n  /**\n   * Iterator to go up the ancestor tree.\n   */\n  public static class AncestorIterable implements Iterable<Node> {\n    private Node cur;\n\n    /**\n     * @param cur The node to start.\n     */\n    AncestorIterable(Node cur) {\n      this.cur = cur;\n    }\n\n    @Override\n    public Iterator<Node> iterator() {\n      return new Iterator<Node>() {\n        @Override\n        public boolean hasNext() {\n          return cur != null;\n        }\n\n        @Override\n        public Node next() {\n          if (!hasNext()) {\n            throw new NoSuchElementException();\n          }\n          Node n = cur;\n          cur = cur.getParent();\n          return n;\n        }\n\n        @Override\n        public void remove() {\n          throw new UnsupportedOperationException();\n        }\n      };\n    }\n  }\n\n  /**\n   * Check for one child more efficiently than by iterating over all the\n   * children as is done with Node.getChildCount().\n   *\n   * @return Whether the node has exactly one child.\n   */\n  public boolean hasOneChild() {\n    return first != null && first == last;\n  }\n\n  /**\n   * Check for more than one child more efficiently than by iterating over all\n   * the children as is done with Node.getChildCount().\n   *\n   * @return Whether the node more than one child.\n   */\n  public boolean hasMoreThanOneChild() {\n    return first != null && first != last;\n  }\n\n  public int getChildCount() {\n    int c = 0;\n    for (Node n = first; n != null; n = n.next) {\n      c++;\n    }\n    return c;\n  }\n\n  // Intended for testing and verification only.\n  public boolean hasChild(Node child) {\n    for (Node n = first; n != null; n = n.getNext()) {\n      if (child == n) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Checks if the subtree under this node is the same as another subtree.\n   * Returns null if it's equal, or a message describing the differences.\n   */\n  public String checkTreeEquals(Node node2) {\n      NodeMismatch diff = checkTreeEqualsImpl(node2);\n      if (diff != null) {\n        return \"Node tree inequality:\" +\n            \"\\nTree1:\\n\" + toStringTree() +\n            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n      }\n      return null;\n  }\n\n  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {", "metadata": {"defects4j_task_id": "cc6aa0a4fdcec022f3ed9da29913e7a6890104cc3392a2c638917be1f7207b96", "task_id": "google_closure-compiler/164", "ground_truth": "\n    if (!isEquivalentTo(node2, false, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n        return res;\n      }\n    }\n    return res;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "rhino", "Node.java"], "context_start_lineno": 0, "function_name": "checkTreeEqualsImpl", "left_context": "class Node implements Cloneable, Serializable {\n\n  /**\n   * Extracts the line number and character number from a merged line char\n   * number (see {@link #mergeLineCharNo(int, int)}).\n   */\n  protected static int extractLineno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo >>> COLUMN_BITS;\n    }\n  }\n\n  /**\n   * Extracts the character number and character number from a merged line\n   * char number (see {@link #mergeLineCharNo(int, int)}).\n   */\n  protected static int extractCharno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo & COLUMN_MASK;\n    }\n  }\n\n  //==========================================================================\n  // Iteration\n\n  /**\n   * <p>Return an iterable object that iterates over this node's children.\n   * The iterator does not support the optional operation\n   * {@link Iterator#remove()}.</p>\n   *\n   * <p>To iterate over a node's children, one can write</p>\n   * <pre>Node n = ...;\n   * for (Node child : n.children()) { ...</pre>\n   */\n  public Iterable<Node> children() {\n    if (first == null) {\n      return Collections.emptySet();\n    } else {\n      return new SiblingNodeIterable(first);\n    }\n  }\n\n  /**\n   * <p>Return an iterable object that iterates over this node's siblings.\n   * The iterator does not support the optional operation\n   * {@link Iterator#remove()}.</p>\n   *\n   * <p>To iterate over a node's siblings, one can write</p>\n   * <pre>Node n = ...;\n   * for (Node sibling : n.siblings()) { ...</pre>\n   */\n  public Iterable<Node> siblings() {\n    return new SiblingNodeIterable(this);\n  }\n\n  /**\n   * @see Node#siblings()\n   */\n  private static final class SiblingNodeIterable\n      implements Iterable<Node>, Iterator<Node> {\n    private final Node start;\n    private Node current;\n    private boolean used;\n\n    SiblingNodeIterable(Node start) {\n      this.start = start;\n      this.current = start;\n      this.used = false;\n    }\n\n    @Override\n    public Iterator<Node> iterator() {\n      if (!used) {\n        used = true;\n        return this;\n      } else {\n        // We have already used the current object as an iterator;\n        // we must create a new SiblingNodeIterable based on this\n        // iterable's start node.\n        //\n        // Since the primary use case for Node.children is in for\n        // loops, this branch is extremely unlikely.\n        return (new SiblingNodeIterable(start)).iterator();\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      return current != null;\n    }\n\n    @Override\n    public Node next() {\n      if (current == null) {\n        throw new NoSuchElementException();\n      }\n      try {\n        return current;\n      } finally {\n        current = current.getNext();\n      }\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // ==========================================================================\n  // Accessors\n\n  PropListItem getPropListHeadForTesting() {\n    return propListHead;\n  }\n\n  public Node getParent() {\n    return parent;\n  }\n\n  /**\n   * Gets the ancestor node relative to this.\n   *\n   * @param level 0 = this, 1 = the parent, etc.\n   */\n  public Node getAncestor(int level) {\n    Preconditions.checkArgument(level >= 0);\n    Node node = this;\n    while (node != null && level-- > 0) {\n      node = node.getParent();\n    }\n    return node;\n  }\n\n  /**\n   * Iterates all of the node's ancestors excluding itself.\n   */\n  public AncestorIterable getAncestors() {\n    return new AncestorIterable(this.getParent());\n  }\n\n  /**\n   * Iterator to go up the ancestor tree.\n   */\n  public static class AncestorIterable implements Iterable<Node> {\n    private Node cur;\n\n    /**\n     * @param cur The node to start.\n     */\n    AncestorIterable(Node cur) {\n      this.cur = cur;\n    }\n\n    @Override\n    public Iterator<Node> iterator() {\n      return new Iterator<Node>() {\n        @Override\n        public boolean hasNext() {\n          return cur != null;\n        }\n\n        @Override\n        public Node next() {\n          if (!hasNext()) {\n            throw new NoSuchElementException();\n          }\n          Node n = cur;\n          cur = cur.getParent();\n          return n;\n        }\n\n        @Override\n        public void remove() {\n          throw new UnsupportedOperationException();\n        }\n      };\n    }\n  }\n\n  /**\n   * Check for one child more efficiently than by iterating over all the\n   * children as is done with Node.getChildCount().\n   *\n   * @return Whether the node has exactly one child.\n   */\n  public boolean hasOneChild() {\n    return first != null && first == last;\n  }\n\n  /**\n   * Check for more than one child more efficiently than by iterating over all\n   * the children as is done with Node.getChildCount().\n   *\n   * @return Whether the node more than one child.\n   */\n  public boolean hasMoreThanOneChild() {\n    return first != null && first != last;\n  }\n\n  public int getChildCount() {\n    int c = 0;\n    for (Node n = first; n != null; n = n.next) {\n      c++;\n    }\n    return c;\n  }\n\n  // Intended for testing and verification only.\n  public boolean hasChild(Node child) {\n    for (Node n = first; n != null; n = n.getNext()) {\n      if (child == n) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Checks if the subtree under this node is the same as another subtree.\n   * Returns null if it's equal, or a message describing the differences.\n   */\n  public String checkTreeEquals(Node node2) {\n      NodeMismatch diff = checkTreeEqualsImpl(node2);\n      if (diff != null) {\n        return \"Node tree inequality:\" +\n            \"\\nTree1:\\n\" + toStringTree() +\n            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n      }\n      return null;\n  }\n\n  /**\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   */\n  NodeMismatch checkTreeEqualsImpl(Node node2) {", "right_context": "}\n}", "class_name": "Node", "return_type": "NodeMismatch", "parameters": [{"type": "Node", "name": "node2"}]}}
{"prompt": "class MustBeReachingVariableDef extends\n    DataFlowAnalysis<Node, MustBeReachingVariableDef.MustDef> {\n\n  // The scope of the function that we are analyzing.\n  /**\n   * @param n The node in question.\n   * @param cfgNode The node to add\n   * @param conditional true if the definition is not always executed.\n   */\n  private void computeMustDef(\n      Node n, Node cfgNode, MustDef output, boolean conditional) {\n    switch (n.getType()) {\n\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeMustDef(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeMustDef(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (lhs.isVar()) {\n            lhs = lhs.getLastChild(); // for(var x in y) {...}\n          }\n          if (lhs.isName()) {\n            addToDefIfLocal(lhs.getString(), cfgNode, rhs, output);\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeMustDef(n.getFirstChild(), cfgNode, output, conditional);\n        computeMustDef(n.getLastChild(), cfgNode, output, true);\n        return;\n\n      case Token.HOOK:\n        computeMustDef(n.getFirstChild(), cfgNode, output, conditional);\n        computeMustDef(n.getFirstChild().getNext(), cfgNode, output, true);\n        computeMustDef(n.getLastChild(), cfgNode, output, true);\n        return;\n\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (c.hasChildren()) {\n            computeMustDef(c.getFirstChild(), cfgNode, output, conditional);\n            addToDefIfLocal(c.getString(), conditional ? null : cfgNode,\n                c.getFirstChild(), output);\n          }\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n)) {\n          if (n.getFirstChild().isName()) {\n            Node name = n.getFirstChild();\n            computeMustDef(name.getNext(), cfgNode, output, conditional);\n            addToDefIfLocal(name.getString(), conditional ? null : cfgNode,\n              n.getLastChild(), output);\n            return;\n          } else if (NodeUtil.isGet(n.getFirstChild())) {\n            // Treat all assignments to arguments as redefining the\n            // parameters itself.\n            Node obj = n.getFirstChild().getFirstChild();\n            if (obj.isName() && \"arguments\".equals(obj.getString())) {\n              // TODO(user): More accuracy can be introduced\n              // i.e. We know exactly what arguments[x] is if x is a constant\n              // number.\n              escapeParameters(output);\n            }\n          }\n        }\n\n        if (n.isName() && \"arguments\".equals(n.getString())) {\n          escapeParameters(output);\n        }\n\n        // DEC and INC actually defines the variable.\n        if (n.isDec() || n.isInc()) {\n          Node target = n.getFirstChild();\n          if (target.isName()) {\n            addToDefIfLocal(target.getString(),\n                conditional ? null : cfgNode, null, output);\n            return;\n          }\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          computeMustDef(c, cfgNode, output, conditional);\n        }\n    }\n  }\n\n  /**\n   * Set the variable lattice for the given name to the node value in the def\n   * lattice. Do nothing if the variable name is one of the escaped variable.\n   *\n   * @param node The CFG node where the definition should be record to.\n   *     {@code null} if this is a conditional define.\n   */\n  private void addToDefIfLocal(String name, @Nullable Node node,\n      @Nullable Node rValue, MustDef def) {\n    Var var = jsScope.getVar(name);\n\n    // var might be null because the variable might be defined in the extern\n    // that we might not traverse.\n    if (var == null || var.scope != jsScope) {\n      return;\n    }\n\n    for (Var other : def.reachingDef.keySet()) {\n      Definition otherDef = def.reachingDef.get(other);\n      if (otherDef == null) {\n        continue;\n      }\n      if (otherDef.depends.contains(var)) {\n        def.reachingDef.put(other, null);\n      }\n    }\n\n    if (!escaped.contains(var)) {\n      if (node == null) {\n        def.reachingDef.put(var, null);\n      } else {\n        Definition definition = new Definition(node);\n        if (rValue != null) {\n          computeDependence(definition, rValue);\n        }\n        def.reachingDef.put(var, definition);\n      }\n    }\n  }\n\n  private void escapeParameters(MustDef output) {\n    for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {\n      Var v = i.next();\n      if (isParameter(v)) {\n        // Assume we no longer know where the parameter comes from\n        // anymore.\n        output.reachingDef.put(v, null);\n      }\n    }\n\n    // Also, assume we no longer know anything that depends on a parameter.\n    for (Entry<Var, Definition> pair : output.reachingDef.entrySet()) {\n      Definition value = pair.getValue();\n      if (value == null) {\n        continue;\n      }\n      for (Var dep : value.depends) {\n        if (isParameter(dep)) {\n          output.reachingDef.put(pair.getKey(), null);\n        }\n      }\n    }\n  }\n\n  private boolean isParameter(Var v) {\n    return v.getParentNode().isParamList();\n  }\n\n  /**\n   * Computes all the local variables that rValue reads from and store that\n   * in the def's depends set.\n   */\n  private void computeDependence(final Definition def, Node rValue) {\n    NodeTraversal.traverse(compiler, rValue,\n        new AbstractCfgNodeTraversalCallback() {\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isName()) {\n          Var dep = jsScope.getVar(n.getString());\n          if (dep == null) {\n            def.unknownDependencies = true;\n          } else {\n            def.depends.add(dep);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Gets the must reaching definition of a given node.\n   *\n   * @param name name of the variable. It can only be names of local variable\n   *     that are not function parameters, escaped variables or variables\n   *     declared in catch.\n   * @param useNode the location of the use where the definition reaches.\n   */\n  Definition getDef(String name, Node useNode) {", "metadata": {"defects4j_task_id": "1a240672062e93922416cc64d278be93de1bce4f15e211b39db8c6edb6ecf5f1", "task_id": "google_closure-compiler/29", "ground_truth": "\n    Preconditions.checkArgument(getCfg().hasNode(useNode));\n    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n    FlowState<MustDef> state = n.getAnnotation();\n    return state.getIn().reachingDef.get(jsScope.getVar(name));\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "MustBeReachingVariableDef.java"], "context_start_lineno": 0, "function_name": "getDef", "left_context": "class MustBeReachingVariableDef extends\n    DataFlowAnalysis<Node, MustBeReachingVariableDef.MustDef> {\n\n  // The scope of the function that we are analyzing.\n  /**\n   * @param n The node in question.\n   * @param cfgNode The node to add\n   * @param conditional true if the definition is not always executed.\n   */\n  private void computeMustDef(\n      Node n, Node cfgNode, MustDef output, boolean conditional) {\n    switch (n.getType()) {\n\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeMustDef(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeMustDef(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (lhs.isVar()) {\n            lhs = lhs.getLastChild(); // for(var x in y) {...}\n          }\n          if (lhs.isName()) {\n            addToDefIfLocal(lhs.getString(), cfgNode, rhs, output);\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeMustDef(n.getFirstChild(), cfgNode, output, conditional);\n        computeMustDef(n.getLastChild(), cfgNode, output, true);\n        return;\n\n      case Token.HOOK:\n        computeMustDef(n.getFirstChild(), cfgNode, output, conditional);\n        computeMustDef(n.getFirstChild().getNext(), cfgNode, output, true);\n        computeMustDef(n.getLastChild(), cfgNode, output, true);\n        return;\n\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (c.hasChildren()) {\n            computeMustDef(c.getFirstChild(), cfgNode, output, conditional);\n            addToDefIfLocal(c.getString(), conditional ? null : cfgNode,\n                c.getFirstChild(), output);\n          }\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n)) {\n          if (n.getFirstChild().isName()) {\n            Node name = n.getFirstChild();\n            computeMustDef(name.getNext(), cfgNode, output, conditional);\n            addToDefIfLocal(name.getString(), conditional ? null : cfgNode,\n              n.getLastChild(), output);\n            return;\n          } else if (NodeUtil.isGet(n.getFirstChild())) {\n            // Treat all assignments to arguments as redefining the\n            // parameters itself.\n            Node obj = n.getFirstChild().getFirstChild();\n            if (obj.isName() && \"arguments\".equals(obj.getString())) {\n              // TODO(user): More accuracy can be introduced\n              // i.e. We know exactly what arguments[x] is if x is a constant\n              // number.\n              escapeParameters(output);\n            }\n          }\n        }\n\n        if (n.isName() && \"arguments\".equals(n.getString())) {\n          escapeParameters(output);\n        }\n\n        // DEC and INC actually defines the variable.\n        if (n.isDec() || n.isInc()) {\n          Node target = n.getFirstChild();\n          if (target.isName()) {\n            addToDefIfLocal(target.getString(),\n                conditional ? null : cfgNode, null, output);\n            return;\n          }\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          computeMustDef(c, cfgNode, output, conditional);\n        }\n    }\n  }\n\n  /**\n   * Set the variable lattice for the given name to the node value in the def\n   * lattice. Do nothing if the variable name is one of the escaped variable.\n   *\n   * @param node The CFG node where the definition should be record to.\n   *     {@code null} if this is a conditional define.\n   */\n  private void addToDefIfLocal(String name, @Nullable Node node,\n      @Nullable Node rValue, MustDef def) {\n    Var var = jsScope.getVar(name);\n\n    // var might be null because the variable might be defined in the extern\n    // that we might not traverse.\n    if (var == null || var.scope != jsScope) {\n      return;\n    }\n\n    for (Var other : def.reachingDef.keySet()) {\n      Definition otherDef = def.reachingDef.get(other);\n      if (otherDef == null) {\n        continue;\n      }\n      if (otherDef.depends.contains(var)) {\n        def.reachingDef.put(other, null);\n      }\n    }\n\n    if (!escaped.contains(var)) {\n      if (node == null) {\n        def.reachingDef.put(var, null);\n      } else {\n        Definition definition = new Definition(node);\n        if (rValue != null) {\n          computeDependence(definition, rValue);\n        }\n        def.reachingDef.put(var, definition);\n      }\n    }\n  }\n\n  private void escapeParameters(MustDef output) {\n    for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {\n      Var v = i.next();\n      if (isParameter(v)) {\n        // Assume we no longer know where the parameter comes from\n        // anymore.\n        output.reachingDef.put(v, null);\n      }\n    }\n\n    // Also, assume we no longer know anything that depends on a parameter.\n    for (Entry<Var, Definition> pair : output.reachingDef.entrySet()) {\n      Definition value = pair.getValue();\n      if (value == null) {\n        continue;\n      }\n      for (Var dep : value.depends) {\n        if (isParameter(dep)) {\n          output.reachingDef.put(pair.getKey(), null);\n        }\n      }\n    }\n  }\n\n  private boolean isParameter(Var v) {\n    return v.getParentNode().isParamList();\n  }\n\n  /**\n   * Computes all the local variables that rValue reads from and store that\n   * in the def's depends set.\n   */\n  private void computeDependence(final Definition def, Node rValue) {\n    NodeTraversal.traverse(compiler, rValue,\n        new AbstractCfgNodeTraversalCallback() {\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isName()) {\n          Var dep = jsScope.getVar(n.getString());\n          if (dep == null) {\n            def.unknownDependencies = true;\n          } else {\n            def.depends.add(dep);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Gets the must reaching definition of a given node.\n   *\n   * @param name name of the variable. It can only be names of local variable\n   *     that are not function parameters, escaped variables or variables\n   *     declared in catch.\n   * @param useNode the location of the use where the definition reaches.\n   */\n  Definition getDef(String name, Node useNode) {", "right_context": "}\n}", "class_name": "MustBeReachingVariableDef", "return_type": "Definition", "parameters": [{"type": "String", "name": "name"}, {"type": "Node", "name": "useNode"}]}}
{"prompt": "class DisambiguateProperties<T> implements CompilerPass {\n  // To prevent the logs from filling up, we cap the number of warnings\n  // that we tell the user to fix per-property.\n  private static final Logger logger = Logger.getLogger(\n      DisambiguateProperties.class.getName());\n\n  static class Warnings {\n    // TODO(user): {1} and {2} are not exactly useful for most people.\n    static final DiagnosticType INVALIDATION = DiagnosticType.disabled(\n        \"JSC_INVALIDATION\",\n        \"Property disambiguator skipping all instances of property {0} \"\n        + \"because of type {1} node {2}. {3}\");\n\n    static final DiagnosticType INVALIDATION_ON_TYPE = DiagnosticType.disabled(\n        \"JSC_INVALIDATION_TYPE\",\n        \"Property disambiguator skipping instances of property {0} \"\n        + \"on type {1}. {2}\");\n  }\n\n  private final AbstractCompiler compiler;\n  private final TypeSystem<T> typeSystem;\n\n  /**\n   * Map of a type to all the related errors that invalidated the type\n   * for disambiguation. It has be Object because of the generic nature of\n   * this pass.\n   */\n  private Multimap<Object, JSError> invalidationMap;\n\n  /**\n   * In practice any large code base will have thousands and thousands of\n   * type invalidations, which makes reporting all of the errors useless.\n   * However, certain properties are worth specifically guarding because of the\n   * large amount of code that can be removed as dead code. This list contains\n   * the properties (eg: \"toString\") that we care about; if any of these\n   * properties is invalidated it causes an error.\n   */\n  private final Map<String, CheckLevel> propertiesToErrorFor;\n\n  private class Property {\n    /** The name of the property. */\n    final String name;\n\n    /** All types on which the field exists, grouped together if related. */\n    private UnionFind<T> types;\n\n    /**\n     * A set of types for which renaming this field should be skipped. This\n     * list is first filled by fields defined in the externs file.\n     */\n    Set<T> typesToSkip = Sets.newHashSet();\n\n    /**\n     * If true, do not rename any instance of this field, as it has been\n     * referenced from an unknown type.\n     */\n    boolean skipRenaming;\n\n    /** Set of nodes for this field that need renaming. */\n    Set<Node> renameNodes = Sets.newHashSet();\n\n    /**\n     * Map from node to the highest type in the prototype chain containing the\n     * field for that node. In the case of a union, the type is the highest type\n     * of one of the types in the union.\n     */\n    final Map<Node, T> rootTypes = Maps.newHashMap();\n\n    Property(String name) {\n      this.name = name;\n    }\n\n    /** Returns the types on which this field is referenced. */\n    UnionFind<T> getTypes() {\n      if (types == null) {\n        types = new StandardUnionFind<T>();\n      }\n      return types;\n    }\n\n    /**\n     * Record that this property is referenced from this type.\n     * @return true if the type was recorded for this property, else false,\n     *     which would happen if the type was invalidating.\n     */\n    boolean addType(T type, T top, T relatedType) {", "metadata": {"defects4j_task_id": "0ab6739cce009ca5230240d924213e3597ce1792abf4b5db075b92e2f7c6edc4", "task_id": "google_closure-compiler/11", "ground_truth": "\n      checkState(!skipRenaming, \"Attempt to record skipped property: %s\", name);\n      if (typeSystem.isInvalidatingType(top)) {\n        invalidate();\n        return false;\n      } else {\n        if (typeSystem.isTypeToSkip(top)) {\n          addTypeToSkip(top);\n        }\n\n        if (relatedType == null) {\n          getTypes().add(top);\n        } else {\n          getTypes().union(top, relatedType);\n        }\n        typeSystem.recordInterfaces(type, top, this);\n        return true;\n      }\n    ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "DisambiguateProperties.java"], "context_start_lineno": 0, "function_name": "addType", "left_context": "class DisambiguateProperties<T> implements CompilerPass {\n  // To prevent the logs from filling up, we cap the number of warnings\n  // that we tell the user to fix per-property.\n  private static final Logger logger = Logger.getLogger(\n      DisambiguateProperties.class.getName());\n\n  static class Warnings {\n    // TODO(user): {1} and {2} are not exactly useful for most people.\n    static final DiagnosticType INVALIDATION = DiagnosticType.disabled(\n        \"JSC_INVALIDATION\",\n        \"Property disambiguator skipping all instances of property {0} \"\n        + \"because of type {1} node {2}. {3}\");\n\n    static final DiagnosticType INVALIDATION_ON_TYPE = DiagnosticType.disabled(\n        \"JSC_INVALIDATION_TYPE\",\n        \"Property disambiguator skipping instances of property {0} \"\n        + \"on type {1}. {2}\");\n  }\n\n  private final AbstractCompiler compiler;\n  private final TypeSystem<T> typeSystem;\n\n  /**\n   * Map of a type to all the related errors that invalidated the type\n   * for disambiguation. It has be Object because of the generic nature of\n   * this pass.\n   */\n  private Multimap<Object, JSError> invalidationMap;\n\n  /**\n   * In practice any large code base will have thousands and thousands of\n   * type invalidations, which makes reporting all of the errors useless.\n   * However, certain properties are worth specifically guarding because of the\n   * large amount of code that can be removed as dead code. This list contains\n   * the properties (eg: \"toString\") that we care about; if any of these\n   * properties is invalidated it causes an error.\n   */\n  private final Map<String, CheckLevel> propertiesToErrorFor;\n\n  private class Property {\n    /** The name of the property. */\n    final String name;\n\n    /** All types on which the field exists, grouped together if related. */\n    private UnionFind<T> types;\n\n    /**\n     * A set of types for which renaming this field should be skipped. This\n     * list is first filled by fields defined in the externs file.\n     */\n    Set<T> typesToSkip = Sets.newHashSet();\n\n    /**\n     * If true, do not rename any instance of this field, as it has been\n     * referenced from an unknown type.\n     */\n    boolean skipRenaming;\n\n    /** Set of nodes for this field that need renaming. */\n    Set<Node> renameNodes = Sets.newHashSet();\n\n    /**\n     * Map from node to the highest type in the prototype chain containing the\n     * field for that node. In the case of a union, the type is the highest type\n     * of one of the types in the union.\n     */\n    final Map<Node, T> rootTypes = Maps.newHashMap();\n\n    Property(String name) {\n      this.name = name;\n    }\n\n    /** Returns the types on which this field is referenced. */\n    UnionFind<T> getTypes() {\n      if (types == null) {\n        types = new StandardUnionFind<T>();\n      }\n      return types;\n    }\n\n    /**\n     * Record that this property is referenced from this type.\n     * @return true if the type was recorded for this property, else false,\n     *     which would happen if the type was invalidating.\n     */\n    boolean addType(T type, T top, T relatedType) {", "right_context": "}\n\n    /** Records the given type as one to skip for this property. */\n    void addTypeToSkip(T type) {\n      for (T skipType : typeSystem.getTypesToSkipForType(type)) {\n        typesToSkip.add(skipType);\n        getTypes().union(skipType, type);\n      }\n    }\n\n    /** Invalidates any types related to invalid types. */\n    void expandTypesToSkip() {\n      // If we are not going to rename any properties, then we do not need to\n      // update the list of invalid types, as they are all invalid.\n      if (shouldRename()) {\n        int count = 0;\n        while (true) {\n          // It should usually only take one time through this do-while.\n          checkState(++count < 10, \"Stuck in loop expanding types to skip.\");\n\n          // Make sure that the representative type for each type to skip is\n          // marked as being skipped.\n          Set<T> rootTypesToSkip = Sets.newHashSet();\n          for (T subType : typesToSkip) {\n            rootTypesToSkip.add(types.find(subType));\n          }\n          typesToSkip.addAll(rootTypesToSkip);\n\n          Set<T> newTypesToSkip = Sets.newHashSet();\n          Set<T> allTypes = types.elements();\n          int originalTypesSize = allTypes.size();\n          for (T subType : allTypes) {\n            if (!typesToSkip.contains(subType)\n                && typesToSkip.contains(types.find(subType))) {\n              newTypesToSkip.add(subType);\n            }\n          }\n\n          for (T newType : newTypesToSkip) {\n            addTypeToSkip(newType);\n          }\n\n          // If there were not any new types added, we are done here.\n          if (types.elements().size() == originalTypesSize) {\n            break;\n          }\n        }\n      }\n    }\n\n    /** Returns true if any instance of this property should be renamed. */\n    boolean shouldRename() {\n      return !skipRenaming && types != null\n          && types.allEquivalenceClasses().size() > 1;\n    }\n\n    /**\n     * Returns true if this property should be renamed on this type.\n     * expandTypesToSkip() should be called before this, if anything has been\n     * added to the typesToSkip list.\n     */\n    boolean shouldRename(T type) {\n      return !skipRenaming && !typesToSkip.contains(type);\n    }\n\n    /**\n     * Invalidates a field from renaming.  Used for field references on an\n     * object with unknown type.\n     */\n    boolean invalidate() {\n      boolean changed = !skipRenaming;\n      skipRenaming = true;\n      types = null;\n      return changed;\n    }\n\n    /**\n     * Schedule the node to potentially be renamed.\n     * @param node the node to rename\n     * @param type the highest type in the prototype chain for which the\n     *     property is defined\n     * @return True if type was accepted without invalidation or if the property\n     *     was already invalidated.  False if this property was invalidated this\n     *     time.\n     */\n    boolean scheduleRenaming(Node node, T type) {\n      if (!skipRenaming) {\n        if (typeSystem.isInvalidatingType(type)) {\n          invalidate();\n          return false;\n        }\n        renameNodes.add(node);\n        rootTypes.put(node, type);\n      }\n      return true;\n    }\n  }\n\n}", "class_name": "DisambiguateProperties", "return_type": "boolean", "parameters": [{"type": "T", "name": "type"}, {"type": "T", "name": "top"}, {"type": "T", "name": "relatedType"}]}}
{"prompt": "class JsMessage {\n\n  @Override\n  public boolean equals(Object o) {\n    if (o == this) {\n      return true;\n    }\n    if (!(o instanceof JsMessage)) {\n      return false;\n    }\n    JsMessage m = (JsMessage) o;\n    return id.equals(m.id) &&\n           key.equals(m.key) &&\n           isAnonymous == m.isAnonymous &&\n           parts.equals(m.parts) &&\n           (meaning == null ? m.meaning == null : meaning.equals(m.meaning)) &&\n           placeholders.equals(m.placeholders) &&\n           (desc == null ? m.desc == null : desc.equals(m.desc)) &&\n           (sourceName == null\n               ? m.sourceName == null\n               : sourceName.equals(m.sourceName)) &&\n           hidden == m.hidden;\n  }\n\n  @Override\n  public int hashCode() {\n    int hash = key.hashCode();\n    hash = 31 * hash + (isAnonymous ? 1 : 0);\n    hash = 31 * hash + id.hashCode();\n    hash = 31 * hash + parts.hashCode();\n    hash = 31 * hash + (desc != null ? desc.hashCode() : 0);\n    hash = 31 * hash + (hidden ? 1 : 0);\n    hash = 31 * hash + (sourceName != null ? sourceName.hashCode() : 0);\n    return hash;\n  }\n\n  /** A reference to a placeholder in a translatable message. */\n  public static class PlaceholderReference implements CharSequence {\n\n    private final String name;\n\n    PlaceholderReference(String name) {\n      this.name = name;\n    }\n\n    @Override\n    public int length() {\n      return name.length();\n    }\n\n    @Override\n    public char charAt(int index) {\n      return name.charAt(index);\n    }\n\n    @Override\n    public CharSequence subSequence(int start, int end) {\n      return name.subSequence(start, end);\n    }\n\n    public String getName() {\n      return name;\n    }\n\n    @Override\n    public String toString() {\n      return String.format(MESSAGE_REPRESENTATION_FORMAT, name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      return o == this ||\n             o instanceof PlaceholderReference &&\n             name.equals(((PlaceholderReference) o).name);\n    }\n\n    @Override\n    public int hashCode() {\n      return 31 * name.hashCode();\n    }\n  }\n\n  /**\n   * Contains functionality for creating JS messages. Generates authoritative\n   * keys and fingerprints for a message that must stay constant over time.\n   *\n   * This implementation correctly processes unnamed messages and creates a key\n   * for them that looks like MSG_<fingerprint value>.\n   */\n  public static class Builder {\n\n    private static final Pattern MSG_EXTERNAL_PATTERN =\n        Pattern.compile(\"MSG_EXTERNAL_(\\\\d+)\");\n\n    /**\n     * @return an external message id or null if this is not an\n     * external message identifier\n     */\n    private static String getExternalMessageId(String identifier) {\n      Matcher m = MSG_EXTERNAL_PATTERN.matcher(identifier);\n      return m.matches() ? m.group(1) : null;\n    }\n\n    private String key;\n\n    private String meaning;\n\n    private String desc;\n    private boolean hidden;\n\n    private List<CharSequence> parts = Lists.newLinkedList();\n    private Set<String> placeholders = Sets.newHashSet();\n\n    private String sourceName;\n\n    public Builder() {\n      this(null);\n    }\n\n    /** Creates an instance. */\n    public Builder(String key) {\n      this.key = key;\n    }\n\n    /** Gets the message's key (e.g. {@code \"MSG_HELLO\"}). */\n    public String getKey() {\n      return key;\n    }\n\n    /**\n     * @param key a key that should uniquely identify this message; typically\n     *     it is the message's name (e.g. {@code \"MSG_HELLO\"}).\n     */\n    public Builder setKey(String key) {\n      this.key = key;\n      return this;\n    }\n\n    /**\n     * @param sourceName The message's sourceName.\n     */\n    public Builder setSourceName(String sourceName) {\n      this.sourceName = sourceName;\n      return this;\n    }\n\n    /**\n     * Appends a placeholder reference to the message\n     */\n    public Builder appendPlaceholderReference(String name) {\n      Preconditions.checkNotNull(name, \"Placeholder name could not be null\");\n      parts.add(new PlaceholderReference(name));\n      placeholders.add(name);\n      return this;\n    }\n\n    /** Appends a translatable string literal to the message. */\n    public Builder appendStringPart(String part) {\n      Preconditions.checkNotNull(part,\n          \"String part of the message could not be null\");\n      parts.add(part);\n      return this;\n    }\n\n    /** Returns the message registered placeholders */\n    public Set<String> getPlaceholders() {\n      return placeholders;\n    }\n\n    /** Sets the description of the message, which helps translators. */\n    public Builder setDesc(String desc) {\n      this.desc = desc;\n      return this;\n    }\n\n    /**\n     * Sets the programmer-specified meaning of this message, which\n     * forces this message to translate differently.\n     */\n    public Builder setMeaning(String meaning) {\n      this.meaning = meaning;\n      return this;\n    }\n\n    /** Sets whether the message should be hidden from volunteer translators. */\n    public Builder setIsHidden(boolean hidden) {\n      this.hidden = hidden;\n      return this;\n    }\n\n    /** Gets whether at least one part has been appended. */\n    public boolean hasParts() {\n      return !parts.isEmpty();\n    }\n\n    public List<CharSequence> getParts() {\n      return parts;\n    }\n\n    public JsMessage build() {\n      return build(null);\n    }\n\n    public JsMessage build(IdGenerator idGenerator) {\n      boolean isAnonymous = false;\n      boolean isExternal = false;\n      String id = null;\n\n      if (getKey() == null) {\n        // Before constructing a message we need to change unnamed messages name\n        // to the unique one.\n        key = JsMessageVisitor.MSG_PREFIX + fingerprint(getParts());\n        isAnonymous = true;\n      }\n\n      if (!isAnonymous) {\n        String externalId = getExternalMessageId(key);\n        if (externalId != null) {\n          isExternal = true;\n          id = externalId;\n        }\n      }\n\n      if (!isExternal) {\n        String defactoMeaning = meaning != null ? meaning : key;\n        id = idGenerator == null ? defactoMeaning :\n            idGenerator.generateId(defactoMeaning, parts);\n      }\n\n      return new JsMessage(sourceName, key, isAnonymous, isExternal, id, parts,\n          placeholders, desc, hidden, meaning);\n    }\n\n    /**\n     * Generates a compact uppercase alphanumeric text representation of a\n     * 63-bit fingerprint of the content parts of a message.\n     */\n    private static String fingerprint(List<CharSequence> messageParts) {", "metadata": {"defects4j_task_id": "bcf55eed350d82323b2f32ce7169051a815355652b6913ee58abae501fc7cb54", "task_id": "google_closure-compiler/158", "ground_truth": "\n      StringBuilder sb = new StringBuilder();\n      for (CharSequence part : messageParts) {\n        if (part instanceof JsMessage.PlaceholderReference) {\n          sb.append(part.toString());\n        } else {\n          sb.append(part);\n        }\n      }\n      long nonnegativeHash = Long.MAX_VALUE & Hash.hash64(sb.toString());\n      return Long.toString(nonnegativeHash, 36).toUpperCase();\n    ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "JsMessage.java"], "context_start_lineno": 0, "function_name": "fingerprint", "left_context": "class JsMessage {\n\n  @Override\n  public boolean equals(Object o) {\n    if (o == this) {\n      return true;\n    }\n    if (!(o instanceof JsMessage)) {\n      return false;\n    }\n    JsMessage m = (JsMessage) o;\n    return id.equals(m.id) &&\n           key.equals(m.key) &&\n           isAnonymous == m.isAnonymous &&\n           parts.equals(m.parts) &&\n           (meaning == null ? m.meaning == null : meaning.equals(m.meaning)) &&\n           placeholders.equals(m.placeholders) &&\n           (desc == null ? m.desc == null : desc.equals(m.desc)) &&\n           (sourceName == null\n               ? m.sourceName == null\n               : sourceName.equals(m.sourceName)) &&\n           hidden == m.hidden;\n  }\n\n  @Override\n  public int hashCode() {\n    int hash = key.hashCode();\n    hash = 31 * hash + (isAnonymous ? 1 : 0);\n    hash = 31 * hash + id.hashCode();\n    hash = 31 * hash + parts.hashCode();\n    hash = 31 * hash + (desc != null ? desc.hashCode() : 0);\n    hash = 31 * hash + (hidden ? 1 : 0);\n    hash = 31 * hash + (sourceName != null ? sourceName.hashCode() : 0);\n    return hash;\n  }\n\n  /** A reference to a placeholder in a translatable message. */\n  public static class PlaceholderReference implements CharSequence {\n\n    private final String name;\n\n    PlaceholderReference(String name) {\n      this.name = name;\n    }\n\n    @Override\n    public int length() {\n      return name.length();\n    }\n\n    @Override\n    public char charAt(int index) {\n      return name.charAt(index);\n    }\n\n    @Override\n    public CharSequence subSequence(int start, int end) {\n      return name.subSequence(start, end);\n    }\n\n    public String getName() {\n      return name;\n    }\n\n    @Override\n    public String toString() {\n      return String.format(MESSAGE_REPRESENTATION_FORMAT, name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      return o == this ||\n             o instanceof PlaceholderReference &&\n             name.equals(((PlaceholderReference) o).name);\n    }\n\n    @Override\n    public int hashCode() {\n      return 31 * name.hashCode();\n    }\n  }\n\n  /**\n   * Contains functionality for creating JS messages. Generates authoritative\n   * keys and fingerprints for a message that must stay constant over time.\n   *\n   * This implementation correctly processes unnamed messages and creates a key\n   * for them that looks like MSG_<fingerprint value>.\n   */\n  public static class Builder {\n\n    private static final Pattern MSG_EXTERNAL_PATTERN =\n        Pattern.compile(\"MSG_EXTERNAL_(\\\\d+)\");\n\n    /**\n     * @return an external message id or null if this is not an\n     * external message identifier\n     */\n    private static String getExternalMessageId(String identifier) {\n      Matcher m = MSG_EXTERNAL_PATTERN.matcher(identifier);\n      return m.matches() ? m.group(1) : null;\n    }\n\n    private String key;\n\n    private String meaning;\n\n    private String desc;\n    private boolean hidden;\n\n    private List<CharSequence> parts = Lists.newLinkedList();\n    private Set<String> placeholders = Sets.newHashSet();\n\n    private String sourceName;\n\n    public Builder() {\n      this(null);\n    }\n\n    /** Creates an instance. */\n    public Builder(String key) {\n      this.key = key;\n    }\n\n    /** Gets the message's key (e.g. {@code \"MSG_HELLO\"}). */\n    public String getKey() {\n      return key;\n    }\n\n    /**\n     * @param key a key that should uniquely identify this message; typically\n     *     it is the message's name (e.g. {@code \"MSG_HELLO\"}).\n     */\n    public Builder setKey(String key) {\n      this.key = key;\n      return this;\n    }\n\n    /**\n     * @param sourceName The message's sourceName.\n     */\n    public Builder setSourceName(String sourceName) {\n      this.sourceName = sourceName;\n      return this;\n    }\n\n    /**\n     * Appends a placeholder reference to the message\n     */\n    public Builder appendPlaceholderReference(String name) {\n      Preconditions.checkNotNull(name, \"Placeholder name could not be null\");\n      parts.add(new PlaceholderReference(name));\n      placeholders.add(name);\n      return this;\n    }\n\n    /** Appends a translatable string literal to the message. */\n    public Builder appendStringPart(String part) {\n      Preconditions.checkNotNull(part,\n          \"String part of the message could not be null\");\n      parts.add(part);\n      return this;\n    }\n\n    /** Returns the message registered placeholders */\n    public Set<String> getPlaceholders() {\n      return placeholders;\n    }\n\n    /** Sets the description of the message, which helps translators. */\n    public Builder setDesc(String desc) {\n      this.desc = desc;\n      return this;\n    }\n\n    /**\n     * Sets the programmer-specified meaning of this message, which\n     * forces this message to translate differently.\n     */\n    public Builder setMeaning(String meaning) {\n      this.meaning = meaning;\n      return this;\n    }\n\n    /** Sets whether the message should be hidden from volunteer translators. */\n    public Builder setIsHidden(boolean hidden) {\n      this.hidden = hidden;\n      return this;\n    }\n\n    /** Gets whether at least one part has been appended. */\n    public boolean hasParts() {\n      return !parts.isEmpty();\n    }\n\n    public List<CharSequence> getParts() {\n      return parts;\n    }\n\n    public JsMessage build() {\n      return build(null);\n    }\n\n    public JsMessage build(IdGenerator idGenerator) {\n      boolean isAnonymous = false;\n      boolean isExternal = false;\n      String id = null;\n\n      if (getKey() == null) {\n        // Before constructing a message we need to change unnamed messages name\n        // to the unique one.\n        key = JsMessageVisitor.MSG_PREFIX + fingerprint(getParts());\n        isAnonymous = true;\n      }\n\n      if (!isAnonymous) {\n        String externalId = getExternalMessageId(key);\n        if (externalId != null) {\n          isExternal = true;\n          id = externalId;\n        }\n      }\n\n      if (!isExternal) {\n        String defactoMeaning = meaning != null ? meaning : key;\n        id = idGenerator == null ? defactoMeaning :\n            idGenerator.generateId(defactoMeaning, parts);\n      }\n\n      return new JsMessage(sourceName, key, isAnonymous, isExternal, id, parts,\n          placeholders, desc, hidden, meaning);\n    }\n\n    /**\n     * Generates a compact uppercase alphanumeric text representation of a\n     * 63-bit fingerprint of the content parts of a message.\n     */\n    private static String fingerprint(List<CharSequence> messageParts) {", "right_context": "}\n  }\n\n}", "class_name": "JsMessage", "return_type": "String", "parameters": [{"type": "List<CharSequence>", "name": "messageParts"}]}}
{"prompt": "class NodeUtil {\n\n  /**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      result.setJSDocInfo(info);\n    } else if (value != null) {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      result.getFirstChild().setJSDocInfo(info);\n    } else {\n      result = IR.exprResult(nameNode);\n      result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n  }\n\n  /**\n   * Creates a node representing a qualified name, copying over the source\n   * location information from the basis node and assigning the given original\n   * name to the node.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @param basisNode The node that represents the name as currently found in\n   *     the AST.\n   * @param originalName The original name of the item being represented by the\n   *     NAME node. Used for debugging information.\n   *\n   * @return A NAME or GETPROP node\n   */\n  static Node newQualifiedNameNode(\n      CodingConvention convention, String name, Node basisNode,\n      String originalName) {\n    Node node = newQualifiedNameNode(convention, name);\n    setDebugInformation(node, basisNode, originalName);\n    return node;\n  }\n\n  /**\n   * Gets the root node of a qualified name. Must be either NAME or THIS.\n   */\n  static Node getRootOfQualifiedName(Node qName) {\n    for (Node current = qName; true;\n         current = current.getFirstChild()) {\n      if (current.isName() || current.isThis()) {\n        return current;\n      }\n      Preconditions.checkState(current.isGetProp());\n    }\n  }\n\n  /**\n   * Sets the debug information (source file info and original name)\n   * on the given node.\n   *\n   * @param node The node on which to set the debug information.\n   * @param basisNode The basis node from which to copy the source file info.\n   * @param originalName The original name of the node.\n   */\n  static void setDebugInformation(Node node, Node basisNode,\n                                  String originalName) {\n    node.copyInformationFromForTree(basisNode);\n    node.putProp(Node.ORIGINALNAME_PROP, originalName);\n  }\n\n  private static Node newName(\n      CodingConvention convention, String name) {\n    Node nameNode = IR.name(name);\n    if (convention.isConstant(name)) {\n      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    return nameNode;\n  }\n\n  /**\n   * Creates a new node representing an *existing* name, copying over the source\n   * location information from the basis node.\n   *\n   * @param name The name for the new NAME node.\n   * @param srcref The node that represents the name as currently found in\n   *     the AST.\n   *\n   * @return The node created.\n   */\n  static Node newName(CodingConvention convention, String name, Node srcref) {\n    return newName(convention, name).srcref(srcref);\n  }\n\n  /**\n   * Creates a new node representing an *existing* name, copying over the source\n   * location information from the basis node and assigning the given original\n   * name to the node.\n   *\n   * @param name The name for the new NAME node.\n   * @param basisNode The node that represents the name as currently found in\n   *     the AST.\n   * @param originalName The original name of the item being represented by the\n   *     NAME node. Used for debugging information.\n   *\n   * @return The node created.\n   */\n  static Node newName(\n      CodingConvention convention, String name,\n      Node basisNode, String originalName) {\n    Node nameNode = newName(convention, name, basisNode);\n    nameNode.putProp(Node.ORIGINALNAME_PROP, originalName);\n    return nameNode;\n  }\n\n  /** Test if all characters in the string are in the Basic Latin (aka ASCII)\n   * character set - that they have UTF-16 values equal to or below 0x7f.\n   * This check can find which identifiers with Unicode characters need to be\n   * escaped in order to allow resulting files to be processed by non-Unicode\n   * aware UNIX tools and editors.\n   * *\n   * See http://en.wikipedia.org/wiki/Latin_characters_in_Unicode\n   * for more on Basic Latin.\n   *\n   * @param s The string to be checked for ASCII-goodness.\n   *\n   * @return True if all characters in the string are in Basic Latin set.\n   */\n  static boolean isLatin(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c > LARGEST_BASIC_LATIN) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the given name is a valid variable name.\n   */\n  static boolean isValidSimpleName(String name) {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }\n\n  /**\n   * Determines whether the given name is a valid qualified name.\n   */\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  public static boolean isValidQualifiedName(String name) {", "metadata": {"defects4j_task_id": "697c7f3fa926be353032e874ad2b442346a9c0a572c4d0e0bbfa060c326b1cc1", "task_id": "google_closure-compiler/88", "ground_truth": "\n    if (name.endsWith(\".\") || name.startsWith(\".\")) {\n      return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "NodeUtil.java"], "context_start_lineno": 0, "function_name": "isValidQualifiedName", "left_context": "class NodeUtil {\n\n  /**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      result.setJSDocInfo(info);\n    } else if (value != null) {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      result.getFirstChild().setJSDocInfo(info);\n    } else {\n      result = IR.exprResult(nameNode);\n      result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n  }\n\n  /**\n   * Creates a node representing a qualified name, copying over the source\n   * location information from the basis node and assigning the given original\n   * name to the node.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @param basisNode The node that represents the name as currently found in\n   *     the AST.\n   * @param originalName The original name of the item being represented by the\n   *     NAME node. Used for debugging information.\n   *\n   * @return A NAME or GETPROP node\n   */\n  static Node newQualifiedNameNode(\n      CodingConvention convention, String name, Node basisNode,\n      String originalName) {\n    Node node = newQualifiedNameNode(convention, name);\n    setDebugInformation(node, basisNode, originalName);\n    return node;\n  }\n\n  /**\n   * Gets the root node of a qualified name. Must be either NAME or THIS.\n   */\n  static Node getRootOfQualifiedName(Node qName) {\n    for (Node current = qName; true;\n         current = current.getFirstChild()) {\n      if (current.isName() || current.isThis()) {\n        return current;\n      }\n      Preconditions.checkState(current.isGetProp());\n    }\n  }\n\n  /**\n   * Sets the debug information (source file info and original name)\n   * on the given node.\n   *\n   * @param node The node on which to set the debug information.\n   * @param basisNode The basis node from which to copy the source file info.\n   * @param originalName The original name of the node.\n   */\n  static void setDebugInformation(Node node, Node basisNode,\n                                  String originalName) {\n    node.copyInformationFromForTree(basisNode);\n    node.putProp(Node.ORIGINALNAME_PROP, originalName);\n  }\n\n  private static Node newName(\n      CodingConvention convention, String name) {\n    Node nameNode = IR.name(name);\n    if (convention.isConstant(name)) {\n      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    return nameNode;\n  }\n\n  /**\n   * Creates a new node representing an *existing* name, copying over the source\n   * location information from the basis node.\n   *\n   * @param name The name for the new NAME node.\n   * @param srcref The node that represents the name as currently found in\n   *     the AST.\n   *\n   * @return The node created.\n   */\n  static Node newName(CodingConvention convention, String name, Node srcref) {\n    return newName(convention, name).srcref(srcref);\n  }\n\n  /**\n   * Creates a new node representing an *existing* name, copying over the source\n   * location information from the basis node and assigning the given original\n   * name to the node.\n   *\n   * @param name The name for the new NAME node.\n   * @param basisNode The node that represents the name as currently found in\n   *     the AST.\n   * @param originalName The original name of the item being represented by the\n   *     NAME node. Used for debugging information.\n   *\n   * @return The node created.\n   */\n  static Node newName(\n      CodingConvention convention, String name,\n      Node basisNode, String originalName) {\n    Node nameNode = newName(convention, name, basisNode);\n    nameNode.putProp(Node.ORIGINALNAME_PROP, originalName);\n    return nameNode;\n  }\n\n  /** Test if all characters in the string are in the Basic Latin (aka ASCII)\n   * character set - that they have UTF-16 values equal to or below 0x7f.\n   * This check can find which identifiers with Unicode characters need to be\n   * escaped in order to allow resulting files to be processed by non-Unicode\n   * aware UNIX tools and editors.\n   * *\n   * See http://en.wikipedia.org/wiki/Latin_characters_in_Unicode\n   * for more on Basic Latin.\n   *\n   * @param s The string to be checked for ASCII-goodness.\n   *\n   * @return True if all characters in the string are in Basic Latin set.\n   */\n  static boolean isLatin(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c > LARGEST_BASIC_LATIN) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the given name is a valid variable name.\n   */\n  static boolean isValidSimpleName(String name) {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }\n\n  /**\n   * Determines whether the given name is a valid qualified name.\n   */\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  public static boolean isValidQualifiedName(String name) {", "right_context": "}\n}", "class_name": "NodeUtil", "return_type": "boolean", "parameters": [{"type": "String", "name": "name"}]}}
{"prompt": "class MaybeReachingVariableUse extends\n    DataFlowAnalysis<Node, MaybeReachingVariableUse.ReachingUses> {\n\n  // The scope of the function that we are analyzing.\n  /**\n   * The join is a simple union because of the \"may be\" nature of the analysis.\n   *\n   * Consider: A = 1; if (x) { A = 2 }; alert(A);\n   *\n   * The read of A \"may be\" exposed to A = 1 in the beginning.\n   */\n  private static class ReachingUsesJoinOp implements JoinOp<ReachingUses> {\n    @Override\n    public ReachingUses apply(List<ReachingUses> from) {\n      ReachingUses result = new ReachingUses();\n      for (ReachingUses uses : from) {\n        result.mayUseMap.putAll(uses.mayUseMap);\n      }\n      return result;\n    }\n  }\n\n  @Override\n  boolean isForward() {\n    return false;\n  }\n\n  @Override\n  ReachingUses createEntryLattice() {\n    return new ReachingUses();\n  }\n\n  @Override\n  ReachingUses createInitialEstimateLattice() {\n    return new ReachingUses();\n  }\n\n  @Override\n  ReachingUses flowThrough(Node n, ReachingUses input) {\n    ReachingUses output = new ReachingUses(input);\n\n    // If there's an ON_EX edge, this cfgNode may or may not get executed.\n    // We can express this concisely by just pretending this happens in\n    // a conditional.\n    boolean conditional = hasExceptionHandler(n);\n    computeMayUse(n, n, output, conditional);\n\n    return output;\n  }\n\n  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private void computeMayUse(\n      Node n, Node cfgNode, ReachingUses output, boolean conditional) {\n    switch (n.getType()) {\n\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.NAME:\n        addToUseIfLocal(n.getString(), cfgNode, output);\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeMayUse(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeMayUse(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (lhs.isVar()) {\n            lhs = lhs.getLastChild(); // for(var x in y) {...}\n          }\n          if (lhs.isName() && !conditional) {\n            removeFromUseIfLocal(lhs.getString(), output);\n          }\n          computeMayUse(rhs, cfgNode, output, conditional);\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.HOOK:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild().getNext(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.VAR:\n        Node varName = n.getFirstChild();\n        Preconditions.checkState(n.hasChildren(), \"AST should be normalized\");\n\n        if (varName.hasChildren()) {\n          computeMayUse(varName.getFirstChild(), cfgNode, output, conditional);\n          if (!conditional) {\n            removeFromUseIfLocal(varName.getString(), output);\n          }\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {\n          Node name = n.getFirstChild();\n          if (!conditional) {\n            removeFromUseIfLocal(name.getString(), output);\n          }\n\n          // In case of a += \"Hello\". There is a read of a.\n          if (!n.isAssign()) {\n            addToUseIfLocal(name.getString(), cfgNode, output);\n          }\n\n          computeMayUse(name.getNext(), cfgNode, output, conditional);\n        } else {\n          /*\n           * We want to traverse in reverse order because we want the LAST\n           * definition in the sub-tree....\n           * But we have no better way to traverse in reverse other :'(\n           */\n          for (Node c = n.getLastChild(); c != null; c = n.getChildBefore(c)) {\n            computeMayUse(c, cfgNode, output, conditional);\n          }\n        }\n    }\n  }\n\n  /**\n   * Sets the variable for the given name to the node value in the upward\n   * exposed lattice. Do nothing if the variable name is one of the escaped\n   * variable.\n   */\n  private void addToUseIfLocal(String name, Node node, ReachingUses use) {\n    Var var = jsScope.getVar(name);\n    if (var == null || var.scope != jsScope) {\n      return;\n    }\n    if (!escaped.contains(var)) {\n      use.mayUseMap.put(var, node);\n    }\n  }\n\n  /**\n   * Removes the variable for the given name from the node value in the upward\n   * exposed lattice. Do nothing if the variable name is one of the escaped\n   * variable.\n   */\n  private void removeFromUseIfLocal(String name, ReachingUses use) {\n    Var var = jsScope.getVar(name);\n    if (var == null || var.scope != jsScope) {\n      return;\n    }\n    if (!escaped.contains(var)) {\n      use.mayUseMap.removeAll(var);\n    }\n  }\n\n  /**\n   * Gets a list of nodes that may be using the value assigned to {@code name}\n   * in {@code defNode}. {@code defNode} must be one of the control flow graph\n   * nodes.\n   *\n   * @param name name of the variable. It can only be names of local variable\n   *     that are not function parameters, escaped variables or variables\n   *     declared in catch.\n   * @param defNode The list of upward exposed use for the variable.\n   */\n  Collection<Node> getUses(String name, Node defNode) {", "metadata": {"defects4j_task_id": "7ccca7eee38f94ebf5e3e4539e406280ccd5bb72b14e08e3f840330118479adf", "task_id": "google_closure-compiler/103", "ground_truth": "\n    GraphNode<Node, Branch> n = getCfg().getNode(defNode);\n    Preconditions.checkNotNull(n);\n    FlowState<ReachingUses> state = n.getAnnotation();\n    return state.getOut().mayUseMap.get(jsScope.getVar(name));\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "MaybeReachingVariableUse.java"], "context_start_lineno": 0, "function_name": "getUses", "left_context": "class MaybeReachingVariableUse extends\n    DataFlowAnalysis<Node, MaybeReachingVariableUse.ReachingUses> {\n\n  // The scope of the function that we are analyzing.\n  /**\n   * The join is a simple union because of the \"may be\" nature of the analysis.\n   *\n   * Consider: A = 1; if (x) { A = 2 }; alert(A);\n   *\n   * The read of A \"may be\" exposed to A = 1 in the beginning.\n   */\n  private static class ReachingUsesJoinOp implements JoinOp<ReachingUses> {\n    @Override\n    public ReachingUses apply(List<ReachingUses> from) {\n      ReachingUses result = new ReachingUses();\n      for (ReachingUses uses : from) {\n        result.mayUseMap.putAll(uses.mayUseMap);\n      }\n      return result;\n    }\n  }\n\n  @Override\n  boolean isForward() {\n    return false;\n  }\n\n  @Override\n  ReachingUses createEntryLattice() {\n    return new ReachingUses();\n  }\n\n  @Override\n  ReachingUses createInitialEstimateLattice() {\n    return new ReachingUses();\n  }\n\n  @Override\n  ReachingUses flowThrough(Node n, ReachingUses input) {\n    ReachingUses output = new ReachingUses(input);\n\n    // If there's an ON_EX edge, this cfgNode may or may not get executed.\n    // We can express this concisely by just pretending this happens in\n    // a conditional.\n    boolean conditional = hasExceptionHandler(n);\n    computeMayUse(n, n, output, conditional);\n\n    return output;\n  }\n\n  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private void computeMayUse(\n      Node n, Node cfgNode, ReachingUses output, boolean conditional) {\n    switch (n.getType()) {\n\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.NAME:\n        addToUseIfLocal(n.getString(), cfgNode, output);\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeMayUse(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeMayUse(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (lhs.isVar()) {\n            lhs = lhs.getLastChild(); // for(var x in y) {...}\n          }\n          if (lhs.isName() && !conditional) {\n            removeFromUseIfLocal(lhs.getString(), output);\n          }\n          computeMayUse(rhs, cfgNode, output, conditional);\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.HOOK:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild().getNext(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.VAR:\n        Node varName = n.getFirstChild();\n        Preconditions.checkState(n.hasChildren(), \"AST should be normalized\");\n\n        if (varName.hasChildren()) {\n          computeMayUse(varName.getFirstChild(), cfgNode, output, conditional);\n          if (!conditional) {\n            removeFromUseIfLocal(varName.getString(), output);\n          }\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {\n          Node name = n.getFirstChild();\n          if (!conditional) {\n            removeFromUseIfLocal(name.getString(), output);\n          }\n\n          // In case of a += \"Hello\". There is a read of a.\n          if (!n.isAssign()) {\n            addToUseIfLocal(name.getString(), cfgNode, output);\n          }\n\n          computeMayUse(name.getNext(), cfgNode, output, conditional);\n        } else {\n          /*\n           * We want to traverse in reverse order because we want the LAST\n           * definition in the sub-tree....\n           * But we have no better way to traverse in reverse other :'(\n           */\n          for (Node c = n.getLastChild(); c != null; c = n.getChildBefore(c)) {\n            computeMayUse(c, cfgNode, output, conditional);\n          }\n        }\n    }\n  }\n\n  /**\n   * Sets the variable for the given name to the node value in the upward\n   * exposed lattice. Do nothing if the variable name is one of the escaped\n   * variable.\n   */\n  private void addToUseIfLocal(String name, Node node, ReachingUses use) {\n    Var var = jsScope.getVar(name);\n    if (var == null || var.scope != jsScope) {\n      return;\n    }\n    if (!escaped.contains(var)) {\n      use.mayUseMap.put(var, node);\n    }\n  }\n\n  /**\n   * Removes the variable for the given name from the node value in the upward\n   * exposed lattice. Do nothing if the variable name is one of the escaped\n   * variable.\n   */\n  private void removeFromUseIfLocal(String name, ReachingUses use) {\n    Var var = jsScope.getVar(name);\n    if (var == null || var.scope != jsScope) {\n      return;\n    }\n    if (!escaped.contains(var)) {\n      use.mayUseMap.removeAll(var);\n    }\n  }\n\n  /**\n   * Gets a list of nodes that may be using the value assigned to {@code name}\n   * in {@code defNode}. {@code defNode} must be one of the control flow graph\n   * nodes.\n   *\n   * @param name name of the variable. It can only be names of local variable\n   *     that are not function parameters, escaped variables or variables\n   *     declared in catch.\n   * @param defNode The list of upward exposed use for the variable.\n   */\n  Collection<Node> getUses(String name, Node defNode) {", "right_context": "}}\n}", "class_name": "MaybeReachingVariableUse", "return_type": "Collection<Node>", "parameters": [{"type": "String", "name": "name"}, {"type": "Node", "name": "defNode"}]}}
{"prompt": "class FunctionRewriter implements CompilerPass {\n  private static final int SAVINGS_THRESHOLD = 16;\n\n  FunctionRewriter(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(),\n                                              new GetterReducer(),\n                                              new SetterReducer(),\n                                              new EmptyFunctionReducer(),\n                                              new IdentityReducer());\n\n    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n\n    // Accumulate possible reductions in the reduction multi-map.  They\n    // will be applied in the loop below.\n    NodeTraversal.traverse(compiler, root,\n                           new ReductionGatherer(reducers, reductionMap));\n\n    // Apply reductions iff they will provide some savings.\n    for (Reducer reducer : reducers) {\n      Collection<Reduction> reductions = reductionMap.get(reducer);\n      if (reductions.isEmpty()) {\n        continue;\n      }\n\n      Node helperCode = parseHelperCode(reducer);\n      if (helperCode == null) {\n        continue;\n      }\n\n      int helperCodeCost = InlineCostEstimator.getCost(helperCode);\n\n      // Estimate savings\n      int savings = 0;\n      for (Reduction reduction : reductions) {\n        savings += reduction.estimateSavings();\n      }\n\n      // Compare estimated savings against the helper cost.  Apply\n      // reductions if doing so will result in some savings.\n      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {\n        for (Reduction reduction : reductions) {\n          reduction.apply();\n        }\n\n        Node addingRoot = compiler.getNodeForCodeInsertion(null);\n        addingRoot.addChildrenToFront(helperCode);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  /**\n   * Parse helper code needed by a reducer.\n   *\n   * @return Helper code root.  If parse fails, return null.\n   */\n  public Node parseHelperCode(Reducer reducer) {\n    Node root = compiler.parseSyntheticCode(\n        reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n    return (root != null) ? root.removeFirstChild() : null;\n  }\n\n  private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n)\n        && !NodeUtil.isGetOrSetKey(n.getParent());\n  }\n\n  /**\n   * Information needed to apply a reduction.\n   */\n  private class Reduction {\n    private final Node parent;\n    private final Node oldChild;\n    private final Node newChild;\n\n    Reduction(Node parent, Node oldChild, Node newChild) {\n      this.parent = parent;\n      this.oldChild = oldChild;\n      this.newChild = newChild;\n    }\n\n    /**\n     * Apply the reduction by replacing the old child with the new child.\n     */\n    void apply() {\n      parent.replaceChild(oldChild, newChild);\n      compiler.reportCodeChange();\n    }\n\n    /**\n     * Estimate number of bytes saved by applying this reduction.\n     */\n    int estimateSavings() {\n      return InlineCostEstimator.getCost(oldChild) -\n          InlineCostEstimator.getCost(newChild);\n    }\n  }\n\n  /**\n   * Gathers a list of reductions to apply later by doing an in-order\n   * AST traversal.  If a suitable reduction is found, stop traversal\n   * in that branch.\n   */\n  private class ReductionGatherer implements Callback {\n    private final List<Reducer> reducers;\n    private final Multimap<Reducer, Reduction> reductions;\n\n    /**\n     * @param reducers List of reducers to apply during traversal.\n     * @param reductions Reducer -> Reduction multimap,\n     *                   populated during traversal.\n     */\n    ReductionGatherer(List<Reducer> reducers,\n                      Multimap<Reducer, Reduction> reductions) {\n      this.reducers = reducers;\n      this.reductions = reductions;\n    }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal raversal,\n                                  Node node,\n                                  Node parent) {\n      for (Reducer reducer : reducers) {\n        Node replacement = reducer.reduce(node);\n        if (replacement != node) {\n          reductions.put(reducer, new Reduction(parent, node, replacement));\n          return false;\n        }\n      }\n      return true;\n    }\n\n\n    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n    }\n  }\n\n  /**\n   * Interface implemented by the strength-reduction optimizers below.\n   */\n  abstract static class Reducer {\n    /**\n     * @return JS source for helper methods used by this reduction.\n     */\n    abstract String getHelperSource();\n\n    /**\n     * @return root of the reduced subtree if a reduction was applied;\n     *         otherwise returns the node argument.\n     */\n    abstract Node reduce(Node node);\n\n    /**\n     * Builds a method call based on the the given method name,\n     * argument and history.\n     *\n     * @param methodName Method to call.\n     * @param argumentNode Method argument.\n     */\n    protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref) {", "metadata": {"defects4j_task_id": "9131c0ff61c644e3faca3596b12c0c0c1840f645542ca00b20ca230f3b4fcd8f", "task_id": "google_closure-compiler/118", "ground_truth": "\n      Node call = IR.call(IR.name(methodName)).srcref(srcref);\n      call.putBooleanProp(Node.FREE_CALL, true);\n      if (argumentNode != null) {\n        call.addChildToBack(argumentNode.cloneTree());\n      }\n      return call;\n    ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "FunctionRewriter.java"], "context_start_lineno": 0, "function_name": "buildCallNode", "left_context": "class FunctionRewriter implements CompilerPass {\n  private static final int SAVINGS_THRESHOLD = 16;\n\n  FunctionRewriter(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(),\n                                              new GetterReducer(),\n                                              new SetterReducer(),\n                                              new EmptyFunctionReducer(),\n                                              new IdentityReducer());\n\n    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n\n    // Accumulate possible reductions in the reduction multi-map.  They\n    // will be applied in the loop below.\n    NodeTraversal.traverse(compiler, root,\n                           new ReductionGatherer(reducers, reductionMap));\n\n    // Apply reductions iff they will provide some savings.\n    for (Reducer reducer : reducers) {\n      Collection<Reduction> reductions = reductionMap.get(reducer);\n      if (reductions.isEmpty()) {\n        continue;\n      }\n\n      Node helperCode = parseHelperCode(reducer);\n      if (helperCode == null) {\n        continue;\n      }\n\n      int helperCodeCost = InlineCostEstimator.getCost(helperCode);\n\n      // Estimate savings\n      int savings = 0;\n      for (Reduction reduction : reductions) {\n        savings += reduction.estimateSavings();\n      }\n\n      // Compare estimated savings against the helper cost.  Apply\n      // reductions if doing so will result in some savings.\n      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {\n        for (Reduction reduction : reductions) {\n          reduction.apply();\n        }\n\n        Node addingRoot = compiler.getNodeForCodeInsertion(null);\n        addingRoot.addChildrenToFront(helperCode);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  /**\n   * Parse helper code needed by a reducer.\n   *\n   * @return Helper code root.  If parse fails, return null.\n   */\n  public Node parseHelperCode(Reducer reducer) {\n    Node root = compiler.parseSyntheticCode(\n        reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n    return (root != null) ? root.removeFirstChild() : null;\n  }\n\n  private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n)\n        && !NodeUtil.isGetOrSetKey(n.getParent());\n  }\n\n  /**\n   * Information needed to apply a reduction.\n   */\n  private class Reduction {\n    private final Node parent;\n    private final Node oldChild;\n    private final Node newChild;\n\n    Reduction(Node parent, Node oldChild, Node newChild) {\n      this.parent = parent;\n      this.oldChild = oldChild;\n      this.newChild = newChild;\n    }\n\n    /**\n     * Apply the reduction by replacing the old child with the new child.\n     */\n    void apply() {\n      parent.replaceChild(oldChild, newChild);\n      compiler.reportCodeChange();\n    }\n\n    /**\n     * Estimate number of bytes saved by applying this reduction.\n     */\n    int estimateSavings() {\n      return InlineCostEstimator.getCost(oldChild) -\n          InlineCostEstimator.getCost(newChild);\n    }\n  }\n\n  /**\n   * Gathers a list of reductions to apply later by doing an in-order\n   * AST traversal.  If a suitable reduction is found, stop traversal\n   * in that branch.\n   */\n  private class ReductionGatherer implements Callback {\n    private final List<Reducer> reducers;\n    private final Multimap<Reducer, Reduction> reductions;\n\n    /**\n     * @param reducers List of reducers to apply during traversal.\n     * @param reductions Reducer -> Reduction multimap,\n     *                   populated during traversal.\n     */\n    ReductionGatherer(List<Reducer> reducers,\n                      Multimap<Reducer, Reduction> reductions) {\n      this.reducers = reducers;\n      this.reductions = reductions;\n    }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal raversal,\n                                  Node node,\n                                  Node parent) {\n      for (Reducer reducer : reducers) {\n        Node replacement = reducer.reduce(node);\n        if (replacement != node) {\n          reductions.put(reducer, new Reduction(parent, node, replacement));\n          return false;\n        }\n      }\n      return true;\n    }\n\n\n    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n    }\n  }\n\n  /**\n   * Interface implemented by the strength-reduction optimizers below.\n   */\n  abstract static class Reducer {\n    /**\n     * @return JS source for helper methods used by this reduction.\n     */\n    abstract String getHelperSource();\n\n    /**\n     * @return root of the reduced subtree if a reduction was applied;\n     *         otherwise returns the node argument.\n     */\n    abstract Node reduce(Node node);\n\n    /**\n     * Builds a method call based on the the given method name,\n     * argument and history.\n     *\n     * @param methodName Method to call.\n     * @param argumentNode Method argument.\n     */\n    protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref) {", "right_context": "}\n  }\n\n}", "class_name": "FunctionRewriter", "return_type": "Node", "parameters": [{"type": "String", "name": "methodName"}, {"type": "Node", "name": "argumentNode"}, {"type": "Node", "name": "srcref"}]}}
{"prompt": "class CheckMissingReturn implements ScopedCallback {\n\n  static final DiagnosticType MISSING_RETURN_STATEMENT =\n      DiagnosticType.warning(\n          \"JSC_MISSING_RETURN_STATEMENT\",\n          \"Missing return statement. Function expected to return {0}.\");\n\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n\n  private static final Predicate<Node> IS_RETURN = new Predicate<Node>() {\n    @Override\n    public boolean apply(Node input) {\n      // Check for null because the control flow graph's implicit return node is\n      // represented by null, so this value might be input.\n      return input != null && input.isReturn();\n    }\n  };\n\n  /* Skips all exception edges and impossible edges. */\n  private static final Predicate<DiGraphEdge<Node, ControlFlowGraph.Branch>>\n      GOES_THROUGH_TRUE_CONDITION_PREDICATE =\n        new Predicate<DiGraphEdge<Node, ControlFlowGraph.Branch>>() {\n    @Override\n    public boolean apply(DiGraphEdge<Node, ControlFlowGraph.Branch> input) {\n      // First skill all exceptions.\n      Branch branch = input.getValue();\n      if (branch == Branch.ON_EX) {\n        return false;\n      } else if (branch.isConditional()) {\n        Node condition = NodeUtil.getConditionExpression(\n            input.getSource().getValue());\n        // TODO(user): We CAN make this bit smarter just looking at\n        // constants. We DO have a full blown ReverseAbstractInterupter and\n        // type system that can evaluate some impressions' boolean value but\n        // for now we will keep this pass lightweight.\n        if (condition != null) {\n          TernaryValue val = NodeUtil.getImpureBooleanValue(condition);\n          if (val != TernaryValue.UNKNOWN) {\n            return val.toBoolean(true) == (Branch.ON_TRUE == branch);\n          }\n        }\n      }\n      return true;\n    }\n  };\n\n  /**\n   * @param level level of severity to report when a missing return statement\n   *     is discovered\n   */\n  CheckMissingReturn(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.level = level;\n  }\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n    JSType returnType = explicitReturnExpected(t.getScopeRoot());\n    if (returnType == null) {\n      return;\n    }\n\n    if (fastAllPathsReturnCheck(t.getControlFlowGraph())) {\n      return;\n    }\n\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n        new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n            t.getControlFlowGraph(),\n            t.getControlFlowGraph().getEntry(),\n            t.getControlFlowGraph().getImplicitReturn(),\n            IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n\n    if (!test.allPathsSatisfyPredicate()) {\n      compiler.report(\n          t.makeError(t.getScopeRoot(), level,\n              MISSING_RETURN_STATEMENT, returnType.toString()));\n    }\n  }\n\n  /**\n   * Fast check to see if all execution paths contain a return statement.\n   * May spuriously report that a return statement is missing.\n   *\n   * @return true if all paths return, converse not necessarily true\n   */\n  private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg) {", "metadata": {"defects4j_task_id": "335f5ee118ed677b5624e330a085bd732a0728261c3db6e320f9f7ed40a2723f", "task_id": "google_closure-compiler/45", "ground_truth": "\n    for (DiGraphEdge<Node, Branch> s : cfg.getImplicitReturn().getInEdges()) {\n      if (!s.getSource().getValue().isReturn()) {\n        return false;\n      }\n    }\n    return true;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "CheckMissingReturn.java"], "context_start_lineno": 0, "function_name": "fastAllPathsReturnCheck", "left_context": "class CheckMissingReturn implements ScopedCallback {\n\n  static final DiagnosticType MISSING_RETURN_STATEMENT =\n      DiagnosticType.warning(\n          \"JSC_MISSING_RETURN_STATEMENT\",\n          \"Missing return statement. Function expected to return {0}.\");\n\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n\n  private static final Predicate<Node> IS_RETURN = new Predicate<Node>() {\n    @Override\n    public boolean apply(Node input) {\n      // Check for null because the control flow graph's implicit return node is\n      // represented by null, so this value might be input.\n      return input != null && input.isReturn();\n    }\n  };\n\n  /* Skips all exception edges and impossible edges. */\n  private static final Predicate<DiGraphEdge<Node, ControlFlowGraph.Branch>>\n      GOES_THROUGH_TRUE_CONDITION_PREDICATE =\n        new Predicate<DiGraphEdge<Node, ControlFlowGraph.Branch>>() {\n    @Override\n    public boolean apply(DiGraphEdge<Node, ControlFlowGraph.Branch> input) {\n      // First skill all exceptions.\n      Branch branch = input.getValue();\n      if (branch == Branch.ON_EX) {\n        return false;\n      } else if (branch.isConditional()) {\n        Node condition = NodeUtil.getConditionExpression(\n            input.getSource().getValue());\n        // TODO(user): We CAN make this bit smarter just looking at\n        // constants. We DO have a full blown ReverseAbstractInterupter and\n        // type system that can evaluate some impressions' boolean value but\n        // for now we will keep this pass lightweight.\n        if (condition != null) {\n          TernaryValue val = NodeUtil.getImpureBooleanValue(condition);\n          if (val != TernaryValue.UNKNOWN) {\n            return val.toBoolean(true) == (Branch.ON_TRUE == branch);\n          }\n        }\n      }\n      return true;\n    }\n  };\n\n  /**\n   * @param level level of severity to report when a missing return statement\n   *     is discovered\n   */\n  CheckMissingReturn(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.level = level;\n  }\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n    JSType returnType = explicitReturnExpected(t.getScopeRoot());\n    if (returnType == null) {\n      return;\n    }\n\n    if (fastAllPathsReturnCheck(t.getControlFlowGraph())) {\n      return;\n    }\n\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n        new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n            t.getControlFlowGraph(),\n            t.getControlFlowGraph().getEntry(),\n            t.getControlFlowGraph().getImplicitReturn(),\n            IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n\n    if (!test.allPathsSatisfyPredicate()) {\n      compiler.report(\n          t.makeError(t.getScopeRoot(), level,\n              MISSING_RETURN_STATEMENT, returnType.toString()));\n    }\n  }\n\n  /**\n   * Fast check to see if all execution paths contain a return statement.\n   * May spuriously report that a return statement is missing.\n   *\n   * @return true if all paths return, converse not necessarily true\n   */\n  private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg) {", "right_context": "}\n\n  @Override\n  public void exitScope(NodeTraversal t) {\n  }\n\n  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n  }\n\n  /**\n   * Determines if the given scope should explicitly return. All functions\n   * with non-void or non-unknown return types must have explicit returns.\n   *\n   * Exception: Constructors which specifically specify a return type are\n   * used to allow invocation without requiring the \"new\" keyword. They\n   * have an implicit return type. See unit tests.\n   *\n   * @return If a return type is expected, returns it. Otherwise, returns null.\n   */\n  private JSType explicitReturnExpected(Node scope) {\n    FunctionType scopeType = JSType.toMaybeFunctionType(scope.getJSType());\n\n    if (scopeType == null) {\n      return null;\n    }\n\n    if (isEmptyFunction(scope)) {\n      return null;\n    }\n\n    if (scopeType.isConstructor()) {\n      return null;\n    }\n\n    JSType returnType = scopeType.getReturnType();\n\n    if (returnType == null) {\n      return null;\n    }\n\n    if (!isVoidOrUnknown(returnType)) {\n      return returnType;\n    }\n\n    return null;\n  }\n\n  /**\n   * @return {@code true} if function represents a JavaScript function\n   *     with an empty body\n   */\n  private static boolean isEmptyFunction(Node function) {\n    return function.getChildCount() == 3 &&\n           !function.getFirstChild().getNext().getNext().hasChildren();\n  }\n\n  /**\n   * @return {@code true} if returnType is void, unknown, or a union\n   *     containing void or unknown\n   */\n  private boolean isVoidOrUnknown(JSType returnType) {\n    final JSType voidType =\n        compiler.getTypeRegistry().getNativeType(JSTypeNative.VOID_TYPE);\n    return voidType.isSubtype(returnType);\n  }\n}", "class_name": "CheckMissingReturn", "return_type": "boolean", "parameters": [{"type": "ControlFlowGraph<Node>", "name": "cfg"}]}}
{"prompt": "class GraphColoring<N, E> {\n  // Maps a color (represented by an integer) to a variable. If, for example,\n  // the color 5 is mapped to \"foo\". Then any other variables colored with the\n  // color 5 will now use the name \"foo\".\n  protected N[] colorToNodeMap;\n  protected final AdjacencyGraph<N, E> graph;\n\n  public GraphColoring(AdjacencyGraph<N, E> graph) {\n    this.graph = graph;\n  }\n\n  /**\n   * Annotates the graph with {@link Color} objects using\n   * {@link GraphNode#setAnnotation(Annotation)}.\n   *\n   * @return The number of unique colors need.\n   */\n  public abstract int color();\n\n  /**\n   * Using the coloring as partitions, finds the node that represents that\n   * partition as the super node. The first to retrieve its partition will\n   * become the super node.\n   */\n  public N getPartitionSuperNode(N node) {", "metadata": {"defects4j_task_id": "ac147f08ca2adc289b31a2bb143f087518d06ed9e77eb2f73ceff05d8c0eba9d", "task_id": "google_closure-compiler/146", "ground_truth": "\n    Preconditions.checkNotNull(colorToNodeMap,\n        \"No coloring founded. color() should be called first.\");\n    Color color = graph.getNode(node).getAnnotation();\n    N headNode = colorToNodeMap[color.value];\n    if (headNode == null) {\n      colorToNodeMap[color.value] = node;\n      return node;\n    } else {\n      return headNode;\n    }\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "graph", "GraphColoring.java"], "context_start_lineno": 0, "function_name": "getPartitionSuperNode", "left_context": "class GraphColoring<N, E> {\n  // Maps a color (represented by an integer) to a variable. If, for example,\n  // the color 5 is mapped to \"foo\". Then any other variables colored with the\n  // color 5 will now use the name \"foo\".\n  protected N[] colorToNodeMap;\n  protected final AdjacencyGraph<N, E> graph;\n\n  public GraphColoring(AdjacencyGraph<N, E> graph) {\n    this.graph = graph;\n  }\n\n  /**\n   * Annotates the graph with {@link Color} objects using\n   * {@link GraphNode#setAnnotation(Annotation)}.\n   *\n   * @return The number of unique colors need.\n   */\n  public abstract int color();\n\n  /**\n   * Using the coloring as partitions, finds the node that represents that\n   * partition as the super node. The first to retrieve its partition will\n   * become the super node.\n   */\n  public N getPartitionSuperNode(N node) {", "right_context": "}\n\n  public AdjacencyGraph<N, E> getGraph() {\n    return graph;\n  }\n\n  /** The color of a node */\n  public static class Color implements Annotation {\n    int value = 0;\n\n    Color(int value) {\n      this.value = value;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n      if (!(other instanceof Color)) {\n        return false;\n      } else {\n        return value == ((Color) other).value;\n      }\n    }\n\n    @Override\n    public int hashCode() {\n      return value;\n    }\n  }\n\n  /**\n   * Greedily assign nodes with high degree unique colors.\n   */\n  public static class GreedyGraphColoring<N, E> extends GraphColoring<N, E> {\n\n    private final Comparator<N> tieBreaker;\n    public GreedyGraphColoring(AdjacencyGraph<N, E> graph) {\n      this(graph, null);\n    }\n\n    /**\n     * @param tieBreaker In case of a tie between two nodes of the same degree,\n     *     this comparator will determine which node should be colored first.\n     */\n    public GreedyGraphColoring(\n        AdjacencyGraph<N, E> graph, Comparator<N> tieBreaker) {\n      super(graph);\n      this.tieBreaker = tieBreaker;\n    }\n\n    @Override\n    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\n          return result == 0 && tieBreaker != null ?\n              tieBreaker.compare(o1.getValue(), o2.getValue()) : result;\n        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }\n  }\n}", "class_name": "GraphColoring", "return_type": "N", "parameters": [{"type": "N", "name": "node"}]}}
{"prompt": "class SortedDependencies<INPUT extends DependencyInfo> {\n\n  private final List<INPUT> sortedList;\n\n  // A list of all the inputs that do not have provides.\n  private final List<INPUT> noProvides;\n\n  private final Map<String, INPUT> provideMap = Maps.newHashMap();\n\n  public SortedDependencies(List<INPUT> inputs)\n      throws CircularDependencyException {\n    this.inputs = Lists.newArrayList(inputs);\n    noProvides = Lists.newArrayList();\n\n    // Collect all symbols provided in these files.\n    for (INPUT input : inputs) {\n      Collection<String> currentProvides = input.getProvides();\n      if (currentProvides.isEmpty()) {\n        noProvides.add(input);\n      }\n\n      for (String provide : currentProvides) {\n        provideMap.put(provide, input);\n      }\n    }\n\n    // Get the direct dependencies.\n    final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n      for (String req : input.getRequires()) {\n        INPUT dep = provideMap.get(req);\n        if (dep != null && dep != input) {\n          deps.put(input, dep);\n        }\n      }\n    }\n\n    // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n    sortedList = topologicalStableSort(inputs, deps);\n\n    // The dependency graph of inputs has a cycle iff sortedList is a proper\n    // subset of inputs. Also, it has a cycle iff the subgraph\n    // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n    // by the lemma that a graph has a cycle iff it has a subgraph where\n    // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n    // to the reader.\n    if (sortedList.size() < inputs.size()) {\n      List<INPUT> subGraph = Lists.newArrayList(inputs);\n      subGraph.removeAll(sortedList);\n\n      throw new CircularDependencyException(\n          cycleToString(findCycle(subGraph, deps)));\n    }\n  }\n\n  /**\n   * Return the input that gives us the given symbol.\n   * @throws MissingProvideException An exception if there is no\n   *     input for this symbol.\n   */\n  public INPUT getInputProviding(String symbol)\n      throws MissingProvideException {\n    if (provideMap.containsKey(symbol)) {\n      return provideMap.get(symbol);\n    }\n    throw new MissingProvideException(symbol);\n  }\n\n  /**\n   * Return the input that gives us the given symbol, or null.\n   */\n  public INPUT maybeGetInputProviding(String symbol) {\n    return provideMap.get(symbol);\n  }\n\n  /**\n   * Returns the first circular dependency found. Expressed as a list of\n   * items in reverse dependency order (the second element depends on the\n   * first, etc.).\n   */\n  private List<INPUT> findCycle(\n      List<INPUT> subGraph, Multimap<INPUT, INPUT> deps) {\n    return findCycle(subGraph.get(0), Sets.<INPUT>newHashSet(subGraph),\n        deps, Sets.<INPUT>newHashSet());\n  }\n\n  private List<INPUT> findCycle(\n      INPUT current, Set<INPUT> subGraph, Multimap<INPUT, INPUT> deps,\n      Set<INPUT> covered) {\n    if (covered.add(current)) {\n      List<INPUT> cycle = findCycle(\n          findRequireInSubGraphOrFail(current, subGraph),\n          subGraph, deps, covered);\n\n      // Don't add the input to the list if the cycle has closed already.\n      if (cycle.get(0) != cycle.get(cycle.size() - 1)) {\n        cycle.add(current);\n      }\n\n      return cycle;\n    } else {\n      // Explicitly use the add() method, to prevent a generics constructor\n      // warning that is dumb. The condition it's protecting is\n      // obscure, and I think people have proposed that it be removed.\n      List<INPUT> cycle = Lists.<INPUT>newArrayList();\n      cycle.add(current);\n      return cycle;\n    }\n  }\n\n  private INPUT findRequireInSubGraphOrFail(INPUT input, Set<INPUT> subGraph) {\n    for (String symbol : input.getRequires()) {\n      INPUT candidate = provideMap.get(symbol);\n      if (subGraph.contains(candidate)) {\n        return candidate;\n      }\n    }\n    throw new IllegalStateException(\"no require found in subgraph\");\n  }\n\n  /**\n   * @param cycle A cycle in reverse-dependency order.\n   */\n  private String cycleToString(List<INPUT> cycle) {\n    List<String> symbols = Lists.newArrayList();\n    for (int i = cycle.size() - 1; i >= 0; i--) {\n      symbols.add(cycle.get(i).getProvides().iterator().next());\n    }\n    symbols.add(symbols.get(0));\n    return Joiner.on(\" -> \").join(symbols);\n  }\n\n  public List<INPUT> getSortedList() {\n    return Collections.<INPUT>unmodifiableList(sortedList);\n  }\n\n  /**\n   * Gets all the dependencies of the given roots. The inputs must be returned\n   * in a stable order. In other words, if A comes before B, and A does not\n   * transitively depend on B, then A must also come before B in the returned\n   * list.\n   */\n  public List<INPUT> getSortedDependenciesOf(List<INPUT> roots) {\n    return getDependenciesOf(roots, true);\n  }\n\n  /**\n   * Gets all the dependencies of the given roots. The inputs must be returned\n   * in a stable order. In other words, if A comes before B, and A does not\n   * transitively depend on B, then A must also come before B in the returned\n   * list.\n   *\n   * @param sorted If true, get them in topologically sorted order. If false,\n   *     get them in the original order they were passed to the compiler.\n   */\n  public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted) {", "metadata": {"defects4j_task_id": "112ad1f48db216c30ecc475ba99b3ae34ea2b85888e292bab0c59985ea4fcaef", "task_id": "google_closure-compiler/17", "ground_truth": "\n    Preconditions.checkArgument(inputs.containsAll(roots));\n    Set<INPUT> included = Sets.newHashSet();\n    Deque<INPUT> worklist = new ArrayDeque<INPUT>(roots);\n    while (!worklist.isEmpty()) {\n      INPUT current = worklist.pop();\n      if (included.add(current)) {\n        for (String req : current.getRequires()) {\n          INPUT dep = provideMap.get(req);\n          if (dep != null) {\n            worklist.add(dep);\n          }\n        }\n      }\n    }\n\n    ImmutableList.Builder<INPUT> builder = ImmutableList.builder();\n    for (INPUT current : (sorted ? sortedList : inputs)) {\n      if (included.contains(current)) {\n        builder.add(current);\n      }\n    }\n    return builder.build();\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "deps", "SortedDependencies.java"], "context_start_lineno": 0, "function_name": "getDependenciesOf", "left_context": "class SortedDependencies<INPUT extends DependencyInfo> {\n\n  private final List<INPUT> sortedList;\n\n  // A list of all the inputs that do not have provides.\n  private final List<INPUT> noProvides;\n\n  private final Map<String, INPUT> provideMap = Maps.newHashMap();\n\n  public SortedDependencies(List<INPUT> inputs)\n      throws CircularDependencyException {\n    this.inputs = Lists.newArrayList(inputs);\n    noProvides = Lists.newArrayList();\n\n    // Collect all symbols provided in these files.\n    for (INPUT input : inputs) {\n      Collection<String> currentProvides = input.getProvides();\n      if (currentProvides.isEmpty()) {\n        noProvides.add(input);\n      }\n\n      for (String provide : currentProvides) {\n        provideMap.put(provide, input);\n      }\n    }\n\n    // Get the direct dependencies.\n    final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n      for (String req : input.getRequires()) {\n        INPUT dep = provideMap.get(req);\n        if (dep != null && dep != input) {\n          deps.put(input, dep);\n        }\n      }\n    }\n\n    // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n    sortedList = topologicalStableSort(inputs, deps);\n\n    // The dependency graph of inputs has a cycle iff sortedList is a proper\n    // subset of inputs. Also, it has a cycle iff the subgraph\n    // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n    // by the lemma that a graph has a cycle iff it has a subgraph where\n    // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n    // to the reader.\n    if (sortedList.size() < inputs.size()) {\n      List<INPUT> subGraph = Lists.newArrayList(inputs);\n      subGraph.removeAll(sortedList);\n\n      throw new CircularDependencyException(\n          cycleToString(findCycle(subGraph, deps)));\n    }\n  }\n\n  /**\n   * Return the input that gives us the given symbol.\n   * @throws MissingProvideException An exception if there is no\n   *     input for this symbol.\n   */\n  public INPUT getInputProviding(String symbol)\n      throws MissingProvideException {\n    if (provideMap.containsKey(symbol)) {\n      return provideMap.get(symbol);\n    }\n    throw new MissingProvideException(symbol);\n  }\n\n  /**\n   * Return the input that gives us the given symbol, or null.\n   */\n  public INPUT maybeGetInputProviding(String symbol) {\n    return provideMap.get(symbol);\n  }\n\n  /**\n   * Returns the first circular dependency found. Expressed as a list of\n   * items in reverse dependency order (the second element depends on the\n   * first, etc.).\n   */\n  private List<INPUT> findCycle(\n      List<INPUT> subGraph, Multimap<INPUT, INPUT> deps) {\n    return findCycle(subGraph.get(0), Sets.<INPUT>newHashSet(subGraph),\n        deps, Sets.<INPUT>newHashSet());\n  }\n\n  private List<INPUT> findCycle(\n      INPUT current, Set<INPUT> subGraph, Multimap<INPUT, INPUT> deps,\n      Set<INPUT> covered) {\n    if (covered.add(current)) {\n      List<INPUT> cycle = findCycle(\n          findRequireInSubGraphOrFail(current, subGraph),\n          subGraph, deps, covered);\n\n      // Don't add the input to the list if the cycle has closed already.\n      if (cycle.get(0) != cycle.get(cycle.size() - 1)) {\n        cycle.add(current);\n      }\n\n      return cycle;\n    } else {\n      // Explicitly use the add() method, to prevent a generics constructor\n      // warning that is dumb. The condition it's protecting is\n      // obscure, and I think people have proposed that it be removed.\n      List<INPUT> cycle = Lists.<INPUT>newArrayList();\n      cycle.add(current);\n      return cycle;\n    }\n  }\n\n  private INPUT findRequireInSubGraphOrFail(INPUT input, Set<INPUT> subGraph) {\n    for (String symbol : input.getRequires()) {\n      INPUT candidate = provideMap.get(symbol);\n      if (subGraph.contains(candidate)) {\n        return candidate;\n      }\n    }\n    throw new IllegalStateException(\"no require found in subgraph\");\n  }\n\n  /**\n   * @param cycle A cycle in reverse-dependency order.\n   */\n  private String cycleToString(List<INPUT> cycle) {\n    List<String> symbols = Lists.newArrayList();\n    for (int i = cycle.size() - 1; i >= 0; i--) {\n      symbols.add(cycle.get(i).getProvides().iterator().next());\n    }\n    symbols.add(symbols.get(0));\n    return Joiner.on(\" -> \").join(symbols);\n  }\n\n  public List<INPUT> getSortedList() {\n    return Collections.<INPUT>unmodifiableList(sortedList);\n  }\n\n  /**\n   * Gets all the dependencies of the given roots. The inputs must be returned\n   * in a stable order. In other words, if A comes before B, and A does not\n   * transitively depend on B, then A must also come before B in the returned\n   * list.\n   */\n  public List<INPUT> getSortedDependenciesOf(List<INPUT> roots) {\n    return getDependenciesOf(roots, true);\n  }\n\n  /**\n   * Gets all the dependencies of the given roots. The inputs must be returned\n   * in a stable order. In other words, if A comes before B, and A does not\n   * transitively depend on B, then A must also come before B in the returned\n   * list.\n   *\n   * @param sorted If true, get them in topologically sorted order. If false,\n   *     get them in the original order they were passed to the compiler.\n   */\n  public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted) {", "right_context": "}\n}", "class_name": "SortedDependencies", "return_type": "List<INPUT>", "parameters": [{"type": "List<INPUT>", "name": "roots"}, {"type": "boolean", "name": "sorted"}]}}
{"prompt": "class JsMessageVisitor extends AbstractPostOrderCallback\n    implements CompilerPass {\n\n  /** Get a previously tracked message. */\n  private JsMessage getTrackedMessage(NodeTraversal t, String msgName) {\n    boolean isUnnamedMessage = isUnnamedMessageName(msgName);\n    if (!isUnnamedMessage) {\n      MessageLocation location = messageNames.get(msgName);\n      return location == null ? null : location.message;\n    } else {\n      Var var = t.getScope().getVar(msgName);\n      if (var != null) {\n        return unnamedMessages.get(var);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n\n  /**\n   * Creates a {@link JsMessage} for a JS message defined using a JS variable\n   * declaration (e.g <code>var MSG_X = ...;</code>).\n   *\n   * @param builder the message builder\n   * @param nameNode a NAME node for a JS message variable\n   * @param parentNode a VAR node, parent of {@code nameNode}\n   * @param grandParentNode the grandparent of {@code nameNode}. This node is\n   *        only used to get meta data about the message that might be\n   *        surrounding it (e.g. a message description). This argument may be\n   *        null if the meta data is not needed.\n   * @throws MalformedException if {@code varNode} does not\n   *         correspond to a valid JS message VAR node\n   */\n  private void extractMessageFromVariable(\n      Builder builder, Node nameNode, Node parentNode,\n      @Nullable Node grandParentNode) throws MalformedException {\n\n    // Determine the message's value\n    Node valueNode = nameNode.getFirstChild();\n    switch (valueNode.getType()) {\n      case Token.STRING:\n      case Token.ADD:\n        maybeInitMetaDataFromJsDocOrHelpVar(builder, parentNode,\n            grandParentNode);\n        builder.appendStringPart(extractStringFromStringExprNode(valueNode));\n        break;\n      case Token.FUNCTION:\n        maybeInitMetaDataFromJsDocOrHelpVar(builder, parentNode,\n            grandParentNode);\n        extractFromFunctionNode(builder, valueNode);\n        break;\n      case Token.CALL:\n        maybeInitMetaDataFromJsDoc(builder, parentNode);\n        extractFromCallNode(builder, valueNode);\n        break;\n      default:\n        throw new MalformedException(\"Cannot parse value of message \"\n            + builder.getKey(), valueNode);\n    }\n  }\n\n  /**\n   * Creates a {@link JsMessage} for a JS message defined using an assignment to\n   * a qualified name (e.g <code>a.b.MSG_X = goog.getMsg(...);</code>).\n   *\n   * @param builder the message builder\n   * @param getPropNode a GETPROP node in a JS message assignment\n   * @param assignNode an ASSIGN node, parent of {@code getPropNode}.\n   * @throws MalformedException if {@code getPropNode} does not\n   *         correspond to a valid JS message node\n   */\n  private void extractMessageFromProperty(\n      Builder builder, Node getPropNode, Node assignNode)\n      throws MalformedException {\n    Node callNode = getPropNode.getNext();\n    maybeInitMetaDataFromJsDoc(builder, assignNode);\n    extractFromCallNode(builder, callNode);\n  }\n\n  /**\n   * Initializes the meta data in a JsMessage by examining the nodes just before\n   * and after a message VAR node.\n   *\n   * @param builder the message builder whose meta data will be initialized\n   * @param varNode the message VAR node\n   * @param parentOfVarNode {@code varNode}'s parent node\n   */\n  private void maybeInitMetaDataFromJsDocOrHelpVar(\n      Builder builder, Node varNode, @Nullable Node parentOfVarNode)\n      throws MalformedException {\n\n    // First check description in @desc\n    if (maybeInitMetaDataFromJsDoc(builder, varNode)) {\n      return;\n    }\n\n    // Check the preceding node for meta data\n    if ((parentOfVarNode != null) &&\n        maybeInitMetaDataFromHelpVar(builder,\n            parentOfVarNode.getChildBefore(varNode))) {\n      return;\n    }\n\n    // Check the subsequent node for meta data\n    maybeInitMetaDataFromHelpVar(builder, varNode.getNext());\n  }\n\n  /**\n   * Initializes the meta data in a JsMessage by examining a node just before or\n   * after a message VAR node.\n   *\n   * @param builder the message builder whose meta data will be initialized\n   * @param sibling a node adjacent to the message VAR node\n   * @return true iff message has corresponding description variable\n   */\n  private boolean maybeInitMetaDataFromHelpVar(Builder builder,\n      @Nullable Node sibling) throws MalformedException {\n    if ((sibling != null) && (sibling.isVar())) {\n      Node nameNode = sibling.getFirstChild();\n      String name = nameNode.getString();\n      if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n        Node valueNode = nameNode.getFirstChild();\n        String desc = extractStringFromStringExprNode(valueNode);\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Initializes the meta data in a message builder given a node that may\n   * contain JsDoc properties.\n   *\n   * @param builder the message builder whose meta data will be initialized\n   * @param node the node with the message's JSDoc properties\n   * @return true if message has JsDoc with valid description in @desc\n   *         annotation\n   */\n  private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node) {", "metadata": {"defects4j_task_id": "b42ce558fc1dee8701120cb66aa88a3ff5204720996183f79fe43d3de8a12d5c", "task_id": "google_closure-compiler/153", "ground_truth": "\n    boolean messageHasDesc = false;\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      String desc = info.getDescription();\n      if (desc != null) {\n        builder.setDesc(desc);\n        messageHasDesc = true;\n      }\n      if (info.isHidden()) {\n        builder.setIsHidden(true);\n      }\n      if (info.getMeaning() != null) {\n        builder.setMeaning(info.getMeaning());\n      }\n    }\n\n    return messageHasDesc;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "JsMessageVisitor.java"], "context_start_lineno": 0, "function_name": "maybeInitMetaDataFromJsDoc", "left_context": "class JsMessageVisitor extends AbstractPostOrderCallback\n    implements CompilerPass {\n\n  /** Get a previously tracked message. */\n  private JsMessage getTrackedMessage(NodeTraversal t, String msgName) {\n    boolean isUnnamedMessage = isUnnamedMessageName(msgName);\n    if (!isUnnamedMessage) {\n      MessageLocation location = messageNames.get(msgName);\n      return location == null ? null : location.message;\n    } else {\n      Var var = t.getScope().getVar(msgName);\n      if (var != null) {\n        return unnamedMessages.get(var);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n\n  /**\n   * Creates a {@link JsMessage} for a JS message defined using a JS variable\n   * declaration (e.g <code>var MSG_X = ...;</code>).\n   *\n   * @param builder the message builder\n   * @param nameNode a NAME node for a JS message variable\n   * @param parentNode a VAR node, parent of {@code nameNode}\n   * @param grandParentNode the grandparent of {@code nameNode}. This node is\n   *        only used to get meta data about the message that might be\n   *        surrounding it (e.g. a message description). This argument may be\n   *        null if the meta data is not needed.\n   * @throws MalformedException if {@code varNode} does not\n   *         correspond to a valid JS message VAR node\n   */\n  private void extractMessageFromVariable(\n      Builder builder, Node nameNode, Node parentNode,\n      @Nullable Node grandParentNode) throws MalformedException {\n\n    // Determine the message's value\n    Node valueNode = nameNode.getFirstChild();\n    switch (valueNode.getType()) {\n      case Token.STRING:\n      case Token.ADD:\n        maybeInitMetaDataFromJsDocOrHelpVar(builder, parentNode,\n            grandParentNode);\n        builder.appendStringPart(extractStringFromStringExprNode(valueNode));\n        break;\n      case Token.FUNCTION:\n        maybeInitMetaDataFromJsDocOrHelpVar(builder, parentNode,\n            grandParentNode);\n        extractFromFunctionNode(builder, valueNode);\n        break;\n      case Token.CALL:\n        maybeInitMetaDataFromJsDoc(builder, parentNode);\n        extractFromCallNode(builder, valueNode);\n        break;\n      default:\n        throw new MalformedException(\"Cannot parse value of message \"\n            + builder.getKey(), valueNode);\n    }\n  }\n\n  /**\n   * Creates a {@link JsMessage} for a JS message defined using an assignment to\n   * a qualified name (e.g <code>a.b.MSG_X = goog.getMsg(...);</code>).\n   *\n   * @param builder the message builder\n   * @param getPropNode a GETPROP node in a JS message assignment\n   * @param assignNode an ASSIGN node, parent of {@code getPropNode}.\n   * @throws MalformedException if {@code getPropNode} does not\n   *         correspond to a valid JS message node\n   */\n  private void extractMessageFromProperty(\n      Builder builder, Node getPropNode, Node assignNode)\n      throws MalformedException {\n    Node callNode = getPropNode.getNext();\n    maybeInitMetaDataFromJsDoc(builder, assignNode);\n    extractFromCallNode(builder, callNode);\n  }\n\n  /**\n   * Initializes the meta data in a JsMessage by examining the nodes just before\n   * and after a message VAR node.\n   *\n   * @param builder the message builder whose meta data will be initialized\n   * @param varNode the message VAR node\n   * @param parentOfVarNode {@code varNode}'s parent node\n   */\n  private void maybeInitMetaDataFromJsDocOrHelpVar(\n      Builder builder, Node varNode, @Nullable Node parentOfVarNode)\n      throws MalformedException {\n\n    // First check description in @desc\n    if (maybeInitMetaDataFromJsDoc(builder, varNode)) {\n      return;\n    }\n\n    // Check the preceding node for meta data\n    if ((parentOfVarNode != null) &&\n        maybeInitMetaDataFromHelpVar(builder,\n            parentOfVarNode.getChildBefore(varNode))) {\n      return;\n    }\n\n    // Check the subsequent node for meta data\n    maybeInitMetaDataFromHelpVar(builder, varNode.getNext());\n  }\n\n  /**\n   * Initializes the meta data in a JsMessage by examining a node just before or\n   * after a message VAR node.\n   *\n   * @param builder the message builder whose meta data will be initialized\n   * @param sibling a node adjacent to the message VAR node\n   * @return true iff message has corresponding description variable\n   */\n  private boolean maybeInitMetaDataFromHelpVar(Builder builder,\n      @Nullable Node sibling) throws MalformedException {\n    if ((sibling != null) && (sibling.isVar())) {\n      Node nameNode = sibling.getFirstChild();\n      String name = nameNode.getString();\n      if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n        Node valueNode = nameNode.getFirstChild();\n        String desc = extractStringFromStringExprNode(valueNode);\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Initializes the meta data in a message builder given a node that may\n   * contain JsDoc properties.\n   *\n   * @param builder the message builder whose meta data will be initialized\n   * @param node the node with the message's JSDoc properties\n   * @return true if message has JsDoc with valid description in @desc\n   *         annotation\n   */\n  private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node) {", "right_context": "}\n}", "class_name": "JsMessageVisitor", "return_type": "boolean", "parameters": [{"type": "Builder", "name": "builder"}, {"type": "Node", "name": "node"}]}}
{"prompt": "class FramedSnappyCompressorInputStream extends CompressorInputStream {\n\n    private static final int STREAM_IDENTIFIER_TYPE = 0xff;\n    static final int COMPRESSED_CHUNK_TYPE = 0;\n    private static final int UNCOMPRESSED_CHUNK_TYPE = 1;\n    private static final int PADDING_CHUNK_TYPE = 0xfe;\n    private static final int MIN_UNSKIPPABLE_TYPE = 2;\n    private static final int MAX_UNSKIPPABLE_TYPE = 0x7f;\n    private static final int MAX_SKIPPABLE_TYPE = 0xfd;\n\n    // used by FramedSnappyCompressorOutputStream as well\n    static final byte[] SZ_SIGNATURE = new byte[] { //NOSONAR\n        (byte) STREAM_IDENTIFIER_TYPE, // tag\n        6, 0, 0, // length\n        's', 'N', 'a', 'P', 'p', 'Y'\n    };\n\n    /** The underlying stream to read compressed data from */\n    private final PushbackInputStream in;\n\n    /** The dialect to expect */\n    private final FramedSnappyDialect dialect;\n\n    private SnappyCompressorInputStream currentCompressedChunk;\n\n    // used in no-arg read method\n    private final byte[] oneByte = new byte[1];\n\n    private boolean endReached, inUncompressedChunk;\n\n    private int uncompressedBytesRemaining;\n    private long expectedChecksum = -1;\n    private final int blockSize;\n    private final PureJavaCrc32C checksum = new PureJavaCrc32C();\n\n    private final ByteUtils.ByteSupplier supplier = new ByteUtils.ByteSupplier() {\n        @Override\n        public int getAsByte() throws IOException {\n            return readOneByte();\n        }\n    };\n\n    /**\n     * Constructs a new input stream that decompresses\n     * snappy-framed-compressed data from the specified input stream\n     * using the {@link FramedSnappyDialect#STANDARD} dialect.\n     * @param in  the InputStream from which to read the compressed data\n     * @throws IOException if reading fails\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in) throws IOException {\n        this(in, FramedSnappyDialect.STANDARD);\n    }\n\n    /**\n     * Constructs a new input stream that decompresses snappy-framed-compressed data\n     * from the specified input stream.\n     * @param in  the InputStream from which to read the compressed data\n     * @param dialect the dialect used by the compressed stream\n     * @throws IOException if reading fails\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in,\n                                             final FramedSnappyDialect dialect)\n        throws IOException {\n        this(in, SnappyCompressorInputStream.DEFAULT_BLOCK_SIZE, dialect);\n    }\n\n    /**\n     * Constructs a new input stream that decompresses snappy-framed-compressed data\n     * from the specified input stream.\n     * @param in  the InputStream from which to read the compressed data\n     * @param blockSize the block size to use for the compressed stream\n     * @param dialect the dialect used by the compressed stream\n     * @throws IOException if reading fails\n     * @since 1.14\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in,\n                                             final int blockSize,\n                                             final FramedSnappyDialect dialect)\n        throws IOException {\n        this.in = new PushbackInputStream(in, 1);\n        this.blockSize = blockSize;\n        this.dialect = dialect;\n        if (dialect.hasStreamIdentifier()) {\n            readStreamIdentifier();\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int read() throws IOException {\n        return read(oneByte, 0, 1) == -1 ? -1 : oneByte[0] & 0xFF;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void close() throws IOException {\n        if (currentCompressedChunk != null) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        in.close();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        int read = readOnce(b, off, len);\n        if (read == -1) {\n            readNextBlock();\n            if (endReached) {\n                return -1;\n            }\n            read = readOnce(b, off, len);\n        }\n        return read;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int available() throws IOException {\n        if (inUncompressedChunk) {\n            return Math.min(uncompressedBytesRemaining,\n                            in.available());\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.available();\n        }\n        return 0;\n    }\n\n    /**\n     * Read from the current chunk into the given array.\n     *\n     * @return -1 if there is no current chunk or the number of bytes\n     * read from the current chunk (which may be -1 if the end of the\n     * chunk is reached).\n     */\n    private int readOnce(final byte[] b, final int off, final int len) throws IOException {", "metadata": {"defects4j_task_id": "fae7ab2c7d32932ef3e7c0aea28f376b843bb53fe6dbcd8bf8f2f8ac2657c051", "task_id": "google_closure-compiler/204", "ground_truth": "\n      int adjustedArgIndex = argIndex;\n      Node parent = site.node.getParent();\n      if (NodeUtil.isFunctionObjectCall(parent)) {\n        adjustedArgIndex++;\n      }\n      return NodeUtil.getArgumentForCallOrNew(parent, adjustedArgIndex);\n    ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "RemoveUnusedVars.java"], "context_start_lineno": 0, "function_name": "getArgumentForCallOrNewOrDotCall", "left_context": "class FramedSnappyCompressorInputStream extends CompressorInputStream {\n\n    private static final int STREAM_IDENTIFIER_TYPE = 0xff;\n    static final int COMPRESSED_CHUNK_TYPE = 0;\n    private static final int UNCOMPRESSED_CHUNK_TYPE = 1;\n    private static final int PADDING_CHUNK_TYPE = 0xfe;\n    private static final int MIN_UNSKIPPABLE_TYPE = 2;\n    private static final int MAX_UNSKIPPABLE_TYPE = 0x7f;\n    private static final int MAX_SKIPPABLE_TYPE = 0xfd;\n\n    // used by FramedSnappyCompressorOutputStream as well\n    static final byte[] SZ_SIGNATURE = new byte[] { //NOSONAR\n        (byte) STREAM_IDENTIFIER_TYPE, // tag\n        6, 0, 0, // length\n        's', 'N', 'a', 'P', 'p', 'Y'\n    };\n\n    /** The underlying stream to read compressed data from */\n    private final PushbackInputStream in;\n\n    /** The dialect to expect */\n    private final FramedSnappyDialect dialect;\n\n    private SnappyCompressorInputStream currentCompressedChunk;\n\n    // used in no-arg read method\n    private final byte[] oneByte = new byte[1];\n\n    private boolean endReached, inUncompressedChunk;\n\n    private int uncompressedBytesRemaining;\n    private long expectedChecksum = -1;\n    private final int blockSize;\n    private final PureJavaCrc32C checksum = new PureJavaCrc32C();\n\n    private final ByteUtils.ByteSupplier supplier = new ByteUtils.ByteSupplier() {\n        @Override\n        public int getAsByte() throws IOException {\n            return readOneByte();\n        }\n    };\n\n    /**\n     * Constructs a new input stream that decompresses\n     * snappy-framed-compressed data from the specified input stream\n     * using the {@link FramedSnappyDialect#STANDARD} dialect.\n     * @param in  the InputStream from which to read the compressed data\n     * @throws IOException if reading fails\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in) throws IOException {\n        this(in, FramedSnappyDialect.STANDARD);\n    }\n\n    /**\n     * Constructs a new input stream that decompresses snappy-framed-compressed data\n     * from the specified input stream.\n     * @param in  the InputStream from which to read the compressed data\n     * @param dialect the dialect used by the compressed stream\n     * @throws IOException if reading fails\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in,\n                                             final FramedSnappyDialect dialect)\n        throws IOException {\n        this(in, SnappyCompressorInputStream.DEFAULT_BLOCK_SIZE, dialect);\n    }\n\n    /**\n     * Constructs a new input stream that decompresses snappy-framed-compressed data\n     * from the specified input stream.\n     * @param in  the InputStream from which to read the compressed data\n     * @param blockSize the block size to use for the compressed stream\n     * @param dialect the dialect used by the compressed stream\n     * @throws IOException if reading fails\n     * @since 1.14\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in,\n                                             final int blockSize,\n                                             final FramedSnappyDialect dialect)\n        throws IOException {\n        this.in = new PushbackInputStream(in, 1);\n        this.blockSize = blockSize;\n        this.dialect = dialect;\n        if (dialect.hasStreamIdentifier()) {\n            readStreamIdentifier();\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int read() throws IOException {\n        return read(oneByte, 0, 1) == -1 ? -1 : oneByte[0] & 0xFF;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void close() throws IOException {\n        if (currentCompressedChunk != null) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        in.close();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        int read = readOnce(b, off, len);\n        if (read == -1) {\n            readNextBlock();\n            if (endReached) {\n                return -1;\n            }\n            read = readOnce(b, off, len);\n        }\n        return read;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int available() throws IOException {\n        if (inUncompressedChunk) {\n            return Math.min(uncompressedBytesRemaining,\n                            in.available());\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.available();\n        }\n        return 0;\n    }\n\n    /**\n     * Read from the current chunk into the given array.\n     *\n     * @return -1 if there is no current chunk or the number of bytes\n     * read from the current chunk (which may be -1 if the end of the\n     * chunk is reached).\n     */\n    private int readOnce(final byte[] b, final int off, final int len) throws IOException {", "right_context": "}\n\n}", "class_name": "RemoveUnusedVars", "return_type": "Node", "parameters": [{"type": "UseSite", "name": "site"}, {"type": "int", "name": "argIndex"}]}}
{"prompt": "class ExtractPrototypeMemberDeclarations implements CompilerPass {\n\n  // The name of variable that will temporary hold the pointer to the prototype\n  // object. Of cause, we assume that it'll be renamed by RenameVars.\n  /**\n   * At a given ExtractionInstance, stores and prototype object in the temp\n   * variable and rewrite each member declaration to assign to the temp variable\n   * instead.\n   */\n  private void extractInstance(ExtractionInstance instance) {\n    PrototypeMemberDeclaration first = instance.declarations.getFirst();\n    String className = first.qualifiedClassName;\n    if (pattern == Pattern.USE_GLOBAL_TEMP) {\n      // Use the temp variable to hold the prototype.\n      Node stmt = new Node(first.node.getType(),\n         IR.assign(\n              IR.name(prototypeAlias),\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), className + \".prototype\",\n                  instance.parent, className + \".prototype\")))\n          .copyInformationFromForTree(first.node);\n\n      instance.parent.addChildBefore(stmt, first.node);\n    } else if (pattern == Pattern.USE_ANON_FUNCTION){\n      Node block = IR.block();\n      Node func = IR.function(\n           IR.name(\"\"),\n           IR.paramList(IR.name(prototypeAlias)),\n           block);\n\n      Node call = IR.call(func,\n           NodeUtil.newQualifiedNameNode(\n               compiler.getCodingConvention(), className + \".prototype\",\n               instance.parent, className + \".prototype\"));\n      call.putIntProp(Node.FREE_CALL, 1);\n\n      Node stmt = new Node(first.node.getType(), call);\n      stmt.copyInformationFromForTree(first.node);\n      instance.parent.addChildBefore(stmt, first.node);\n      for (PrototypeMemberDeclaration declar : instance.declarations) {\n        block.addChildToBack(declar.node.detachFromParent());\n      }\n    }\n    // Go thought each member declaration and replace it with an assignment\n    // to the prototype variable.\n    for (PrototypeMemberDeclaration declar : instance.declarations) {\n      replacePrototypeMemberDeclaration(declar);\n    }\n  }\n\n  /**\n   * Replaces a member declaration to an assignment to the temp prototype\n   * object.\n   */\n  private void replacePrototypeMemberDeclaration(\n      PrototypeMemberDeclaration declar) {\n    // x.prototype.y = ...  ->  t.y = ...\n    Node assignment = declar.node.getFirstChild();\n    Node lhs = assignment.getFirstChild();\n    Node name = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention(),\n        prototypeAlias + \".\" + declar.memberName, declar.node,\n        declar.memberName);\n\n    // Save the full prototype path on the left hand side of the assignment\n    // for debugging purposes.\n    // declar.lhs = x.prototype.y so first child of the first child\n    // is 'x'.\n    Node accessNode = declar.lhs.getFirstChild().getFirstChild();\n    Object originalName = accessNode.getProp(Node.ORIGINALNAME_PROP);\n\n    String className = \"?\";\n\n    if (originalName != null) {\n      className = originalName.toString();\n    }\n\n    NodeUtil.setDebugInformation(name.getFirstChild(), lhs,\n                                 className + \".prototype\");\n\n    assignment.replaceChild(lhs, name);\n  }\n\n  /**\n   * Collects all the possible extraction instances in a node traversal.\n   */\n  private class GatherExtractionInfo extends AbstractShallowCallback {\n\n    private List<ExtractionInstance> instances = Lists.newLinkedList();\n    private int totalDelta = pattern.globalOverhead;\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      if (!n.isScript() && !n.isBlock()) {\n        return;\n      }\n\n      for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) {\n        PrototypeMemberDeclaration prototypeMember =\n            PrototypeMemberDeclaration.extractDeclaration(cur);\n        if (prototypeMember == null) {\n          continue;\n        }\n\n        // Found a good site here. The constructor will computes the chain of\n        // declarations that is qualified for extraction.\n        ExtractionInstance instance =\n            new ExtractionInstance(prototypeMember, n);\n        cur = instance.declarations.getLast().node;\n\n        // Only add it to our work list if the extraction at this instance\n        // makes the code smaller.\n        if (instance.isFavorable()) {\n          instances.add(instance);\n          totalDelta += instance.delta;\n        }\n      }\n    }\n\n    /**\n     * @return <@code true> if the sum of all the extraction instance gain\n     * outweighs the overhead of the temp variable declaration.\n     */\n    private boolean shouldExtract() {\n      return totalDelta < 0;\n    }\n  }\n\n  private class ExtractionInstance {\n    LinkedList<PrototypeMemberDeclaration> declarations = Lists.newLinkedList();\n    private int delta = 0;\n    private final Node parent;\n\n    private ExtractionInstance(PrototypeMemberDeclaration head, Node parent) {\n      this.parent = parent;\n      declarations.add(head);\n      delta = pattern.perExtractionOverhead + pattern.perMemberOverhead;\n\n      for (Node cur = head.node.getNext(); cur != null; cur = cur.getNext()) {\n\n        // We can skip over any named functions because they have no effect on\n        // the control flow. In fact, they are lifted to the beginning of the\n        // block. This happens a lot when devirtualization breaks the whole\n        // chain.\n        if (cur.isFunction()) {\n          continue;\n        }\n\n        PrototypeMemberDeclaration prototypeMember =\n            PrototypeMemberDeclaration.extractDeclaration(cur);\n        if (prototypeMember == null || !head.isSameClass(prototypeMember)) {\n          break;\n        }\n        declarations.add(prototypeMember);\n        delta += pattern.perMemberOverhead;\n      }\n    }\n\n    /**\n     * @return {@code true} if extracting all the declarations at this instance\n     * will overweight the overhead of aliasing the prototype object.\n     */\n    boolean isFavorable() {\n      return delta <= 0;\n    }\n  }\n\n  /**\n   * Abstraction for a prototype member declaration.\n   *\n   * <p>{@code a.b.c.prototype.d = ....}\n   */\n  private static class PrototypeMemberDeclaration {\n    final String memberName;\n    final Node node;\n    final String qualifiedClassName;\n    final Node lhs;\n\n    private PrototypeMemberDeclaration(Node lhs, Node node) {\n      this.lhs = lhs;\n      this.memberName = NodeUtil.getPrototypePropertyName(lhs);\n      this.node = node;\n      this.qualifiedClassName =\n          NodeUtil.getPrototypeClassName(lhs).getQualifiedName();\n    }\n\n    private boolean isSameClass(PrototypeMemberDeclaration other) {\n      return qualifiedClassName.equals(other.qualifiedClassName);\n    }\n\n    /**\n     * @return A prototype member declaration representation if there is one\n     * else it returns {@code null}.\n     */\n    private static PrototypeMemberDeclaration extractDeclaration(Node n) {", "metadata": {"defects4j_task_id": "600876231a45d46a1b278add85609f0872c099d8cd510b4828cb3817f57f9af2", "task_id": "google_closure-compiler/83", "ground_truth": "\n      if (!NodeUtil.isPrototypePropertyDeclaration(n)) {\n        return null;\n      }\n      Node lhs = n.getFirstChild().getFirstChild();\n      return new PrototypeMemberDeclaration(lhs, n);\n    ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "ExtractPrototypeMemberDeclarations.java"], "context_start_lineno": 0, "function_name": "extractDeclaration", "left_context": "class ExtractPrototypeMemberDeclarations implements CompilerPass {\n\n  // The name of variable that will temporary hold the pointer to the prototype\n  // object. Of cause, we assume that it'll be renamed by RenameVars.\n  /**\n   * At a given ExtractionInstance, stores and prototype object in the temp\n   * variable and rewrite each member declaration to assign to the temp variable\n   * instead.\n   */\n  private void extractInstance(ExtractionInstance instance) {\n    PrototypeMemberDeclaration first = instance.declarations.getFirst();\n    String className = first.qualifiedClassName;\n    if (pattern == Pattern.USE_GLOBAL_TEMP) {\n      // Use the temp variable to hold the prototype.\n      Node stmt = new Node(first.node.getType(),\n         IR.assign(\n              IR.name(prototypeAlias),\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), className + \".prototype\",\n                  instance.parent, className + \".prototype\")))\n          .copyInformationFromForTree(first.node);\n\n      instance.parent.addChildBefore(stmt, first.node);\n    } else if (pattern == Pattern.USE_ANON_FUNCTION){\n      Node block = IR.block();\n      Node func = IR.function(\n           IR.name(\"\"),\n           IR.paramList(IR.name(prototypeAlias)),\n           block);\n\n      Node call = IR.call(func,\n           NodeUtil.newQualifiedNameNode(\n               compiler.getCodingConvention(), className + \".prototype\",\n               instance.parent, className + \".prototype\"));\n      call.putIntProp(Node.FREE_CALL, 1);\n\n      Node stmt = new Node(first.node.getType(), call);\n      stmt.copyInformationFromForTree(first.node);\n      instance.parent.addChildBefore(stmt, first.node);\n      for (PrototypeMemberDeclaration declar : instance.declarations) {\n        block.addChildToBack(declar.node.detachFromParent());\n      }\n    }\n    // Go thought each member declaration and replace it with an assignment\n    // to the prototype variable.\n    for (PrototypeMemberDeclaration declar : instance.declarations) {\n      replacePrototypeMemberDeclaration(declar);\n    }\n  }\n\n  /**\n   * Replaces a member declaration to an assignment to the temp prototype\n   * object.\n   */\n  private void replacePrototypeMemberDeclaration(\n      PrototypeMemberDeclaration declar) {\n    // x.prototype.y = ...  ->  t.y = ...\n    Node assignment = declar.node.getFirstChild();\n    Node lhs = assignment.getFirstChild();\n    Node name = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention(),\n        prototypeAlias + \".\" + declar.memberName, declar.node,\n        declar.memberName);\n\n    // Save the full prototype path on the left hand side of the assignment\n    // for debugging purposes.\n    // declar.lhs = x.prototype.y so first child of the first child\n    // is 'x'.\n    Node accessNode = declar.lhs.getFirstChild().getFirstChild();\n    Object originalName = accessNode.getProp(Node.ORIGINALNAME_PROP);\n\n    String className = \"?\";\n\n    if (originalName != null) {\n      className = originalName.toString();\n    }\n\n    NodeUtil.setDebugInformation(name.getFirstChild(), lhs,\n                                 className + \".prototype\");\n\n    assignment.replaceChild(lhs, name);\n  }\n\n  /**\n   * Collects all the possible extraction instances in a node traversal.\n   */\n  private class GatherExtractionInfo extends AbstractShallowCallback {\n\n    private List<ExtractionInstance> instances = Lists.newLinkedList();\n    private int totalDelta = pattern.globalOverhead;\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      if (!n.isScript() && !n.isBlock()) {\n        return;\n      }\n\n      for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) {\n        PrototypeMemberDeclaration prototypeMember =\n            PrototypeMemberDeclaration.extractDeclaration(cur);\n        if (prototypeMember == null) {\n          continue;\n        }\n\n        // Found a good site here. The constructor will computes the chain of\n        // declarations that is qualified for extraction.\n        ExtractionInstance instance =\n            new ExtractionInstance(prototypeMember, n);\n        cur = instance.declarations.getLast().node;\n\n        // Only add it to our work list if the extraction at this instance\n        // makes the code smaller.\n        if (instance.isFavorable()) {\n          instances.add(instance);\n          totalDelta += instance.delta;\n        }\n      }\n    }\n\n    /**\n     * @return <@code true> if the sum of all the extraction instance gain\n     * outweighs the overhead of the temp variable declaration.\n     */\n    private boolean shouldExtract() {\n      return totalDelta < 0;\n    }\n  }\n\n  private class ExtractionInstance {\n    LinkedList<PrototypeMemberDeclaration> declarations = Lists.newLinkedList();\n    private int delta = 0;\n    private final Node parent;\n\n    private ExtractionInstance(PrototypeMemberDeclaration head, Node parent) {\n      this.parent = parent;\n      declarations.add(head);\n      delta = pattern.perExtractionOverhead + pattern.perMemberOverhead;\n\n      for (Node cur = head.node.getNext(); cur != null; cur = cur.getNext()) {\n\n        // We can skip over any named functions because they have no effect on\n        // the control flow. In fact, they are lifted to the beginning of the\n        // block. This happens a lot when devirtualization breaks the whole\n        // chain.\n        if (cur.isFunction()) {\n          continue;\n        }\n\n        PrototypeMemberDeclaration prototypeMember =\n            PrototypeMemberDeclaration.extractDeclaration(cur);\n        if (prototypeMember == null || !head.isSameClass(prototypeMember)) {\n          break;\n        }\n        declarations.add(prototypeMember);\n        delta += pattern.perMemberOverhead;\n      }\n    }\n\n    /**\n     * @return {@code true} if extracting all the declarations at this instance\n     * will overweight the overhead of aliasing the prototype object.\n     */\n    boolean isFavorable() {\n      return delta <= 0;\n    }\n  }\n\n  /**\n   * Abstraction for a prototype member declaration.\n   *\n   * <p>{@code a.b.c.prototype.d = ....}\n   */\n  private static class PrototypeMemberDeclaration {\n    final String memberName;\n    final Node node;\n    final String qualifiedClassName;\n    final Node lhs;\n\n    private PrototypeMemberDeclaration(Node lhs, Node node) {\n      this.lhs = lhs;\n      this.memberName = NodeUtil.getPrototypePropertyName(lhs);\n      this.node = node;\n      this.qualifiedClassName =\n          NodeUtil.getPrototypeClassName(lhs).getQualifiedName();\n    }\n\n    private boolean isSameClass(PrototypeMemberDeclaration other) {\n      return qualifiedClassName.equals(other.qualifiedClassName);\n    }\n\n    /**\n     * @return A prototype member declaration representation if there is one\n     * else it returns {@code null}.\n     */\n    private static PrototypeMemberDeclaration extractDeclaration(Node n) {", "right_context": "}\n  }\n\n}", "class_name": "ExtractPrototypeMemberDeclarations", "return_type": "PrototypeMemberDeclaration", "parameters": [{"type": "Node", "name": "n"}]}}
{"prompt": "class MinimizedCondition {\n\n  /** A representation equivalent to the original condition. */\n  private final MeasuredNode positive;\n  /** A representation equivalent to the negation of the original condition. */\n  private final MeasuredNode negative;\n\n  /** A placeholder at the same AST location as the original condition */\n  private Node placeholder;\n\n  private MinimizedCondition(MeasuredNode p, MeasuredNode n) {\n    Preconditions.checkArgument(p.node.getParent() == null);\n    Preconditions.checkArgument(n.node.getParent() == null);\n    positive = p;\n    negative = n.change();\n  }\n\n  Node getPlaceholder() {\n    return placeholder;\n  }\n\n  MinimizedCondition setPlaceholder(Node placeholder) {\n    this.placeholder = placeholder;\n    return this;\n  }\n\n  /**\n   * Remove the passed condition node from the AST, and then return a\n   * MinimizedCondition that represents the condition node after\n   * minimization.\n   */\n  static MinimizedCondition fromConditionNode(Node n) {\n    switch (n.getType()) {\n      case Token.NOT:\n      case Token.AND:\n      case Token.OR:\n      case Token.HOOK:\n      case Token.COMMA:\n        Node placeholder = swapWithPlaceholderNode(n);\n        return computeMinimizedCondition(n).setPlaceholder(placeholder);\n      default:\n        return unoptimized(n);\n    }\n  }\n\n  /**\n   * Return the shorter representation of the original condition node.\n   * <p>\n   * Depending on the context, this may require to either penalize or\n   * not the existance of a leading NOT node.\n   * <ul><li>When {@code style} is {@code PREFER_UNNEGATED}, simply try to\n   * minimize the total length of the conditional.</li>\n   * <li>When {@code style} is {@code ALLOW_LEADING_NOT}, prefer the right side\n   * in cases such as:\n   * <br><code>\n   *    !x || !y || z  ==>  !(x && y && !z)\n   * </code><br>\n   * This is useful in contexts such as IFs or HOOKs where subsequent\n   * optimizations can efficiently deal with leading NOTs.\n   * </li></ul>\n   *\n   * @return the minimized condition MeasuredNode, with equivalent semantics\n   *   to that passed to {@link #fromConditionNode}.\n   */\n  MeasuredNode getMinimized(MinimizationStyle style) {\n    if (style == MinimizationStyle.PREFER_UNNEGATED\n        || positive.node.isNot()\n        || positive.length <= negative.length) {\n      return positive;\n    } else {\n      return negative.addNot();\n    }\n  }\n\n  /**\n   * Return a MeasuredNode of the given condition node, without minimizing\n   * the result.\n   * <p>\n   * Since a MinimizedCondition necessarily must contain two trees, this\n   * method sets the negative side to a {@link Token#SCRIPT} node (never valid\n   * inside an expression) with an unreasonably high length so that it will\n   * never be chosen by {@link #getMinimized}.\n   *\n   * @param n the conditional expression tree to minimize.\n   *  This must be connected to the AST, and will be swapped\n   *  with a placeholder node during minimization.\n   * @return a MinimizedCondition object representing that tree.\n   */\n  static MinimizedCondition unoptimized(Node n) {", "metadata": {"defects4j_task_id": "e05eb001dfb4b4c408839ae91a34e03fdd11aa73cac409ab8ffe36e82489967b", "task_id": "google_closure-compiler/184", "ground_truth": "\n    Preconditions.checkNotNull(n.getParent());\n    Node placeholder = swapWithPlaceholderNode(n);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(IR.script(), Integer.MAX_VALUE, true);\n    return new MinimizedCondition(pos, neg).setPlaceholder(placeholder);\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "MinimizedCondition.java"], "context_start_lineno": 0, "function_name": "unoptimized", "left_context": "class MinimizedCondition {\n\n  /** A representation equivalent to the original condition. */\n  private final MeasuredNode positive;\n  /** A representation equivalent to the negation of the original condition. */\n  private final MeasuredNode negative;\n\n  /** A placeholder at the same AST location as the original condition */\n  private Node placeholder;\n\n  private MinimizedCondition(MeasuredNode p, MeasuredNode n) {\n    Preconditions.checkArgument(p.node.getParent() == null);\n    Preconditions.checkArgument(n.node.getParent() == null);\n    positive = p;\n    negative = n.change();\n  }\n\n  Node getPlaceholder() {\n    return placeholder;\n  }\n\n  MinimizedCondition setPlaceholder(Node placeholder) {\n    this.placeholder = placeholder;\n    return this;\n  }\n\n  /**\n   * Remove the passed condition node from the AST, and then return a\n   * MinimizedCondition that represents the condition node after\n   * minimization.\n   */\n  static MinimizedCondition fromConditionNode(Node n) {\n    switch (n.getType()) {\n      case Token.NOT:\n      case Token.AND:\n      case Token.OR:\n      case Token.HOOK:\n      case Token.COMMA:\n        Node placeholder = swapWithPlaceholderNode(n);\n        return computeMinimizedCondition(n).setPlaceholder(placeholder);\n      default:\n        return unoptimized(n);\n    }\n  }\n\n  /**\n   * Return the shorter representation of the original condition node.\n   * <p>\n   * Depending on the context, this may require to either penalize or\n   * not the existance of a leading NOT node.\n   * <ul><li>When {@code style} is {@code PREFER_UNNEGATED}, simply try to\n   * minimize the total length of the conditional.</li>\n   * <li>When {@code style} is {@code ALLOW_LEADING_NOT}, prefer the right side\n   * in cases such as:\n   * <br><code>\n   *    !x || !y || z  ==>  !(x && y && !z)\n   * </code><br>\n   * This is useful in contexts such as IFs or HOOKs where subsequent\n   * optimizations can efficiently deal with leading NOTs.\n   * </li></ul>\n   *\n   * @return the minimized condition MeasuredNode, with equivalent semantics\n   *   to that passed to {@link #fromConditionNode}.\n   */\n  MeasuredNode getMinimized(MinimizationStyle style) {\n    if (style == MinimizationStyle.PREFER_UNNEGATED\n        || positive.node.isNot()\n        || positive.length <= negative.length) {\n      return positive;\n    } else {\n      return negative.addNot();\n    }\n  }\n\n  /**\n   * Return a MeasuredNode of the given condition node, without minimizing\n   * the result.\n   * <p>\n   * Since a MinimizedCondition necessarily must contain two trees, this\n   * method sets the negative side to a {@link Token#SCRIPT} node (never valid\n   * inside an expression) with an unreasonably high length so that it will\n   * never be chosen by {@link #getMinimized}.\n   *\n   * @param n the conditional expression tree to minimize.\n   *  This must be connected to the AST, and will be swapped\n   *  with a placeholder node during minimization.\n   * @return a MinimizedCondition object representing that tree.\n   */\n  static MinimizedCondition unoptimized(Node n) {", "right_context": "}\n\n}", "class_name": "MinimizedCondition", "return_type": "MinimizedCondition", "parameters": [{"type": "Node", "name": "n"}]}}
{"prompt": "class MinimizedCondition {\n\n  /**\n   * Minimize the condition at the given node.\n   *\n   * @param n the conditional expression tree to minimize.\n   *  This must be connected to the AST, and will be swapped\n   *  with a placeholder node during minimization.\n   * @return a MinimizedCondition object representing that tree.\n   */\n  private static MinimizedCondition computeMinimizedCondition(Node n) {\n    Preconditions.checkArgument(n.getParent() == null);\n    switch (n.getType()) {\n      case Token.NOT: {\n        MinimizedCondition subtree =\n            computeMinimizedCondition(n.getFirstChild().detachFromParent());\n        ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n            subtree.positive.cloneTree().addNot(),\n            subtree.negative.cloneTree());\n        ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n            subtree.negative.negate(),\n            subtree.positive);\n        return new MinimizedCondition(\n            Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n            Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n      }\n      case Token.AND:\n      case Token.OR: {\n        int opType = n.getType();\n        int complementType = opType == Token.AND ? Token.OR : Token.AND;\n        MinimizedCondition leftSubtree =\n            computeMinimizedCondition(n.getFirstChild().detachFromParent());\n        MinimizedCondition rightSubtree =\n            computeMinimizedCondition(n.getLastChild().detachFromParent());\n        ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n            MeasuredNode.addNode(new Node(opType).srcref(n),\n                leftSubtree.positive.cloneTree(),\n                rightSubtree.positive.cloneTree()),\n            MeasuredNode.addNode(new Node(complementType).srcref(n),\n                leftSubtree.negative.cloneTree(),\n                rightSubtree.negative.cloneTree()).negate());\n        ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n            MeasuredNode.addNode(new Node(opType).srcref(n),\n                leftSubtree.positive,\n                rightSubtree.positive).negate(),\n            MeasuredNode.addNode(new Node(complementType).srcref(n),\n                leftSubtree.negative,\n                rightSubtree.negative));\n        return new MinimizedCondition(\n            Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n            Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n      }\n      case Token.HOOK: {\n        Node cond = n.getFirstChild();\n        Node thenNode = cond.getNext();\n        Node elseNode = thenNode.getNext();\n        MinimizedCondition thenSubtree =\n            computeMinimizedCondition(thenNode.detachFromParent());\n        MinimizedCondition elseSubtree =\n            computeMinimizedCondition(elseNode.detachFromParent());\n        MeasuredNode posTree = MeasuredNode.addNode(\n            new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n            thenSubtree.positive,\n            elseSubtree.positive);\n        MeasuredNode negTree = MeasuredNode.addNode(\n            new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n            thenSubtree.negative,\n            elseSubtree.negative);\n        return new MinimizedCondition(posTree, negTree);\n      }\n      case Token.COMMA: {\n        Node lhs = n.getFirstChild();\n        MinimizedCondition rhsSubtree =\n            computeMinimizedCondition(lhs.getNext().detachFromParent());\n        MeasuredNode posTree = MeasuredNode.addNode(\n            new Node(Token.COMMA, lhs.cloneTree()).srcref(n),\n            rhsSubtree.positive);\n        MeasuredNode negTree = MeasuredNode.addNode(\n            new Node(Token.COMMA, lhs.cloneTree()).srcref(n),\n            rhsSubtree.negative);\n        return new MinimizedCondition(posTree, negTree);\n      }\n      default: {\n        MeasuredNode pos = new MeasuredNode(n, 0, false);\n        MeasuredNode neg = pos.cloneTree().negate();\n        return new MinimizedCondition(pos, neg);\n      }\n    }\n  }\n\n  private static final Comparator<MeasuredNode> AST_LENGTH_COMPARATOR =\n      new Comparator<MeasuredNode>() {\n    @Override\n    public int compare(MeasuredNode o1, MeasuredNode o2) {\n      return o1.length - o2.length;\n    }\n  };\n\n  /** An AST-node along with some additional metadata. */\n  static class MeasuredNode {\n    private Node node;\n    private int length;\n    private boolean changed;\n\n    Node getNode() {\n      return node;\n    }\n\n    boolean isChanged() {\n      return changed;\n    }\n\n    MeasuredNode(Node n, int len, boolean ch) {\n      node = n;\n      length = len;\n      changed = ch;\n    }\n\n    private MeasuredNode negate() {\n      this.change();\n      switch (node.getType()) {\n        case Token.EQ:\n          node.setType(Token.NE);\n          return this;\n        case Token.NE:\n          node.setType(Token.EQ);\n          return this;\n        case Token.SHEQ:\n          node.setType(Token.SHNE);\n          return this;\n        case Token.SHNE:\n          node.setType(Token.SHEQ);\n          return this;\n        default:\n          return this.addNot();\n      }\n    }\n\n    private MeasuredNode change() {\n      this.changed = true;\n      return this;\n    }\n\n    private MeasuredNode addNot() {\n      node = new Node(Token.NOT, node).srcref(node);\n      length += estimateCostOneLevel(node);\n      return this;\n    }\n\n    /**\n     *  Estimate the number of characters in the textual representation of\n     *  the given node and that will be devoted to negation or parentheses.\n     *  Since these are the only characters that flipping a condition\n     *  according to De Morgan's rule can affect, these are the only ones\n     *  we count.\n     *  Not nodes are counted by the NOT node itself, whereas\n     *  parentheses around an expression are counted by the parent node.\n     *  @param n the node to be checked.\n     *  @return the number of negations and parentheses in the node.\n     */\n    private static int estimateCostOneLevel(Node n) {", "metadata": {"defects4j_task_id": "15abfe6c65d74e1dd21d695ca03a4e2eccfac00267cf470695ab1d5d4ee6d3f4", "task_id": "google_closure-compiler/21", "ground_truth": "\n      int cost = 0;\n      if (n.isNot()) {\n        cost++;  // A negation is needed.\n      }\n      int parentPrecedence = NodeUtil.precedence(n.getType());\n      for (Node child = n.getFirstChild();\n          child != null; child = child.getNext()) {\n        if (PeepholeMinimizeConditions.isLowerPrecedence(child, parentPrecedence)) {\n          cost += 2;  // A pair of parenthesis is needed.\n        }\n      }\n      return cost;\n    ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "MinimizedCondition.java"], "context_start_lineno": 0, "function_name": "estimateCostOneLevel", "left_context": "class MinimizedCondition {\n\n  /**\n   * Minimize the condition at the given node.\n   *\n   * @param n the conditional expression tree to minimize.\n   *  This must be connected to the AST, and will be swapped\n   *  with a placeholder node during minimization.\n   * @return a MinimizedCondition object representing that tree.\n   */\n  private static MinimizedCondition computeMinimizedCondition(Node n) {\n    Preconditions.checkArgument(n.getParent() == null);\n    switch (n.getType()) {\n      case Token.NOT: {\n        MinimizedCondition subtree =\n            computeMinimizedCondition(n.getFirstChild().detachFromParent());\n        ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n            subtree.positive.cloneTree().addNot(),\n            subtree.negative.cloneTree());\n        ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n            subtree.negative.negate(),\n            subtree.positive);\n        return new MinimizedCondition(\n            Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n            Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n      }\n      case Token.AND:\n      case Token.OR: {\n        int opType = n.getType();\n        int complementType = opType == Token.AND ? Token.OR : Token.AND;\n        MinimizedCondition leftSubtree =\n            computeMinimizedCondition(n.getFirstChild().detachFromParent());\n        MinimizedCondition rightSubtree =\n            computeMinimizedCondition(n.getLastChild().detachFromParent());\n        ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n            MeasuredNode.addNode(new Node(opType).srcref(n),\n                leftSubtree.positive.cloneTree(),\n                rightSubtree.positive.cloneTree()),\n            MeasuredNode.addNode(new Node(complementType).srcref(n),\n                leftSubtree.negative.cloneTree(),\n                rightSubtree.negative.cloneTree()).negate());\n        ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n            MeasuredNode.addNode(new Node(opType).srcref(n),\n                leftSubtree.positive,\n                rightSubtree.positive).negate(),\n            MeasuredNode.addNode(new Node(complementType).srcref(n),\n                leftSubtree.negative,\n                rightSubtree.negative));\n        return new MinimizedCondition(\n            Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n            Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n      }\n      case Token.HOOK: {\n        Node cond = n.getFirstChild();\n        Node thenNode = cond.getNext();\n        Node elseNode = thenNode.getNext();\n        MinimizedCondition thenSubtree =\n            computeMinimizedCondition(thenNode.detachFromParent());\n        MinimizedCondition elseSubtree =\n            computeMinimizedCondition(elseNode.detachFromParent());\n        MeasuredNode posTree = MeasuredNode.addNode(\n            new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n            thenSubtree.positive,\n            elseSubtree.positive);\n        MeasuredNode negTree = MeasuredNode.addNode(\n            new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n            thenSubtree.negative,\n            elseSubtree.negative);\n        return new MinimizedCondition(posTree, negTree);\n      }\n      case Token.COMMA: {\n        Node lhs = n.getFirstChild();\n        MinimizedCondition rhsSubtree =\n            computeMinimizedCondition(lhs.getNext().detachFromParent());\n        MeasuredNode posTree = MeasuredNode.addNode(\n            new Node(Token.COMMA, lhs.cloneTree()).srcref(n),\n            rhsSubtree.positive);\n        MeasuredNode negTree = MeasuredNode.addNode(\n            new Node(Token.COMMA, lhs.cloneTree()).srcref(n),\n            rhsSubtree.negative);\n        return new MinimizedCondition(posTree, negTree);\n      }\n      default: {\n        MeasuredNode pos = new MeasuredNode(n, 0, false);\n        MeasuredNode neg = pos.cloneTree().negate();\n        return new MinimizedCondition(pos, neg);\n      }\n    }\n  }\n\n  private static final Comparator<MeasuredNode> AST_LENGTH_COMPARATOR =\n      new Comparator<MeasuredNode>() {\n    @Override\n    public int compare(MeasuredNode o1, MeasuredNode o2) {\n      return o1.length - o2.length;\n    }\n  };\n\n  /** An AST-node along with some additional metadata. */\n  static class MeasuredNode {\n    private Node node;\n    private int length;\n    private boolean changed;\n\n    Node getNode() {\n      return node;\n    }\n\n    boolean isChanged() {\n      return changed;\n    }\n\n    MeasuredNode(Node n, int len, boolean ch) {\n      node = n;\n      length = len;\n      changed = ch;\n    }\n\n    private MeasuredNode negate() {\n      this.change();\n      switch (node.getType()) {\n        case Token.EQ:\n          node.setType(Token.NE);\n          return this;\n        case Token.NE:\n          node.setType(Token.EQ);\n          return this;\n        case Token.SHEQ:\n          node.setType(Token.SHNE);\n          return this;\n        case Token.SHNE:\n          node.setType(Token.SHEQ);\n          return this;\n        default:\n          return this.addNot();\n      }\n    }\n\n    private MeasuredNode change() {\n      this.changed = true;\n      return this;\n    }\n\n    private MeasuredNode addNot() {\n      node = new Node(Token.NOT, node).srcref(node);\n      length += estimateCostOneLevel(node);\n      return this;\n    }\n\n    /**\n     *  Estimate the number of characters in the textual representation of\n     *  the given node and that will be devoted to negation or parentheses.\n     *  Since these are the only characters that flipping a condition\n     *  according to De Morgan's rule can affect, these are the only ones\n     *  we count.\n     *  Not nodes are counted by the NOT node itself, whereas\n     *  parentheses around an expression are counted by the parent node.\n     *  @param n the node to be checked.\n     *  @return the number of negations and parentheses in the node.\n     */\n    private static int estimateCostOneLevel(Node n) {", "right_context": "}\n\n    private MeasuredNode cloneTree() {\n      return new MeasuredNode(node.cloneTree(), length, changed);\n    }\n\n    private static MeasuredNode addNode(Node parent, MeasuredNode... children) {\n      int cost = 0;\n      boolean changed = false;\n      for (MeasuredNode child : children) {\n        parent.addChildrenToBack(child.node);\n        cost += child.length;\n        changed = changed || child.changed;\n      }\n      cost += estimateCostOneLevel(parent);\n      return new MeasuredNode(parent, cost, changed);\n    }\n\n  }\n\n\n}", "class_name": "MinimizedCondition", "return_type": "int", "parameters": [{"type": "Node", "name": "n"}]}}
{"prompt": "class ExternExportsPass extends NodeTraversal.AbstractPostOrderCallback\n    implements CompilerPass {\n\n  /** A list of function names used to export properties. */\n  private List<String> exportPropertyFunctionNames;\n\n  private abstract class Export {\n    protected final String symbolName;\n    protected final Node value;\n\n    Export(String symbolName, Node value) {\n      this.symbolName = symbolName;\n      this.value = value;\n    }\n\n    /**\n     * Generates the externs representation of this export and appends\n     * it to the externsRoot AST.\n     */\n    void generateExterns() {\n      appendExtern(getExportedPath(), getValue(value));\n    }\n\n    /**\n     * Returns the path exported by this export.\n     */\n    abstract String getExportedPath();\n\n    /**\n     * Appends the exported function and all paths necessary for the path to be\n     * declared. For example, for a property \"a.b.c\", the initializers for\n     * paths \"a\", \"a.b\" will be appended (if they have not already) and a.b.c\n     * will be initialized with the exported version of the function:\n     * <pre>\n     * var a = {};\n     * a.b = {};\n     * a.b.c = function(x,y) { }\n     * </pre>\n     */\n    void appendExtern(String path, Node valueToExport) {\n      List<String> pathPrefixes = computePathPrefixes(path);\n\n      for (int i = 0; i < pathPrefixes.size(); ++i) {\n        String pathPrefix = pathPrefixes.get(i);\n\n        /* The complete path (the last path prefix) must be emitted and\n         * it gets initialized to the externed version of the value.\n         */\n        boolean isCompletePathPrefix = (i == pathPrefixes.size() - 1);\n\n        boolean skipPathPrefix = pathPrefix.endsWith(\".prototype\")\n            || (alreadyExportedPaths.contains(pathPrefix)\n                && !isCompletePathPrefix);\n\n        if (!skipPathPrefix) {\n           Node initializer;\n\n          /* Namespaces get initialized to {}, functions to\n           * externed versions of their value, and if we can't\n           * figure out where the value came from we initialize\n           * it to {}.\n           *\n           * Since externs are always exported in sorted order,\n           * we know that if we export a.b = function() {} and later\n           * a.b.c = function then a.b will always be in alreadyExportedPaths\n           * when we emit a.b.c and thus we will never overwrite the function\n           * exported for a.b with a namespace.\n           */\n\n          if (isCompletePathPrefix && valueToExport != null) {\n            if (valueToExport.isFunction()) {\n              initializer = createExternFunction(valueToExport);\n            } else {\n              Preconditions.checkState(valueToExport.isObjectLit());\n              initializer = createExternObjectLit(valueToExport);\n            }\n          } else {\n            initializer = IR.empty();\n          }\n\n          appendPathDefinition(pathPrefix, initializer);\n        }\n      }\n    }\n\n    /**\n     * Computes a list of the path prefixes constructed from the components\n     * of the path.\n     * <pre>\n     * E.g., if the path is:\n     *      \"a.b.c\"\n     * then then path prefixes will be\n     *    [\"a\",\"a.b\",\"a.b.c\"]:\n     * </pre>\n     */\n    private List<String> computePathPrefixes(String path) {\n      List<String> pieces = Lists.newArrayList(path.split(\"\\\\.\"));\n\n      List<String> pathPrefixes = Lists.newArrayList();\n\n      for (int i = 0; i < pieces.size(); i++) {\n        pathPrefixes.add(Joiner.on(\".\").join(Iterables.limit(pieces, i + 1)));\n      }\n\n      return pathPrefixes;\n    }\n\n    private void appendPathDefinition(String path, Node initializer) {\n      Node pathDefinition;\n\n      if (!path.contains(\".\")) {\n        if (initializer.isEmpty()) {\n          pathDefinition = IR.var(IR.name(path));\n        } else {\n          pathDefinition = NodeUtil.newVarNode(path, initializer);\n        }\n      } else {\n        Node qualifiedPath = NodeUtil.newQualifiedNameNode(\n            compiler.getCodingConvention(), path);\n        if (initializer.isEmpty()) {\n          pathDefinition = NodeUtil.newExpr(qualifiedPath);\n        } else {\n          pathDefinition = NodeUtil.newExpr(\n              IR.assign(qualifiedPath, initializer));\n        }\n      }\n\n      externsRoot.addChildToBack(pathDefinition);\n\n      alreadyExportedPaths.add(path);\n    }\n\n    /**\n     * Given a function to export, create the empty function that\n     * will be put in the externs file. This extern function should have\n     * the same type as the original function and the same parameter\n     * name but no function body.\n     *\n     * We create a warning here if the the function to export is missing\n     * parameter or return types.\n     */\n    private Node createExternFunction(Node exportedFunction) {", "metadata": {"defects4j_task_id": "0bc6b652908ba02091e0f230c8191ea446a616831625ff1b875c40848f603aa9", "task_id": "google_closure-compiler/13", "ground_truth": "\n      Node paramList = NodeUtil.getFunctionParameters(exportedFunction)\n          .cloneTree();\n      // Use the original parameter names so that the externs look pretty.\n      Node param = paramList.getFirstChild();\n      while (param != null && param.isName()) {\n        String originalName = (String) param.getProp(Node.ORIGINALNAME_PROP);\n        if (originalName != null) {\n          param.setString(originalName);\n        }\n        param = param.getNext();\n      }\n      Node externFunction = IR.function(IR.name(\"\"), paramList, IR.block());\n\n      externFunction.setJSType(exportedFunction.getJSType());\n\n      return externFunction;\n    ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "ExternExportsPass.java"], "context_start_lineno": 0, "function_name": "createExternFunction", "left_context": "class ExternExportsPass extends NodeTraversal.AbstractPostOrderCallback\n    implements CompilerPass {\n\n  /** A list of function names used to export properties. */\n  private List<String> exportPropertyFunctionNames;\n\n  private abstract class Export {\n    protected final String symbolName;\n    protected final Node value;\n\n    Export(String symbolName, Node value) {\n      this.symbolName = symbolName;\n      this.value = value;\n    }\n\n    /**\n     * Generates the externs representation of this export and appends\n     * it to the externsRoot AST.\n     */\n    void generateExterns() {\n      appendExtern(getExportedPath(), getValue(value));\n    }\n\n    /**\n     * Returns the path exported by this export.\n     */\n    abstract String getExportedPath();\n\n    /**\n     * Appends the exported function and all paths necessary for the path to be\n     * declared. For example, for a property \"a.b.c\", the initializers for\n     * paths \"a\", \"a.b\" will be appended (if they have not already) and a.b.c\n     * will be initialized with the exported version of the function:\n     * <pre>\n     * var a = {};\n     * a.b = {};\n     * a.b.c = function(x,y) { }\n     * </pre>\n     */\n    void appendExtern(String path, Node valueToExport) {\n      List<String> pathPrefixes = computePathPrefixes(path);\n\n      for (int i = 0; i < pathPrefixes.size(); ++i) {\n        String pathPrefix = pathPrefixes.get(i);\n\n        /* The complete path (the last path prefix) must be emitted and\n         * it gets initialized to the externed version of the value.\n         */\n        boolean isCompletePathPrefix = (i == pathPrefixes.size() - 1);\n\n        boolean skipPathPrefix = pathPrefix.endsWith(\".prototype\")\n            || (alreadyExportedPaths.contains(pathPrefix)\n                && !isCompletePathPrefix);\n\n        if (!skipPathPrefix) {\n           Node initializer;\n\n          /* Namespaces get initialized to {}, functions to\n           * externed versions of their value, and if we can't\n           * figure out where the value came from we initialize\n           * it to {}.\n           *\n           * Since externs are always exported in sorted order,\n           * we know that if we export a.b = function() {} and later\n           * a.b.c = function then a.b will always be in alreadyExportedPaths\n           * when we emit a.b.c and thus we will never overwrite the function\n           * exported for a.b with a namespace.\n           */\n\n          if (isCompletePathPrefix && valueToExport != null) {\n            if (valueToExport.isFunction()) {\n              initializer = createExternFunction(valueToExport);\n            } else {\n              Preconditions.checkState(valueToExport.isObjectLit());\n              initializer = createExternObjectLit(valueToExport);\n            }\n          } else {\n            initializer = IR.empty();\n          }\n\n          appendPathDefinition(pathPrefix, initializer);\n        }\n      }\n    }\n\n    /**\n     * Computes a list of the path prefixes constructed from the components\n     * of the path.\n     * <pre>\n     * E.g., if the path is:\n     *      \"a.b.c\"\n     * then then path prefixes will be\n     *    [\"a\",\"a.b\",\"a.b.c\"]:\n     * </pre>\n     */\n    private List<String> computePathPrefixes(String path) {\n      List<String> pieces = Lists.newArrayList(path.split(\"\\\\.\"));\n\n      List<String> pathPrefixes = Lists.newArrayList();\n\n      for (int i = 0; i < pieces.size(); i++) {\n        pathPrefixes.add(Joiner.on(\".\").join(Iterables.limit(pieces, i + 1)));\n      }\n\n      return pathPrefixes;\n    }\n\n    private void appendPathDefinition(String path, Node initializer) {\n      Node pathDefinition;\n\n      if (!path.contains(\".\")) {\n        if (initializer.isEmpty()) {\n          pathDefinition = IR.var(IR.name(path));\n        } else {\n          pathDefinition = NodeUtil.newVarNode(path, initializer);\n        }\n      } else {\n        Node qualifiedPath = NodeUtil.newQualifiedNameNode(\n            compiler.getCodingConvention(), path);\n        if (initializer.isEmpty()) {\n          pathDefinition = NodeUtil.newExpr(qualifiedPath);\n        } else {\n          pathDefinition = NodeUtil.newExpr(\n              IR.assign(qualifiedPath, initializer));\n        }\n      }\n\n      externsRoot.addChildToBack(pathDefinition);\n\n      alreadyExportedPaths.add(path);\n    }\n\n    /**\n     * Given a function to export, create the empty function that\n     * will be put in the externs file. This extern function should have\n     * the same type as the original function and the same parameter\n     * name but no function body.\n     *\n     * We create a warning here if the the function to export is missing\n     * parameter or return types.\n     */\n    private Node createExternFunction(Node exportedFunction) {", "right_context": "}\n\n    /**\n     * Given an object literal to export, create an object lit with all its\n     * string properties. We don't care what the values of those properties\n     * are because they are not checked.\n     */\n    private Node createExternObjectLit(Node exportedObjectLit) {\n      Node lit = IR.objectlit();\n      lit.setJSType(exportedObjectLit.getJSType());\n\n      // This is an indirect way of telling the typed code generator\n      // \"print the type of this\"\n      lit.setJSDocInfo(new JSDocInfo());\n\n      int index = 1;\n      for (Node child = exportedObjectLit.getFirstChild();\n           child != null;\n           child = child.getNext()) {\n        // TODO(user): handle getters or setters?\n        if (child.isStringKey()) {\n          lit.addChildToBack(\n              IR.propdef(\n                  IR.stringKey(child.getString()),\n                  IR.number(index++)));\n        }\n      }\n      return lit;\n    }\n\n    /**\n     * If the given value is a qualified name which refers\n     * a function or object literal, the node is returned. Otherwise,\n     * {@code null} is returned.\n     */\n    protected Node getValue(Node qualifiedNameNode) {\n      String qualifiedName = value.getQualifiedName();\n\n      if (qualifiedName == null) {\n        return null;\n      }\n\n      Node definitionParent = definitionMap.get(qualifiedName);\n      if (definitionParent == null) {\n        return null;\n      }\n\n      Node definition;\n\n      switch (definitionParent.getType()) {\n        case Token.ASSIGN:\n          definition = definitionParent.getLastChild();\n          break;\n        case Token.VAR:\n          definition = definitionParent.getLastChild().getLastChild();\n          break;\n        case Token.FUNCTION:\n          if (NodeUtil.isFunctionDeclaration(definitionParent)) {\n            definition = definitionParent;\n          } else {\n            return null;\n          }\n          break;\n        default:\n            return null;\n      }\n\n      if (!definition.isFunction() && !definition.isObjectLit()) {\n        return null;\n      }\n\n      return definition;\n    }\n  }\n\n}", "class_name": "ExternExportsPass", "return_type": "Node", "parameters": [{"type": "Node", "name": "exportedFunction"}]}}
{"prompt": "class ReplaceStrings extends AbstractPostOrderCallback\n    implements CompilerPass {\n  private void initMapping(\n      VariableMap previousVarMap, Set<String> reservedNames) {\n    Map<String, String> previous = previousVarMap.getOriginalNameToNewNameMap();\n    for (Map.Entry<String, String> entry : previous.entrySet()) {\n      String key = entry.getKey();\n      if (!reservedNames.contains(key)) {\n        String value = entry.getValue();\n        results.put(value, new Result(value, key));\n      }\n    }\n  }\n\n  static final Predicate<Result> USED_RESULTS = new Predicate<Result>() {\n    @Override\n    public boolean apply(Result result) {\n      // The list of locations may be empty if the map\n      // was pre-populated from a previous map.\n      return !result.replacementLocations.isEmpty();\n    }\n  };\n\n  // Get the list of all replacements performed.\n  List<Result> getResult() {\n    return ImmutableList.copyOf(\n        Iterables.filter(results.values(), USED_RESULTS));\n  }\n\n  // Get the list of replaces as a VariableMap\n  VariableMap getStringMap() {\n    ImmutableMap.Builder<String, String> map = ImmutableMap.builder();\n    for (Result result : Iterables.filter(results.values(), USED_RESULTS)) {\n      map.put(result.replacement, result.original);\n    }\n\n    VariableMap stringMap = new VariableMap(map.build());\n    return stringMap;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // TODO(johnlenz): Determine if it is necessary to support \".call\" or\n    // \".apply\".\n    switch (n.getType()) {\n      case Token.NEW: // e.g. new Error('msg');\n      case Token.CALL: // e.g. Error('msg');\n        Node calledFn = n.getFirstChild();\n\n        // Look for calls to static functions.\n        String name = calledFn.getQualifiedName();\n        if (name != null) {\n          Config config = findMatching(name);\n          if (config != null) {\n            doSubstitutions(t, config, n);\n            return;\n          }\n        }\n\n        // Look for calls to class methods.\n        if (NodeUtil.isGet(calledFn)) {\n          Node rhs = calledFn.getLastChild();\n          if (rhs.isName() || rhs.isString()) {\n            String methodName = rhs.getString();\n            Collection<String> classes = methods.get(methodName);\n            if (classes != null) {\n              Node lhs = calledFn.getFirstChild();\n              if (lhs.getJSType() != null) {\n                JSType type = lhs.getJSType().restrictByNotNullOrUndefined();\n                Config config = findMatchingClass(type, classes);\n                if (config != null) {\n                  doSubstitutions(t, config, n);\n                  return;\n                }\n              }\n            }\n          }\n        }\n        break;\n    }\n  }\n\n  /**\n   * @param name The function name to find.\n   * @return The Config object for the name or null if no match was found.\n   */\n  private Config findMatching(String name) {\n    Config config = functions.get(name);\n    if (config == null) {\n      name = name.replace('$', '.');\n      config = functions.get(name);\n    }\n    return config;\n  }\n\n  /**\n   * @return The Config object for the class match the specified type or null\n   * if no match was found.\n   */\n  private Config findMatchingClass(\n      JSType callClassType, Collection<String> declarationNames) {\n    if (!callClassType.isNoObjectType() && !callClassType.isUnknownType()) {\n      for (String declarationName : declarationNames) {\n        String className = getClassFromDeclarationName(declarationName);\n        JSType methodClassType = registry.getType(className);\n        if (methodClassType != null\n            && callClassType.isSubtype(methodClassType)) {\n          return functions.get(declarationName);\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Replace the parameters specified in the config, if possible.\n   */\n  private void doSubstitutions(NodeTraversal t, Config config, Node n) {\n    Preconditions.checkState(\n        n.isNew() || n.isCall());\n\n    if (config.parameter != Config.REPLACE_ALL_VALUE) {\n      // Note: the first child is the function, but the parameter id is 1 based.\n      Node arg = n.getChildAtIndex(config.parameter);\n      if (arg != null) {\n        replaceExpression(t, arg, n);\n      }\n    } else {\n      // Replace all parameters.\n      Node firstParam = n.getFirstChild().getNext();\n      for (Node arg = firstParam; arg != null; arg = arg.getNext()) {\n        arg = replaceExpression(t, arg, n);\n      }\n    }\n  }\n\n  /**\n   * Replaces a string expression with a short encoded string expression.\n   *\n   * @param t The traversal\n   * @param expr The expression node\n   * @param parent The expression node's parent\n   * @return The replacement node (or the original expression if no replacement\n   *         is made)\n   */\n  private Node replaceExpression(NodeTraversal t, Node expr, Node parent) {", "metadata": {"defects4j_task_id": "b1fe5a95c64c296d923520e7c39c6a16d26fe3e7a74cb27aec2b049828d4219f", "task_id": "google_closure-compiler/151", "ground_truth": "\n    Node replacement;\n    String key = null;\n    String replacementString;\n    switch (expr.getType()) {\n      case Token.STRING:\n        key = expr.getString();\n        replacementString = getReplacement(key);\n        replacement = IR.string(replacementString);\n        break;\n      case Token.ADD:\n        StringBuilder keyBuilder = new StringBuilder();\n        Node keyNode = IR.string(\"\");\n        replacement = buildReplacement(expr, keyNode, keyBuilder);\n        key = keyBuilder.toString();\n        replacementString = getReplacement(key);\n        keyNode.setString(replacementString);\n        break;\n      case Token.NAME:\n        // If the referenced variable is a constant, use its value.\n        Scope.Var var = t.getScope().getVar(expr.getString());\n        if (var != null && var.isConst()) {\n          Node value = var.getInitialValue();\n          if (value != null && value.isString()) {\n            key = value.getString();\n            replacementString = getReplacement(key);\n            replacement = IR.string(replacementString);\n            break;\n          }\n        }\n        return expr;\n      default:\n        // This may be a function call or a variable reference. We don't\n        // replace these.\n        return expr;\n    }\n\n    Preconditions.checkNotNull(key);\n    Preconditions.checkNotNull(replacementString);\n    recordReplacement(expr, key);\n\n    parent.replaceChild(expr, replacement);\n    compiler.reportCodeChange();\n    return replacement;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "ReplaceStrings.java"], "context_start_lineno": 0, "function_name": "replaceExpression", "left_context": "class ReplaceStrings extends AbstractPostOrderCallback\n    implements CompilerPass {\n  private void initMapping(\n      VariableMap previousVarMap, Set<String> reservedNames) {\n    Map<String, String> previous = previousVarMap.getOriginalNameToNewNameMap();\n    for (Map.Entry<String, String> entry : previous.entrySet()) {\n      String key = entry.getKey();\n      if (!reservedNames.contains(key)) {\n        String value = entry.getValue();\n        results.put(value, new Result(value, key));\n      }\n    }\n  }\n\n  static final Predicate<Result> USED_RESULTS = new Predicate<Result>() {\n    @Override\n    public boolean apply(Result result) {\n      // The list of locations may be empty if the map\n      // was pre-populated from a previous map.\n      return !result.replacementLocations.isEmpty();\n    }\n  };\n\n  // Get the list of all replacements performed.\n  List<Result> getResult() {\n    return ImmutableList.copyOf(\n        Iterables.filter(results.values(), USED_RESULTS));\n  }\n\n  // Get the list of replaces as a VariableMap\n  VariableMap getStringMap() {\n    ImmutableMap.Builder<String, String> map = ImmutableMap.builder();\n    for (Result result : Iterables.filter(results.values(), USED_RESULTS)) {\n      map.put(result.replacement, result.original);\n    }\n\n    VariableMap stringMap = new VariableMap(map.build());\n    return stringMap;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // TODO(johnlenz): Determine if it is necessary to support \".call\" or\n    // \".apply\".\n    switch (n.getType()) {\n      case Token.NEW: // e.g. new Error('msg');\n      case Token.CALL: // e.g. Error('msg');\n        Node calledFn = n.getFirstChild();\n\n        // Look for calls to static functions.\n        String name = calledFn.getQualifiedName();\n        if (name != null) {\n          Config config = findMatching(name);\n          if (config != null) {\n            doSubstitutions(t, config, n);\n            return;\n          }\n        }\n\n        // Look for calls to class methods.\n        if (NodeUtil.isGet(calledFn)) {\n          Node rhs = calledFn.getLastChild();\n          if (rhs.isName() || rhs.isString()) {\n            String methodName = rhs.getString();\n            Collection<String> classes = methods.get(methodName);\n            if (classes != null) {\n              Node lhs = calledFn.getFirstChild();\n              if (lhs.getJSType() != null) {\n                JSType type = lhs.getJSType().restrictByNotNullOrUndefined();\n                Config config = findMatchingClass(type, classes);\n                if (config != null) {\n                  doSubstitutions(t, config, n);\n                  return;\n                }\n              }\n            }\n          }\n        }\n        break;\n    }\n  }\n\n  /**\n   * @param name The function name to find.\n   * @return The Config object for the name or null if no match was found.\n   */\n  private Config findMatching(String name) {\n    Config config = functions.get(name);\n    if (config == null) {\n      name = name.replace('$', '.');\n      config = functions.get(name);\n    }\n    return config;\n  }\n\n  /**\n   * @return The Config object for the class match the specified type or null\n   * if no match was found.\n   */\n  private Config findMatchingClass(\n      JSType callClassType, Collection<String> declarationNames) {\n    if (!callClassType.isNoObjectType() && !callClassType.isUnknownType()) {\n      for (String declarationName : declarationNames) {\n        String className = getClassFromDeclarationName(declarationName);\n        JSType methodClassType = registry.getType(className);\n        if (methodClassType != null\n            && callClassType.isSubtype(methodClassType)) {\n          return functions.get(declarationName);\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Replace the parameters specified in the config, if possible.\n   */\n  private void doSubstitutions(NodeTraversal t, Config config, Node n) {\n    Preconditions.checkState(\n        n.isNew() || n.isCall());\n\n    if (config.parameter != Config.REPLACE_ALL_VALUE) {\n      // Note: the first child is the function, but the parameter id is 1 based.\n      Node arg = n.getChildAtIndex(config.parameter);\n      if (arg != null) {\n        replaceExpression(t, arg, n);\n      }\n    } else {\n      // Replace all parameters.\n      Node firstParam = n.getFirstChild().getNext();\n      for (Node arg = firstParam; arg != null; arg = arg.getNext()) {\n        arg = replaceExpression(t, arg, n);\n      }\n    }\n  }\n\n  /**\n   * Replaces a string expression with a short encoded string expression.\n   *\n   * @param t The traversal\n   * @param expr The expression node\n   * @param parent The expression node's parent\n   * @return The replacement node (or the original expression if no replacement\n   *         is made)\n   */\n  private Node replaceExpression(NodeTraversal t, Node expr, Node parent) {", "right_context": "}\n}", "class_name": "ReplaceStrings", "return_type": "Node", "parameters": [{"type": "NodeTraversal", "name": "t"}, {"type": "Node", "name": "expr"}, {"type": "Node", "name": "parent"}]}}
{"prompt": "class ExpressionDecomposer {\n\n  /**\n   * Rewrite the call so \"this\" is preserved.\n   *   a.b(c);\n   * becomes:\n   *   var temp1 = a;\n   *   var temp0 = temp1.b;\n   *   temp0.call(temp1,c);\n   *\n   * @return The replacement node.\n   */\n  private Node rewriteCallExpression(Node call, DecompositionState state) {\n    Preconditions.checkArgument(call.isCall());\n    Node first = call.getFirstChild();\n    Preconditions.checkArgument(NodeUtil.isGet(first));\n\n    // Extracts the expression representing the function to call. For example:\n    //   \"a['b'].c\" from \"a['b'].c()\"\n    Node getVarNode = extractExpression(\n        first, state.extractBeforeStatement);\n    state.extractBeforeStatement = getVarNode;\n\n    // Extracts the object reference to be used as \"this\". For example:\n    //   \"a['b']\" from \"a['b'].c\"\n    Node getExprNode = getVarNode.getFirstChild().getFirstChild();\n    Preconditions.checkArgument(NodeUtil.isGet(getExprNode));\n    Node thisVarNode = extractExpression(\n        getExprNode.getFirstChild(), state.extractBeforeStatement);\n    state.extractBeforeStatement = thisVarNode;\n\n    // Rewrite the CALL expression.\n    Node thisNameNode = thisVarNode.getFirstChild();\n    Node functionNameNode = getVarNode.getFirstChild();\n\n    // CALL\n    //   GETPROP\n    //     functionName\n    //     \"call\"\n    //   thisName\n    //   original-parameter1\n    //   original-parameter2\n    //   ...\n    Node newCall = IR.call(\n        IR.getprop(\n            functionNameNode.cloneNode(),\n            IR.string(\"call\")),\n        thisNameNode.cloneNode()).srcref(call);\n\n    // Throw away the call name\n    call.removeFirstChild();\n    if (call.hasChildren()) {\n      // Add the call parameters to the new call.\n      newCall.addChildrenToBack(call.removeChildren());\n    }\n\n    // Replace the call.\n    Node callParent = call.getParent();\n    callParent.replaceChild(call, newCall);\n\n    return newCall;\n  }\n\n  private String tempNamePrefix = \"JSCompiler_temp\";\n  private String resultNamePrefix = \"JSCompiler_inline_result\";\n\n  /**\n   * Allow the temp name to be overridden to make tests more readable.\n   */\n  @VisibleForTesting\n  public void setTempNamePrefix(String prefix) {\n    this.tempNamePrefix = prefix;\n  }\n\n  /**\n   * Create a unique temp name.\n   */\n  private String getTempValueName(){\n    return tempNamePrefix + ContextualRenamer.UNIQUE_ID_SEPARATOR\n        + safeNameIdSupplier.get();\n  }\n\n  /**\n   * Allow the temp name to be overridden to make tests more readable.\n   */\n  @VisibleForTesting\n  public void setResultNamePrefix(String prefix) {\n    this.resultNamePrefix = prefix;\n  }\n\n  /**\n   * Create a unique name for call results.\n   */\n  private String getResultValueName() {\n    return resultNamePrefix\n        + ContextualRenamer.UNIQUE_ID_SEPARATOR + safeNameIdSupplier.get();\n  }\n\n  /**\n   * Create a constant unique temp name.\n   */\n  private String getTempConstantValueName(){\n    String name = tempNamePrefix + \"_const\"\n        + ContextualRenamer.UNIQUE_ID_SEPARATOR\n        + safeNameIdSupplier.get();\n    this.knownConstants.add(name);\n    return name;\n  }\n\n  /**\n   * @return For the subExpression, find the nearest statement Node before which\n   * it can be inlined.  Null if no such location can be found.\n   */\n  static Node findInjectionPoint(Node subExpression) {\n    Node expressionRoot = findExpressionRoot(subExpression);\n    Preconditions.checkNotNull(expressionRoot);\n\n    Node injectionPoint = expressionRoot;\n\n    Node parent = injectionPoint.getParent();\n    while (parent.isLabel()) {\n      injectionPoint = parent;\n      parent = injectionPoint.getParent();\n    }\n\n    Preconditions.checkState(\n        NodeUtil.isStatementBlock(injectionPoint.getParent()));\n    return injectionPoint;\n  }\n\n  /**\n   * @return Whether the node is a conditional op.\n   */\n  private static boolean isConditionalOp(Node n) {\n    switch(n.getType()) {\n      case Token.HOOK:\n      case Token.AND:\n      case Token.OR:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * @return The statement containing the expression. null if subExpression\n   *     is not contain by in by a Node where inlining is known to be possible.\n   *     For example, a WHILE node condition expression.\n   */\n  static Node findExpressionRoot(Node subExpression) {\n    Node child = subExpression;\n    for (Node parent : child.getAncestors()) {\n      int parentType = parent.getType();\n      switch (parentType) {\n        // Supported expression roots:\n        // SWITCH and IF can have multiple children, but the CASE, DEFAULT,\n        // or BLOCK will be encountered first for any of the children other\n        // than the condition.\n        case Token.EXPR_RESULT:\n        case Token.IF:\n        case Token.SWITCH:\n        case Token.RETURN:\n        case Token.VAR:\n          Preconditions.checkState(child == parent.getFirstChild());\n          return parent;\n        // Any of these indicate an unsupported expression:\n        case Token.SCRIPT:\n        case Token.BLOCK:\n        case Token.LABEL:\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n          return null;\n      }\n      child = parent;\n    }\n\n    throw new IllegalStateException(\"Unexpected AST structure.\");\n  }\n\n  /**\n   * Determine whether a expression is movable, or can be be made movable be\n   * decomposing the containing expression.\n   *\n   * An subExpression is MOVABLE if it can be replaced with a temporary holding\n   * its results and moved to immediately before the root of the expression.\n   * There are three conditions that must be met for this to occur:\n   * 1) There must be a location to inject a statement for the expression.  For\n   * example, this condition can not be met if the expression is a loop\n   * condition or CASE condition.\n   * 2) If the expression can be affect by side-effects, there can not be a\n   * side-effect between original location and the expression root.\n   * 3) If the expression has side-effects, there can not be any other\n   * expression that can be effected between the original location and the\n   * expression root.\n   *\n   * An expression is DECOMPOSABLE if it can be rewritten so that an\n   * subExpression is MOVABLE.\n   *\n   * An expression is decomposed by moving any other sub-expressions that\n   * preventing an subExpression from being MOVABLE.\n   *\n   * @return Whether This is a call that can be moved to an new point in the\n   * AST to allow it to be inlined.\n   */\n  DecompositionType canExposeExpression(Node subExpression) {", "metadata": {"defects4j_task_id": "399bbb7eb06a5e9883f399becb93a9a369fb6528781af1393cdfe5fd6938f606", "task_id": "google_closure-compiler/51", "ground_truth": "\n    Node expressionRoot = findExpressionRoot(subExpression);\n    if (expressionRoot != null) {\n      return isSubexpressionMovable(expressionRoot, subExpression);\n    }\n    return DecompositionType.UNDECOMPOSABLE;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "ExpressionDecomposer.java"], "context_start_lineno": 0, "function_name": "canExposeExpression", "left_context": "class ExpressionDecomposer {\n\n  /**\n   * Rewrite the call so \"this\" is preserved.\n   *   a.b(c);\n   * becomes:\n   *   var temp1 = a;\n   *   var temp0 = temp1.b;\n   *   temp0.call(temp1,c);\n   *\n   * @return The replacement node.\n   */\n  private Node rewriteCallExpression(Node call, DecompositionState state) {\n    Preconditions.checkArgument(call.isCall());\n    Node first = call.getFirstChild();\n    Preconditions.checkArgument(NodeUtil.isGet(first));\n\n    // Extracts the expression representing the function to call. For example:\n    //   \"a['b'].c\" from \"a['b'].c()\"\n    Node getVarNode = extractExpression(\n        first, state.extractBeforeStatement);\n    state.extractBeforeStatement = getVarNode;\n\n    // Extracts the object reference to be used as \"this\". For example:\n    //   \"a['b']\" from \"a['b'].c\"\n    Node getExprNode = getVarNode.getFirstChild().getFirstChild();\n    Preconditions.checkArgument(NodeUtil.isGet(getExprNode));\n    Node thisVarNode = extractExpression(\n        getExprNode.getFirstChild(), state.extractBeforeStatement);\n    state.extractBeforeStatement = thisVarNode;\n\n    // Rewrite the CALL expression.\n    Node thisNameNode = thisVarNode.getFirstChild();\n    Node functionNameNode = getVarNode.getFirstChild();\n\n    // CALL\n    //   GETPROP\n    //     functionName\n    //     \"call\"\n    //   thisName\n    //   original-parameter1\n    //   original-parameter2\n    //   ...\n    Node newCall = IR.call(\n        IR.getprop(\n            functionNameNode.cloneNode(),\n            IR.string(\"call\")),\n        thisNameNode.cloneNode()).srcref(call);\n\n    // Throw away the call name\n    call.removeFirstChild();\n    if (call.hasChildren()) {\n      // Add the call parameters to the new call.\n      newCall.addChildrenToBack(call.removeChildren());\n    }\n\n    // Replace the call.\n    Node callParent = call.getParent();\n    callParent.replaceChild(call, newCall);\n\n    return newCall;\n  }\n\n  private String tempNamePrefix = \"JSCompiler_temp\";\n  private String resultNamePrefix = \"JSCompiler_inline_result\";\n\n  /**\n   * Allow the temp name to be overridden to make tests more readable.\n   */\n  @VisibleForTesting\n  public void setTempNamePrefix(String prefix) {\n    this.tempNamePrefix = prefix;\n  }\n\n  /**\n   * Create a unique temp name.\n   */\n  private String getTempValueName(){\n    return tempNamePrefix + ContextualRenamer.UNIQUE_ID_SEPARATOR\n        + safeNameIdSupplier.get();\n  }\n\n  /**\n   * Allow the temp name to be overridden to make tests more readable.\n   */\n  @VisibleForTesting\n  public void setResultNamePrefix(String prefix) {\n    this.resultNamePrefix = prefix;\n  }\n\n  /**\n   * Create a unique name for call results.\n   */\n  private String getResultValueName() {\n    return resultNamePrefix\n        + ContextualRenamer.UNIQUE_ID_SEPARATOR + safeNameIdSupplier.get();\n  }\n\n  /**\n   * Create a constant unique temp name.\n   */\n  private String getTempConstantValueName(){\n    String name = tempNamePrefix + \"_const\"\n        + ContextualRenamer.UNIQUE_ID_SEPARATOR\n        + safeNameIdSupplier.get();\n    this.knownConstants.add(name);\n    return name;\n  }\n\n  /**\n   * @return For the subExpression, find the nearest statement Node before which\n   * it can be inlined.  Null if no such location can be found.\n   */\n  static Node findInjectionPoint(Node subExpression) {\n    Node expressionRoot = findExpressionRoot(subExpression);\n    Preconditions.checkNotNull(expressionRoot);\n\n    Node injectionPoint = expressionRoot;\n\n    Node parent = injectionPoint.getParent();\n    while (parent.isLabel()) {\n      injectionPoint = parent;\n      parent = injectionPoint.getParent();\n    }\n\n    Preconditions.checkState(\n        NodeUtil.isStatementBlock(injectionPoint.getParent()));\n    return injectionPoint;\n  }\n\n  /**\n   * @return Whether the node is a conditional op.\n   */\n  private static boolean isConditionalOp(Node n) {\n    switch(n.getType()) {\n      case Token.HOOK:\n      case Token.AND:\n      case Token.OR:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * @return The statement containing the expression. null if subExpression\n   *     is not contain by in by a Node where inlining is known to be possible.\n   *     For example, a WHILE node condition expression.\n   */\n  static Node findExpressionRoot(Node subExpression) {\n    Node child = subExpression;\n    for (Node parent : child.getAncestors()) {\n      int parentType = parent.getType();\n      switch (parentType) {\n        // Supported expression roots:\n        // SWITCH and IF can have multiple children, but the CASE, DEFAULT,\n        // or BLOCK will be encountered first for any of the children other\n        // than the condition.\n        case Token.EXPR_RESULT:\n        case Token.IF:\n        case Token.SWITCH:\n        case Token.RETURN:\n        case Token.VAR:\n          Preconditions.checkState(child == parent.getFirstChild());\n          return parent;\n        // Any of these indicate an unsupported expression:\n        case Token.SCRIPT:\n        case Token.BLOCK:\n        case Token.LABEL:\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n          return null;\n      }\n      child = parent;\n    }\n\n    throw new IllegalStateException(\"Unexpected AST structure.\");\n  }\n\n  /**\n   * Determine whether a expression is movable, or can be be made movable be\n   * decomposing the containing expression.\n   *\n   * An subExpression is MOVABLE if it can be replaced with a temporary holding\n   * its results and moved to immediately before the root of the expression.\n   * There are three conditions that must be met for this to occur:\n   * 1) There must be a location to inject a statement for the expression.  For\n   * example, this condition can not be met if the expression is a loop\n   * condition or CASE condition.\n   * 2) If the expression can be affect by side-effects, there can not be a\n   * side-effect between original location and the expression root.\n   * 3) If the expression has side-effects, there can not be any other\n   * expression that can be effected between the original location and the\n   * expression root.\n   *\n   * An expression is DECOMPOSABLE if it can be rewritten so that an\n   * subExpression is MOVABLE.\n   *\n   * An expression is decomposed by moving any other sub-expressions that\n   * preventing an subExpression from being MOVABLE.\n   *\n   * @return Whether This is a call that can be moved to an new point in the\n   * AST to allow it to be inlined.\n   */\n  DecompositionType canExposeExpression(Node subExpression) {", "right_context": "}\n}", "class_name": "ExpressionDecomposer", "return_type": "DecompositionType", "parameters": [{"type": "Node", "name": "subExpression"}]}}
{"prompt": "class SymbolTable\n    implements StaticSymbolTable<SymbolTable.Symbol, SymbolTable.Reference> {\n  /**\n   * The name we use for the JavaScript built-in Global object.  It's\n   * anonymous in JavaScript, so we have to give it an invalid identifier\n   * to avoid conflicts with user-defined property names.\n   */\n  public static final String GLOBAL_THIS = \"*global*\";\n\n  /**\n   * All symbols in the program, uniquely identified by the node where\n   * they're declared and their name.\n   */\n  private final Table<Node, String, Symbol> symbols = HashBasedTable.create();\n\n  /**\n   * All syntactic scopes in the program, uniquely identified by the node where\n   * they're declared.\n   */\n  private final Map<Node, SymbolScope> scopes = Maps.newLinkedHashMap();\n\n  /**\n   * All JSDocInfo in the program.\n   */\n  private final List<JSDocInfo> docInfos = Lists.newArrayList();\n\n  private SymbolScope globalScope = null;\n\n  private final JSTypeRegistry registry;\n\n  /**\n   * Clients should get a symbol table by asking the compiler at the end\n   * of a compilation job.\n   */\n  SymbolTable(JSTypeRegistry registry) {\n    this.registry = registry;\n  }\n\n  @Override\n  public Iterable<Reference> getReferences(Symbol symbol) {\n    return Collections.unmodifiableCollection(symbol.references.values());\n  }\n\n  public List<Reference> getReferenceList(Symbol symbol) {\n    return ImmutableList.copyOf(symbol.references.values());\n  }\n\n  @Override\n  public Iterable<Symbol> getAllSymbols() {\n    return Collections.unmodifiableCollection(symbols.values());\n  }\n\n  /**\n   * Get the symbols in their natural ordering.\n   * Always returns a mutable list.\n   */\n  public List<Symbol> getAllSymbolsSorted() {\n    List<Symbol> sortedSymbols = Lists.newArrayList(symbols.values());\n    Collections.sort(sortedSymbols, getNaturalSymbolOrdering());\n    return sortedSymbols;\n  }\n\n  /**\n   * Gets the 'natural' ordering of symbols.\n   *\n   * Right now, we only guarantee that symbols in the global scope will come\n   * before symbols in local scopes. After that, the order is deterministic but\n   * undefined.\n   */\n  public Ordering<Symbol> getNaturalSymbolOrdering() {\n    return symbolOrdering;\n  }\n\n  @Override\n  public SymbolScope getScope(Symbol slot) {\n    return slot.scope;\n  }\n\n  public Collection<JSDocInfo> getAllJSDocInfo() {\n    return Collections.unmodifiableList(docInfos);\n  }\n\n  /**\n   * Declare a symbol after the main symbol table was constructed.\n   * Throws an exception if you try to declare a symbol twice.\n   */\n  public Symbol declareInferredSymbol(\n      SymbolScope scope, String name, Node declNode) {\n    return declareSymbol(name, null, true, scope, declNode, null);\n  }\n\n  /**\n   * Gets the scope that contains the given node.\n   * If {@code n} is a function name, we return the scope that contains the\n   * function, not the function itself.\n   */\n  public SymbolScope getEnclosingScope(Node n) {\n    Node current = n.getParent();\n    if (n.isName() &&\n        n.getParent().isFunction()) {\n      current = current.getParent();\n    }\n\n    for (; current != null; current = current.getParent()) {\n      if (scopes.containsKey(current)) {\n        return scopes.get(current);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * If {@code sym} is a function, try to find a Symbol for\n   * a parameter with the given name.\n   *\n   * Returns null if we couldn't find one.\n   *\n   * Notice that this just makes a best effort, and may not be able\n   * to find parameters for non-conventional function definitions.\n   * For example, we would not be able to find \"y\" in this code:\n   * <code>\n   * var x = x() ? function(y) {} : function(y) {};\n   * </code>\n   */\n  public Symbol getParameterInFunction(Symbol sym, String paramName) {", "metadata": {"defects4j_task_id": "85daa5271db3c3a6a9e7bd00008164062904f36fcd7e63ae317bd83c6fb01e5e", "task_id": "google_closure-compiler/110", "ground_truth": "\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope != null) {\n      Symbol param = scope.getSlot(paramName);\n      if (param != null && param.scope == scope) {\n        return param;\n      }\n    }\n    return null;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "SymbolTable.java"], "context_start_lineno": 0, "function_name": "getParameterInFunction", "left_context": "class SymbolTable\n    implements StaticSymbolTable<SymbolTable.Symbol, SymbolTable.Reference> {\n  /**\n   * The name we use for the JavaScript built-in Global object.  It's\n   * anonymous in JavaScript, so we have to give it an invalid identifier\n   * to avoid conflicts with user-defined property names.\n   */\n  public static final String GLOBAL_THIS = \"*global*\";\n\n  /**\n   * All symbols in the program, uniquely identified by the node where\n   * they're declared and their name.\n   */\n  private final Table<Node, String, Symbol> symbols = HashBasedTable.create();\n\n  /**\n   * All syntactic scopes in the program, uniquely identified by the node where\n   * they're declared.\n   */\n  private final Map<Node, SymbolScope> scopes = Maps.newLinkedHashMap();\n\n  /**\n   * All JSDocInfo in the program.\n   */\n  private final List<JSDocInfo> docInfos = Lists.newArrayList();\n\n  private SymbolScope globalScope = null;\n\n  private final JSTypeRegistry registry;\n\n  /**\n   * Clients should get a symbol table by asking the compiler at the end\n   * of a compilation job.\n   */\n  SymbolTable(JSTypeRegistry registry) {\n    this.registry = registry;\n  }\n\n  @Override\n  public Iterable<Reference> getReferences(Symbol symbol) {\n    return Collections.unmodifiableCollection(symbol.references.values());\n  }\n\n  public List<Reference> getReferenceList(Symbol symbol) {\n    return ImmutableList.copyOf(symbol.references.values());\n  }\n\n  @Override\n  public Iterable<Symbol> getAllSymbols() {\n    return Collections.unmodifiableCollection(symbols.values());\n  }\n\n  /**\n   * Get the symbols in their natural ordering.\n   * Always returns a mutable list.\n   */\n  public List<Symbol> getAllSymbolsSorted() {\n    List<Symbol> sortedSymbols = Lists.newArrayList(symbols.values());\n    Collections.sort(sortedSymbols, getNaturalSymbolOrdering());\n    return sortedSymbols;\n  }\n\n  /**\n   * Gets the 'natural' ordering of symbols.\n   *\n   * Right now, we only guarantee that symbols in the global scope will come\n   * before symbols in local scopes. After that, the order is deterministic but\n   * undefined.\n   */\n  public Ordering<Symbol> getNaturalSymbolOrdering() {\n    return symbolOrdering;\n  }\n\n  @Override\n  public SymbolScope getScope(Symbol slot) {\n    return slot.scope;\n  }\n\n  public Collection<JSDocInfo> getAllJSDocInfo() {\n    return Collections.unmodifiableList(docInfos);\n  }\n\n  /**\n   * Declare a symbol after the main symbol table was constructed.\n   * Throws an exception if you try to declare a symbol twice.\n   */\n  public Symbol declareInferredSymbol(\n      SymbolScope scope, String name, Node declNode) {\n    return declareSymbol(name, null, true, scope, declNode, null);\n  }\n\n  /**\n   * Gets the scope that contains the given node.\n   * If {@code n} is a function name, we return the scope that contains the\n   * function, not the function itself.\n   */\n  public SymbolScope getEnclosingScope(Node n) {\n    Node current = n.getParent();\n    if (n.isName() &&\n        n.getParent().isFunction()) {\n      current = current.getParent();\n    }\n\n    for (; current != null; current = current.getParent()) {\n      if (scopes.containsKey(current)) {\n        return scopes.get(current);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * If {@code sym} is a function, try to find a Symbol for\n   * a parameter with the given name.\n   *\n   * Returns null if we couldn't find one.\n   *\n   * Notice that this just makes a best effort, and may not be able\n   * to find parameters for non-conventional function definitions.\n   * For example, we would not be able to find \"y\" in this code:\n   * <code>\n   * var x = x() ? function(y) {} : function(y) {};\n   * </code>\n   */\n  public Symbol getParameterInFunction(Symbol sym, String paramName) {", "right_context": "}\n}", "class_name": "SymbolTable", "return_type": "Symbol", "parameters": [{"type": "Symbol", "name": "sym"}, {"type": "String", "name": "paramName"}]}}
{"prompt": "class SymbolTable\n    implements StaticSymbolTable<SymbolTable.Symbol, SymbolTable.Reference> {\n  /** Collects references to types in JSDocInfo. */\n  private class JSDocInfoCollector\n      extends NodeTraversal.AbstractPostOrderCallback {\n    private final JSTypeRegistry typeRegistry;\n\n    private JSDocInfoCollector(JSTypeRegistry registry) {\n      this.typeRegistry = registry;\n    }\n\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getJSDocInfo() != null) {\n\n        // Find references in the JSDocInfo.\n        JSDocInfo info = n.getJSDocInfo();\n        docInfos.add(info);\n\n        for (Node typeAst : info.getTypeNodes()) {\n          SymbolScope scope = scopes.get(t.getScopeRoot());\n          visitTypeNode(scope == null ? globalScope : scope, typeAst);\n        }\n      }\n    }\n\n    public void visitTypeNode(SymbolScope scope, Node n) {\n      if (n.isString()) {\n        Symbol symbol = lookupPossiblyDottedName(scope, n.getString());\n        if (symbol != null) {\n          symbol.defineReferenceAt(n);\n        } else {\n          logger.warning(\"Could not find symbol for type: \" + n.getString());\n        }\n      }\n\n      for (Node child = n.getFirstChild();\n           child != null; child = child.getNext()) {\n        visitTypeNode(scope, child);\n      }\n    }\n\n    // TODO(peterhal): @template types.\n    private Symbol lookupPossiblyDottedName(SymbolScope scope, String dottedName) {\n      // Try the dotted name to start.\n      String[] names = dottedName.split(\"\\\\.\");\n      Symbol result = null;\n      SymbolScope currentScope = scope;\n      for (int i = 0; i < names.length; i++) {\n        String name = names[i];\n        result = currentScope.getSlot(name);\n        if (result == null) {\n          break;\n        }\n        if (i < (names.length - 1)) {\n          currentScope = result.getPropertyScope();\n          if (currentScope == null) {\n            result = null;\n            break;\n          }\n        }\n      }\n\n      if (result == null) {\n        // If we can't find this type, it might be a reference to a\n        // primitive type (like {string}). Autobox it to check.\n        JSType type = typeRegistry.getType(dottedName);\n        JSType autobox = type == null ? null : type.autoboxesTo();\n        result = autobox == null\n            ? null : getSymbolForTypeHelper(autobox, true);\n      }\n      return result;\n    }\n  }\n\n  // Comparators\n  private final Ordering<String> sourceNameOrdering =\n      Ordering.natural().nullsFirst();\n\n  private final Ordering<Node> nodeOrdering = new Ordering<Node>() {\n    @Override\n    public int compare(Node a, Node b) {\n      int result = sourceNameOrdering.compare(\n          a.getSourceFileName(), b.getSourceFileName());\n      if (result != 0) {\n        return result;\n      }\n\n      // Source position is a bit mask of line in the top 4 bits, so this\n      // is a quick way to compare order without computing absolute position.\n      return a.getSourcePosition() - b.getSourcePosition();\n    }\n  };\n\n  private final Ordering<SymbolScope> lexicalScopeOrdering =\n      new Ordering<SymbolScope>() {\n    @Override\n    public int compare(SymbolScope a, SymbolScope b) {\n      Preconditions.checkState(a.isLexicalScope() && b.isLexicalScope(),\n                               \"We can only sort lexical scopes\");\n      return nodeOrdering.compare(a.getRootNode(), b.getRootNode());\n    }\n  };\n\n  private final Ordering<Symbol> symbolOrdering = new Ordering<Symbol>() {\n    @Override\n    public int compare(Symbol a, Symbol b) {\n      SymbolScope scopeA = getScope(a);\n      SymbolScope scopeB = getScope(b);\n\n      // More deeply nested symbols should go later.\n      int result = getLexicalScopeDepth(scopeA) - getLexicalScopeDepth(scopeB);\n      if (result != 0) {\n        return result;\n      }\n\n      // After than, just use lexicographic ordering.\n      // This ensures \"a.b\" comes before \"a.b.c\".\n      return a.getName().compareTo(b.getName());\n    }\n  };\n\n  /**\n   * For a lexical scope, just returns the normal scope depth.\n   *\n   * For a property scope, returns the number of scopes we have to search\n   *     to find the nearest lexical scope, plus that lexical scope's depth.\n   *\n   * For a doc info scope, returns 0.\n   */\n  private int getLexicalScopeDepth(SymbolScope scope) {", "metadata": {"defects4j_task_id": "e6737a8bf7d39ed659b0b1e7fa2ec21ad5d3e00226cd576bee9cadf968a6c47c", "task_id": "google_closure-compiler/187", "ground_truth": "\n    if (scope.isLexicalScope() || scope.isDocScope()) {\n      return scope.getScopeDepth();\n    } else {\n      Preconditions.checkState(scope.isPropertyScope());\n      Symbol sym = scope.getSymbolForScope();\n      Preconditions.checkNotNull(sym);\n      return getLexicalScopeDepth(getScope(sym)) + 1;\n    }\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "SymbolTable.java"], "context_start_lineno": 0, "function_name": "getLexicalScopeDepth", "left_context": "class SymbolTable\n    implements StaticSymbolTable<SymbolTable.Symbol, SymbolTable.Reference> {\n  /** Collects references to types in JSDocInfo. */\n  private class JSDocInfoCollector\n      extends NodeTraversal.AbstractPostOrderCallback {\n    private final JSTypeRegistry typeRegistry;\n\n    private JSDocInfoCollector(JSTypeRegistry registry) {\n      this.typeRegistry = registry;\n    }\n\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getJSDocInfo() != null) {\n\n        // Find references in the JSDocInfo.\n        JSDocInfo info = n.getJSDocInfo();\n        docInfos.add(info);\n\n        for (Node typeAst : info.getTypeNodes()) {\n          SymbolScope scope = scopes.get(t.getScopeRoot());\n          visitTypeNode(scope == null ? globalScope : scope, typeAst);\n        }\n      }\n    }\n\n    public void visitTypeNode(SymbolScope scope, Node n) {\n      if (n.isString()) {\n        Symbol symbol = lookupPossiblyDottedName(scope, n.getString());\n        if (symbol != null) {\n          symbol.defineReferenceAt(n);\n        } else {\n          logger.warning(\"Could not find symbol for type: \" + n.getString());\n        }\n      }\n\n      for (Node child = n.getFirstChild();\n           child != null; child = child.getNext()) {\n        visitTypeNode(scope, child);\n      }\n    }\n\n    // TODO(peterhal): @template types.\n    private Symbol lookupPossiblyDottedName(SymbolScope scope, String dottedName) {\n      // Try the dotted name to start.\n      String[] names = dottedName.split(\"\\\\.\");\n      Symbol result = null;\n      SymbolScope currentScope = scope;\n      for (int i = 0; i < names.length; i++) {\n        String name = names[i];\n        result = currentScope.getSlot(name);\n        if (result == null) {\n          break;\n        }\n        if (i < (names.length - 1)) {\n          currentScope = result.getPropertyScope();\n          if (currentScope == null) {\n            result = null;\n            break;\n          }\n        }\n      }\n\n      if (result == null) {\n        // If we can't find this type, it might be a reference to a\n        // primitive type (like {string}). Autobox it to check.\n        JSType type = typeRegistry.getType(dottedName);\n        JSType autobox = type == null ? null : type.autoboxesTo();\n        result = autobox == null\n            ? null : getSymbolForTypeHelper(autobox, true);\n      }\n      return result;\n    }\n  }\n\n  // Comparators\n  private final Ordering<String> sourceNameOrdering =\n      Ordering.natural().nullsFirst();\n\n  private final Ordering<Node> nodeOrdering = new Ordering<Node>() {\n    @Override\n    public int compare(Node a, Node b) {\n      int result = sourceNameOrdering.compare(\n          a.getSourceFileName(), b.getSourceFileName());\n      if (result != 0) {\n        return result;\n      }\n\n      // Source position is a bit mask of line in the top 4 bits, so this\n      // is a quick way to compare order without computing absolute position.\n      return a.getSourcePosition() - b.getSourcePosition();\n    }\n  };\n\n  private final Ordering<SymbolScope> lexicalScopeOrdering =\n      new Ordering<SymbolScope>() {\n    @Override\n    public int compare(SymbolScope a, SymbolScope b) {\n      Preconditions.checkState(a.isLexicalScope() && b.isLexicalScope(),\n                               \"We can only sort lexical scopes\");\n      return nodeOrdering.compare(a.getRootNode(), b.getRootNode());\n    }\n  };\n\n  private final Ordering<Symbol> symbolOrdering = new Ordering<Symbol>() {\n    @Override\n    public int compare(Symbol a, Symbol b) {\n      SymbolScope scopeA = getScope(a);\n      SymbolScope scopeB = getScope(b);\n\n      // More deeply nested symbols should go later.\n      int result = getLexicalScopeDepth(scopeA) - getLexicalScopeDepth(scopeB);\n      if (result != 0) {\n        return result;\n      }\n\n      // After than, just use lexicographic ordering.\n      // This ensures \"a.b\" comes before \"a.b.c\".\n      return a.getName().compareTo(b.getName());\n    }\n  };\n\n  /**\n   * For a lexical scope, just returns the normal scope depth.\n   *\n   * For a property scope, returns the number of scopes we have to search\n   *     to find the nearest lexical scope, plus that lexical scope's depth.\n   *\n   * For a doc info scope, returns 0.\n   */\n  private int getLexicalScopeDepth(SymbolScope scope) {", "right_context": "}}\n}", "class_name": "SymbolTable", "return_type": "int", "parameters": [{"type": "SymbolScope", "name": "scope"}]}}
{"prompt": "class IRFactory {\n\n  private Node transformBlock(AstNode node) {\n    Node irNode = transform(node);\n    if (!irNode.isBlock()) {\n      if (irNode.isEmpty()) {\n        irNode.setType(Token.BLOCK);\n        irNode.setWasEmptyNode(true);\n      } else {\n        Node newBlock = newNode(Token.BLOCK, irNode);\n        newBlock.setLineno(irNode.getLineno());\n        newBlock.setCharno(irNode.getCharno());\n        maybeSetLengthFrom(newBlock, node);\n        irNode = newBlock;\n      }\n    }\n    return irNode;\n  }\n\n  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]+[ \\t\\n{]\");\n    if (p.matcher(comment.getValue()).find()) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }\n\n  /**\n   * @return true if the jsDocParser represents a fileoverview.\n   */\n  private boolean handlePossibleFileOverviewJsDoc(\n      JsDocInfoParser jsDocParser) {\n    if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n      fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n      return true;\n    }\n    return false;\n  }\n\n  private void handlePossibleFileOverviewJsDoc(Comment comment, Node irNode) {\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n    parsedComments.add(comment);\n    handlePossibleFileOverviewJsDoc(jsDocParser);\n  }\n\n  private JSDocInfo handleJsDoc(AstNode node, Node irNode) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n      parsedComments.add(comment);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n        if (info != null) {\n          validateTypeAnnotations(info, node);\n        }\n        return info;\n      }\n    }\n    return null;\n  }\n\n  private void validateTypeAnnotations(JSDocInfo info, AstNode node) {\n    if (info.hasType()) {\n      boolean valid = false;\n      switch (node.getType()) {\n        // Casts are valid\n        case com.google.javascript.rhino.head.Token.LP:\n          valid = node instanceof ParenthesizedExpression;\n          break;\n        // Variable declarations are valid\n        case com.google.javascript.rhino.head.Token.VAR:\n          valid = true;\n          break;\n        // Function declarations are valid\n        case com.google.javascript.rhino.head.Token.FUNCTION:\n          FunctionNode fnNode = (FunctionNode) node;\n          valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n          break;\n        // Object literal properties, catch declarations and variable\n        // initializers are valid.\n        case com.google.javascript.rhino.head.Token.NAME:\n          AstNode parent = node.getParent();\n          valid = parent instanceof ObjectProperty\n              || parent instanceof CatchClause\n              || parent instanceof FunctionNode\n              || (parent instanceof VariableInitializer &&\n                  node == ((VariableInitializer) parent).getTarget());\n          break;\n        // Object literal properties are valid\n        case com.google.javascript.rhino.head.Token.GET:\n        case com.google.javascript.rhino.head.Token.SET:\n        case com.google.javascript.rhino.head.Token.NUMBER:\n        case com.google.javascript.rhino.head.Token.STRING:\n          valid = node.getParent() instanceof ObjectProperty;\n          break;\n\n        // Property assignments are valid, if at the root of an expression.\n        case com.google.javascript.rhino.head.Token.ASSIGN:\n          if (node instanceof Assignment) {\n            valid = isExprStmt(node.getParent())\n                && isPropAccess(((Assignment) node).getLeft());\n          }\n          break;\n\n        // Property definitions are valid, if at the root of an expression.\n        case com.google.javascript.rhino.head.Token.GETPROP:\n        case com.google.javascript.rhino.head.Token.GETELEM:\n          valid = isExprStmt(node.getParent());\n          break;\n\n        case com.google.javascript.rhino.head.Token.CALL:\n          valid = info.isDefine();\n          break;\n      }\n      if (!valid) {\n        errorReporter.warning(MISPLACED_TYPE_ANNOTATION,\n            sourceName,\n            node.getLineno(), \"\", 0);\n      }\n    }\n  }\n\n  private static boolean isPropAccess(AstNode node) {\n    return node.getType() == com.google.javascript.rhino.head.Token.GETPROP\n        || node.getType() == com.google.javascript.rhino.head.Token.GETELEM;\n  }\n\n  private static boolean isExprStmt(AstNode node) {\n    return node.getType() == com.google.javascript.rhino.head.Token.EXPR_RESULT\n        || node.getType() == com.google.javascript.rhino.head.Token.EXPR_VOID;\n  }\n\n  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n\n  private Node maybeInjectCastNode(AstNode node, JSDocInfo info, Node irNode) {\n    if (node.getType() == com.google.javascript.rhino.head.Token.LP\n        && node instanceof ParenthesizedExpression\n        && info.hasType()) {\n      irNode = newNode(Token.CAST, irNode);\n    }\n    return irNode;\n  }\n\n  /**\n   * NAMEs in parameters or variable declarations are special, because they can\n   * have inline type docs attached.\n   *\n   * function f(/** string &#42;/ x) {}\n   * annotates 'x' as a string.\n   *\n   * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n   *   Using Inline Doc Comments</a>\n   */\n  private Node transformNodeWithInlineJsDoc(AstNode node) {", "metadata": {"defects4j_task_id": "3eb907e3e13f119d28d33981599ff7e52cb5e2a780581bb4ef747c0750208f96", "task_id": "google_closure-compiler/56", "ground_truth": "\n    Node irNode = justTransform(node);\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n      if (info != null) {\n        irNode.setJSDocInfo(info);\n      }\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "parsing", "IRFactory.java"], "context_start_lineno": 0, "function_name": "transformNodeWithInlineJsDoc", "left_context": "class IRFactory {\n\n  private Node transformBlock(AstNode node) {\n    Node irNode = transform(node);\n    if (!irNode.isBlock()) {\n      if (irNode.isEmpty()) {\n        irNode.setType(Token.BLOCK);\n        irNode.setWasEmptyNode(true);\n      } else {\n        Node newBlock = newNode(Token.BLOCK, irNode);\n        newBlock.setLineno(irNode.getLineno());\n        newBlock.setCharno(irNode.getCharno());\n        maybeSetLengthFrom(newBlock, node);\n        irNode = newBlock;\n      }\n    }\n    return irNode;\n  }\n\n  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]+[ \\t\\n{]\");\n    if (p.matcher(comment.getValue()).find()) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }\n\n  /**\n   * @return true if the jsDocParser represents a fileoverview.\n   */\n  private boolean handlePossibleFileOverviewJsDoc(\n      JsDocInfoParser jsDocParser) {\n    if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n      fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n      return true;\n    }\n    return false;\n  }\n\n  private void handlePossibleFileOverviewJsDoc(Comment comment, Node irNode) {\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n    parsedComments.add(comment);\n    handlePossibleFileOverviewJsDoc(jsDocParser);\n  }\n\n  private JSDocInfo handleJsDoc(AstNode node, Node irNode) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n      parsedComments.add(comment);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n        if (info != null) {\n          validateTypeAnnotations(info, node);\n        }\n        return info;\n      }\n    }\n    return null;\n  }\n\n  private void validateTypeAnnotations(JSDocInfo info, AstNode node) {\n    if (info.hasType()) {\n      boolean valid = false;\n      switch (node.getType()) {\n        // Casts are valid\n        case com.google.javascript.rhino.head.Token.LP:\n          valid = node instanceof ParenthesizedExpression;\n          break;\n        // Variable declarations are valid\n        case com.google.javascript.rhino.head.Token.VAR:\n          valid = true;\n          break;\n        // Function declarations are valid\n        case com.google.javascript.rhino.head.Token.FUNCTION:\n          FunctionNode fnNode = (FunctionNode) node;\n          valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n          break;\n        // Object literal properties, catch declarations and variable\n        // initializers are valid.\n        case com.google.javascript.rhino.head.Token.NAME:\n          AstNode parent = node.getParent();\n          valid = parent instanceof ObjectProperty\n              || parent instanceof CatchClause\n              || parent instanceof FunctionNode\n              || (parent instanceof VariableInitializer &&\n                  node == ((VariableInitializer) parent).getTarget());\n          break;\n        // Object literal properties are valid\n        case com.google.javascript.rhino.head.Token.GET:\n        case com.google.javascript.rhino.head.Token.SET:\n        case com.google.javascript.rhino.head.Token.NUMBER:\n        case com.google.javascript.rhino.head.Token.STRING:\n          valid = node.getParent() instanceof ObjectProperty;\n          break;\n\n        // Property assignments are valid, if at the root of an expression.\n        case com.google.javascript.rhino.head.Token.ASSIGN:\n          if (node instanceof Assignment) {\n            valid = isExprStmt(node.getParent())\n                && isPropAccess(((Assignment) node).getLeft());\n          }\n          break;\n\n        // Property definitions are valid, if at the root of an expression.\n        case com.google.javascript.rhino.head.Token.GETPROP:\n        case com.google.javascript.rhino.head.Token.GETELEM:\n          valid = isExprStmt(node.getParent());\n          break;\n\n        case com.google.javascript.rhino.head.Token.CALL:\n          valid = info.isDefine();\n          break;\n      }\n      if (!valid) {\n        errorReporter.warning(MISPLACED_TYPE_ANNOTATION,\n            sourceName,\n            node.getLineno(), \"\", 0);\n      }\n    }\n  }\n\n  private static boolean isPropAccess(AstNode node) {\n    return node.getType() == com.google.javascript.rhino.head.Token.GETPROP\n        || node.getType() == com.google.javascript.rhino.head.Token.GETELEM;\n  }\n\n  private static boolean isExprStmt(AstNode node) {\n    return node.getType() == com.google.javascript.rhino.head.Token.EXPR_RESULT\n        || node.getType() == com.google.javascript.rhino.head.Token.EXPR_VOID;\n  }\n\n  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n\n  private Node maybeInjectCastNode(AstNode node, JSDocInfo info, Node irNode) {\n    if (node.getType() == com.google.javascript.rhino.head.Token.LP\n        && node instanceof ParenthesizedExpression\n        && info.hasType()) {\n      irNode = newNode(Token.CAST, irNode);\n    }\n    return irNode;\n  }\n\n  /**\n   * NAMEs in parameters or variable declarations are special, because they can\n   * have inline type docs attached.\n   *\n   * function f(/** string &#42;/ x) {}\n   * annotates 'x' as a string.\n   *\n   * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n   *   Using Inline Doc Comments</a>\n   */\n  private Node transformNodeWithInlineJsDoc(AstNode node) {", "right_context": "}\n}", "class_name": "IRFactory", "return_type": "Node", "parameters": [{"type": "AstNode", "name": "node"}]}}
{"prompt": "class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n\n    /** The factory for creating value collections. */\n    private final Factory<? extends Collection<V>> collectionFactory;\n    /** The cached values. */\n    private transient Collection<V> valuesView;\n\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to wrap\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n        return MultiValueMap.<K, V, ArrayList> multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * maps keys to collections of type <code>collectionClass</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to wrap\n     * @param collectionClass  the type of the collection class\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n                                                                                    final Class<C> collectionClass) {\n        return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory (must return a Collection object).\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n            final Factory<C> collectionFactory) {\n        return new MultiValueMap<K, V>(map, collectionFactory);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a MultiValueMap based on a <code>HashMap</code> and\n     * storing the multiple values in an <code>ArrayList</code>.\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public MultiValueMap() {\n        this(new HashMap<K, V>(), new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a MultiValueMap which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory which must return a Collection instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected <C extends Collection<V>> MultiValueMap(final Map<K, ? super C> map,\n                                                      final Factory<C> collectionFactory) {\n        super((Map<K, Object>) map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 4.0\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, Object>) in.readObject(); // (1)\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clear the map.\n     */\n    @Override\n    public void clear() {\n        // If you believe that you have GC issues here, try uncommenting this code\n//        Set pairs = getMap().entrySet();\n//        Iterator pairsIterator = pairs.iterator();\n//        while (pairsIterator.hasNext()) {\n//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n//            Collection coll = (Collection) keyValuePair.getValue();\n//            coll.clear();\n//        }\n        decorated().clear();\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, <code>null</code> will be returned\n     * from a subsequent <code>get(key)</code>.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return {@code true} if the mapping was removed, {@code false} otherwise\n     */\n    @Override\n    public boolean removeMapping(final Object key, final Object value) {", "metadata": {"defects4j_task_id": "37497bed336eb012890fc7770295b46f192ccf65b0f828d783eedd1a47cdafb5", "task_id": "google_closure-compiler/48", "ground_truth": "\n      Node ret;\n      if (n instanceof Name) {\n        ret = transformNameAsString((Name) n);\n      } else if (n instanceof NumberLiteral) {\n        ret = transformNumberAsString((NumberLiteral) n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      } else {\n        ret = transform(n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      }\n      Preconditions.checkState(ret.isString());\n      return ret;\n    ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "parsing", "IRFactory.java"], "context_start_lineno": 0, "function_name": "transformAsString", "left_context": "class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n\n    /** The factory for creating value collections. */\n    private final Factory<? extends Collection<V>> collectionFactory;\n    /** The cached values. */\n    private transient Collection<V> valuesView;\n\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to wrap\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n        return MultiValueMap.<K, V, ArrayList> multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * maps keys to collections of type <code>collectionClass</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to wrap\n     * @param collectionClass  the type of the collection class\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n                                                                                    final Class<C> collectionClass) {\n        return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory (must return a Collection object).\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n            final Factory<C> collectionFactory) {\n        return new MultiValueMap<K, V>(map, collectionFactory);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a MultiValueMap based on a <code>HashMap</code> and\n     * storing the multiple values in an <code>ArrayList</code>.\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public MultiValueMap() {\n        this(new HashMap<K, V>(), new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a MultiValueMap which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory which must return a Collection instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected <C extends Collection<V>> MultiValueMap(final Map<K, ? super C> map,\n                                                      final Factory<C> collectionFactory) {\n        super((Map<K, Object>) map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 4.0\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, Object>) in.readObject(); // (1)\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clear the map.\n     */\n    @Override\n    public void clear() {\n        // If you believe that you have GC issues here, try uncommenting this code\n//        Set pairs = getMap().entrySet();\n//        Iterator pairsIterator = pairs.iterator();\n//        while (pairsIterator.hasNext()) {\n//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n//            Collection coll = (Collection) keyValuePair.getValue();\n//            coll.clear();\n//        }\n        decorated().clear();\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, <code>null</code> will be returned\n     * from a subsequent <code>get(key)</code>.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return {@code true} if the mapping was removed, {@code false} otherwise\n     */\n    @Override\n    public boolean removeMapping(final Object key, final Object value) {", "right_context": "}\n\n}", "class_name": "IRFactory", "return_type": "Node", "parameters": [{"type": "AstNode", "name": "n"}]}}
{"prompt": "class JsDocInfoParser {\n\n  /**\n   * Extracts the top-level block comment from the JsDoc comment, if any.\n   * This method differs from the extractMultilineTextualBlock in that it\n   * terminates under different conditions (it doesn't have the same\n   * prechecks), it does not first read in the remaining of the current\n   * line and its conditions for ignoring the \"*\" (STAR) are different.\n   *\n   * @param token The starting token.\n   *\n   * @return The extraction information.\n   */\n  private ExtractionInfo extractBlockComment(JsDocToken token) {\n    StringBuilder builder = new StringBuilder();\n\n    boolean ignoreStar = true;\n\n    do {\n      switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n\n  /**\n   * Trim characters from only the end of a string.\n   * This method will remove all whitespace characters\n   * (defined by Character.isWhitespace(char), in addition to the characters\n   * provided, from the end of the provided string.\n   *\n   * @param s String to be trimmed\n   * @return String with whitespace and characters in extraChars removed\n   *                   from the end.\n   */\n  private static String trimEnd(String s) {\n    int trimCount = 0;\n    while (trimCount < s.length()) {\n      char ch = s.charAt(s.length() - trimCount - 1);\n      if (Character.isWhitespace(ch)) {\n        trimCount++;\n      } else {\n        break;\n      }\n    }\n\n    if (trimCount == 0) {\n      return s;\n    }\n    return s.substring(0, s.length() - trimCount);\n  }\n\n  // Based on ES4 grammar proposed on July 10, 2008.\n  // http://wiki.ecmascript.org/doku.php?id=spec:spec\n  // Deliberately written to line up with the actual grammar rules,\n  // for maximum flexibility.\n\n  // TODO(nicksantos): The current implementation tries to maintain backwards\n  // compatibility with previous versions of the spec whenever we can.\n  // We should try to gradually withdraw support for these.\n\n  /**\n   * TypeExpressionAnnotation := TypeExpression |\n   *     '{' TopLevelTypeExpression '}'\n   */\n  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }\n\n  /**\n   * ParamTypeExpressionAnnotation :=\n   *     '{' OptionalParameterType '}' |\n   *     '{' TopLevelTypeExpression '}' |\n   *     '{' '...' TopLevelTypeExpression '}'\n   *\n   * OptionalParameterType :=\n   *     TopLevelTypeExpression '='\n   */\n  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {", "metadata": {"defects4j_task_id": "70915c89a67cc276c12ac95ff7778b61f14a770bda0281bbd2fcd11834b30345", "task_id": "google_closure-compiler/95", "ground_truth": "\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n\n    boolean restArg = false;\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      if (token == JsDocToken.RC) {\n        // EMPTY represents the UNKNOWN type in the Type AST.\n        return wrapNode(Token.ELLIPSIS, IR.empty());\n      }\n      restArg = true;\n    }\n\n    Node typeNode = parseTopLevelTypeExpression(token);\n    if (typeNode != null) {\n      skipEOLs();\n      if (restArg) {\n        typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n      } else if (match(JsDocToken.EQUALS)) {\n        next();\n        skipEOLs();\n        typeNode = wrapNode(Token.EQUALS, typeNode);\n      }\n\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "parsing", "JsDocInfoParser.java"], "context_start_lineno": 0, "function_name": "parseParamTypeExpressionAnnotation", "left_context": "class JsDocInfoParser {\n\n  /**\n   * Extracts the top-level block comment from the JsDoc comment, if any.\n   * This method differs from the extractMultilineTextualBlock in that it\n   * terminates under different conditions (it doesn't have the same\n   * prechecks), it does not first read in the remaining of the current\n   * line and its conditions for ignoring the \"*\" (STAR) are different.\n   *\n   * @param token The starting token.\n   *\n   * @return The extraction information.\n   */\n  private ExtractionInfo extractBlockComment(JsDocToken token) {\n    StringBuilder builder = new StringBuilder();\n\n    boolean ignoreStar = true;\n\n    do {\n      switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n\n  /**\n   * Trim characters from only the end of a string.\n   * This method will remove all whitespace characters\n   * (defined by Character.isWhitespace(char), in addition to the characters\n   * provided, from the end of the provided string.\n   *\n   * @param s String to be trimmed\n   * @return String with whitespace and characters in extraChars removed\n   *                   from the end.\n   */\n  private static String trimEnd(String s) {\n    int trimCount = 0;\n    while (trimCount < s.length()) {\n      char ch = s.charAt(s.length() - trimCount - 1);\n      if (Character.isWhitespace(ch)) {\n        trimCount++;\n      } else {\n        break;\n      }\n    }\n\n    if (trimCount == 0) {\n      return s;\n    }\n    return s.substring(0, s.length() - trimCount);\n  }\n\n  // Based on ES4 grammar proposed on July 10, 2008.\n  // http://wiki.ecmascript.org/doku.php?id=spec:spec\n  // Deliberately written to line up with the actual grammar rules,\n  // for maximum flexibility.\n\n  // TODO(nicksantos): The current implementation tries to maintain backwards\n  // compatibility with previous versions of the spec whenever we can.\n  // We should try to gradually withdraw support for these.\n\n  /**\n   * TypeExpressionAnnotation := TypeExpression |\n   *     '{' TopLevelTypeExpression '}'\n   */\n  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }\n\n  /**\n   * ParamTypeExpressionAnnotation :=\n   *     '{' OptionalParameterType '}' |\n   *     '{' TopLevelTypeExpression '}' |\n   *     '{' '...' TopLevelTypeExpression '}'\n   *\n   * OptionalParameterType :=\n   *     TopLevelTypeExpression '='\n   */\n  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {", "right_context": "}\n}", "class_name": "JsDocInfoParser", "return_type": "Node", "parameters": [{"type": "JsDocToken", "name": "token"}]}}
{"prompt": "class JsDocInfoParser {\n\n  /**\n   * ParamTypeExpressionAnnotation :=\n   *     '{' OptionalParameterType '}' |\n   *     '{' TopLevelTypeExpression '}' |\n   *     '{' '...' TopLevelTypeExpression '}'\n   *\n   * OptionalParameterType :=\n   *     TopLevelTypeExpression '='\n   */\n  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n\n    boolean restArg = false;\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      if (token == JsDocToken.RC) {\n        // EMPTY represents the UNKNOWN type in the Type AST.\n        return wrapNode(Token.ELLIPSIS, IR.empty());\n      }\n      restArg = true;\n    }\n\n    Node typeNode = parseTopLevelTypeExpression(token);\n    if (typeNode != null) {\n      skipEOLs();\n      if (restArg) {\n        typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n      } else if (match(JsDocToken.EQUALS)) {\n        next();\n        skipEOLs();\n        typeNode = wrapNode(Token.EQUALS, typeNode);\n      }\n\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * TypeNameAnnotation := TypeName | '{' TypeName '}'\n   */\n  private Node parseTypeNameAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTypeName(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeName(token);\n    }\n  }\n\n  /**\n   * TopLevelTypeExpression := TypeExpression\n   *     | TypeUnionList\n   *\n   * We made this rule up, for the sake of backwards compatibility.\n   */\n  private Node parseTopLevelTypeExpression(JsDocToken token) {\n    Node typeExpr = parseTypeExpression(token);\n    if (typeExpr != null) {\n      // top-level unions are allowed\n      if (match(JsDocToken.PIPE)) {\n        next();\n        if (match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards-compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n        return parseUnionTypeWithAlternate(token, typeExpr);\n      }\n    }\n    return typeExpr;\n  }\n\n  /**\n   * TypeExpressionList := TopLevelTypeExpression\n   *     | TopLevelTypeExpression ',' TypeExpressionList\n   */\n  private Node parseTypeExpressionList(JsDocToken token) {\n    Node typeExpr = parseTopLevelTypeExpression(token);\n    if (typeExpr == null) {\n      return null;\n    }\n    Node typeList = IR.block();\n    typeList.addChildToBack(typeExpr);\n    while (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      typeExpr = parseTopLevelTypeExpression(next());\n      if (typeExpr == null) {\n        return null;\n      }\n      typeList.addChildToBack(typeExpr);\n    }\n    return typeList;\n  }\n\n  /**\n   * TypeExpression := BasicTypeExpression\n   *     | '?' BasicTypeExpression\n   *     | '!' BasicTypeExpression\n   *     | BasicTypeExpression '?'\n   *     | BasicTypeExpression '!'\n   *     | '?'\n   */\n  private Node parseTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      // A QMARK could mean that a type is nullable, or that it's unknown.\n      // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n      // we assume it means nullable. There are 8 cases:\n      // {?} - right curly\n      // {?=} - equals\n      // {function(?, number)} - comma\n      // {function(number, ?)} - right paren\n      // {function(number, ...[?])} - right bracket\n      // {function(): ?|number} - pipe\n      // {Array.<?>} - greater than\n      // /** ? */ - EOC (inline types)\n      // I'm not a big fan of using look-ahead for this, but it makes\n      // the type language a lot nicer.\n      token = next();\n      if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE ||\n          token == JsDocToken.GT ||\n          token == JsDocToken.EOC) {\n        restoreLookAhead(token);\n        return newNode(Token.QMARK);\n      }\n\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\n    } else if (token == JsDocToken.BANG) {\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n      Node basicTypeExpr = parseBasicTypeExpression(token);\n      if (basicTypeExpr != null) {\n        if (match(JsDocToken.QMARK)) {\n          next();\n          return wrapNode(Token.QMARK, basicTypeExpr);\n        } else if (match(JsDocToken.BANG)) {\n          next();\n          return wrapNode(Token.BANG, basicTypeExpr);\n        }\n      }\n\n      return basicTypeExpr;\n    }\n  }\n\n  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      return newNode(Token.QMARK);\n    } else {\n      return parseBasicTypeExpression(token);\n    }\n  }\n\n  /**\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   */\n  private Node parseBasicTypeExpression(JsDocToken token) {", "metadata": {"defects4j_task_id": "26506a1fec2014ba0bdb9fe45ad251aa2e6297636bcbe97dccc19fb3f0def776", "task_id": "google_closure-compiler/34", "ground_truth": "\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "parsing", "JsDocInfoParser.java"], "context_start_lineno": 0, "function_name": "parseBasicTypeExpression", "left_context": "class JsDocInfoParser {\n\n  /**\n   * ParamTypeExpressionAnnotation :=\n   *     '{' OptionalParameterType '}' |\n   *     '{' TopLevelTypeExpression '}' |\n   *     '{' '...' TopLevelTypeExpression '}'\n   *\n   * OptionalParameterType :=\n   *     TopLevelTypeExpression '='\n   */\n  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n\n    boolean restArg = false;\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      if (token == JsDocToken.RC) {\n        // EMPTY represents the UNKNOWN type in the Type AST.\n        return wrapNode(Token.ELLIPSIS, IR.empty());\n      }\n      restArg = true;\n    }\n\n    Node typeNode = parseTopLevelTypeExpression(token);\n    if (typeNode != null) {\n      skipEOLs();\n      if (restArg) {\n        typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n      } else if (match(JsDocToken.EQUALS)) {\n        next();\n        skipEOLs();\n        typeNode = wrapNode(Token.EQUALS, typeNode);\n      }\n\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * TypeNameAnnotation := TypeName | '{' TypeName '}'\n   */\n  private Node parseTypeNameAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTypeName(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeName(token);\n    }\n  }\n\n  /**\n   * TopLevelTypeExpression := TypeExpression\n   *     | TypeUnionList\n   *\n   * We made this rule up, for the sake of backwards compatibility.\n   */\n  private Node parseTopLevelTypeExpression(JsDocToken token) {\n    Node typeExpr = parseTypeExpression(token);\n    if (typeExpr != null) {\n      // top-level unions are allowed\n      if (match(JsDocToken.PIPE)) {\n        next();\n        if (match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards-compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n        return parseUnionTypeWithAlternate(token, typeExpr);\n      }\n    }\n    return typeExpr;\n  }\n\n  /**\n   * TypeExpressionList := TopLevelTypeExpression\n   *     | TopLevelTypeExpression ',' TypeExpressionList\n   */\n  private Node parseTypeExpressionList(JsDocToken token) {\n    Node typeExpr = parseTopLevelTypeExpression(token);\n    if (typeExpr == null) {\n      return null;\n    }\n    Node typeList = IR.block();\n    typeList.addChildToBack(typeExpr);\n    while (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      typeExpr = parseTopLevelTypeExpression(next());\n      if (typeExpr == null) {\n        return null;\n      }\n      typeList.addChildToBack(typeExpr);\n    }\n    return typeList;\n  }\n\n  /**\n   * TypeExpression := BasicTypeExpression\n   *     | '?' BasicTypeExpression\n   *     | '!' BasicTypeExpression\n   *     | BasicTypeExpression '?'\n   *     | BasicTypeExpression '!'\n   *     | '?'\n   */\n  private Node parseTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      // A QMARK could mean that a type is nullable, or that it's unknown.\n      // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n      // we assume it means nullable. There are 8 cases:\n      // {?} - right curly\n      // {?=} - equals\n      // {function(?, number)} - comma\n      // {function(number, ?)} - right paren\n      // {function(number, ...[?])} - right bracket\n      // {function(): ?|number} - pipe\n      // {Array.<?>} - greater than\n      // /** ? */ - EOC (inline types)\n      // I'm not a big fan of using look-ahead for this, but it makes\n      // the type language a lot nicer.\n      token = next();\n      if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE ||\n          token == JsDocToken.GT ||\n          token == JsDocToken.EOC) {\n        restoreLookAhead(token);\n        return newNode(Token.QMARK);\n      }\n\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\n    } else if (token == JsDocToken.BANG) {\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n      Node basicTypeExpr = parseBasicTypeExpression(token);\n      if (basicTypeExpr != null) {\n        if (match(JsDocToken.QMARK)) {\n          next();\n          return wrapNode(Token.QMARK, basicTypeExpr);\n        } else if (match(JsDocToken.BANG)) {\n          next();\n          return wrapNode(Token.BANG, basicTypeExpr);\n        }\n      }\n\n      return basicTypeExpr;\n    }\n  }\n\n  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      return newNode(Token.QMARK);\n    } else {\n      return parseBasicTypeExpression(token);\n    }\n  }\n\n  /**\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   */\n  private Node parseBasicTypeExpression(JsDocToken token) {", "right_context": "}\n}", "class_name": "JsDocInfoParser", "return_type": "Node", "parameters": [{"type": "JsDocToken", "name": "token"}]}}
{"prompt": "class JsDocInfoParser {\n\n  /**\n   * ParametersType := RestParameterType | NonRestParametersType\n   *     | NonRestParametersType ',' RestParameterType\n   * RestParameterType := '...' Identifier\n   * NonRestParametersType := ParameterType ',' NonRestParametersType\n   *     | ParameterType\n   *     | OptionalParametersType\n   * OptionalParametersType := OptionalParameterType\n   *     | OptionalParameterType, OptionalParametersType\n   * OptionalParameterType := ParameterType=\n   * ParameterType := TypeExpression | Identifier ':' TypeExpression\n   */\n  // NOTE(nicksantos): The official ES4 grammar forces optional and rest\n  // arguments to come after the required arguments. Our parser does not\n  // enforce this. Instead we allow them anywhere in the function at parse-time,\n  // and then warn about them during type resolution.\n  //\n  // In theory, it might be mathematically nicer to do the order-checking here.\n  // But in practice, the order-checking for structural functions is exactly\n  // the same as the order-checking for @param annotations. And the latter\n  // has to happen during type resolution. Rather than duplicate the\n  // order-checking in two places, we just do all of it in type resolution.\n  private Node parseParametersType(JsDocToken token) {\n    Node paramsType = newNode(Token.PARAM_LIST);\n    boolean isVarArgs = false;\n    Node paramType = null;\n    if (token != JsDocToken.RP) {\n      do {\n        if (paramType != null) {\n          // skip past the comma\n          next();\n          skipEOLs();\n          token = next();\n        }\n\n        if (token == JsDocToken.ELLIPSIS) {\n          // In the latest ES4 proposal, there are no type constraints allowed\n          // on variable arguments. We support the old syntax for backwards\n          // compatibility, but we should gradually tear it out.\n          skipEOLs();\n          if (match(JsDocToken.RP)) {\n            paramType = newNode(Token.ELLIPSIS);\n          } else {\n            skipEOLs();\n            if (!match(JsDocToken.LB)) {\n              return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n            }\n\n            next();\n            skipEOLs();\n            paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n            skipEOLs();\n            if (!match(JsDocToken.RB)) {\n              return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n            }\n            skipEOLs();\n            next();\n          }\n\n          isVarArgs = true;\n        } else {\n          paramType = parseTypeExpression(token);\n          if (match(JsDocToken.EQUALS)) {\n            skipEOLs();\n            next();\n            paramType = wrapNode(Token.EQUALS, paramType);\n          }\n        }\n\n        if (paramType == null) {\n          return null;\n        }\n        paramsType.addChildToBack(paramType);\n        if (isVarArgs) {\n          break;\n        }\n      } while (match(JsDocToken.COMMA));\n    }\n\n    if (isVarArgs && match(JsDocToken.COMMA)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");\n    }\n\n    // The right paren will be checked by parseFunctionType\n\n    return paramsType;\n  }\n\n  /**\n   * ResultType := <empty> | ':' void | ':' TypeExpression\n   */\n  private Node parseResultType(JsDocToken token) {\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return newNode(Token.EMPTY);\n    }\n\n    token = next();\n    skipEOLs();\n    if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) {\n      next();\n      return newNode(Token.VOID);\n    } else {\n      return parseTypeExpression(next());\n    }\n  }\n\n  /**\n   * UnionType := '(' TypeUnionList ')'\n   * TypeUnionList := TypeExpression | TypeExpression '|' TypeUnionList\n   *\n   * We've removed the empty union type.\n   */\n  private Node parseUnionType(JsDocToken token) {\n    return parseUnionTypeWithAlternate(token, null);\n  }\n\n  /**\n   * Create a new union type, with an alternate that has already been\n   * parsed. The alternate may be null.\n   */\n  private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) {\n    Node union = newNode(Token.PIPE);\n    if (alternate != null) {\n      union.addChildToBack(alternate);\n    }\n\n    Node expr = null;\n    do {\n      if (expr != null) {\n        skipEOLs();\n        token = next();\n        Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);\n\n        boolean isPipe = token == JsDocToken.PIPE;\n        if (isPipe && match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n      }\n      expr = parseTypeExpression(token);\n      if (expr == null) {\n        return null;\n      }\n\n      union.addChildToBack(expr);\n      // We support commas for backwards compatibility.\n    } while (match(JsDocToken.PIPE, JsDocToken.COMMA));\n\n    if (alternate == null) {\n      skipEOLs();\n      if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n      }\n      next();\n    }\n    return union;\n  }\n\n  /**\n   * ArrayType := '[' ElementTypeList ']'\n   * ElementTypeList := <empty> | TypeExpression | '...' TypeExpression\n   *     | TypeExpression ',' ElementTypeList\n   */\n  private Node parseArrayType(JsDocToken token) {", "metadata": {"defects4j_task_id": "42093225585dee7416311b6a2ee5d96ae02b218788fa3bb6b14e169ebf7f00d2", "task_id": "google_closure-compiler/58", "ground_truth": "\n    Node array = newNode(Token.LB);\n    Node arg = null;\n    boolean hasVarArgs = false;\n\n    do {\n      if (arg != null) {\n        next();\n        skipEOLs();\n        token = next();\n      }\n      if (token == JsDocToken.ELLIPSIS) {\n        arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n        hasVarArgs = true;\n      } else {\n        arg = parseTypeExpression(token);\n      }\n\n      if (arg == null) {\n        return null;\n      }\n\n      array.addChildToBack(arg);\n      if (hasVarArgs) {\n        break;\n      }\n      skipEOLs();\n    } while (match(JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return array;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "parsing", "JsDocInfoParser.java"], "context_start_lineno": 0, "function_name": "parseArrayType", "left_context": "class JsDocInfoParser {\n\n  /**\n   * ParametersType := RestParameterType | NonRestParametersType\n   *     | NonRestParametersType ',' RestParameterType\n   * RestParameterType := '...' Identifier\n   * NonRestParametersType := ParameterType ',' NonRestParametersType\n   *     | ParameterType\n   *     | OptionalParametersType\n   * OptionalParametersType := OptionalParameterType\n   *     | OptionalParameterType, OptionalParametersType\n   * OptionalParameterType := ParameterType=\n   * ParameterType := TypeExpression | Identifier ':' TypeExpression\n   */\n  // NOTE(nicksantos): The official ES4 grammar forces optional and rest\n  // arguments to come after the required arguments. Our parser does not\n  // enforce this. Instead we allow them anywhere in the function at parse-time,\n  // and then warn about them during type resolution.\n  //\n  // In theory, it might be mathematically nicer to do the order-checking here.\n  // But in practice, the order-checking for structural functions is exactly\n  // the same as the order-checking for @param annotations. And the latter\n  // has to happen during type resolution. Rather than duplicate the\n  // order-checking in two places, we just do all of it in type resolution.\n  private Node parseParametersType(JsDocToken token) {\n    Node paramsType = newNode(Token.PARAM_LIST);\n    boolean isVarArgs = false;\n    Node paramType = null;\n    if (token != JsDocToken.RP) {\n      do {\n        if (paramType != null) {\n          // skip past the comma\n          next();\n          skipEOLs();\n          token = next();\n        }\n\n        if (token == JsDocToken.ELLIPSIS) {\n          // In the latest ES4 proposal, there are no type constraints allowed\n          // on variable arguments. We support the old syntax for backwards\n          // compatibility, but we should gradually tear it out.\n          skipEOLs();\n          if (match(JsDocToken.RP)) {\n            paramType = newNode(Token.ELLIPSIS);\n          } else {\n            skipEOLs();\n            if (!match(JsDocToken.LB)) {\n              return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n            }\n\n            next();\n            skipEOLs();\n            paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n            skipEOLs();\n            if (!match(JsDocToken.RB)) {\n              return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n            }\n            skipEOLs();\n            next();\n          }\n\n          isVarArgs = true;\n        } else {\n          paramType = parseTypeExpression(token);\n          if (match(JsDocToken.EQUALS)) {\n            skipEOLs();\n            next();\n            paramType = wrapNode(Token.EQUALS, paramType);\n          }\n        }\n\n        if (paramType == null) {\n          return null;\n        }\n        paramsType.addChildToBack(paramType);\n        if (isVarArgs) {\n          break;\n        }\n      } while (match(JsDocToken.COMMA));\n    }\n\n    if (isVarArgs && match(JsDocToken.COMMA)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");\n    }\n\n    // The right paren will be checked by parseFunctionType\n\n    return paramsType;\n  }\n\n  /**\n   * ResultType := <empty> | ':' void | ':' TypeExpression\n   */\n  private Node parseResultType(JsDocToken token) {\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return newNode(Token.EMPTY);\n    }\n\n    token = next();\n    skipEOLs();\n    if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) {\n      next();\n      return newNode(Token.VOID);\n    } else {\n      return parseTypeExpression(next());\n    }\n  }\n\n  /**\n   * UnionType := '(' TypeUnionList ')'\n   * TypeUnionList := TypeExpression | TypeExpression '|' TypeUnionList\n   *\n   * We've removed the empty union type.\n   */\n  private Node parseUnionType(JsDocToken token) {\n    return parseUnionTypeWithAlternate(token, null);\n  }\n\n  /**\n   * Create a new union type, with an alternate that has already been\n   * parsed. The alternate may be null.\n   */\n  private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) {\n    Node union = newNode(Token.PIPE);\n    if (alternate != null) {\n      union.addChildToBack(alternate);\n    }\n\n    Node expr = null;\n    do {\n      if (expr != null) {\n        skipEOLs();\n        token = next();\n        Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);\n\n        boolean isPipe = token == JsDocToken.PIPE;\n        if (isPipe && match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n      }\n      expr = parseTypeExpression(token);\n      if (expr == null) {\n        return null;\n      }\n\n      union.addChildToBack(expr);\n      // We support commas for backwards compatibility.\n    } while (match(JsDocToken.PIPE, JsDocToken.COMMA));\n\n    if (alternate == null) {\n      skipEOLs();\n      if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n      }\n      next();\n    }\n    return union;\n  }\n\n  /**\n   * ArrayType := '[' ElementTypeList ']'\n   * ElementTypeList := <empty> | TypeExpression | '...' TypeExpression\n   *     | TypeExpression ',' ElementTypeList\n   */\n  private Node parseArrayType(JsDocToken token) {", "right_context": "}\n}", "class_name": "JsDocInfoParser", "return_type": "Node", "parameters": [{"type": "JsDocToken", "name": "token"}]}}
{"prompt": "class ControlFlowAnalysis implements Callback, CompilerPass {\n\n  /**\n   * Computes the destination node of n when we want to fallthrough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   */\n  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n\n  /**\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   */\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n\n  /**\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   */\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (handler.isFunction()) {\n          return;\n        }\n        Preconditions.checkState(handler.isTry());\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n\n  /**\n   * Get the next sibling (including itself) of one of the given types.\n   */\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n    for (Node c = first; c != null; c = c.getNext()) {\n      for (int type : types) {\n        if (c.getType() == type) {\n          return c;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   */\n  public static boolean isBreakTarget(Node target, String label) {\n    return isBreakStructure(target, label != null) &&\n      matchLabel(target.getParent(), label);\n  }\n\n  /**\n   * Checks if target is actually the continue target of labeled continue. The\n   * label can be null if it is an unlabeled continue.\n   */\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n    return isContinueStructure(target) && matchLabel(parent, label);\n  }\n  /**\n   * Check if label is actually referencing the target control structure. If\n   * label is null, it always returns true.\n   */\n  private static boolean matchLabel(Node target, String label) {", "metadata": {"defects4j_task_id": "8b3b634d7ac52b0228b2f74992ab5307cc337f89c4f30e0ca511b2fe4ec08818", "task_id": "google_closure-compiler/114", "ground_truth": "\n    if (label == null) {\n      return true;\n    }\n    while (target.isLabel()) {\n      if (target.getFirstChild().getString().equals(label)) {\n        return true;\n      }\n      target = target.getParent();\n    }\n    return false;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "ControlFlowAnalysis.java"], "context_start_lineno": 0, "function_name": "matchLabel", "left_context": "class ControlFlowAnalysis implements Callback, CompilerPass {\n\n  /**\n   * Computes the destination node of n when we want to fallthrough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   */\n  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n\n  /**\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   */\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n\n  /**\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   */\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (handler.isFunction()) {\n          return;\n        }\n        Preconditions.checkState(handler.isTry());\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n\n  /**\n   * Get the next sibling (including itself) of one of the given types.\n   */\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n    for (Node c = first; c != null; c = c.getNext()) {\n      for (int type : types) {\n        if (c.getType() == type) {\n          return c;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   */\n  public static boolean isBreakTarget(Node target, String label) {\n    return isBreakStructure(target, label != null) &&\n      matchLabel(target.getParent(), label);\n  }\n\n  /**\n   * Checks if target is actually the continue target of labeled continue. The\n   * label can be null if it is an unlabeled continue.\n   */\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n    return isContinueStructure(target) && matchLabel(parent, label);\n  }\n  /**\n   * Check if label is actually referencing the target control structure. If\n   * label is null, it always returns true.\n   */\n  private static boolean matchLabel(Node target, String label) {", "right_context": "}\n}", "class_name": "ControlFlowAnalysis", "return_type": "boolean", "parameters": [{"type": "Node", "name": "target"}, {"type": "String", "name": "label"}]}}
{"prompt": "class InlineSimpleMethods extends MethodCompilerPass {\n\n  InlineSimpleMethods(AbstractCompiler compiler) {\n    super(compiler);\n  }\n\n  /**\n   * For each method call, see if it is a candidate for inlining.\n   * TODO(kushal): Cache the results of the checks\n   */\n  private class InlineTrivialAccessors extends InvocationsCallback {\n\n    @Override\n    void visit(NodeTraversal t, Node callNode, Node parent, String callName) {\n      if (externMethods.contains(callName) ||\n          nonMethodProperties.contains(callName)) {\n        return;\n      }\n\n      Collection<Node> definitions = methodDefinitions.get(callName);\n      if (definitions == null || definitions.size() == 0) {\n        return;\n      }\n\n      // Do check of arity, complexity, and consistency in what we think is\n      // the order from least to most complex\n      Node firstDefinition = definitions.iterator().next();\n\n      // Check any multiple definitions\n      if (definitions.size() == 1 || allDefinitionsEquivalent(definitions)) {\n\n        if (!argsMayHaveSideEffects(callNode)) {\n          // Verify this is a trivial return\n          Node returned = returnedExpression(firstDefinition);\n          if (returned != null) {\n            if (isPropertyTree(returned)) {\n              logger.fine(\"Inlining property accessor: \" + callName);\n              inlinePropertyReturn(parent, callNode, returned);\n            } else if (NodeUtil.isLiteralValue(returned, false) &&\n              !NodeUtil.mayHaveSideEffects(\n                  callNode.getFirstChild(), compiler)) {\n              logger.fine(\"Inlining constant accessor: \" + callName);\n              inlineConstReturn(parent, callNode, returned);\n            }\n          } else if (isEmptyMethod(firstDefinition) &&\n              !NodeUtil.mayHaveSideEffects(\n                  callNode.getFirstChild(), compiler)) {\n            logger.fine(\"Inlining empty method: \" + callName);\n            inlineEmptyMethod(parent, callNode);\n          }\n        }\n      } else {\n        logger.fine(\"Method '\" + callName + \"' has conflicting definitions.\");\n      }\n    }\n  }\n\n  @Override\n  Callback getActingCallback() {\n    return new InlineTrivialAccessors();\n  }\n\n  /**\n   * Returns true if the provided node is a getprop for\n   * which the left child is this or a valid property tree\n   * and for which the right side is a string.\n   */\n  private static boolean isPropertyTree(Node expectedGetprop) {\n    if (!expectedGetprop.isGetProp()) {\n      return false;\n    }\n\n    Node leftChild = expectedGetprop.getFirstChild();\n    if (!leftChild.isThis() &&\n        !isPropertyTree(leftChild)) {\n      return false;\n    }\n\n    Node retVal = leftChild.getNext();\n    if (NodeUtil.getStringValue(retVal) == null) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Finds the occurrence of \"this\" in the provided property tree and replaces\n   * it with replacement\n   */\n  private static void replaceThis(Node expectedGetprop, Node replacement) {\n    Node leftChild = expectedGetprop.getFirstChild();\n    if (leftChild.isThis()) {\n      expectedGetprop.replaceChild(leftChild, replacement);\n    } else {\n      replaceThis(leftChild, replacement);\n    }\n  }\n\n  /**\n   * Return the node that represents the expression returned\n   * by the method, given a FUNCTION node.\n   */\n  private static Node returnedExpression(Node fn) {\n    Node expectedBlock = getMethodBlock(fn);\n    if (!expectedBlock.hasOneChild()) {\n      return null;\n    }\n\n    Node expectedReturn = expectedBlock.getFirstChild();\n    if (!expectedReturn.isReturn()) {\n      return null;\n    }\n\n    if (!expectedReturn.hasOneChild()) {\n      return null;\n    }\n\n    return expectedReturn.getLastChild();\n  }\n\n\n  /**\n   * Return whether the given FUNCTION node is an empty method definition.\n   *\n   * Must be private, or moved to NodeUtil.\n   */\n  private static boolean isEmptyMethod(Node fn) {\n    Node expectedBlock = getMethodBlock(fn);\n    return expectedBlock == null ?\n        false : NodeUtil.isEmptyBlock(expectedBlock);\n  }\n\n  /**\n   * Return a BLOCK node if the given FUNCTION node is a valid method\n   * definition, null otherwise.\n   *\n   * Must be private, or moved to NodeUtil.\n   */\n  private static Node getMethodBlock(Node fn) {\n    if (fn.getChildCount() != 3) {\n      return null;\n    }\n\n    Node expectedBlock = fn.getLastChild();\n    return  expectedBlock.isBlock() ?\n        expectedBlock : null;\n  }\n\n  /**\n   * Given a set of method definitions, verify they are the same.\n   */\n  private boolean allDefinitionsEquivalent(\n      Collection<Node> definitions) {\n    List<Node> list = Lists.newArrayList();\n    list.addAll(definitions);\n    Node node0 = list.get(0);\n    for (int i = 1; i < list.size(); i++) {\n      if (!compiler.areNodesEqualForInlining(list.get(i), node0)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Replace the provided method call with the tree specified in returnedValue\n   *\n   * Parse tree of a call is\n   * name\n   *   call\n   *     getprop\n   *       obj\n   *       string\n   */\n  private void inlinePropertyReturn(Node parent, Node call,\n      Node returnedValue) {\n    Node getProp = returnedValue.cloneTree();\n    replaceThis(getProp, call.getFirstChild().removeFirstChild());\n    parent.replaceChild(call, getProp);\n    compiler.reportCodeChange();\n  }\n\n  /**\n   * Replace the provided object and its method call with the tree specified\n   * in returnedValue. Should be called only if the object reference has\n   * no side effects.\n   */\n  private void inlineConstReturn(Node parent, Node call,\n      Node returnedValue) {\n    Node retValue = returnedValue.cloneTree();\n    parent.replaceChild(call, retValue);\n    compiler.reportCodeChange();\n  }\n\n  /**\n   * Remove the provided object and its method call.\n   */\n  private void inlineEmptyMethod(Node parent, Node call) {\n    // If the return value of the method call is read,\n    // replace it with \"void 0\". Otherwise, remove the call entirely.\n    if (NodeUtil.isExprCall(parent)) {\n      parent.getParent().replaceChild(parent, IR.empty());\n    } else {\n      Node srcLocation = call;\n      parent.replaceChild(call, NodeUtil.newUndefinedNode(srcLocation));\n    }\n    compiler.reportCodeChange();\n  }\n\n  /**\n   * Check whether the given method call's arguments have side effects.\n   * @param call The call node of a method invocation.\n   */\n  private boolean argsMayHaveSideEffects(Node call) {", "metadata": {"defects4j_task_id": "77061acaa9219a1319f04a8be21be82f74807ef0b3d8a58c962ce2634a8266f6", "task_id": "google_closure-compiler/99", "ground_truth": "\n    for (Node currentChild = call.getFirstChild().getNext();\n         currentChild != null;\n         currentChild = currentChild.getNext()) {\n      if (NodeUtil.mayHaveSideEffects(currentChild, compiler)) {\n        return true;\n      }\n    }\n\n    return false;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "InlineSimpleMethods.java"], "context_start_lineno": 0, "function_name": "argsMayHaveSideEffects", "left_context": "class InlineSimpleMethods extends MethodCompilerPass {\n\n  InlineSimpleMethods(AbstractCompiler compiler) {\n    super(compiler);\n  }\n\n  /**\n   * For each method call, see if it is a candidate for inlining.\n   * TODO(kushal): Cache the results of the checks\n   */\n  private class InlineTrivialAccessors extends InvocationsCallback {\n\n    @Override\n    void visit(NodeTraversal t, Node callNode, Node parent, String callName) {\n      if (externMethods.contains(callName) ||\n          nonMethodProperties.contains(callName)) {\n        return;\n      }\n\n      Collection<Node> definitions = methodDefinitions.get(callName);\n      if (definitions == null || definitions.size() == 0) {\n        return;\n      }\n\n      // Do check of arity, complexity, and consistency in what we think is\n      // the order from least to most complex\n      Node firstDefinition = definitions.iterator().next();\n\n      // Check any multiple definitions\n      if (definitions.size() == 1 || allDefinitionsEquivalent(definitions)) {\n\n        if (!argsMayHaveSideEffects(callNode)) {\n          // Verify this is a trivial return\n          Node returned = returnedExpression(firstDefinition);\n          if (returned != null) {\n            if (isPropertyTree(returned)) {\n              logger.fine(\"Inlining property accessor: \" + callName);\n              inlinePropertyReturn(parent, callNode, returned);\n            } else if (NodeUtil.isLiteralValue(returned, false) &&\n              !NodeUtil.mayHaveSideEffects(\n                  callNode.getFirstChild(), compiler)) {\n              logger.fine(\"Inlining constant accessor: \" + callName);\n              inlineConstReturn(parent, callNode, returned);\n            }\n          } else if (isEmptyMethod(firstDefinition) &&\n              !NodeUtil.mayHaveSideEffects(\n                  callNode.getFirstChild(), compiler)) {\n            logger.fine(\"Inlining empty method: \" + callName);\n            inlineEmptyMethod(parent, callNode);\n          }\n        }\n      } else {\n        logger.fine(\"Method '\" + callName + \"' has conflicting definitions.\");\n      }\n    }\n  }\n\n  @Override\n  Callback getActingCallback() {\n    return new InlineTrivialAccessors();\n  }\n\n  /**\n   * Returns true if the provided node is a getprop for\n   * which the left child is this or a valid property tree\n   * and for which the right side is a string.\n   */\n  private static boolean isPropertyTree(Node expectedGetprop) {\n    if (!expectedGetprop.isGetProp()) {\n      return false;\n    }\n\n    Node leftChild = expectedGetprop.getFirstChild();\n    if (!leftChild.isThis() &&\n        !isPropertyTree(leftChild)) {\n      return false;\n    }\n\n    Node retVal = leftChild.getNext();\n    if (NodeUtil.getStringValue(retVal) == null) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Finds the occurrence of \"this\" in the provided property tree and replaces\n   * it with replacement\n   */\n  private static void replaceThis(Node expectedGetprop, Node replacement) {\n    Node leftChild = expectedGetprop.getFirstChild();\n    if (leftChild.isThis()) {\n      expectedGetprop.replaceChild(leftChild, replacement);\n    } else {\n      replaceThis(leftChild, replacement);\n    }\n  }\n\n  /**\n   * Return the node that represents the expression returned\n   * by the method, given a FUNCTION node.\n   */\n  private static Node returnedExpression(Node fn) {\n    Node expectedBlock = getMethodBlock(fn);\n    if (!expectedBlock.hasOneChild()) {\n      return null;\n    }\n\n    Node expectedReturn = expectedBlock.getFirstChild();\n    if (!expectedReturn.isReturn()) {\n      return null;\n    }\n\n    if (!expectedReturn.hasOneChild()) {\n      return null;\n    }\n\n    return expectedReturn.getLastChild();\n  }\n\n\n  /**\n   * Return whether the given FUNCTION node is an empty method definition.\n   *\n   * Must be private, or moved to NodeUtil.\n   */\n  private static boolean isEmptyMethod(Node fn) {\n    Node expectedBlock = getMethodBlock(fn);\n    return expectedBlock == null ?\n        false : NodeUtil.isEmptyBlock(expectedBlock);\n  }\n\n  /**\n   * Return a BLOCK node if the given FUNCTION node is a valid method\n   * definition, null otherwise.\n   *\n   * Must be private, or moved to NodeUtil.\n   */\n  private static Node getMethodBlock(Node fn) {\n    if (fn.getChildCount() != 3) {\n      return null;\n    }\n\n    Node expectedBlock = fn.getLastChild();\n    return  expectedBlock.isBlock() ?\n        expectedBlock : null;\n  }\n\n  /**\n   * Given a set of method definitions, verify they are the same.\n   */\n  private boolean allDefinitionsEquivalent(\n      Collection<Node> definitions) {\n    List<Node> list = Lists.newArrayList();\n    list.addAll(definitions);\n    Node node0 = list.get(0);\n    for (int i = 1; i < list.size(); i++) {\n      if (!compiler.areNodesEqualForInlining(list.get(i), node0)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Replace the provided method call with the tree specified in returnedValue\n   *\n   * Parse tree of a call is\n   * name\n   *   call\n   *     getprop\n   *       obj\n   *       string\n   */\n  private void inlinePropertyReturn(Node parent, Node call,\n      Node returnedValue) {\n    Node getProp = returnedValue.cloneTree();\n    replaceThis(getProp, call.getFirstChild().removeFirstChild());\n    parent.replaceChild(call, getProp);\n    compiler.reportCodeChange();\n  }\n\n  /**\n   * Replace the provided object and its method call with the tree specified\n   * in returnedValue. Should be called only if the object reference has\n   * no side effects.\n   */\n  private void inlineConstReturn(Node parent, Node call,\n      Node returnedValue) {\n    Node retValue = returnedValue.cloneTree();\n    parent.replaceChild(call, retValue);\n    compiler.reportCodeChange();\n  }\n\n  /**\n   * Remove the provided object and its method call.\n   */\n  private void inlineEmptyMethod(Node parent, Node call) {\n    // If the return value of the method call is read,\n    // replace it with \"void 0\". Otherwise, remove the call entirely.\n    if (NodeUtil.isExprCall(parent)) {\n      parent.getParent().replaceChild(parent, IR.empty());\n    } else {\n      Node srcLocation = call;\n      parent.replaceChild(call, NodeUtil.newUndefinedNode(srcLocation));\n    }\n    compiler.reportCodeChange();\n  }\n\n  /**\n   * Check whether the given method call's arguments have side effects.\n   * @param call The call node of a method invocation.\n   */\n  private boolean argsMayHaveSideEffects(Node call) {", "right_context": "}\n}", "class_name": "InlineSimpleMethods", "return_type": "boolean", "parameters": [{"type": "Node", "name": "call"}]}}
{"prompt": "class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n\n  /**\n   * Whether the given access of a private constructor is legal.\n   *\n   * For example,\n   * new PrivateCtor_(); // not legal\n   * PrivateCtor_.newInstance(); // legal\n   * x instanceof PrivateCtor_ // legal\n   *\n   * This is a weird special case, because our visibility system is inherited\n   * from Java, and JavaScript has no distinction between classes and\n   * constructors like Java does.\n   *\n   * We may want to revisit this if we decide to make the restrictions tighter.\n   */\n  private static boolean isValidPrivateConstructorAccess(Node parent) {\n    return !parent.isNew();\n  }\n\n  /**\n   * Determines whether a deprecation warning should be emitted.\n   * @param t The current traversal.\n   * @param n The node which we are checking.\n   * @param parent The parent of the node which we are checking.\n   */\n  private boolean shouldEmitDeprecationWarning(\n      NodeTraversal t, Node n, Node parent) {\n    // In the global scope, there are only two kinds of accesses that should\n    // be flagged for warnings:\n    // 1) Calls of deprecated functions and methods.\n    // 2) Instantiations of deprecated classes.\n    // For now, we just let everything else by.\n    if (t.inGlobalScope()) {\n      if (!((parent.isCall() && parent.getFirstChild() == n) ||\n              n.isNew())) {\n        return false;\n      }\n    }\n\n    // We can always assign to a deprecated property, to keep it up to date.\n    if (n.isGetProp() && n == parent.getFirstChild() &&\n        NodeUtil.isAssignmentOp(parent)) {\n      return false;\n    }\n\n    return !canAccessDeprecatedTypes(t);\n  }\n\n  /**\n   * Returns whether it's currently OK to access deprecated names and\n   * properties.\n   *\n   * There are 3 exceptions when we're allowed to use a deprecated\n   * type or property:\n   * 1) When we're in a deprecated function.\n   * 2) When we're in a deprecated class.\n   * 3) When we're in a static method of a deprecated class.\n   */\n  private boolean canAccessDeprecatedTypes(NodeTraversal t) {\n    Node scopeRoot = t.getScopeRoot();\n    Node scopeRootParent = scopeRoot.getParent();\n    return\n      // Case #1\n      (deprecatedDepth > 0) ||\n      // Case #2\n      (getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null) ||\n        // Case #3\n      (scopeRootParent != null && scopeRootParent.isAssign() &&\n       getTypeDeprecationInfo(\n           getClassOfMethod(scopeRoot, scopeRootParent)) != null);\n  }\n\n  /**\n   * Returns whether this is a function node annotated as deprecated.\n   */\n  private static boolean isDeprecatedFunction(Node n) {\n    if (n.isFunction()) {\n      JSType type = n.getJSType();\n      if (type != null) {\n        return getTypeDeprecationInfo(type) != null;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the deprecation reason for the type if it is marked\n   * as being deprecated. Returns empty string if the type is deprecated\n   * but no reason was given. Returns null if the type is not deprecated.\n   */\n  private static String getTypeDeprecationInfo(JSType type) {", "metadata": {"defects4j_task_id": "faef70291ef2399e570807ecd9018e2b4bc8f044af55195d72a8acd9ac7f0672", "task_id": "google_closure-compiler/205", "ground_truth": "\n    if (type == null) {\n      return null;\n    }\n\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n    ObjectType objType = ObjectType.cast(type);\n    if (objType != null) {\n      ObjectType implicitProto = objType.getImplicitPrototype();\n      if (implicitProto != null) {\n        return getTypeDeprecationInfo(implicitProto);\n      }\n    }\n    return null;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "CheckAccessControls.java"], "context_start_lineno": 0, "function_name": "getTypeDeprecationInfo", "left_context": "class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n\n  /**\n   * Whether the given access of a private constructor is legal.\n   *\n   * For example,\n   * new PrivateCtor_(); // not legal\n   * PrivateCtor_.newInstance(); // legal\n   * x instanceof PrivateCtor_ // legal\n   *\n   * This is a weird special case, because our visibility system is inherited\n   * from Java, and JavaScript has no distinction between classes and\n   * constructors like Java does.\n   *\n   * We may want to revisit this if we decide to make the restrictions tighter.\n   */\n  private static boolean isValidPrivateConstructorAccess(Node parent) {\n    return !parent.isNew();\n  }\n\n  /**\n   * Determines whether a deprecation warning should be emitted.\n   * @param t The current traversal.\n   * @param n The node which we are checking.\n   * @param parent The parent of the node which we are checking.\n   */\n  private boolean shouldEmitDeprecationWarning(\n      NodeTraversal t, Node n, Node parent) {\n    // In the global scope, there are only two kinds of accesses that should\n    // be flagged for warnings:\n    // 1) Calls of deprecated functions and methods.\n    // 2) Instantiations of deprecated classes.\n    // For now, we just let everything else by.\n    if (t.inGlobalScope()) {\n      if (!((parent.isCall() && parent.getFirstChild() == n) ||\n              n.isNew())) {\n        return false;\n      }\n    }\n\n    // We can always assign to a deprecated property, to keep it up to date.\n    if (n.isGetProp() && n == parent.getFirstChild() &&\n        NodeUtil.isAssignmentOp(parent)) {\n      return false;\n    }\n\n    return !canAccessDeprecatedTypes(t);\n  }\n\n  /**\n   * Returns whether it's currently OK to access deprecated names and\n   * properties.\n   *\n   * There are 3 exceptions when we're allowed to use a deprecated\n   * type or property:\n   * 1) When we're in a deprecated function.\n   * 2) When we're in a deprecated class.\n   * 3) When we're in a static method of a deprecated class.\n   */\n  private boolean canAccessDeprecatedTypes(NodeTraversal t) {\n    Node scopeRoot = t.getScopeRoot();\n    Node scopeRootParent = scopeRoot.getParent();\n    return\n      // Case #1\n      (deprecatedDepth > 0) ||\n      // Case #2\n      (getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null) ||\n        // Case #3\n      (scopeRootParent != null && scopeRootParent.isAssign() &&\n       getTypeDeprecationInfo(\n           getClassOfMethod(scopeRoot, scopeRootParent)) != null);\n  }\n\n  /**\n   * Returns whether this is a function node annotated as deprecated.\n   */\n  private static boolean isDeprecatedFunction(Node n) {\n    if (n.isFunction()) {\n      JSType type = n.getJSType();\n      if (type != null) {\n        return getTypeDeprecationInfo(type) != null;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the deprecation reason for the type if it is marked\n   * as being deprecated. Returns empty string if the type is deprecated\n   * but no reason was given. Returns null if the type is not deprecated.\n   */\n  private static String getTypeDeprecationInfo(JSType type) {", "right_context": "}\n}", "class_name": "CheckAccessControls", "return_type": "String", "parameters": [{"type": "JSType", "name": "type"}]}}
{"prompt": "class LinkedFlowScope implements FlowScope {\n  // The closest flow scope cache.\n  /**\n   * Iterate through all the linked flow scopes before this one.\n   * If there's one and only one slot defined between this scope\n   * and the blind scope, return it.\n   */\n  @Override\n  public StaticSlot<JSType> findUniqueRefinedSlot(FlowScope blindScope) {\n    StaticSlot<JSType> result = null;\n\n    for (LinkedFlowScope currentScope = this;\n         currentScope != blindScope;\n         currentScope = currentScope.parent) {\n      for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n           currentSlot != null &&\n           (currentScope.parent == null ||\n            currentScope.parent.lastSlot != currentSlot);\n           currentSlot = currentSlot.parent) {\n        if (result == null) {\n          result = currentSlot;\n        } else if (!currentSlot.getName().equals(result.getName())) {\n          return null;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Look through the given scope, and try to find slots where it doesn't\n   * have enough type information. Then fill in that type information\n   * with stuff that we've inferred in the local flow.\n   */\n  @Override\n  public void completeScope(StaticScope<JSType> staticScope) {\n    Scope scope = (Scope) staticScope;\n    for (Iterator<Var> it = scope.getVars(); it.hasNext();) {\n      Var var = it.next();\n      if (var.isTypeInferred()) {\n        JSType type = var.getType();\n        if (type == null || type.isUnknownType()) {\n          JSType flowType = getSlot(var.getName()).getType();\n          var.setType(flowType);\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove flow scopes that add nothing to the flow.\n   */\n  // NOTE(nicksantos): This function breaks findUniqueRefinedSlot, because\n  // findUniqueRefinedSlot assumes that this scope is a direct descendant\n  // of blindScope. This is not necessarily true if this scope has been\n  // optimize()d and blindScope has not. This should be fixed. For now,\n  // we only use optimize() where we know that we won't have to do\n  // a findUniqueRefinedSlot on it.\n  @Override\n  public LinkedFlowScope optimize() {\n    LinkedFlowScope current;\n    for (current = this;\n         current.parent != null &&\n             current.lastSlot == current.parent.lastSlot;\n         current = current.parent) {}\n    return current;\n  }\n\n  /** Join the two FlowScopes. */\n  static class FlowScopeJoinOp extends JoinOp.BinaryJoinOp<FlowScope> {\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public FlowScope apply(FlowScope a, FlowScope b) {\n      // To join the two scopes, we have to\n      LinkedFlowScope linkedA = (LinkedFlowScope) a;\n      LinkedFlowScope linkedB = (LinkedFlowScope) b;\n      linkedA.frozen = true;\n      linkedB.frozen = true;\n      if (linkedA.optimize() == linkedB.optimize()) {\n        return linkedA.createChildFlowScope();\n      }\n      return new LinkedFlowScope(new FlatFlowScopeCache(linkedA, linkedB));\n    }\n  }\n\n  @Override\n  public boolean equals(Object other) {\n    if (other instanceof LinkedFlowScope) {\n      LinkedFlowScope that = (LinkedFlowScope) other;\n      if (this.optimize() == that.optimize()) {\n        return true;\n      }\n\n      // If two flow scopes are in the same function, then they could have\n      // two possible function scopes: the real one and the BOTTOM scope.\n      // If they have different function scopes, we *should* iterate through all\n      // the variables in each scope and compare. However, 99.9% of the time,\n      // they're not equal. And the other .1% of the time, we can pretend\n      // they're equal--this just means that data flow analysis will have\n      // to propagate the entry lattice a little bit further than it\n      // really needs to. Everything will still come out ok.\n      if (this.getFunctionScope() != that.getFunctionScope()) {\n        return false;\n      }\n\n      if (cache == that.cache) {\n        // If the two flow scopes have the same cache, then we can check\n        // equality a lot faster: by just looking at the \"dirty\" elements\n        // in the cache, and comparing them in both scopes.\n        for (String name : cache.dirtySymbols) {\n          if (diffSlots(getSlot(name), that.getSlot(name))) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      Map<String, StaticSlot<JSType>> myFlowSlots = allFlowSlots();\n      Map<String, StaticSlot<JSType>> otherFlowSlots = that.allFlowSlots();\n\n      for (StaticSlot<JSType> slot : myFlowSlots.values()) {\n        if (diffSlots(slot, otherFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n        otherFlowSlots.remove(slot.getName());\n      }\n      for (StaticSlot<JSType> slot : otherFlowSlots.values()) {\n        if (diffSlots(slot, myFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether two slots are meaningfully different for the\n   * purposes of data flow analysis.\n   */\n  private boolean diffSlots(StaticSlot<JSType> slotA,\n                            StaticSlot<JSType> slotB) {\n    boolean aIsNull = slotA == null || slotA.getType() == null;\n    boolean bIsNull = slotB == null || slotB.getType() == null;\n    if (aIsNull && bIsNull) {\n      return false;\n    } else if (aIsNull ^ bIsNull) {\n      return true;\n    }\n\n    // Both slots and types must be non-null.\n    return slotA.getType().differsFrom(slotB.getType());\n  }\n\n  /**\n   * Gets all the symbols that have been defined before this point\n   * in the current flow. Does not return slots that have not changed during\n   * the flow.\n   *\n   * For example, consider the code:\n   * <code>\n   * var x = 3;\n   * function f() {\n   *   var y = 5;\n   *   y = 6; // FLOW POINT\n   *   var z = y;\n   *   return z;\n   * }\n   * </code>\n   * A FlowScope at FLOW POINT will return a slot for y, but not\n   * a slot for x or z.\n   */\n  private Map<String, StaticSlot<JSType>> allFlowSlots() {", "metadata": {"defects4j_task_id": "a2c6dea8263f7424f3cda5133e03380fbcb632aeb0ad9883e9c67d40455adb7b", "task_id": "google_closure-compiler/133", "ground_truth": "\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    for (LinkedFlowSlot slot = lastSlot;\n         slot != null; slot = slot.parent) {\n      if (!slots.containsKey(slot.getName())) {\n        slots.put(slot.getName(), slot);\n      }\n    }\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "LinkedFlowScope.java"], "context_start_lineno": 0, "function_name": "allFlowSlots", "left_context": "class LinkedFlowScope implements FlowScope {\n  // The closest flow scope cache.\n  /**\n   * Iterate through all the linked flow scopes before this one.\n   * If there's one and only one slot defined between this scope\n   * and the blind scope, return it.\n   */\n  @Override\n  public StaticSlot<JSType> findUniqueRefinedSlot(FlowScope blindScope) {\n    StaticSlot<JSType> result = null;\n\n    for (LinkedFlowScope currentScope = this;\n         currentScope != blindScope;\n         currentScope = currentScope.parent) {\n      for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n           currentSlot != null &&\n           (currentScope.parent == null ||\n            currentScope.parent.lastSlot != currentSlot);\n           currentSlot = currentSlot.parent) {\n        if (result == null) {\n          result = currentSlot;\n        } else if (!currentSlot.getName().equals(result.getName())) {\n          return null;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Look through the given scope, and try to find slots where it doesn't\n   * have enough type information. Then fill in that type information\n   * with stuff that we've inferred in the local flow.\n   */\n  @Override\n  public void completeScope(StaticScope<JSType> staticScope) {\n    Scope scope = (Scope) staticScope;\n    for (Iterator<Var> it = scope.getVars(); it.hasNext();) {\n      Var var = it.next();\n      if (var.isTypeInferred()) {\n        JSType type = var.getType();\n        if (type == null || type.isUnknownType()) {\n          JSType flowType = getSlot(var.getName()).getType();\n          var.setType(flowType);\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove flow scopes that add nothing to the flow.\n   */\n  // NOTE(nicksantos): This function breaks findUniqueRefinedSlot, because\n  // findUniqueRefinedSlot assumes that this scope is a direct descendant\n  // of blindScope. This is not necessarily true if this scope has been\n  // optimize()d and blindScope has not. This should be fixed. For now,\n  // we only use optimize() where we know that we won't have to do\n  // a findUniqueRefinedSlot on it.\n  @Override\n  public LinkedFlowScope optimize() {\n    LinkedFlowScope current;\n    for (current = this;\n         current.parent != null &&\n             current.lastSlot == current.parent.lastSlot;\n         current = current.parent) {}\n    return current;\n  }\n\n  /** Join the two FlowScopes. */\n  static class FlowScopeJoinOp extends JoinOp.BinaryJoinOp<FlowScope> {\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public FlowScope apply(FlowScope a, FlowScope b) {\n      // To join the two scopes, we have to\n      LinkedFlowScope linkedA = (LinkedFlowScope) a;\n      LinkedFlowScope linkedB = (LinkedFlowScope) b;\n      linkedA.frozen = true;\n      linkedB.frozen = true;\n      if (linkedA.optimize() == linkedB.optimize()) {\n        return linkedA.createChildFlowScope();\n      }\n      return new LinkedFlowScope(new FlatFlowScopeCache(linkedA, linkedB));\n    }\n  }\n\n  @Override\n  public boolean equals(Object other) {\n    if (other instanceof LinkedFlowScope) {\n      LinkedFlowScope that = (LinkedFlowScope) other;\n      if (this.optimize() == that.optimize()) {\n        return true;\n      }\n\n      // If two flow scopes are in the same function, then they could have\n      // two possible function scopes: the real one and the BOTTOM scope.\n      // If they have different function scopes, we *should* iterate through all\n      // the variables in each scope and compare. However, 99.9% of the time,\n      // they're not equal. And the other .1% of the time, we can pretend\n      // they're equal--this just means that data flow analysis will have\n      // to propagate the entry lattice a little bit further than it\n      // really needs to. Everything will still come out ok.\n      if (this.getFunctionScope() != that.getFunctionScope()) {\n        return false;\n      }\n\n      if (cache == that.cache) {\n        // If the two flow scopes have the same cache, then we can check\n        // equality a lot faster: by just looking at the \"dirty\" elements\n        // in the cache, and comparing them in both scopes.\n        for (String name : cache.dirtySymbols) {\n          if (diffSlots(getSlot(name), that.getSlot(name))) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      Map<String, StaticSlot<JSType>> myFlowSlots = allFlowSlots();\n      Map<String, StaticSlot<JSType>> otherFlowSlots = that.allFlowSlots();\n\n      for (StaticSlot<JSType> slot : myFlowSlots.values()) {\n        if (diffSlots(slot, otherFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n        otherFlowSlots.remove(slot.getName());\n      }\n      for (StaticSlot<JSType> slot : otherFlowSlots.values()) {\n        if (diffSlots(slot, myFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether two slots are meaningfully different for the\n   * purposes of data flow analysis.\n   */\n  private boolean diffSlots(StaticSlot<JSType> slotA,\n                            StaticSlot<JSType> slotB) {\n    boolean aIsNull = slotA == null || slotA.getType() == null;\n    boolean bIsNull = slotB == null || slotB.getType() == null;\n    if (aIsNull && bIsNull) {\n      return false;\n    } else if (aIsNull ^ bIsNull) {\n      return true;\n    }\n\n    // Both slots and types must be non-null.\n    return slotA.getType().differsFrom(slotB.getType());\n  }\n\n  /**\n   * Gets all the symbols that have been defined before this point\n   * in the current flow. Does not return slots that have not changed during\n   * the flow.\n   *\n   * For example, consider the code:\n   * <code>\n   * var x = 3;\n   * function f() {\n   *   var y = 5;\n   *   y = 6; // FLOW POINT\n   *   var z = y;\n   *   return z;\n   * }\n   * </code>\n   * A FlowScope at FLOW POINT will return a slot for y, but not\n   * a slot for x or z.\n   */\n  private Map<String, StaticSlot<JSType>> allFlowSlots() {", "right_context": "}\n}", "class_name": "LinkedFlowScope", "return_type": "Map<String,StaticSlot<JSType>>", "parameters": []}}
{"prompt": "class SemanticReverseAbstractInterpreter\n    extends ChainableReverseAbstractInterpreter {\n\n  private FlowScope caseEquality(Node condition, FlowScope blindScope,\n      Function<TypePair, TypePair> merging) {\n    return caseEquality(condition.getFirstChild(), condition.getLastChild(),\n                        blindScope, merging);\n  }\n\n  private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,\n      Function<TypePair, TypePair> merging) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n    }\n\n    // merged types\n    TypePair merged = merging.apply(new TypePair(leftType, rightType));\n\n    // creating new scope\n    if (merged != null) {\n      return maybeRestrictTwoNames(\n          blindScope,\n          left, leftType, leftIsRefineable ? merged.typeA : null,\n          right, rightType, rightIsRefineable ? merged.typeB : null);\n    }\n    return blindScope;\n  }\n\n  private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,\n        FlowScope blindScope, boolean condition) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          left, blindScope, condition);\n    }\n\n    // restricting left type\n    JSType restrictedLeftType = (leftType == null) ? null :\n        leftType.getRestrictedTypeGivenToBooleanOutcome(condition);\n    if (restrictedLeftType == null) {\n      return firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    if (condition) {\n      JSType restrictedRightType = (rightType == null) ? null :\n          rightType.getRestrictedTypeGivenToBooleanOutcome(condition);\n\n      // creating new scope\n      return maybeRestrictTwoNames(\n          blindScope,\n          left, leftType, leftIsRefineable ? restrictedLeftType : null,\n          right, rightType, rightIsRefineable ? restrictedRightType : null);\n    }\n    return blindScope;\n  }\n\n  private FlowScope caseAndOrMaybeShortCircuiting(Node left, Node right,\n      FlowScope blindScope, boolean condition) {\n    FlowScope leftScope = firstPreciserScopeKnowingConditionOutcome(\n        left, blindScope, !condition);\n    StaticSlot<JSType> leftVar = leftScope.findUniqueRefinedSlot(blindScope);\n    if (leftVar == null) {\n      // If we did create a more precise scope, blindScope has a child and\n      // it is frozen. We can't just throw it away to return it. So we\n      // must create a child instead.\n      return blindScope == leftScope ?\n          blindScope : blindScope.createChildFlowScope();\n    }\n    FlowScope rightScope = firstPreciserScopeKnowingConditionOutcome(\n        left, blindScope, condition);\n    rightScope = firstPreciserScopeKnowingConditionOutcome(\n        right, rightScope, !condition);\n    StaticSlot<JSType> rightVar = rightScope.findUniqueRefinedSlot(blindScope);\n    if (rightVar == null || !leftVar.getName().equals(rightVar.getName())) {\n      return blindScope == rightScope ?\n          blindScope : blindScope.createChildFlowScope();\n    }\n    JSType type = leftVar.getType().getLeastSupertype(rightVar.getType());\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(leftVar.getName(), type);\n    return informed;\n  }\n\n  /**\n   * If the restrictedType differs from the originalType, then we should\n   * branch the current flow scope and create a new flow scope with the name\n   * declared with the new type.\n   *\n   * We try not to create spurious child flow scopes as this makes type\n   * inference slower.\n   *\n   * We also do not want spurious slots around in type inference, because\n   * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\n   * type is a symbol that the programmer has already checked and verified that\n   * it's defined, even if we don't know what it is.\n   *\n   * It is OK to pass non-name nodes into this method, as long as you pass\n   * in {@code null} for a restricted type.\n   */\n  private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {", "metadata": {"defects4j_task_id": "ed8fd42fd2612537847d6eacdb8dea8c317fa7e1fe71cd9228c0e5f043fd0ced", "task_id": "google_closure-compiler/196", "ground_truth": "\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "type", "SemanticReverseAbstractInterpreter.java"], "context_start_lineno": 0, "function_name": "maybeRestrictName", "left_context": "class SemanticReverseAbstractInterpreter\n    extends ChainableReverseAbstractInterpreter {\n\n  private FlowScope caseEquality(Node condition, FlowScope blindScope,\n      Function<TypePair, TypePair> merging) {\n    return caseEquality(condition.getFirstChild(), condition.getLastChild(),\n                        blindScope, merging);\n  }\n\n  private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,\n      Function<TypePair, TypePair> merging) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n    }\n\n    // merged types\n    TypePair merged = merging.apply(new TypePair(leftType, rightType));\n\n    // creating new scope\n    if (merged != null) {\n      return maybeRestrictTwoNames(\n          blindScope,\n          left, leftType, leftIsRefineable ? merged.typeA : null,\n          right, rightType, rightIsRefineable ? merged.typeB : null);\n    }\n    return blindScope;\n  }\n\n  private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,\n        FlowScope blindScope, boolean condition) {\n    // left type\n    JSType leftType = getTypeIfRefinable(left, blindScope);\n    boolean leftIsRefineable;\n    if (leftType != null) {\n      leftIsRefineable = true;\n    } else {\n      leftIsRefineable = false;\n      leftType = left.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          left, blindScope, condition);\n    }\n\n    // restricting left type\n    JSType restrictedLeftType = (leftType == null) ? null :\n        leftType.getRestrictedTypeGivenToBooleanOutcome(condition);\n    if (restrictedLeftType == null) {\n      return firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    // right type\n    JSType rightType = getTypeIfRefinable(right, blindScope);\n    boolean rightIsRefineable;\n    if (rightType != null) {\n      rightIsRefineable = true;\n    } else {\n      rightIsRefineable = false;\n      rightType = right.getJSType();\n      blindScope = firstPreciserScopeKnowingConditionOutcome(\n          right, blindScope, condition);\n    }\n\n    if (condition) {\n      JSType restrictedRightType = (rightType == null) ? null :\n          rightType.getRestrictedTypeGivenToBooleanOutcome(condition);\n\n      // creating new scope\n      return maybeRestrictTwoNames(\n          blindScope,\n          left, leftType, leftIsRefineable ? restrictedLeftType : null,\n          right, rightType, rightIsRefineable ? restrictedRightType : null);\n    }\n    return blindScope;\n  }\n\n  private FlowScope caseAndOrMaybeShortCircuiting(Node left, Node right,\n      FlowScope blindScope, boolean condition) {\n    FlowScope leftScope = firstPreciserScopeKnowingConditionOutcome(\n        left, blindScope, !condition);\n    StaticSlot<JSType> leftVar = leftScope.findUniqueRefinedSlot(blindScope);\n    if (leftVar == null) {\n      // If we did create a more precise scope, blindScope has a child and\n      // it is frozen. We can't just throw it away to return it. So we\n      // must create a child instead.\n      return blindScope == leftScope ?\n          blindScope : blindScope.createChildFlowScope();\n    }\n    FlowScope rightScope = firstPreciserScopeKnowingConditionOutcome(\n        left, blindScope, condition);\n    rightScope = firstPreciserScopeKnowingConditionOutcome(\n        right, rightScope, !condition);\n    StaticSlot<JSType> rightVar = rightScope.findUniqueRefinedSlot(blindScope);\n    if (rightVar == null || !leftVar.getName().equals(rightVar.getName())) {\n      return blindScope == rightScope ?\n          blindScope : blindScope.createChildFlowScope();\n    }\n    JSType type = leftVar.getType().getLeastSupertype(rightVar.getType());\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(leftVar.getName(), type);\n    return informed;\n  }\n\n  /**\n   * If the restrictedType differs from the originalType, then we should\n   * branch the current flow scope and create a new flow scope with the name\n   * declared with the new type.\n   *\n   * We try not to create spurious child flow scopes as this makes type\n   * inference slower.\n   *\n   * We also do not want spurious slots around in type inference, because\n   * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\n   * type is a symbol that the programmer has already checked and verified that\n   * it's defined, even if we don't know what it is.\n   *\n   * It is OK to pass non-name nodes into this method, as long as you pass\n   * in {@code null} for a restricted type.\n   */\n  private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {", "right_context": "}\n}", "class_name": "SemanticReverseAbstractInterpreter", "return_type": "FlowScope", "parameters": [{"type": "FlowScope", "name": "blindScope"}, {"type": "Node", "name": "node"}, {"type": "JSType", "name": "originalType"}, {"type": "JSType", "name": "restrictedType"}]}}
{"prompt": "class AngularPass extends AbstractPostOrderCallback implements CompilerPass {\n  /** Nodes annotated with @ngInject */\n  private final List<NodeContext> injectables = new ArrayList<NodeContext>();\n\n  public AngularPass(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  public static final String INJECT_PROPERTY_NAME = \"$inject\";\n\n  static final DiagnosticType INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR =\n      DiagnosticType.error(\"JSC_INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR\",\n          \"@ngInject only applies to functions defined in blocks or \" +\n          \"global scope.\");\n\n  static final DiagnosticType INJECT_NON_FUNCTION_ERROR =\n      DiagnosticType.error(\"JSC_INJECT_NON_FUNCTION_ERROR\",\n          \"@ngInject can only be used when defining a function or \" +\n          \"assigning a function expression.\");\n\n  static final DiagnosticType FUNCTION_NAME_ERROR =\n      DiagnosticType.error(\"JSC_FUNCTION_NAME_ERROR\",\n          \"Unable to determine target function name for @ngInject.\");\n\n  @Override\n  public void process(Node externs, Node root) {\n    // Traverses AST looking for nodes annotated with @ngInject.\n    NodeTraversal.traverse(compiler, root, this);\n    CodingConvention convention = compiler.getCodingConvention();\n    boolean codeChanged = false;\n    // iterates through annotated nodes adding $inject property to elements.\n    for (NodeContext entry : injectables) {\n      String name = entry.getName();\n      Node fn = entry.getFunctionNode();\n      List<Node> dependencies = createDependenciesList(fn);\n      // skips entry if it does have any dependencies.\n      if (dependencies.size() == 0) {\n        continue;\n      }\n      Node dependenciesArray = IR.arraylit(dependencies.toArray(\n          new Node[dependencies.size()]));\n      // creates `something.$inject = ['param1', 'param2']` node.\n      Node statement = IR.exprResult(\n          IR.assign(\n              IR.getelem(\n                  NodeUtil.newQualifiedNameNode(convention, name),\n                  IR.string(INJECT_PROPERTY_NAME)),\n              dependenciesArray\n          )\n      );\n      // adds `something.$inject = [...]` node after the annotated node or the following\n      // goog.inherits call.\n      Node insertionPoint = entry.getTarget();\n      Node next = insertionPoint.getNext();\n      while (next != null &&\n             NodeUtil.isExprCall(next) &&\n             convention.getClassesDefinedByCall(\n                 next.getFirstChild()) != null) {\n        insertionPoint = next;\n        next = insertionPoint.getNext();\n      }\n\n      insertionPoint.getParent().addChildAfter(statement, insertionPoint);\n      codeChanged = true;\n    }\n    if (codeChanged) {\n      compiler.reportCodeChange();\n    }\n  }\n\n  /**\n   * Given a FUNCTION node returns array of STRING nodes representing function\n   * parameters.\n   * @param n the FUNCTION node.\n   * @return STRING nodes.\n   */\n  private static List<Node> createDependenciesList(Node n) {\n    Preconditions.checkArgument(n.isFunction());\n    Node params = NodeUtil.getFunctionParameters(n);\n    if (params != null) {\n      return createStringsFromParamList(params);\n    }\n    return Lists.newArrayList();\n  }\n\n  /**\n   * Given a PARAM_LIST node creates an array of corresponding STRING nodes.\n   * @param params PARAM_LIST node.\n   * @return array of STRING nodes.\n   */\n  private static List<Node> createStringsFromParamList(Node params) {", "metadata": {"defects4j_task_id": "48b2ef59ce4b3ac25fd82fd27d9c133690a3a32528117e5deff419650461b9d6", "task_id": "google_closure-compiler/64", "ground_truth": "\n    Node param = params.getFirstChild();\n    ArrayList<Node> names = Lists.newArrayList();\n    while (param != null && param.isName()) {\n      names.add(IR.string(param.getString()).srcref(param));\n      param = param.getNext();\n    }\n    return names;\n  ", "fpath_tuple": ["google_closure-compiler", "closure-compiler", "src", "com", "google", "javascript", "jscomp", "AngularPass.java"], "context_start_lineno": 0, "function_name": "createStringsFromParamList", "left_context": "class AngularPass extends AbstractPostOrderCallback implements CompilerPass {\n  /** Nodes annotated with @ngInject */\n  private final List<NodeContext> injectables = new ArrayList<NodeContext>();\n\n  public AngularPass(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  public static final String INJECT_PROPERTY_NAME = \"$inject\";\n\n  static final DiagnosticType INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR =\n      DiagnosticType.error(\"JSC_INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR\",\n          \"@ngInject only applies to functions defined in blocks or \" +\n          \"global scope.\");\n\n  static final DiagnosticType INJECT_NON_FUNCTION_ERROR =\n      DiagnosticType.error(\"JSC_INJECT_NON_FUNCTION_ERROR\",\n          \"@ngInject can only be used when defining a function or \" +\n          \"assigning a function expression.\");\n\n  static final DiagnosticType FUNCTION_NAME_ERROR =\n      DiagnosticType.error(\"JSC_FUNCTION_NAME_ERROR\",\n          \"Unable to determine target function name for @ngInject.\");\n\n  @Override\n  public void process(Node externs, Node root) {\n    // Traverses AST looking for nodes annotated with @ngInject.\n    NodeTraversal.traverse(compiler, root, this);\n    CodingConvention convention = compiler.getCodingConvention();\n    boolean codeChanged = false;\n    // iterates through annotated nodes adding $inject property to elements.\n    for (NodeContext entry : injectables) {\n      String name = entry.getName();\n      Node fn = entry.getFunctionNode();\n      List<Node> dependencies = createDependenciesList(fn);\n      // skips entry if it does have any dependencies.\n      if (dependencies.size() == 0) {\n        continue;\n      }\n      Node dependenciesArray = IR.arraylit(dependencies.toArray(\n          new Node[dependencies.size()]));\n      // creates `something.$inject = ['param1', 'param2']` node.\n      Node statement = IR.exprResult(\n          IR.assign(\n              IR.getelem(\n                  NodeUtil.newQualifiedNameNode(convention, name),\n                  IR.string(INJECT_PROPERTY_NAME)),\n              dependenciesArray\n          )\n      );\n      // adds `something.$inject = [...]` node after the annotated node or the following\n      // goog.inherits call.\n      Node insertionPoint = entry.getTarget();\n      Node next = insertionPoint.getNext();\n      while (next != null &&\n             NodeUtil.isExprCall(next) &&\n             convention.getClassesDefinedByCall(\n                 next.getFirstChild()) != null) {\n        insertionPoint = next;\n        next = insertionPoint.getNext();\n      }\n\n      insertionPoint.getParent().addChildAfter(statement, insertionPoint);\n      codeChanged = true;\n    }\n    if (codeChanged) {\n      compiler.reportCodeChange();\n    }\n  }\n\n  /**\n   * Given a FUNCTION node returns array of STRING nodes representing function\n   * parameters.\n   * @param n the FUNCTION node.\n   * @return STRING nodes.\n   */\n  private static List<Node> createDependenciesList(Node n) {\n    Preconditions.checkArgument(n.isFunction());\n    Node params = NodeUtil.getFunctionParameters(n);\n    if (params != null) {\n      return createStringsFromParamList(params);\n    }\n    return Lists.newArrayList();\n  }\n\n  /**\n   * Given a PARAM_LIST node creates an array of corresponding STRING nodes.\n   * @param params PARAM_LIST node.\n   * @return array of STRING nodes.\n   */\n  private static List<Node> createStringsFromParamList(Node params) {", "right_context": "}\n}", "class_name": "AngularPass", "return_type": "List<Node>", "parameters": [{"type": "Node", "name": "params"}]}}
{"prompt": "class URLCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {\n\n    /**\n     * The default charset used for string decoding and encoding.\n     *\n     * @deprecated TODO: This field will be changed to a private final Charset in 2.0. (CODEC-126)\n     */\n    @Deprecated\n    protected String charset;\n\n    /**\n     * Release 1.5 made this field final.\n     */\n    protected static final byte ESCAPE_CHAR = '%';\n\n    /**\n     * BitSet of www-form-url safe characters.\n     * @deprecated Will be removed in 2.0 (CODEC-230)\n     */\n    @Deprecated\n    protected static final BitSet WWW_FORM_URL;\n\n    private static final BitSet WWW_FORM_URL_SAFE = new BitSet(256);\n\n    // Static initializer for www_form_url\n    static {\n        // alpha characters\n        for (int i = 'a'; i <= 'z'; i++) {\n            WWW_FORM_URL_SAFE.set(i);\n        }\n        for (int i = 'A'; i <= 'Z'; i++) {\n            WWW_FORM_URL_SAFE.set(i);\n        }\n        // numeric characters\n        for (int i = '0'; i <= '9'; i++) {\n            WWW_FORM_URL_SAFE.set(i);\n        }\n        // special chars\n        WWW_FORM_URL_SAFE.set('-');\n        WWW_FORM_URL_SAFE.set('_');\n        WWW_FORM_URL_SAFE.set('.');\n        WWW_FORM_URL_SAFE.set('*');\n        // blank to be replaced with +\n        WWW_FORM_URL_SAFE.set(' ');\n\n        // Create a copy in case anyone (ab)uses it\n        WWW_FORM_URL = (BitSet) WWW_FORM_URL_SAFE.clone();\n    }\n\n\n    /**\n     * Default constructor.\n     */\n    public URLCodec() {\n        this(CharEncoding.UTF_8);\n    }\n\n    /**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset the default string charset to use.\n     */\n    public URLCodec(final String charset) {\n        super();\n        this.charset = charset;\n    }\n\n    /**\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\n     *\n     * @param urlsafe\n     *            bitset of characters deemed URL safe\n     * @param bytes\n     *            array of bytes to convert to URL safe characters\n     * @return array of bytes containing URL safe characters\n     */\n    public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        if (urlsafe == null) {\n            urlsafe = WWW_FORM_URL_SAFE;\n        }\n\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (final byte c : bytes) {\n            int b = c;\n            if (b < 0) {\n                b = 256 + b;\n            }\n            if (urlsafe.get(b)) {\n                if (b == ' ') {\n                    b = '+';\n                }\n                buffer.write(b);\n            } else {\n                buffer.write(ESCAPE_CHAR);\n                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n                buffer.write(hex1);\n                buffer.write(hex2);\n            }\n        }\n        return buffer.toByteArray();\n    }\n\n    /**\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param bytes\n     *            array of URL safe characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     */\n    public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {", "metadata": {"defects4j_task_id": "42dd693494f79aee9af41cf5f8885999ef528e30dda7f8f60aacc906e780243b", "task_id": "apache_commons-codec/60", "ground_truth": "\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == '+') {\n                buffer.write(' ');\n            } else if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Utils.digit16(bytes[++i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    ", "fpath_tuple": ["apache_commons-codec", "commons-codec", "src", "main", "java", "org", "apache", "commons", "codec", "net", "URLCodec.java"], "context_start_lineno": 0, "function_name": "decodeUrl", "left_context": "class URLCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {\n\n    /**\n     * The default charset used for string decoding and encoding.\n     *\n     * @deprecated TODO: This field will be changed to a private final Charset in 2.0. (CODEC-126)\n     */\n    @Deprecated\n    protected String charset;\n\n    /**\n     * Release 1.5 made this field final.\n     */\n    protected static final byte ESCAPE_CHAR = '%';\n\n    /**\n     * BitSet of www-form-url safe characters.\n     * @deprecated Will be removed in 2.0 (CODEC-230)\n     */\n    @Deprecated\n    protected static final BitSet WWW_FORM_URL;\n\n    private static final BitSet WWW_FORM_URL_SAFE = new BitSet(256);\n\n    // Static initializer for www_form_url\n    static {\n        // alpha characters\n        for (int i = 'a'; i <= 'z'; i++) {\n            WWW_FORM_URL_SAFE.set(i);\n        }\n        for (int i = 'A'; i <= 'Z'; i++) {\n            WWW_FORM_URL_SAFE.set(i);\n        }\n        // numeric characters\n        for (int i = '0'; i <= '9'; i++) {\n            WWW_FORM_URL_SAFE.set(i);\n        }\n        // special chars\n        WWW_FORM_URL_SAFE.set('-');\n        WWW_FORM_URL_SAFE.set('_');\n        WWW_FORM_URL_SAFE.set('.');\n        WWW_FORM_URL_SAFE.set('*');\n        // blank to be replaced with +\n        WWW_FORM_URL_SAFE.set(' ');\n\n        // Create a copy in case anyone (ab)uses it\n        WWW_FORM_URL = (BitSet) WWW_FORM_URL_SAFE.clone();\n    }\n\n\n    /**\n     * Default constructor.\n     */\n    public URLCodec() {\n        this(CharEncoding.UTF_8);\n    }\n\n    /**\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset the default string charset to use.\n     */\n    public URLCodec(final String charset) {\n        super();\n        this.charset = charset;\n    }\n\n    /**\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\n     *\n     * @param urlsafe\n     *            bitset of characters deemed URL safe\n     * @param bytes\n     *            array of bytes to convert to URL safe characters\n     * @return array of bytes containing URL safe characters\n     */\n    public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        if (urlsafe == null) {\n            urlsafe = WWW_FORM_URL_SAFE;\n        }\n\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (final byte c : bytes) {\n            int b = c;\n            if (b < 0) {\n                b = 256 + b;\n            }\n            if (urlsafe.get(b)) {\n                if (b == ' ') {\n                    b = '+';\n                }\n                buffer.write(b);\n            } else {\n                buffer.write(ESCAPE_CHAR);\n                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n                buffer.write(hex1);\n                buffer.write(hex2);\n            }\n        }\n        return buffer.toByteArray();\n    }\n\n    /**\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param bytes\n     *            array of URL safe characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     */\n    public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {", "right_context": "}\n\n}", "class_name": "URLCodec", "return_type": "byte[]", "parameters": [{"type": "byte[]", "name": "bytes"}]}}
{"prompt": "class Soundex implements StringEncoder {\n\n    /**\n     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\n     * means do not encode.\n     *\n     * @see Soundex#Soundex(char[])\n     */\n    private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\n\n    /**\n     * An instance of Soundex using the US_ENGLISH_MAPPING mapping.\n     *\n     * @see #US_ENGLISH_MAPPING\n     */\n    public static final Soundex US_ENGLISH = new Soundex();\n\n    /**\n     * The maximum length of a Soundex code - Soundex codes are only four characters by definition.\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     */\n    @Deprecated\n    private int maxLength = 4;\n\n    /**\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     */\n    private final char[] soundexMapping;\n\n    /**\n     * Creates an instance using US_ENGLISH_MAPPING\n     *\n     * @see Soundex#Soundex(char[])\n     * @see Soundex#US_ENGLISH_MAPPING\n     */\n    public Soundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }\n\n    /**\n     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\n     * mapping for a non-Western character set.\n     *\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for a given character\n     */\n    public Soundex(final char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }\n\n    /**\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     */\n    public Soundex(final String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }\n\n    /**\n     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n     * identical values.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n     *          T-SQL DIFFERENCE </a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     */\n    public int difference(final String s1, final String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }\n\n    /**\n     * Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\n     *\n     * @param obj\n     *                  Object to encode\n     * @return An object (or type java.lang.String) containing the soundex code which corresponds to the String\n     *             supplied.\n     * @throws EncoderException\n     *                  if the parameter supplied is not of type java.lang.String\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Soundex encode is not of type java.lang.String\");\n        }\n        return soundex((String) obj);\n    }\n\n    /**\n     * Encodes a String using the soundex algorithm.\n     *\n     * @param str\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    @Override\n    public String encode(final String str) {\n        return soundex(str);\n    }\n\n    /**\n     * Returns the maxLength. Standard Soundex\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @return int\n     */\n    @Deprecated\n    public int getMaxLength() {\n        return this.maxLength;\n    }\n\n    /**\n     * Returns the soundex mapping.\n     *\n     * @return soundexMapping.\n     */\n    private char[] getSoundexMapping() {\n        return this.soundexMapping;\n    }\n\n    /**\n     * Maps the given upper-case character to its Soundex code.\n     *\n     * @param ch\n     *                  An upper-case character.\n     * @return A Soundex code.\n     * @throws IllegalArgumentException\n     *                  Thrown if <code>ch</code> is not mapped.\n     */\n    private char map(final char ch) {\n        final int index = ch - 'A';\n        if (index < 0 || index >= this.getSoundexMapping().length) {\n            throw new IllegalArgumentException(\"The character is not mapped: \" + ch);\n        }\n        return this.getSoundexMapping()[index];\n    }\n\n    /**\n     * Sets the maxLength.\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @param maxLength\n     *                  The maxLength to set\n     */\n    @Deprecated\n    public void setMaxLength(final int maxLength) {\n        this.maxLength = maxLength;\n    }\n\n    /**\n     * Retrieves the Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Soundex algorithm\n     * @return A soundex code for the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    public String soundex(String str) {", "metadata": {"defects4j_task_id": "5c4592ee8e4852c2825ceaa6c800e1e029818780cc00fc1f0a675c8962bf0ada", "task_id": "apache_commons-codec/80", "ground_truth": "\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char out[] = {'0', '0', '0', '0'};\n        char last, mapped;\n        int incount = 1, count = 1;\n        out[0] = str.charAt(0);\n        // map() throws IllegalArgumentException\n        last = this.map(str.charAt(0));\n        while (incount < str.length() && count < out.length) {\n            mapped = this.map(str.charAt(incount++));\n            if (mapped == '0') {\n                last = mapped;\n            } else if (mapped != '#' && mapped != last) {\n                out[count++] = mapped;\n                last = mapped;\n            }\n        }\n        return new String(out);\n    ", "fpath_tuple": ["apache_commons-codec", "commons-codec", "src", "main", "java", "org", "apache", "commons", "codec", "language", "Soundex.java"], "context_start_lineno": 0, "function_name": "soundex", "left_context": "class Soundex implements StringEncoder {\n\n    /**\n     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\n     * means do not encode.\n     *\n     * @see Soundex#Soundex(char[])\n     */\n    private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\n\n    /**\n     * An instance of Soundex using the US_ENGLISH_MAPPING mapping.\n     *\n     * @see #US_ENGLISH_MAPPING\n     */\n    public static final Soundex US_ENGLISH = new Soundex();\n\n    /**\n     * The maximum length of a Soundex code - Soundex codes are only four characters by definition.\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     */\n    @Deprecated\n    private int maxLength = 4;\n\n    /**\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     */\n    private final char[] soundexMapping;\n\n    /**\n     * Creates an instance using US_ENGLISH_MAPPING\n     *\n     * @see Soundex#Soundex(char[])\n     * @see Soundex#US_ENGLISH_MAPPING\n     */\n    public Soundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }\n\n    /**\n     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\n     * mapping for a non-Western character set.\n     *\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for a given character\n     */\n    public Soundex(final char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }\n\n    /**\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     */\n    public Soundex(final String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }\n\n    /**\n     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n     * identical values.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n     *          T-SQL DIFFERENCE </a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     */\n    public int difference(final String s1, final String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }\n\n    /**\n     * Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\n     *\n     * @param obj\n     *                  Object to encode\n     * @return An object (or type java.lang.String) containing the soundex code which corresponds to the String\n     *             supplied.\n     * @throws EncoderException\n     *                  if the parameter supplied is not of type java.lang.String\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Soundex encode is not of type java.lang.String\");\n        }\n        return soundex((String) obj);\n    }\n\n    /**\n     * Encodes a String using the soundex algorithm.\n     *\n     * @param str\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    @Override\n    public String encode(final String str) {\n        return soundex(str);\n    }\n\n    /**\n     * Returns the maxLength. Standard Soundex\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @return int\n     */\n    @Deprecated\n    public int getMaxLength() {\n        return this.maxLength;\n    }\n\n    /**\n     * Returns the soundex mapping.\n     *\n     * @return soundexMapping.\n     */\n    private char[] getSoundexMapping() {\n        return this.soundexMapping;\n    }\n\n    /**\n     * Maps the given upper-case character to its Soundex code.\n     *\n     * @param ch\n     *                  An upper-case character.\n     * @return A Soundex code.\n     * @throws IllegalArgumentException\n     *                  Thrown if <code>ch</code> is not mapped.\n     */\n    private char map(final char ch) {\n        final int index = ch - 'A';\n        if (index < 0 || index >= this.getSoundexMapping().length) {\n            throw new IllegalArgumentException(\"The character is not mapped: \" + ch);\n        }\n        return this.getSoundexMapping()[index];\n    }\n\n    /**\n     * Sets the maxLength.\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @param maxLength\n     *                  The maxLength to set\n     */\n    @Deprecated\n    public void setMaxLength(final int maxLength) {\n        this.maxLength = maxLength;\n    }\n\n    /**\n     * Retrieves the Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Soundex algorithm\n     * @return A soundex code for the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     */\n    public String soundex(String str) {", "right_context": "}}\n\n}", "class_name": "Soundex", "return_type": "String", "parameters": [{"type": "String", "name": "str"}]}}
{"prompt": "class Base64 extends BaseNCodec {\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(final byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,\n                                      final boolean urlSafe, final int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        // Create this so can use the super-class method\n        // Also ensures that the same roundings are performed by the ctor and the code\n        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        final long len = b64.getEncodedLength(binaryData);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maximum size of \" +\n                maxResultSize);\n        }\n\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets.\n     * <p>\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\n     * </p>\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(final String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets.\n     * <p>\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\n     * </p>\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(final byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    // Implementation of the Encoder Interface\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(final byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(final BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     *\n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(final BigInteger bigInt) {", "metadata": {"defects4j_task_id": "0f467622273ec92e5b33f7fa0c25ed6538682abe605bb37ee009fa42dbed7086", "task_id": "apache_commons-codec/15", "ground_truth": "\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        final byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        final byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    ", "fpath_tuple": ["apache_commons-codec", "commons-codec", "src", "main", "java", "org", "apache", "commons", "codec", "binary", "Base64.java"], "context_start_lineno": 0, "function_name": "toIntegerBytes", "left_context": "class Base64 extends BaseNCodec {\n\n    /**\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     */\n    public static byte[] encodeBase64Chunked(final byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     */\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,\n                                      final boolean urlSafe, final int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        // Create this so can use the super-class method\n        // Also ensures that the same roundings are performed by the ctor and the code\n        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        final long len = b64.getEncodedLength(binaryData);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maximum size of \" +\n                maxResultSize);\n        }\n\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets.\n     * <p>\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\n     * </p>\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(final String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets.\n     * <p>\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\n     * </p>\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(final byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    // Implementation of the Encoder Interface\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(final byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }\n\n    /**\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     */\n    public static byte[] encodeInteger(final BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }\n\n    /**\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     *\n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     */\n    static byte[] toIntegerBytes(final BigInteger bigInt) {", "right_context": "}\n\n}", "class_name": "Base64", "return_type": "byte[]", "parameters": [{"type": "BigInteger", "name": "bigInt"}]}}
{"prompt": "class DigestUtils {\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest\n     * @since 1.4\n     */\n    public static byte[] sha512(final byte[] data) {\n        return getSha512Digest().digest(data);\n    }\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     */\n    public static byte[] sha512(final InputStream data) throws IOException {\n        return digest(getSha512Digest(), data);\n    }\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-512 digest\n     * @since 1.4\n     */\n    public static byte[] sha512(final String data) {\n        return sha512(StringUtils.getBytesUtf8(data));\n    }\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @since 1.4\n     */\n    public static String sha512Hex(final byte[] data) {\n        return Hex.encodeHexString(sha512(data));\n    }\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     */\n    public static String sha512Hex(final InputStream data) throws IOException {\n        return Hex.encodeHexString(sha512(data));\n    }\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @since 1.4\n     */\n    public static String sha512Hex(final String data) {\n        return Hex.encodeHexString(sha512(data));\n    }\n\n    /**\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @deprecated Use {@link #sha1Hex(byte[])}\n     */\n    @Deprecated\n    public static String shaHex(final byte[] data) {\n        return sha1Hex(data);\n    }\n\n    /**\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     * @deprecated Use {@link #sha1Hex(InputStream)}\n     */\n    @Deprecated\n    public static String shaHex(final InputStream data) throws IOException {\n        return sha1Hex(data);\n    }\n\n    /**\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @deprecated Use {@link #sha1Hex(String)}\n     */\n    @Deprecated\n    public static String shaHex(final String data) {\n        return sha1Hex(data);\n    }\n\n    /**\n     * Updates the given {@link MessageDigest}.\n     *\n     * @param messageDigest\n     *            the {@link MessageDigest} to update\n     * @param valueToDigest\n     *            the value to update the {@link MessageDigest} with\n     * @return the updated {@link MessageDigest}\n     * @since 1.7\n     */\n    public static MessageDigest updateDigest(final MessageDigest messageDigest, final byte[] valueToDigest) {\n        messageDigest.update(valueToDigest);\n        return messageDigest;\n    }\n\n    /**\n     * Updates the given {@link MessageDigest}.\n     *\n     * @param messageDigest\n     *            the {@link MessageDigest} to update\n     * @param valueToDigest\n     *            the value to update the {@link MessageDigest} with\n     * @return the updated {@link MessageDigest}\n     * @since 1.11\n     */\n    public static MessageDigest updateDigest(final MessageDigest messageDigest, final ByteBuffer valueToDigest) {\n        messageDigest.update(valueToDigest);\n        return messageDigest;\n    }\n\n    /**\n     * Reads through a File and updates the digest for the data\n     *\n     * @param digest\n     *            The MessageDigest to use (e.g. MD5)\n     * @param data\n     *            Data to digest\n     * @return the digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.11\n     */\n    public static MessageDigest updateDigest(final MessageDigest digest, final File data) throws IOException {\n        final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(data));\n        try {\n            return updateDigest(digest, stream);\n        } finally {\n            stream.close();\n        }\n    }\n\n    /**\n     * Reads through an InputStream and updates the digest for the data\n     *\n     * @param digest\n     *            The MessageDigest to use (e.g. MD5)\n     * @param data\n     *            Data to digest\n     * @return the digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.8\n     */\n    public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException {", "metadata": {"defects4j_task_id": "845cd673bc9db45075fc67454c2dc7d7b9dcdaaeffe32d849cf9566b83c011db", "task_id": "apache_commons-codec/108", "ground_truth": "\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n        while (read > -1) {\n            digest.update(buffer, 0, read);\n            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n        }\n\n        return digest;\n    ", "fpath_tuple": ["apache_commons-codec", "commons-codec", "src", "main", "java", "org", "apache", "commons", "codec", "digest", "DigestUtils.java"], "context_start_lineno": 0, "function_name": "updateDigest", "left_context": "class DigestUtils {\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest\n     * @since 1.4\n     */\n    public static byte[] sha512(final byte[] data) {\n        return getSha512Digest().digest(data);\n    }\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     */\n    public static byte[] sha512(final InputStream data) throws IOException {\n        return digest(getSha512Digest(), data);\n    }\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-512 digest\n     * @since 1.4\n     */\n    public static byte[] sha512(final String data) {\n        return sha512(StringUtils.getBytesUtf8(data));\n    }\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @since 1.4\n     */\n    public static String sha512Hex(final byte[] data) {\n        return Hex.encodeHexString(sha512(data));\n    }\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     */\n    public static String sha512Hex(final InputStream data) throws IOException {\n        return Hex.encodeHexString(sha512(data));\n    }\n\n    /**\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @since 1.4\n     */\n    public static String sha512Hex(final String data) {\n        return Hex.encodeHexString(sha512(data));\n    }\n\n    /**\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @deprecated Use {@link #sha1Hex(byte[])}\n     */\n    @Deprecated\n    public static String shaHex(final byte[] data) {\n        return sha1Hex(data);\n    }\n\n    /**\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     * @deprecated Use {@link #sha1Hex(InputStream)}\n     */\n    @Deprecated\n    public static String shaHex(final InputStream data) throws IOException {\n        return sha1Hex(data);\n    }\n\n    /**\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @deprecated Use {@link #sha1Hex(String)}\n     */\n    @Deprecated\n    public static String shaHex(final String data) {\n        return sha1Hex(data);\n    }\n\n    /**\n     * Updates the given {@link MessageDigest}.\n     *\n     * @param messageDigest\n     *            the {@link MessageDigest} to update\n     * @param valueToDigest\n     *            the value to update the {@link MessageDigest} with\n     * @return the updated {@link MessageDigest}\n     * @since 1.7\n     */\n    public static MessageDigest updateDigest(final MessageDigest messageDigest, final byte[] valueToDigest) {\n        messageDigest.update(valueToDigest);\n        return messageDigest;\n    }\n\n    /**\n     * Updates the given {@link MessageDigest}.\n     *\n     * @param messageDigest\n     *            the {@link MessageDigest} to update\n     * @param valueToDigest\n     *            the value to update the {@link MessageDigest} with\n     * @return the updated {@link MessageDigest}\n     * @since 1.11\n     */\n    public static MessageDigest updateDigest(final MessageDigest messageDigest, final ByteBuffer valueToDigest) {\n        messageDigest.update(valueToDigest);\n        return messageDigest;\n    }\n\n    /**\n     * Reads through a File and updates the digest for the data\n     *\n     * @param digest\n     *            The MessageDigest to use (e.g. MD5)\n     * @param data\n     *            Data to digest\n     * @return the digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.11\n     */\n    public static MessageDigest updateDigest(final MessageDigest digest, final File data) throws IOException {\n        final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(data));\n        try {\n            return updateDigest(digest, stream);\n        } finally {\n            stream.close();\n        }\n    }\n\n    /**\n     * Reads through an InputStream and updates the digest for the data\n     *\n     * @param digest\n     *            The MessageDigest to use (e.g. MD5)\n     * @param data\n     *            Data to digest\n     * @return the digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.8\n     */\n    public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException {", "right_context": "}\n\n}", "class_name": "DigestUtils", "return_type": "MessageDigest", "parameters": [{"type": "MessageDigest", "name": "digest"}, {"type": "InputStream", "name": "data"}]}}
{"prompt": "class TokenQueue {\n    /**\n     Tests if the next characters match any of the sequences. Case insensitive.\n     @param seq list of strings to case insensitively check for\n     @return true of any matched, false if none did\n     */\n    public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        for (char c: seq) {\n            if (queue.charAt(pos) == c)\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesStartTag() {\n        // micro opt for matching \"<x\"\n        return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos+1)));\n    }\n\n    /**\n     * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the\n     * queue.\n     * @param seq String to search for, and if found, remove from queue.\n     * @return true if found and removed, false if not found.\n     */\n    public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     Tests if queue starts with a whitespace character.\n     @return if starts with whitespace\n     */\n    public boolean matchesWhitespace() {\n        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));\n    }\n\n    /**\n     Test if the queue matches a word character (letter or digit).\n     @return if matches a word character\n     */\n    public boolean matchesWord() {\n        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n    }\n\n    /**\n     * Drops the next character off the queue.\n     */\n    public void advance() {\n        if (!isEmpty()) pos++;\n    }\n\n    /**\n     * Consume one character off queue.\n     * @return first character on queue.\n     */\n    public char consume() {\n        return queue.charAt(pos++);\n    }\n\n    /**\n     * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will\n     * throw an illegal state exception -- but you should be running match() against that condition.\n     <p>\n     Case insensitive.\n     * @param seq sequence to remove from head of queue.\n     */\n    public void consume(String seq) {\n        if (!matches(seq))\n            throw new IllegalStateException(\"Queue did not match expected sequence\");\n        int len = seq.length();\n        if (len > remainingLength())\n            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n        \n        pos += len;\n    }\n\n    /**\n     * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.\n     * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>\n     * @return The matched data consumed from queue.\n     */\n    public String consumeTo(String seq) {\n        int offset = queue.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = queue.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return remainder();\n        }\n    }\n    \n    public String consumeToIgnoreCase(String seq) {\n        int start = pos;\n        String first = seq.substring(0, 1);\n        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); // if first is not cased, use index of\n        while (!isEmpty()) {\n            if (matches(seq))\n                break;\n            \n            if (canScan) {\n                int skip = queue.indexOf(first, pos) - pos;\n                if (skip == 0) // this char is the skip char, but not match, so force advance of pos\n                    pos++;\n                else if (skip < 0) // no chance of finding, grab to end\n                    pos = queue.length();\n                else\n                    pos += skip;\n            }\n            else\n                pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     Consumes to the first sequence provided, or to the end of the queue. Leaves the terminator on the queue.\n     @param seq any number of terminators to consume to. <b>Case insensitive.</b>\n     @return consumed string   \n     */\n    // todo: method name. not good that consumeTo cares for case, and consume to any doesn't. And the only use for this\n    // is is a case sensitive time...\n    public String consumeToAny(String... seq) {\n        int start = pos;\n        while (!isEmpty() && !matchesAny(seq)) {\n            pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n     * <p>\n     * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go\n     * isEmpty() == true).\n     * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>\n     * @return Data matched from queue.\n     */\n    public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }\n    \n    public String chompToIgnoreCase(String seq) {\n        String data = consumeToIgnoreCase(seq); // case insensitive scan\n        matchChomp(seq);\n        return data;\n    }\n\n    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can be quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {", "metadata": {"defects4j_task_id": "979ad380fd344088d8ad0f815606df2034679d982d7ec44d391b8e74812ef9b7", "task_id": "jhy_jsoup/125", "ground_truth": "\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if (c.equals('\\'') && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c.equals('\"') && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    ", "fpath_tuple": ["jhy_jsoup", "jsoup", "src", "main", "java", "org", "jsoup", "parser", "TokenQueue.java"], "context_start_lineno": 0, "function_name": "chompBalanced", "left_context": "class TokenQueue {\n    /**\n     Tests if the next characters match any of the sequences. Case insensitive.\n     @param seq list of strings to case insensitively check for\n     @return true of any matched, false if none did\n     */\n    public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        for (char c: seq) {\n            if (queue.charAt(pos) == c)\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesStartTag() {\n        // micro opt for matching \"<x\"\n        return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos+1)));\n    }\n\n    /**\n     * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the\n     * queue.\n     * @param seq String to search for, and if found, remove from queue.\n     * @return true if found and removed, false if not found.\n     */\n    public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     Tests if queue starts with a whitespace character.\n     @return if starts with whitespace\n     */\n    public boolean matchesWhitespace() {\n        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));\n    }\n\n    /**\n     Test if the queue matches a word character (letter or digit).\n     @return if matches a word character\n     */\n    public boolean matchesWord() {\n        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n    }\n\n    /**\n     * Drops the next character off the queue.\n     */\n    public void advance() {\n        if (!isEmpty()) pos++;\n    }\n\n    /**\n     * Consume one character off queue.\n     * @return first character on queue.\n     */\n    public char consume() {\n        return queue.charAt(pos++);\n    }\n\n    /**\n     * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will\n     * throw an illegal state exception -- but you should be running match() against that condition.\n     <p>\n     Case insensitive.\n     * @param seq sequence to remove from head of queue.\n     */\n    public void consume(String seq) {\n        if (!matches(seq))\n            throw new IllegalStateException(\"Queue did not match expected sequence\");\n        int len = seq.length();\n        if (len > remainingLength())\n            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n        \n        pos += len;\n    }\n\n    /**\n     * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.\n     * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>\n     * @return The matched data consumed from queue.\n     */\n    public String consumeTo(String seq) {\n        int offset = queue.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = queue.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return remainder();\n        }\n    }\n    \n    public String consumeToIgnoreCase(String seq) {\n        int start = pos;\n        String first = seq.substring(0, 1);\n        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); // if first is not cased, use index of\n        while (!isEmpty()) {\n            if (matches(seq))\n                break;\n            \n            if (canScan) {\n                int skip = queue.indexOf(first, pos) - pos;\n                if (skip == 0) // this char is the skip char, but not match, so force advance of pos\n                    pos++;\n                else if (skip < 0) // no chance of finding, grab to end\n                    pos = queue.length();\n                else\n                    pos += skip;\n            }\n            else\n                pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     Consumes to the first sequence provided, or to the end of the queue. Leaves the terminator on the queue.\n     @param seq any number of terminators to consume to. <b>Case insensitive.</b>\n     @return consumed string   \n     */\n    // todo: method name. not good that consumeTo cares for case, and consume to any doesn't. And the only use for this\n    // is is a case sensitive time...\n    public String consumeToAny(String... seq) {\n        int start = pos;\n        while (!isEmpty() && !matchesAny(seq)) {\n            pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n     * <p>\n     * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go\n     * isEmpty() == true).\n     * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>\n     * @return Data matched from queue.\n     */\n    public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }\n    \n    public String chompToIgnoreCase(String seq) {\n        String data = consumeToIgnoreCase(seq); // case insensitive scan\n        matchChomp(seq);\n        return data;\n    }\n\n    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can be quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {", "right_context": "}\n}", "class_name": "TokenQueue", "return_type": "String", "parameters": [{"type": "char", "name": "open"}, {"type": "char", "name": "close"}]}}
{"prompt": "class Element extends Node {\n    /**\n     * Create a new Element from a tag and a base URI.\n     * \n     * @param tag element tag\n     * @param baseUri the base URI of this element. It is acceptable for the base URI to be an empty\n     *            string, but not null.\n     * @see Tag#valueOf(String, ParseSettings)\n     */\n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, null);\n    }\n\n    protected List<Node> ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new NodeList(this, 4);\n        }\n        return childNodes;\n    }\n\n    @Override\n    protected boolean hasAttributes() {\n        return attributes != null;\n    }\n\n    @Override\n    public Attributes attributes() {\n        if (!hasAttributes())\n            attributes = new Attributes();\n        return attributes;\n    }\n\n    @Override\n    public String baseUri() {\n        return baseUri;\n    }\n\n    @Override\n    protected void doSetBaseUri(String baseUri) {\n        this.baseUri = baseUri;\n    }\n\n    @Override\n    public int childNodeSize() {\n        return childNodes.size();\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    /**\n     * Get the name of the tag for this element. E.g. {@code div}. If you are using {@link ParseSettings#preserveCase\n     * case preserving parsing}, this will return the source's original case.\n     * \n     * @return the tag name\n     */\n    public String tagName() {\n        return tag.getName();\n    }\n\n    /**\n     * Get the normalized name of this Element's tag. This will always be the lowercased version of the tag, regardless\n     * of the tag case preserving setting of the parser.\n     * @return\n     */\n    public String normalName() {\n        return tag.normalName();\n    }\n\n    /**\n     * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\n     * {@code el.tagName(\"div\");}.\n     *\n     * @param tagName new tag name for this element\n     * @return this element, for chaining\n     */\n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings()); // maintains the case option of the original parse\n        return this;\n    }\n\n    /**\n     * Get the Tag for this element.\n     * \n     * @return the tag object\n     */\n    public Tag tag() {\n        return tag;\n    }\n    \n    /**\n     * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element\n     * {@code <p> == false}).\n     * \n     * @return true if block, false if not (and thus inline)\n     */\n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    /**\n     * Get the {@code id} attribute of this element.\n     * \n     * @return The id attribute, if present, or an empty string if not.\n     */\n    public String id() {\n        return attributes().getIgnoreCase(\"id\");\n    }\n\n    /**\n     * Set an attribute value on this element. If this element already has an attribute with the\n     * key, its value is updated; otherwise, a new attribute is added.\n     * \n     * @return this element\n     */\n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n    \n    /**\n     * Set a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to \"\" and\n     * marks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute\n     * with the same key if it exists.\n     * \n     * @param attributeKey the attribute key\n     * @param attributeValue the attribute value\n     * \n     * @return this element\n     */\n    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     * Get this element's HTML5 custom data attributes. Each attribute in the element that has a key\n     * starting with \"data-\" is included the dataset.\n     * <p>\n     * E.g., the element {@code <div data-package=\"jsoup\" data-language=\"Java\" class=\"group\">...} has the dataset\n     * {@code package=jsoup, language=java}.\n     * <p>\n     * This map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected\n     * in the other map.\n     * <p>\n     * You can find elements that have data attributes using the {@code [^data-]} attribute key prefix selector.\n     * @return a map of {@code key=value} custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    /**\n     * Get this element's parent and ancestors, up to the document root.\n     * @return this element's stack of parents, closest first.\n     */\n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    /**\n     * Get a child element of this element, by its 0-based index number.\n     * <p>\n     * Note that an element can have both mixed Nodes and Elements as children. This method inspects\n     * a filtered list of children that are elements, and the index is based on that filtered list.\n     * </p>\n     * \n     * @param index the index number of the element to retrieve\n     * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n     * @see #childNode(int)\n     */\n    public Element child(int index) {\n        return childElementsList().get(index);\n    }\n\n    /**\n     * Get this element's child elements.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n     * </p>\n     * @return child elements. If this element has no children, returns an empty list.\n     * @see #childNodes()\n     */\n    public Elements children() {\n        return new Elements(childElementsList());\n    }\n\n    /**\n     * Maintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.\n     * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.\n     * @return a list of child elements\n     */\n    private List<Element> childElementsList() {", "metadata": {"defects4j_task_id": "392d20e709a78d802c65dfb347273af9288d7a394e65be12c4a516ca94c31eb9", "task_id": "jhy_jsoup/49", "ground_truth": "\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    ", "fpath_tuple": ["jhy_jsoup", "jsoup", "src", "main", "java", "org", "jsoup", "nodes", "Element.java"], "context_start_lineno": 0, "function_name": "childElementsList", "left_context": "class Element extends Node {\n    /**\n     * Create a new Element from a tag and a base URI.\n     * \n     * @param tag element tag\n     * @param baseUri the base URI of this element. It is acceptable for the base URI to be an empty\n     *            string, but not null.\n     * @see Tag#valueOf(String, ParseSettings)\n     */\n    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, null);\n    }\n\n    protected List<Node> ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new NodeList(this, 4);\n        }\n        return childNodes;\n    }\n\n    @Override\n    protected boolean hasAttributes() {\n        return attributes != null;\n    }\n\n    @Override\n    public Attributes attributes() {\n        if (!hasAttributes())\n            attributes = new Attributes();\n        return attributes;\n    }\n\n    @Override\n    public String baseUri() {\n        return baseUri;\n    }\n\n    @Override\n    protected void doSetBaseUri(String baseUri) {\n        this.baseUri = baseUri;\n    }\n\n    @Override\n    public int childNodeSize() {\n        return childNodes.size();\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    /**\n     * Get the name of the tag for this element. E.g. {@code div}. If you are using {@link ParseSettings#preserveCase\n     * case preserving parsing}, this will return the source's original case.\n     * \n     * @return the tag name\n     */\n    public String tagName() {\n        return tag.getName();\n    }\n\n    /**\n     * Get the normalized name of this Element's tag. This will always be the lowercased version of the tag, regardless\n     * of the tag case preserving setting of the parser.\n     * @return\n     */\n    public String normalName() {\n        return tag.normalName();\n    }\n\n    /**\n     * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\n     * {@code el.tagName(\"div\");}.\n     *\n     * @param tagName new tag name for this element\n     * @return this element, for chaining\n     */\n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings()); // maintains the case option of the original parse\n        return this;\n    }\n\n    /**\n     * Get the Tag for this element.\n     * \n     * @return the tag object\n     */\n    public Tag tag() {\n        return tag;\n    }\n    \n    /**\n     * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element\n     * {@code <p> == false}).\n     * \n     * @return true if block, false if not (and thus inline)\n     */\n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    /**\n     * Get the {@code id} attribute of this element.\n     * \n     * @return The id attribute, if present, or an empty string if not.\n     */\n    public String id() {\n        return attributes().getIgnoreCase(\"id\");\n    }\n\n    /**\n     * Set an attribute value on this element. If this element already has an attribute with the\n     * key, its value is updated; otherwise, a new attribute is added.\n     * \n     * @return this element\n     */\n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n    \n    /**\n     * Set a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to \"\" and\n     * marks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute\n     * with the same key if it exists.\n     * \n     * @param attributeKey the attribute key\n     * @param attributeValue the attribute value\n     * \n     * @return this element\n     */\n    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     * Get this element's HTML5 custom data attributes. Each attribute in the element that has a key\n     * starting with \"data-\" is included the dataset.\n     * <p>\n     * E.g., the element {@code <div data-package=\"jsoup\" data-language=\"Java\" class=\"group\">...} has the dataset\n     * {@code package=jsoup, language=java}.\n     * <p>\n     * This map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected\n     * in the other map.\n     * <p>\n     * You can find elements that have data attributes using the {@code [^data-]} attribute key prefix selector.\n     * @return a map of {@code key=value} custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    /**\n     * Get this element's parent and ancestors, up to the document root.\n     * @return this element's stack of parents, closest first.\n     */\n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    /**\n     * Get a child element of this element, by its 0-based index number.\n     * <p>\n     * Note that an element can have both mixed Nodes and Elements as children. This method inspects\n     * a filtered list of children that are elements, and the index is based on that filtered list.\n     * </p>\n     * \n     * @param index the index number of the element to retrieve\n     * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n     * @see #childNode(int)\n     */\n    public Element child(int index) {\n        return childElementsList().get(index);\n    }\n\n    /**\n     * Get this element's child elements.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n     * </p>\n     * @return child elements. If this element has no children, returns an empty list.\n     * @see #childNodes()\n     */\n    public Elements children() {\n        return new Elements(childElementsList());\n    }\n\n    /**\n     * Maintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.\n     * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.\n     * @return a list of child elements\n     */\n    private List<Element> childElementsList() {", "right_context": "}\n}", "class_name": "Element", "return_type": "List<Element>", "parameters": []}}
{"prompt": "class Element extends Node {\n    /**\n     * Get the normalized name of this Element's tag. This will always be the lowercased version of the tag, regardless\n     * of the tag case preserving setting of the parser.\n     * @return\n     */\n    public String normalName() {\n        return tag.normalName();\n    }\n\n    /**\n     * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\n     * {@code el.tagName(\"div\");}.\n     *\n     * @param tagName new tag name for this element\n     * @return this element, for chaining\n     */\n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings()); // maintains the case option of the original parse\n        return this;\n    }\n\n    /**\n     * Get the Tag for this element.\n     * \n     * @return the tag object\n     */\n    public Tag tag() {\n        return tag;\n    }\n    \n    /**\n     * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element\n     * {@code <p> == false}).\n     * \n     * @return true if block, false if not (and thus inline)\n     */\n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    /**\n     * Get the {@code id} attribute of this element.\n     * \n     * @return The id attribute, if present, or an empty string if not.\n     */\n    public String id() {\n        return attributes().getIgnoreCase(\"id\");\n    }\n\n    /**\n     * Set an attribute value on this element. If this element already has an attribute with the\n     * key, its value is updated; otherwise, a new attribute is added.\n     * \n     * @return this element\n     */\n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n    \n    /**\n     * Set a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to \"\" and\n     * marks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute\n     * with the same key if it exists.\n     * \n     * @param attributeKey the attribute key\n     * @param attributeValue the attribute value\n     * \n     * @return this element\n     */\n    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     * Get this element's HTML5 custom data attributes. Each attribute in the element that has a key\n     * starting with \"data-\" is included the dataset.\n     * <p>\n     * E.g., the element {@code <div data-package=\"jsoup\" data-language=\"Java\" class=\"group\">...} has the dataset\n     * {@code package=jsoup, language=java}.\n     * <p>\n     * This map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected\n     * in the other map.\n     * <p>\n     * You can find elements that have data attributes using the {@code [^data-]} attribute key prefix selector.\n     * @return a map of {@code key=value} custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    /**\n     * Get this element's parent and ancestors, up to the document root.\n     * @return this element's stack of parents, closest first.\n     */\n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    /**\n     * Get a child element of this element, by its 0-based index number.\n     * <p>\n     * Note that an element can have both mixed Nodes and Elements as children. This method inspects\n     * a filtered list of children that are elements, and the index is based on that filtered list.\n     * </p>\n     * \n     * @param index the index number of the element to retrieve\n     * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n     * @see #childNode(int)\n     */\n    public Element child(int index) {\n        return childElementsList().get(index);\n    }\n\n    /**\n     * Get this element's child elements.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n     * </p>\n     * @return child elements. If this element has no children, returns an empty list.\n     * @see #childNodes()\n     */\n    public Elements children() {\n        return new Elements(childElementsList());\n    }\n\n    /**\n     * Maintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.\n     * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.\n     * @return a list of child elements\n     */\n    private List<Element> childElementsList() {\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    }\n\n    /**\n     * Clears the cached shadow child elements.\n     */\n    @Override\n    void nodelistChanged() {\n        super.nodelistChanged();\n        shadowChildrenRef = null;\n    }\n\n    /**\n     * Get this element's child text nodes. The list is unmodifiable but the text nodes may be manipulated.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Text nodes.\n     * @return child text nodes. If this element has no text nodes, returns an\n     * empty list.\n     * </p>\n     * For example, with the input HTML: {@code <p>One <span>Two</span> Three <br> Four</p>} with the {@code p} element selected:\n     * <ul>\n     *     <li>{@code p.text()} = {@code \"One Two Three Four\"}</li>\n     *     <li>{@code p.ownText()} = {@code \"One Three Four\"}</li>\n     *     <li>{@code p.children()} = {@code Elements[<span>, <br>]}</li>\n     *     <li>{@code p.childNodes()} = {@code List<Node>[\"One \", <span>, \" Three \", <br>, \" Four\"]}</li>\n     *     <li>{@code p.textNodes()} = {@code List<TextNode>[\"One \", \" Three \", \" Four\"]}</li>\n     * </ul>\n     */\n    public List<TextNode> textNodes() {", "metadata": {"defects4j_task_id": "6d8382f4e771b8290d78b09ba0c015af9142027c6decf093ab3d819b1c58d8e4", "task_id": "jhy_jsoup/90", "ground_truth": "\n        List<TextNode> textNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    ", "fpath_tuple": ["jhy_jsoup", "jsoup", "src", "main", "java", "org", "jsoup", "nodes", "Element.java"], "context_start_lineno": 0, "function_name": "textNodes", "left_context": "class Element extends Node {\n    /**\n     * Get the normalized name of this Element's tag. This will always be the lowercased version of the tag, regardless\n     * of the tag case preserving setting of the parser.\n     * @return\n     */\n    public String normalName() {\n        return tag.normalName();\n    }\n\n    /**\n     * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\n     * {@code el.tagName(\"div\");}.\n     *\n     * @param tagName new tag name for this element\n     * @return this element, for chaining\n     */\n    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings()); // maintains the case option of the original parse\n        return this;\n    }\n\n    /**\n     * Get the Tag for this element.\n     * \n     * @return the tag object\n     */\n    public Tag tag() {\n        return tag;\n    }\n    \n    /**\n     * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element\n     * {@code <p> == false}).\n     * \n     * @return true if block, false if not (and thus inline)\n     */\n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    /**\n     * Get the {@code id} attribute of this element.\n     * \n     * @return The id attribute, if present, or an empty string if not.\n     */\n    public String id() {\n        return attributes().getIgnoreCase(\"id\");\n    }\n\n    /**\n     * Set an attribute value on this element. If this element already has an attribute with the\n     * key, its value is updated; otherwise, a new attribute is added.\n     * \n     * @return this element\n     */\n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n    \n    /**\n     * Set a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to \"\" and\n     * marks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute\n     * with the same key if it exists.\n     * \n     * @param attributeKey the attribute key\n     * @param attributeValue the attribute value\n     * \n     * @return this element\n     */\n    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     * Get this element's HTML5 custom data attributes. Each attribute in the element that has a key\n     * starting with \"data-\" is included the dataset.\n     * <p>\n     * E.g., the element {@code <div data-package=\"jsoup\" data-language=\"Java\" class=\"group\">...} has the dataset\n     * {@code package=jsoup, language=java}.\n     * <p>\n     * This map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected\n     * in the other map.\n     * <p>\n     * You can find elements that have data attributes using the {@code [^data-]} attribute key prefix selector.\n     * @return a map of {@code key=value} custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }\n\n    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    /**\n     * Get this element's parent and ancestors, up to the document root.\n     * @return this element's stack of parents, closest first.\n     */\n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }\n\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }\n\n    /**\n     * Get a child element of this element, by its 0-based index number.\n     * <p>\n     * Note that an element can have both mixed Nodes and Elements as children. This method inspects\n     * a filtered list of children that are elements, and the index is based on that filtered list.\n     * </p>\n     * \n     * @param index the index number of the element to retrieve\n     * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n     * @see #childNode(int)\n     */\n    public Element child(int index) {\n        return childElementsList().get(index);\n    }\n\n    /**\n     * Get this element's child elements.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n     * </p>\n     * @return child elements. If this element has no children, returns an empty list.\n     * @see #childNodes()\n     */\n    public Elements children() {\n        return new Elements(childElementsList());\n    }\n\n    /**\n     * Maintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.\n     * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.\n     * @return a list of child elements\n     */\n    private List<Element> childElementsList() {\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    }\n\n    /**\n     * Clears the cached shadow child elements.\n     */\n    @Override\n    void nodelistChanged() {\n        super.nodelistChanged();\n        shadowChildrenRef = null;\n    }\n\n    /**\n     * Get this element's child text nodes. The list is unmodifiable but the text nodes may be manipulated.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Text nodes.\n     * @return child text nodes. If this element has no text nodes, returns an\n     * empty list.\n     * </p>\n     * For example, with the input HTML: {@code <p>One <span>Two</span> Three <br> Four</p>} with the {@code p} element selected:\n     * <ul>\n     *     <li>{@code p.text()} = {@code \"One Two Three Four\"}</li>\n     *     <li>{@code p.ownText()} = {@code \"One Three Four\"}</li>\n     *     <li>{@code p.children()} = {@code Elements[<span>, <br>]}</li>\n     *     <li>{@code p.childNodes()} = {@code List<Node>[\"One \", <span>, \" Three \", <br>, \" Four\"]}</li>\n     *     <li>{@code p.textNodes()} = {@code List<TextNode>[\"One \", \" Three \", \" Four\"]}</li>\n     * </ul>\n     */\n    public List<TextNode> textNodes() {", "right_context": "}\n}", "class_name": "Element", "return_type": "List<TextNode>", "parameters": []}}
{"prompt": "class Element extends Node {\n    /**\n     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n     *\n     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n     * end\n     * @param children child nodes to insert\n     * @return this element, for chaining.\n     */\n    public Element insertChildren(int index, Node... children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; // roll around\n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        addChildren(index, children);\n        return this;\n    }\n    \n    /**\n     * Create a new element by tag name, and add it as the last child.\n     * \n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @return the new element, to allow you to add content to it, e.g.:\n     *  {@code parent.appendElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n     */\n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n        appendChild(child);\n        return child;\n    }\n    \n    /**\n     * Create a new element by tag name, and add it as the first child.\n     * \n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @return the new element, to allow you to add content to it, e.g.:\n     *  {@code parent.prependElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n     */\n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n        prependChild(child);\n        return child;\n    }\n    \n    /**\n     * Create and append a new TextNode to this element.\n     * \n     * @param text the unencoded text to add\n     * @return this element\n     */\n    public Element appendText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        appendChild(node);\n        return this;\n    }\n    \n    /**\n     * Create and prepend a new TextNode to this element.\n     * \n     * @param text the unencoded text to add\n     * @return this element\n     */\n    public Element prependText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        prependChild(node);\n        return this;\n    }\n    \n    /**\n     * Add inner HTML to this element. The supplied HTML will be parsed, and each node appended to the end of the children.\n     * @param html HTML to add inside this element, after the existing HTML\n     * @return this element\n     * @see #html(String)\n     */\n    public Element append(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[0]));\n        return this;\n    }\n    \n    /**\n     * Add inner HTML into this element. The supplied HTML will be parsed, and each node prepended to the start of the element's children.\n     * @param html HTML to add inside this element, before the existing HTML\n     * @return this element\n     * @see #html(String)\n     */\n    public Element prepend(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[0]));\n        return this;\n    }\n\n    /**\n     * Insert the specified HTML into the DOM before this element (as a preceding sibling).\n     *\n     * @param html HTML to add before this element\n     * @return this element, for chaining\n     * @see #after(String)\n     */\n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    /**\n     * Insert the specified node into the DOM before this node (as a preceding sibling).\n     * @param node to add before this element\n     * @return this Element, for chaining\n     * @see #after(Node)\n     */\n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    /**\n     * Insert the specified HTML into the DOM after this element (as a following sibling).\n     *\n     * @param html HTML to add after this element\n     * @return this element, for chaining\n     * @see #before(String)\n     */\n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    /**\n     * Insert the specified node into the DOM after this node (as a following sibling).\n     * @param node to add after this element\n     * @return this element, for chaining\n     * @see #before(Node)\n     */\n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    /**\n     * Remove all of the element's child nodes. Any attributes are left as-is.\n     * @return this element\n     */\n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    /**\n     * Wrap the supplied HTML around this element.\n     *\n     * @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     * @return this element, for chaining.\n     */\n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    /**\n     * Get a CSS selector that will uniquely select this element.\n     * <p>\n     * If the element has an ID, returns #id;\n     * otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},\n     * followed by a unique selector for the element (tag.class.class:nth-child(n)).\n     * </p>\n     *\n     * @return the CSS Path that can be used to retrieve the element in a selector.\n     */\n    public String cssSelector() {", "metadata": {"defects4j_task_id": "14d6f275f51ca7a86e7763b141b158e160e506d9e968a38ce4aebf82f4442057", "task_id": "jhy_jsoup/20", "ground_truth": "\n        if (id().length() > 0)\n            return \"#\" + id();\n\n        // Translate HTML namespace ns:tag to CSS namespace syntax ns|tag\n        String tagName = tagName().replace(':', '|');\n        StringBuilder selector = new StringBuilder(tagName);\n        String classes = StringUtil.join(classNames(), \".\");\n        if (classes.length() > 0)\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node\n            return selector.toString();\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return parent().cssSelector() + selector.toString();\n    ", "fpath_tuple": ["jhy_jsoup", "jsoup", "src", "main", "java", "org", "jsoup", "nodes", "Element.java"], "context_start_lineno": 0, "function_name": "cssSelector", "left_context": "class Element extends Node {\n    /**\n     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n     *\n     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n     * end\n     * @param children child nodes to insert\n     * @return this element, for chaining.\n     */\n    public Element insertChildren(int index, Node... children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; // roll around\n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        addChildren(index, children);\n        return this;\n    }\n    \n    /**\n     * Create a new element by tag name, and add it as the last child.\n     * \n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @return the new element, to allow you to add content to it, e.g.:\n     *  {@code parent.appendElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n     */\n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n        appendChild(child);\n        return child;\n    }\n    \n    /**\n     * Create a new element by tag name, and add it as the first child.\n     * \n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @return the new element, to allow you to add content to it, e.g.:\n     *  {@code parent.prependElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n     */\n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n        prependChild(child);\n        return child;\n    }\n    \n    /**\n     * Create and append a new TextNode to this element.\n     * \n     * @param text the unencoded text to add\n     * @return this element\n     */\n    public Element appendText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        appendChild(node);\n        return this;\n    }\n    \n    /**\n     * Create and prepend a new TextNode to this element.\n     * \n     * @param text the unencoded text to add\n     * @return this element\n     */\n    public Element prependText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        prependChild(node);\n        return this;\n    }\n    \n    /**\n     * Add inner HTML to this element. The supplied HTML will be parsed, and each node appended to the end of the children.\n     * @param html HTML to add inside this element, after the existing HTML\n     * @return this element\n     * @see #html(String)\n     */\n    public Element append(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[0]));\n        return this;\n    }\n    \n    /**\n     * Add inner HTML into this element. The supplied HTML will be parsed, and each node prepended to the start of the element's children.\n     * @param html HTML to add inside this element, before the existing HTML\n     * @return this element\n     * @see #html(String)\n     */\n    public Element prepend(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[0]));\n        return this;\n    }\n\n    /**\n     * Insert the specified HTML into the DOM before this element (as a preceding sibling).\n     *\n     * @param html HTML to add before this element\n     * @return this element, for chaining\n     * @see #after(String)\n     */\n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    /**\n     * Insert the specified node into the DOM before this node (as a preceding sibling).\n     * @param node to add before this element\n     * @return this Element, for chaining\n     * @see #after(Node)\n     */\n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    /**\n     * Insert the specified HTML into the DOM after this element (as a following sibling).\n     *\n     * @param html HTML to add after this element\n     * @return this element, for chaining\n     * @see #before(String)\n     */\n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    /**\n     * Insert the specified node into the DOM after this node (as a following sibling).\n     * @param node to add after this element\n     * @return this element, for chaining\n     * @see #before(Node)\n     */\n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    /**\n     * Remove all of the element's child nodes. Any attributes are left as-is.\n     * @return this element\n     */\n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    /**\n     * Wrap the supplied HTML around this element.\n     *\n     * @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     * @return this element, for chaining.\n     */\n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    /**\n     * Get a CSS selector that will uniquely select this element.\n     * <p>\n     * If the element has an ID, returns #id;\n     * otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},\n     * followed by a unique selector for the element (tag.class.class:nth-child(n)).\n     * </p>\n     *\n     * @return the CSS Path that can be used to retrieve the element in a selector.\n     */\n    public String cssSelector() {", "right_context": "}\n}", "class_name": "Element", "return_type": "String", "parameters": []}}
{"prompt": "class Element extends Node {\n    /**\n     * Remove all of the element's child nodes. Any attributes are left as-is.\n     * @return this element\n     */\n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    /**\n     * Wrap the supplied HTML around this element.\n     *\n     * @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     * @return this element, for chaining.\n     */\n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    /**\n     * Get a CSS selector that will uniquely select this element.\n     * <p>\n     * If the element has an ID, returns #id;\n     * otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},\n     * followed by a unique selector for the element (tag.class.class:nth-child(n)).\n     * </p>\n     *\n     * @return the CSS Path that can be used to retrieve the element in a selector.\n     */\n    public String cssSelector() {\n        if (id().length() > 0)\n            return \"#\" + id();\n\n        // Translate HTML namespace ns:tag to CSS namespace syntax ns|tag\n        String tagName = tagName().replace(':', '|');\n        StringBuilder selector = new StringBuilder(tagName);\n        String classes = StringUtil.join(classNames(), \".\");\n        if (classes.length() > 0)\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node\n            return selector.toString();\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return parent().cssSelector() + selector.toString();\n    }\n\n    /**\n     * Get sibling elements. If the element has no sibling elements, returns an empty list. An element is not a sibling\n     * of itself, so will not be included in the returned list.\n     * @return sibling elements\n     */\n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().childElementsList();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }\n\n    /**\n     * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s, \n     * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n     * <p>\n     * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n     * </p>\n     * @return the next element, or null if there is no next element\n     * @see #previousElementSibling()\n     */\n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    /**\n     * Get each of the sibling elements that come after this element.\n     *\n     * @return each of the element siblings after this element, or an empty list if there are no next sibling elements\n     */\n    public Elements nextElementSiblings() {\n        return nextElementSiblings(true);\n    }\n\n    /**\n     * Gets the previous element sibling of this element.\n     * @return the previous element, or null if there is no previous element\n     * @see #nextElementSibling()\n     */\n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    /**\n     * Get each of the element siblings before this element.\n     *\n     * @return the previous element siblings, or an empty list if there are none.\n     */\n    public Elements previousElementSiblings() {\n        return nextElementSiblings(false);\n    }\n\n    private Elements nextElementSiblings(boolean next) {\n        Elements els = new Elements();\n        if (parentNode == null)\n            return  els;\n        els.add(this);\n        return next ?  els.nextAll() : els.prevAll();\n    }\n\n    /**\n     * Gets the first element sibling of this element.\n     * @return the first sibling that is an element (aka the parent's first element child) \n     */\n    public Element firstElementSibling() {\n        // todo: should firstSibling() exclude this?\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }\n    \n    /**\n     * Get the list index of this element in its element sibling list. I.e. if this is the first element\n     * sibling, returns 0.\n     * @return position in element sibling list\n     */\n    public int elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().childElementsList());\n    }\n\n    /**\n     * Gets the last element sibling of this element\n     * @return the last sibling that is an element (aka the parent's last element child) \n     */\n    public Element lastElementSibling() {\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n\n    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n        final int size = elements.size();\n        for (int i = 0; i < size; i++) {\n            if (elements.get(i) == search)\n                return i;\n        }\n        return 0;\n    }\n\n    // DOM type methods\n\n    /**\n     * Finds elements, including and recursively under this element, with the specified tag name.\n     * @param tagName The tag name to search for (case insensitively).\n     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n     */\n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = normalize(tagName);\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    /**\n     * Find an element by ID, including or under this element.\n     * <p>\n     * Note that this finds the first matching ID, starting with this element. If you search down from a different\n     * starting point, it is possible to find a different element by ID. For unique element by ID within a Document,\n     * use {@link Document#getElementById(String)}\n     * @param id The ID to search for.\n     * @return The first matching element by ID, starting with this element, or null if none found.\n     */\n    public Element getElementById(String id) {", "metadata": {"defects4j_task_id": "a834f1590256fe04f2e0f76c4d049d707dd31438fb274eaa29d7cb9a8ce3e6c1", "task_id": "jhy_jsoup/140", "ground_truth": "\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    ", "fpath_tuple": ["jhy_jsoup", "jsoup", "src", "main", "java", "org", "jsoup", "nodes", "Element.java"], "context_start_lineno": 0, "function_name": "getElementById", "left_context": "class Element extends Node {\n    /**\n     * Remove all of the element's child nodes. Any attributes are left as-is.\n     * @return this element\n     */\n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }\n\n    /**\n     * Wrap the supplied HTML around this element.\n     *\n     * @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     * @return this element, for chaining.\n     */\n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    /**\n     * Get a CSS selector that will uniquely select this element.\n     * <p>\n     * If the element has an ID, returns #id;\n     * otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},\n     * followed by a unique selector for the element (tag.class.class:nth-child(n)).\n     * </p>\n     *\n     * @return the CSS Path that can be used to retrieve the element in a selector.\n     */\n    public String cssSelector() {\n        if (id().length() > 0)\n            return \"#\" + id();\n\n        // Translate HTML namespace ns:tag to CSS namespace syntax ns|tag\n        String tagName = tagName().replace(':', '|');\n        StringBuilder selector = new StringBuilder(tagName);\n        String classes = StringUtil.join(classNames(), \".\");\n        if (classes.length() > 0)\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node\n            return selector.toString();\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return parent().cssSelector() + selector.toString();\n    }\n\n    /**\n     * Get sibling elements. If the element has no sibling elements, returns an empty list. An element is not a sibling\n     * of itself, so will not be included in the returned list.\n     * @return sibling elements\n     */\n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().childElementsList();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }\n\n    /**\n     * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s, \n     * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n     * <p>\n     * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n     * </p>\n     * @return the next element, or null if there is no next element\n     * @see #previousElementSibling()\n     */\n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n    /**\n     * Get each of the sibling elements that come after this element.\n     *\n     * @return each of the element siblings after this element, or an empty list if there are no next sibling elements\n     */\n    public Elements nextElementSiblings() {\n        return nextElementSiblings(true);\n    }\n\n    /**\n     * Gets the previous element sibling of this element.\n     * @return the previous element, or null if there is no previous element\n     * @see #nextElementSibling()\n     */\n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n    /**\n     * Get each of the element siblings before this element.\n     *\n     * @return the previous element siblings, or an empty list if there are none.\n     */\n    public Elements previousElementSiblings() {\n        return nextElementSiblings(false);\n    }\n\n    private Elements nextElementSiblings(boolean next) {\n        Elements els = new Elements();\n        if (parentNode == null)\n            return  els;\n        els.add(this);\n        return next ?  els.nextAll() : els.prevAll();\n    }\n\n    /**\n     * Gets the first element sibling of this element.\n     * @return the first sibling that is an element (aka the parent's first element child) \n     */\n    public Element firstElementSibling() {\n        // todo: should firstSibling() exclude this?\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }\n    \n    /**\n     * Get the list index of this element in its element sibling list. I.e. if this is the first element\n     * sibling, returns 0.\n     * @return position in element sibling list\n     */\n    public int elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().childElementsList());\n    }\n\n    /**\n     * Gets the last element sibling of this element\n     * @return the last sibling that is an element (aka the parent's last element child) \n     */\n    public Element lastElementSibling() {\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n\n    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n        final int size = elements.size();\n        for (int i = 0; i < size; i++) {\n            if (elements.get(i) == search)\n                return i;\n        }\n        return 0;\n    }\n\n    // DOM type methods\n\n    /**\n     * Finds elements, including and recursively under this element, with the specified tag name.\n     * @param tagName The tag name to search for (case insensitively).\n     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n     */\n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = normalize(tagName);\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    /**\n     * Find an element by ID, including or under this element.\n     * <p>\n     * Note that this finds the first matching ID, starting with this element. If you search down from a different\n     * starting point, it is possible to find a different element by ID. For unique element by ID within a Document,\n     * use {@link Document#getElementById(String)}\n     * @param id The ID to search for.\n     * @return The first matching element by ID, starting with this element, or null if none found.\n     */\n    public Element getElementById(String id) {", "right_context": "}\n}", "class_name": "Element", "return_type": "Element", "parameters": [{"type": "String", "name": "id"}]}}
{"prompt": "class TextNode extends LeafNode {\n\n    /**\n     Create a new TextNode representing the supplied (unencoded) text).\n\n     @param text raw text\n     @see #createFromEncoded(String)\n     */\n    public TextNode(String text) {\n        value = text;\n    }\n\n    /**\n     Create a new TextNode representing the supplied (unencoded) text).\n\n     @param text raw text\n     @param baseUri base uri - ignored for this node type\n     @see #createFromEncoded(String, String)\n     @deprecated use {@link TextNode#TextNode(String)}\n     */\n    public TextNode(String text, String baseUri) {\n        this(text);\n    }\n\n\tpublic String nodeName() {\n        return \"#text\";\n    }\n    \n    /**\n     * Get the text content of this text node.\n     * @return Unencoded, normalised text.\n     * @see TextNode#getWholeText()\n     */\n    public String text() {\n        return StringUtil.normaliseWhitespace(getWholeText());\n    }\n    \n    /**\n     * Set the text content of this text node.\n     * @param text unencoded text\n     * @return this, for chaining\n     */\n    public TextNode text(String text) {\n        coreValue(text);\n        return this;\n    }\n\n    /**\n     Get the (unencoded) text of this text node, including any newlines and spaces present in the original.\n     @return text\n     */\n    public String getWholeText() {\n        return coreValue();\n    }\n\n    /**\n     Test if this text node is blank -- that is, empty or only whitespace (including newlines).\n     @return true if this document is empty or only whitespace, false if it contains any text content.\n     */\n    public boolean isBlank() {\n        return StringUtil.isBlank(coreValue());\n    }\n\n    /**\n     * Split this text node into two nodes at the specified string offset. After splitting, this node will contain the\n     * original text up to the offset, and will have a new text node sibling containing the text after the offset.\n     * @param offset string offset point to split node at.\n     * @return the newly created text node containing the text after the offset.\n     */\n    public TextNode splitText(int offset) {", "metadata": {"defects4j_task_id": "1699667fbf0cde565c043a5f805d3da7aa22b98c77542c930903b2d1c704feb2", "task_id": "jhy_jsoup/24", "ground_truth": "\n        final String text = coreValue();\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < text.length(), \"Split offset must not be greater than current text length\");\n\n        String head = text.substring(0, offset);\n        String tail = text.substring(offset);\n        text(head);\n        TextNode tailNode = new TextNode(tail);\n        if (parent() != null)\n            parent().addChildren(siblingIndex()+1, tailNode);\n\n        return tailNode;\n    ", "fpath_tuple": ["jhy_jsoup", "jsoup", "src", "main", "java", "org", "jsoup", "nodes", "TextNode.java"], "context_start_lineno": 0, "function_name": "splitText", "left_context": "class TextNode extends LeafNode {\n\n    /**\n     Create a new TextNode representing the supplied (unencoded) text).\n\n     @param text raw text\n     @see #createFromEncoded(String)\n     */\n    public TextNode(String text) {\n        value = text;\n    }\n\n    /**\n     Create a new TextNode representing the supplied (unencoded) text).\n\n     @param text raw text\n     @param baseUri base uri - ignored for this node type\n     @see #createFromEncoded(String, String)\n     @deprecated use {@link TextNode#TextNode(String)}\n     */\n    public TextNode(String text, String baseUri) {\n        this(text);\n    }\n\n\tpublic String nodeName() {\n        return \"#text\";\n    }\n    \n    /**\n     * Get the text content of this text node.\n     * @return Unencoded, normalised text.\n     * @see TextNode#getWholeText()\n     */\n    public String text() {\n        return StringUtil.normaliseWhitespace(getWholeText());\n    }\n    \n    /**\n     * Set the text content of this text node.\n     * @param text unencoded text\n     * @return this, for chaining\n     */\n    public TextNode text(String text) {\n        coreValue(text);\n        return this;\n    }\n\n    /**\n     Get the (unencoded) text of this text node, including any newlines and spaces present in the original.\n     @return text\n     */\n    public String getWholeText() {\n        return coreValue();\n    }\n\n    /**\n     Test if this text node is blank -- that is, empty or only whitespace (including newlines).\n     @return true if this document is empty or only whitespace, false if it contains any text content.\n     */\n    public boolean isBlank() {\n        return StringUtil.isBlank(coreValue());\n    }\n\n    /**\n     * Split this text node into two nodes at the specified string offset. After splitting, this node will contain the\n     * original text up to the offset, and will have a new text node sibling containing the text after the offset.\n     * @param offset string offset point to split node at.\n     * @return the newly created text node containing the text after the offset.\n     */\n    public TextNode splitText(int offset) {", "right_context": "}\n\n\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.outline() && siblingNodes().size()>0 && !isBlank()) ))\n            indent(accum, depth, out);\n\n        boolean normaliseWhite = out.prettyPrint() && parent() instanceof Element\n                && !Element.preserveWhitespace(parent());\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, false);\n    }\n\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }\n\n    /**\n     * Create a new TextNode from HTML encoded (aka escaped) data.\n     * @param encodedText Text containing encoded HTML (e.g. &amp;lt;)\n     * @param baseUri Base uri\n     * @return TextNode containing unencoded data (e.g. &lt;)\n     * @deprecated use {@link TextNode#createFromEncoded(String)} instead, as LeafNodes don't carry base URIs.\n     */\n    public static TextNode createFromEncoded(String encodedText, String baseUri) {\n        String text = Entities.unescape(encodedText);\n        return new TextNode(text);\n    }\n\n    /**\n     * Create a new TextNode from HTML encoded (aka escaped) data.\n     * @param encodedText Text containing encoded HTML (e.g. &amp;lt;)\n     * @return TextNode containing unencoded data (e.g. &lt;)\n     */\n    public static TextNode createFromEncoded(String encodedText) {\n        String text = Entities.unescape(encodedText);\n        return new TextNode(text);\n    }\n\n    static String normaliseWhitespace(String text) {\n        text = StringUtil.normaliseWhitespace(text);\n        return text;\n    }\n\n    static String stripLeadingWhitespace(String text) {\n        return text.replaceFirst(\"^\\\\s+\", \"\");\n    }\n\n    static boolean lastCharIsWhitespace(StringBuilder sb) {\n        return sb.length() != 0 && sb.charAt(sb.length() - 1) == ' ';\n    }\n\n\n}", "class_name": "TextNode", "return_type": "TextNode", "parameters": [{"type": "int", "name": "offset"}]}}
{"prompt": "class BitInputStream implements Closeable {\n    private static final int MAXIMUM_CACHE_SIZE = 63; // bits in long minus sign bit\n    private static final long[] MASKS = new long[MAXIMUM_CACHE_SIZE + 1];\n\n    static {\n        for (int i = 1; i <= MAXIMUM_CACHE_SIZE; i++) {\n            MASKS[i] = (MASKS[i - 1] << 1) + 1;\n        }\n    }\n\n    private final InputStream in;\n    private final ByteOrder byteOrder;\n    private long bitsCached = 0;\n    private int bitsCachedSize = 0;\n\n    /**\n     * Constructor taking an InputStream and its bit arrangement.\n     * @param in the InputStream\n     * @param byteOrder the bit arrangement across byte boundaries,\n     *      either BIG_ENDIAN (aaaaabbb bb000000) or LITTLE_ENDIAN (bbbaaaaa 000000bb)\n     */\n    public BitInputStream(final InputStream in, final ByteOrder byteOrder) {\n        this.in = in;\n        this.byteOrder = byteOrder;\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n\n    /**\n     * Clears the cache of bits that have been read from the\n     * underlying stream but not yet provided via {@link #readBits}.\n     */\n    public void clearBitCache() {\n        bitsCached = 0;\n        bitsCachedSize = 0;\n    }\n\n    /**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException {", "metadata": {"defects4j_task_id": "86e64f0b5eb7a66e7ea70d7e0a343d5bd8b5bc8bf2f59b0f7be1b990fd6a2015", "task_id": "apache_commons-compress/112", "ground_truth": "\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n        if (ensureCache(count)) {\n            return -1;\n        }\n\n        if (bitsCachedSize < count) {\n            return processBitsGreater57(count);\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    ", "fpath_tuple": ["apache_commons-compress", "commons-compress", "src", "main", "java", "org", "apache", "commons", "compress", "utils", "BitInputStream.java"], "context_start_lineno": 0, "function_name": "readBits", "left_context": "class BitInputStream implements Closeable {\n    private static final int MAXIMUM_CACHE_SIZE = 63; // bits in long minus sign bit\n    private static final long[] MASKS = new long[MAXIMUM_CACHE_SIZE + 1];\n\n    static {\n        for (int i = 1; i <= MAXIMUM_CACHE_SIZE; i++) {\n            MASKS[i] = (MASKS[i - 1] << 1) + 1;\n        }\n    }\n\n    private final InputStream in;\n    private final ByteOrder byteOrder;\n    private long bitsCached = 0;\n    private int bitsCachedSize = 0;\n\n    /**\n     * Constructor taking an InputStream and its bit arrangement.\n     * @param in the InputStream\n     * @param byteOrder the bit arrangement across byte boundaries,\n     *      either BIG_ENDIAN (aaaaabbb bb000000) or LITTLE_ENDIAN (bbbaaaaa 000000bb)\n     */\n    public BitInputStream(final InputStream in, final ByteOrder byteOrder) {\n        this.in = in;\n        this.byteOrder = byteOrder;\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n\n    /**\n     * Clears the cache of bits that have been read from the\n     * underlying stream but not yet provided via {@link #readBits}.\n     */\n    public void clearBitCache() {\n        bitsCached = 0;\n        bitsCachedSize = 0;\n    }\n\n    /**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException {", "right_context": "}\n\n    /**\n     * Returns the number of bits that can be read from this input\n     * stream without reading from the underlying input stream at all.\n     * @return estimate of the number of bits that can be read without reading from the underlying stream\n     * @since 1.16\n     */\n    public int bitsCached() {\n        return bitsCachedSize;\n    }\n\n    /**\n     * Returns an estimate of the number of bits that can be read from\n     * this input stream without blocking by the next invocation of a\n     * method for this input stream.\n     * @throws IOException if the underlying stream throws one when calling available\n     * @return estimate of the number of bits that can be read without blocking\n     * @since 1.16\n     */\n    public long bitsAvailable() throws IOException {\n        return bitsCachedSize + 8l * in.available();\n    }\n\n    /**\n     * Drops bits until the next bits will be read from a byte boundary.\n     * @throws IOException if reading the remaining bits to the next byte boundary fails\n     * @since 1.16\n     */\n    public void alignWithByteBoundary() throws IOException {\n        int toSkip = bitsCachedSize % 8;\n        if (toSkip > 0) {\n            readBits(toSkip);\n        }\n    }\n\n    private long processBitsGreater57(final int count) throws IOException {\n        final long bitsOut;\n        int overflowBits = 0;\n        long overflow = 0l;\n\n        // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n        int bitsToAddCount = count - bitsCachedSize;\n        overflowBits = 8 - bitsToAddCount;\n        final long nextByte = in.read();\n        if (nextByte < 0) {\n            return nextByte;\n        }\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n            bitsCached |= (bitsToAdd << bitsCachedSize);\n            overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n        } else {\n            bitsCached <<= bitsToAddCount;\n            long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n            bitsCached |= bitsToAdd;\n            overflow = nextByte & MASKS[overflowBits];\n        }\n        bitsOut = bitsCached & MASKS[count];\n        bitsCached = overflow;\n        bitsCachedSize = overflowBits;\n        return bitsOut;\n    }\n\n    /**\n     * Fills the cache up to 56 bits\n     * @param count\n     * @return return true, when EOF\n     * @throws IOException\n     */\n    private boolean ensureCache(final int count) throws IOException {\n        while (bitsCachedSize < count && bitsCachedSize < 57) {\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return true;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsCached |= (nextByte << bitsCachedSize);\n            } else {\n                bitsCached <<= 8;\n                bitsCached |= nextByte;\n            }\n            bitsCachedSize += 8;\n        }\n        return false;\n    }\n}", "class_name": "BitInputStream", "return_type": "long", "parameters": [{"type": "int", "name": "count"}]}}
{"prompt": "class FramedSnappyCompressorInputStream extends CompressorInputStream {\n\n    private static final int STREAM_IDENTIFIER_TYPE = 0xff;\n    static final int COMPRESSED_CHUNK_TYPE = 0;\n    private static final int UNCOMPRESSED_CHUNK_TYPE = 1;\n    private static final int PADDING_CHUNK_TYPE = 0xfe;\n    private static final int MIN_UNSKIPPABLE_TYPE = 2;\n    private static final int MAX_UNSKIPPABLE_TYPE = 0x7f;\n    private static final int MAX_SKIPPABLE_TYPE = 0xfd;\n\n    // used by FramedSnappyCompressorOutputStream as well\n    static final byte[] SZ_SIGNATURE = new byte[] { //NOSONAR\n        (byte) STREAM_IDENTIFIER_TYPE, // tag\n        6, 0, 0, // length\n        's', 'N', 'a', 'P', 'p', 'Y'\n    };\n\n    /** The underlying stream to read compressed data from */\n    private final PushbackInputStream in;\n\n    /** The dialect to expect */\n    private final FramedSnappyDialect dialect;\n\n    private SnappyCompressorInputStream currentCompressedChunk;\n\n    // used in no-arg read method\n    private final byte[] oneByte = new byte[1];\n\n    private boolean endReached, inUncompressedChunk;\n\n    private int uncompressedBytesRemaining;\n    private long expectedChecksum = -1;\n    private final int blockSize;\n    private final PureJavaCrc32C checksum = new PureJavaCrc32C();\n\n    private final ByteUtils.ByteSupplier supplier = new ByteUtils.ByteSupplier() {\n        @Override\n        public int getAsByte() throws IOException {\n            return readOneByte();\n        }\n    };\n\n    /**\n     * Constructs a new input stream that decompresses\n     * snappy-framed-compressed data from the specified input stream\n     * using the {@link FramedSnappyDialect#STANDARD} dialect.\n     * @param in  the InputStream from which to read the compressed data\n     * @throws IOException if reading fails\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in) throws IOException {\n        this(in, FramedSnappyDialect.STANDARD);\n    }\n\n    /**\n     * Constructs a new input stream that decompresses snappy-framed-compressed data\n     * from the specified input stream.\n     * @param in  the InputStream from which to read the compressed data\n     * @param dialect the dialect used by the compressed stream\n     * @throws IOException if reading fails\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in,\n                                             final FramedSnappyDialect dialect)\n        throws IOException {\n        this(in, SnappyCompressorInputStream.DEFAULT_BLOCK_SIZE, dialect);\n    }\n\n    /**\n     * Constructs a new input stream that decompresses snappy-framed-compressed data\n     * from the specified input stream.\n     * @param in  the InputStream from which to read the compressed data\n     * @param blockSize the block size to use for the compressed stream\n     * @param dialect the dialect used by the compressed stream\n     * @throws IOException if reading fails\n     * @since 1.14\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in,\n                                             final int blockSize,\n                                             final FramedSnappyDialect dialect)\n        throws IOException {\n        this.in = new PushbackInputStream(in, 1);\n        this.blockSize = blockSize;\n        this.dialect = dialect;\n        if (dialect.hasStreamIdentifier()) {\n            readStreamIdentifier();\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int read() throws IOException {\n        return read(oneByte, 0, 1) == -1 ? -1 : oneByte[0] & 0xFF;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void close() throws IOException {\n        if (currentCompressedChunk != null) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        in.close();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        int read = readOnce(b, off, len);\n        if (read == -1) {\n            readNextBlock();\n            if (endReached) {\n                return -1;\n            }\n            read = readOnce(b, off, len);\n        }\n        return read;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int available() throws IOException {\n        if (inUncompressedChunk) {\n            return Math.min(uncompressedBytesRemaining,\n                            in.available());\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.available();\n        }\n        return 0;\n    }\n\n    /**\n     * Read from the current chunk into the given array.\n     *\n     * @return -1 if there is no current chunk or the number of bytes\n     * read from the current chunk (which may be -1 if the end of the\n     * chunk is reached).\n     */\n    private int readOnce(final byte[] b, final int off, final int len) throws IOException {", "metadata": {"defects4j_task_id": "f982413e9a54c1068f431aa1a549e1505d9e0d6e292628135f02938c6799fc3d", "task_id": "apache_commons-compress/203", "ground_truth": "\n        int read = -1;\n        if (inUncompressedChunk) {\n            final int amount = Math.min(uncompressedBytesRemaining, len);\n            if (amount == 0) {\n                return -1;\n            }\n            read = in.read(b, off, amount);\n            if (read != -1) {\n                uncompressedBytesRemaining -= read;\n                count(read);\n            }\n        } else if (currentCompressedChunk != null) {\n            final long before = currentCompressedChunk.getBytesRead();\n            read = currentCompressedChunk.read(b, off, len);\n            if (read == -1) {\n                currentCompressedChunk.close();\n                currentCompressedChunk = null;\n            } else {\n                count(currentCompressedChunk.getBytesRead() - before);\n            }\n        }\n        if (read > 0) {\n            checksum.update(b, off, read);\n        }\n        return read;\n    ", "fpath_tuple": ["apache_commons-compress", "commons-compress", "src", "main", "java", "org", "apache", "commons", "compress", "compressors", "snappy", "FramedSnappyCompressorInputStream.java"], "context_start_lineno": 0, "function_name": "readOnce", "left_context": "class FramedSnappyCompressorInputStream extends CompressorInputStream {\n\n    private static final int STREAM_IDENTIFIER_TYPE = 0xff;\n    static final int COMPRESSED_CHUNK_TYPE = 0;\n    private static final int UNCOMPRESSED_CHUNK_TYPE = 1;\n    private static final int PADDING_CHUNK_TYPE = 0xfe;\n    private static final int MIN_UNSKIPPABLE_TYPE = 2;\n    private static final int MAX_UNSKIPPABLE_TYPE = 0x7f;\n    private static final int MAX_SKIPPABLE_TYPE = 0xfd;\n\n    // used by FramedSnappyCompressorOutputStream as well\n    static final byte[] SZ_SIGNATURE = new byte[] { //NOSONAR\n        (byte) STREAM_IDENTIFIER_TYPE, // tag\n        6, 0, 0, // length\n        's', 'N', 'a', 'P', 'p', 'Y'\n    };\n\n    /** The underlying stream to read compressed data from */\n    private final PushbackInputStream in;\n\n    /** The dialect to expect */\n    private final FramedSnappyDialect dialect;\n\n    private SnappyCompressorInputStream currentCompressedChunk;\n\n    // used in no-arg read method\n    private final byte[] oneByte = new byte[1];\n\n    private boolean endReached, inUncompressedChunk;\n\n    private int uncompressedBytesRemaining;\n    private long expectedChecksum = -1;\n    private final int blockSize;\n    private final PureJavaCrc32C checksum = new PureJavaCrc32C();\n\n    private final ByteUtils.ByteSupplier supplier = new ByteUtils.ByteSupplier() {\n        @Override\n        public int getAsByte() throws IOException {\n            return readOneByte();\n        }\n    };\n\n    /**\n     * Constructs a new input stream that decompresses\n     * snappy-framed-compressed data from the specified input stream\n     * using the {@link FramedSnappyDialect#STANDARD} dialect.\n     * @param in  the InputStream from which to read the compressed data\n     * @throws IOException if reading fails\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in) throws IOException {\n        this(in, FramedSnappyDialect.STANDARD);\n    }\n\n    /**\n     * Constructs a new input stream that decompresses snappy-framed-compressed data\n     * from the specified input stream.\n     * @param in  the InputStream from which to read the compressed data\n     * @param dialect the dialect used by the compressed stream\n     * @throws IOException if reading fails\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in,\n                                             final FramedSnappyDialect dialect)\n        throws IOException {\n        this(in, SnappyCompressorInputStream.DEFAULT_BLOCK_SIZE, dialect);\n    }\n\n    /**\n     * Constructs a new input stream that decompresses snappy-framed-compressed data\n     * from the specified input stream.\n     * @param in  the InputStream from which to read the compressed data\n     * @param blockSize the block size to use for the compressed stream\n     * @param dialect the dialect used by the compressed stream\n     * @throws IOException if reading fails\n     * @since 1.14\n     */\n    public FramedSnappyCompressorInputStream(final InputStream in,\n                                             final int blockSize,\n                                             final FramedSnappyDialect dialect)\n        throws IOException {\n        this.in = new PushbackInputStream(in, 1);\n        this.blockSize = blockSize;\n        this.dialect = dialect;\n        if (dialect.hasStreamIdentifier()) {\n            readStreamIdentifier();\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int read() throws IOException {\n        return read(oneByte, 0, 1) == -1 ? -1 : oneByte[0] & 0xFF;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void close() throws IOException {\n        if (currentCompressedChunk != null) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        in.close();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        int read = readOnce(b, off, len);\n        if (read == -1) {\n            readNextBlock();\n            if (endReached) {\n                return -1;\n            }\n            read = readOnce(b, off, len);\n        }\n        return read;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int available() throws IOException {\n        if (inUncompressedChunk) {\n            return Math.min(uncompressedBytesRemaining,\n                            in.available());\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.available();\n        }\n        return 0;\n    }\n\n    /**\n     * Read from the current chunk into the given array.\n     *\n     * @return -1 if there is no current chunk or the number of bytes\n     * read from the current chunk (which may be -1 if the end of the\n     * chunk is reached).\n     */\n    private int readOnce(final byte[] b, final int off, final int len) throws IOException {", "right_context": "}\n\n}", "class_name": "FramedSnappyCompressorInputStream", "return_type": "int", "parameters": [{"type": "byte[]", "name": "b"}, {"type": "int", "name": "off"}, {"type": "int", "name": "len"}]}}
{"prompt": "class CpioUtil {\n\n    /**\n     * Extracts the file type bits from a mode.\n     */\n    static long fileType(final long mode) {\n        return mode & CpioConstants.S_IFMT;\n    }\n\n    /**\n     * Converts a byte array to a long. Halfwords can be swapped by setting\n     * swapHalfWord=true.\n     *\n     * @param number\n     *            An array of bytes containing a number\n     * @param swapHalfWord\n     *            Swap halfwords ([0][1][2][3]->[1][0][3][2])\n     * @return The long value\n     * @throws UnsupportedOperationException if number length is not a multiple of 2\n     */\n    static long byteArray2long(final byte[] number, final boolean swapHalfWord) {", "metadata": {"defects4j_task_id": "e8bf5f440b01cef99aca13a3d4be249c1adb41e8898268eaa219dcb3dcfa6bdc", "task_id": "apache_commons-compress/191", "ground_truth": "\n        if (number.length % 2 != 0) {\n            throw new UnsupportedOperationException();\n        }\n\n        long ret = 0;\n        int pos = 0;\n        final byte tmp_number[] = new byte[number.length];\n        System.arraycopy(number, 0, tmp_number, 0, number.length);\n\n        if (!swapHalfWord) {\n            byte tmp = 0;\n            for (pos = 0; pos < tmp_number.length; pos++) {\n                tmp = tmp_number[pos];\n                tmp_number[pos++] = tmp_number[pos];\n                tmp_number[pos] = tmp;\n            }\n        }\n\n        ret = tmp_number[0] & 0xFF;\n        for (pos = 1; pos < tmp_number.length; pos++) {\n            ret <<= 8;\n            ret |= tmp_number[pos] & 0xFF;\n        }\n        return ret;\n    ", "fpath_tuple": ["apache_commons-compress", "commons-compress", "src", "main", "java", "org", "apache", "commons", "compress", "archivers", "cpio", "CpioUtil.java"], "context_start_lineno": 0, "function_name": "byteArray2long", "left_context": "class CpioUtil {\n\n    /**\n     * Extracts the file type bits from a mode.\n     */\n    static long fileType(final long mode) {\n        return mode & CpioConstants.S_IFMT;\n    }\n\n    /**\n     * Converts a byte array to a long. Halfwords can be swapped by setting\n     * swapHalfWord=true.\n     *\n     * @param number\n     *            An array of bytes containing a number\n     * @param swapHalfWord\n     *            Swap halfwords ([0][1][2][3]->[1][0][3][2])\n     * @return The long value\n     * @throws UnsupportedOperationException if number length is not a multiple of 2\n     */\n    static long byteArray2long(final byte[] number, final boolean swapHalfWord) {", "right_context": "}\n\n    /**\n     * Converts a long number to a byte array\n     * Halfwords can be swapped by setting swapHalfWord=true.\n     *\n     * @param number\n     *            the input long number to be converted\n     *\n     * @param length\n     *            The length of the returned array\n     * @param swapHalfWord\n     *            Swap halfwords ([0][1][2][3]->[1][0][3][2])\n     * @return The long value\n     * @throws UnsupportedOperationException if the length is not a positive multiple of two\n     */\n    static byte[] long2byteArray(final long number, final int length,\n            final boolean swapHalfWord) {\n        final byte[] ret = new byte[length];\n        int pos = 0;\n        long tmp_number = 0;\n\n        if (length % 2 != 0 || length < 2) {\n            throw new UnsupportedOperationException();\n        }\n\n        tmp_number = number;\n        for (pos = length - 1; pos >= 0; pos--) {\n            ret[pos] = (byte) (tmp_number & 0xFF);\n            tmp_number >>= 8;\n        }\n\n        if (!swapHalfWord) {\n            byte tmp = 0;\n            for (pos = 0; pos < length; pos++) {\n                tmp = ret[pos];\n                ret[pos++] = ret[pos];\n                ret[pos] = tmp;\n            }\n        }\n\n        return ret;\n    }\n}", "class_name": "CpioUtil", "return_type": "long", "parameters": [{"type": "byte[]", "name": "number"}, {"type": "boolean", "name": "swapHalfWord"}]}}
{"prompt": "class ExtraFieldUtils {\n\n    /**\n     * Static registry of known extra fields.\n     */\n    private static final Map<ZipShort, Class<?>> implementations;\n\n    static {\n        implementations = new ConcurrentHashMap<>();\n        register(AsiExtraField.class);\n        register(X5455_ExtendedTimestamp.class);\n        register(X7875_NewUnix.class);\n        register(JarMarker.class);\n        register(UnicodePathExtraField.class);\n        register(UnicodeCommentExtraField.class);\n        register(Zip64ExtendedInformationExtraField.class);\n        register(X000A_NTFS.class);\n        register(X0014_X509Certificates.class);\n        register(X0015_CertificateIdForFile.class);\n        register(X0016_CertificateIdForCentralDirectory.class);\n        register(X0017_StrongEncryptionHeader.class);\n        register(X0019_EncryptionRecipientCertificateList.class);\n        register(ResourceAlignmentExtraField.class);\n    }\n\n    /**\n     * Register a ZipExtraField implementation.\n     *\n     * <p>The given class must have a no-arg constructor and implement\n     * the {@link ZipExtraField ZipExtraField interface}.</p>\n     * @param c the class to register\n     */\n    public static void register(final Class<?> c) {\n        try {\n            final ZipExtraField ze = (ZipExtraField) c.newInstance();\n            implementations.put(ze.getHeaderId(), c);\n        } catch (final ClassCastException cc) {\n            throw new RuntimeException(c + \" doesn\\'t implement ZipExtraField\"); //NOSONAR\n        } catch (final InstantiationException ie) {\n            throw new RuntimeException(c + \" is not a concrete class\"); //NOSONAR\n        } catch (final IllegalAccessException ie) {\n            throw new RuntimeException(c + \"\\'s no-arg constructor is not public\"); //NOSONAR\n        }\n    }\n\n    /**\n     * Create an instance of the appropriate ExtraField, falls back to\n     * {@link UnrecognizedExtraField UnrecognizedExtraField}.\n     * @param headerId the header identifier\n     * @return an instance of the appropriate ExtraField\n     * @throws InstantiationException if unable to instantiate the class\n     * @throws IllegalAccessException if not allowed to instantiate the class\n     */\n    public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException {", "metadata": {"defects4j_task_id": "d56f01f90944eb54416a1c084a65978e279e631476001f740e0a720a4d8ad4db", "task_id": "apache_commons-compress/174", "ground_truth": "\n        final Class<?> c = implementations.get(headerId);\n        if (c != null) {\n            return (ZipExtraField) c.newInstance();\n        }\n        final UnrecognizedExtraField u = new UnrecognizedExtraField();\n        u.setHeaderId(headerId);\n        return u;\n    ", "fpath_tuple": ["apache_commons-compress", "commons-compress", "src", "main", "java", "org", "apache", "commons", "compress", "archivers", "zip", "ExtraFieldUtils.java"], "context_start_lineno": 0, "function_name": "createExtraField", "left_context": "class ExtraFieldUtils {\n\n    /**\n     * Static registry of known extra fields.\n     */\n    private static final Map<ZipShort, Class<?>> implementations;\n\n    static {\n        implementations = new ConcurrentHashMap<>();\n        register(AsiExtraField.class);\n        register(X5455_ExtendedTimestamp.class);\n        register(X7875_NewUnix.class);\n        register(JarMarker.class);\n        register(UnicodePathExtraField.class);\n        register(UnicodeCommentExtraField.class);\n        register(Zip64ExtendedInformationExtraField.class);\n        register(X000A_NTFS.class);\n        register(X0014_X509Certificates.class);\n        register(X0015_CertificateIdForFile.class);\n        register(X0016_CertificateIdForCentralDirectory.class);\n        register(X0017_StrongEncryptionHeader.class);\n        register(X0019_EncryptionRecipientCertificateList.class);\n        register(ResourceAlignmentExtraField.class);\n    }\n\n    /**\n     * Register a ZipExtraField implementation.\n     *\n     * <p>The given class must have a no-arg constructor and implement\n     * the {@link ZipExtraField ZipExtraField interface}.</p>\n     * @param c the class to register\n     */\n    public static void register(final Class<?> c) {\n        try {\n            final ZipExtraField ze = (ZipExtraField) c.newInstance();\n            implementations.put(ze.getHeaderId(), c);\n        } catch (final ClassCastException cc) {\n            throw new RuntimeException(c + \" doesn\\'t implement ZipExtraField\"); //NOSONAR\n        } catch (final InstantiationException ie) {\n            throw new RuntimeException(c + \" is not a concrete class\"); //NOSONAR\n        } catch (final IllegalAccessException ie) {\n            throw new RuntimeException(c + \"\\'s no-arg constructor is not public\"); //NOSONAR\n        }\n    }\n\n    /**\n     * Create an instance of the appropriate ExtraField, falls back to\n     * {@link UnrecognizedExtraField UnrecognizedExtraField}.\n     * @param headerId the header identifier\n     * @return an instance of the appropriate ExtraField\n     * @throws InstantiationException if unable to instantiate the class\n     * @throws IllegalAccessException if not allowed to instantiate the class\n     */\n    public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException {", "right_context": "}\n}", "class_name": "ExtraFieldUtils", "return_type": "ZipExtraField", "parameters": [{"type": "ZipShort", "name": "headerId"}]}}
{"prompt": "class ExtraFieldUtils {\n\n    /**\n     * Register a ZipExtraField implementation.\n     *\n     * <p>The given class must have a no-arg constructor and implement\n     * the {@link ZipExtraField ZipExtraField interface}.</p>\n     * @param c the class to register\n     */\n    public static void register(final Class<?> c) {\n        try {\n            final ZipExtraField ze = (ZipExtraField) c.newInstance();\n            implementations.put(ze.getHeaderId(), c);\n        } catch (final ClassCastException cc) {\n            throw new RuntimeException(c + \" doesn\\'t implement ZipExtraField\"); //NOSONAR\n        } catch (final InstantiationException ie) {\n            throw new RuntimeException(c + \" is not a concrete class\"); //NOSONAR\n        } catch (final IllegalAccessException ie) {\n            throw new RuntimeException(c + \"\\'s no-arg constructor is not public\"); //NOSONAR\n        }\n    }\n\n    /**\n     * Create an instance of the appropriate ExtraField, falls back to\n     * {@link UnrecognizedExtraField UnrecognizedExtraField}.\n     * @param headerId the header identifier\n     * @return an instance of the appropriate ExtraField\n     * @throws InstantiationException if unable to instantiate the class\n     * @throws IllegalAccessException if not allowed to instantiate the class\n     */\n    public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException {\n        final Class<?> c = implementations.get(headerId);\n        if (c != null) {\n            return (ZipExtraField) c.newInstance();\n        }\n        final UnrecognizedExtraField u = new UnrecognizedExtraField();\n        u.setHeaderId(headerId);\n        return u;\n    }\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data as local file data, throwing an exception if the\n     * data cannot be parsed.\n     * @param data an array of bytes as it appears in local file data\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     */\n    public static ZipExtraField[] parse(final byte[] data) throws ZipException {\n        return parse(data, true, UnparseableExtraField.THROW);\n    }\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data, throwing an exception if the data cannot be parsed.\n     * @param data an array of bytes\n     * @param local whether data originates from the local file data\n     * or the central directory\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     */\n    public static ZipExtraField[] parse(final byte[] data, final boolean local)\n        throws ZipException {\n        return parse(data, local, UnparseableExtraField.THROW);\n    }\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data.\n     * @param data an array of bytes\n     * @param local whether data originates from the local file data\n     * or the central directory\n     * @param onUnparseableData what to do if the extra field data\n     * cannot be parsed.\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     *\n     * @since 1.1\n     */\n    public static ZipExtraField[] parse(final byte[] data, final boolean local,\n                                        final UnparseableExtraField onUnparseableData)\n        throws ZipException {\n        final List<ZipExtraField> v = new ArrayList<>();\n        int start = 0;\n        LOOP:\n        while (start <= data.length - WORD) {\n            final ZipShort headerId = new ZipShort(data, start);\n            final int length = new ZipShort(data, start + 2).getValue();\n            if (start + WORD + length > data.length) {\n                switch(onUnparseableData.getKey()) {\n                case UnparseableExtraField.THROW_KEY:\n                    throw new ZipException(\"bad extra field starting at \"\n                                           + start + \".  Block length of \"\n                                           + length + \" bytes exceeds remaining\"\n                                           + \" data of \"\n                                           + (data.length - start - WORD)\n                                           + \" bytes.\");\n                case UnparseableExtraField.READ_KEY:\n                    final UnparseableExtraFieldData field =\n                        new UnparseableExtraFieldData();\n                    if (local) {\n                        field.parseFromLocalFileData(data, start,\n                                                     data.length - start);\n                    } else {\n                        field.parseFromCentralDirectoryData(data, start,\n                                                            data.length - start);\n                    }\n                    v.add(field);\n                    //$FALL-THROUGH$\n                case UnparseableExtraField.SKIP_KEY:\n                    // since we cannot parse the data we must assume\n                    // the extra field consumes the whole rest of the\n                    // available data\n                    break LOOP;\n                default:\n                    throw new ZipException(\"unknown UnparseableExtraField key: \"\n                                           + onUnparseableData.getKey());\n                }\n            }\n            try {\n                final ZipExtraField ze = createExtraField(headerId);\n                if (local) {\n                    ze.parseFromLocalFileData(data, start + WORD, length);\n                } else {\n                    ze.parseFromCentralDirectoryData(data, start + WORD,\n                                                     length);\n                }\n                v.add(ze);\n            } catch (final InstantiationException | IllegalAccessException ie) {\n                throw (ZipException) new ZipException(ie.getMessage()).initCause(ie);\n            }\n            start += length + WORD;\n        }\n\n        final ZipExtraField[] result = new ZipExtraField[v.size()];\n        return v.toArray(result);\n    }\n\n    /**\n     * Merges the local file data fields of the given ZipExtraFields.\n     * @param data an array of ExtraFiles\n     * @return an array of bytes\n     */\n    public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {", "metadata": {"defects4j_task_id": "79cce55ed917ece8b1cb2260741455f8c4ea533d01461be44b1e05b125daccee", "task_id": "apache_commons-compress/101", "ground_truth": "\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    ", "fpath_tuple": ["apache_commons-compress", "commons-compress", "src", "main", "java", "org", "apache", "commons", "compress", "archivers", "zip", "ExtraFieldUtils.java"], "context_start_lineno": 0, "function_name": "mergeLocalFileDataData", "left_context": "class ExtraFieldUtils {\n\n    /**\n     * Register a ZipExtraField implementation.\n     *\n     * <p>The given class must have a no-arg constructor and implement\n     * the {@link ZipExtraField ZipExtraField interface}.</p>\n     * @param c the class to register\n     */\n    public static void register(final Class<?> c) {\n        try {\n            final ZipExtraField ze = (ZipExtraField) c.newInstance();\n            implementations.put(ze.getHeaderId(), c);\n        } catch (final ClassCastException cc) {\n            throw new RuntimeException(c + \" doesn\\'t implement ZipExtraField\"); //NOSONAR\n        } catch (final InstantiationException ie) {\n            throw new RuntimeException(c + \" is not a concrete class\"); //NOSONAR\n        } catch (final IllegalAccessException ie) {\n            throw new RuntimeException(c + \"\\'s no-arg constructor is not public\"); //NOSONAR\n        }\n    }\n\n    /**\n     * Create an instance of the appropriate ExtraField, falls back to\n     * {@link UnrecognizedExtraField UnrecognizedExtraField}.\n     * @param headerId the header identifier\n     * @return an instance of the appropriate ExtraField\n     * @throws InstantiationException if unable to instantiate the class\n     * @throws IllegalAccessException if not allowed to instantiate the class\n     */\n    public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException {\n        final Class<?> c = implementations.get(headerId);\n        if (c != null) {\n            return (ZipExtraField) c.newInstance();\n        }\n        final UnrecognizedExtraField u = new UnrecognizedExtraField();\n        u.setHeaderId(headerId);\n        return u;\n    }\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data as local file data, throwing an exception if the\n     * data cannot be parsed.\n     * @param data an array of bytes as it appears in local file data\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     */\n    public static ZipExtraField[] parse(final byte[] data) throws ZipException {\n        return parse(data, true, UnparseableExtraField.THROW);\n    }\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data, throwing an exception if the data cannot be parsed.\n     * @param data an array of bytes\n     * @param local whether data originates from the local file data\n     * or the central directory\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     */\n    public static ZipExtraField[] parse(final byte[] data, final boolean local)\n        throws ZipException {\n        return parse(data, local, UnparseableExtraField.THROW);\n    }\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data.\n     * @param data an array of bytes\n     * @param local whether data originates from the local file data\n     * or the central directory\n     * @param onUnparseableData what to do if the extra field data\n     * cannot be parsed.\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     *\n     * @since 1.1\n     */\n    public static ZipExtraField[] parse(final byte[] data, final boolean local,\n                                        final UnparseableExtraField onUnparseableData)\n        throws ZipException {\n        final List<ZipExtraField> v = new ArrayList<>();\n        int start = 0;\n        LOOP:\n        while (start <= data.length - WORD) {\n            final ZipShort headerId = new ZipShort(data, start);\n            final int length = new ZipShort(data, start + 2).getValue();\n            if (start + WORD + length > data.length) {\n                switch(onUnparseableData.getKey()) {\n                case UnparseableExtraField.THROW_KEY:\n                    throw new ZipException(\"bad extra field starting at \"\n                                           + start + \".  Block length of \"\n                                           + length + \" bytes exceeds remaining\"\n                                           + \" data of \"\n                                           + (data.length - start - WORD)\n                                           + \" bytes.\");\n                case UnparseableExtraField.READ_KEY:\n                    final UnparseableExtraFieldData field =\n                        new UnparseableExtraFieldData();\n                    if (local) {\n                        field.parseFromLocalFileData(data, start,\n                                                     data.length - start);\n                    } else {\n                        field.parseFromCentralDirectoryData(data, start,\n                                                            data.length - start);\n                    }\n                    v.add(field);\n                    //$FALL-THROUGH$\n                case UnparseableExtraField.SKIP_KEY:\n                    // since we cannot parse the data we must assume\n                    // the extra field consumes the whole rest of the\n                    // available data\n                    break LOOP;\n                default:\n                    throw new ZipException(\"unknown UnparseableExtraField key: \"\n                                           + onUnparseableData.getKey());\n                }\n            }\n            try {\n                final ZipExtraField ze = createExtraField(headerId);\n                if (local) {\n                    ze.parseFromLocalFileData(data, start + WORD, length);\n                } else {\n                    ze.parseFromCentralDirectoryData(data, start + WORD,\n                                                     length);\n                }\n                v.add(ze);\n            } catch (final InstantiationException | IllegalAccessException ie) {\n                throw (ZipException) new ZipException(ie.getMessage()).initCause(ie);\n            }\n            start += length + WORD;\n        }\n\n        final ZipExtraField[] result = new ZipExtraField[v.size()];\n        return v.toArray(result);\n    }\n\n    /**\n     * Merges the local file data fields of the given ZipExtraFields.\n     * @param data an array of ExtraFiles\n     * @return an array of bytes\n     */\n    public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {", "right_context": "}\n}", "class_name": "ExtraFieldUtils", "return_type": "byte[]", "parameters": [{"type": "ZipExtraField[]", "name": "data"}]}}
{"prompt": "class ExtraFieldUtils {\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data as local file data, throwing an exception if the\n     * data cannot be parsed.\n     * @param data an array of bytes as it appears in local file data\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     */\n    public static ZipExtraField[] parse(final byte[] data) throws ZipException {\n        return parse(data, true, UnparseableExtraField.THROW);\n    }\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data, throwing an exception if the data cannot be parsed.\n     * @param data an array of bytes\n     * @param local whether data originates from the local file data\n     * or the central directory\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     */\n    public static ZipExtraField[] parse(final byte[] data, final boolean local)\n        throws ZipException {\n        return parse(data, local, UnparseableExtraField.THROW);\n    }\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data.\n     * @param data an array of bytes\n     * @param local whether data originates from the local file data\n     * or the central directory\n     * @param onUnparseableData what to do if the extra field data\n     * cannot be parsed.\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     *\n     * @since 1.1\n     */\n    public static ZipExtraField[] parse(final byte[] data, final boolean local,\n                                        final UnparseableExtraField onUnparseableData)\n        throws ZipException {\n        final List<ZipExtraField> v = new ArrayList<>();\n        int start = 0;\n        LOOP:\n        while (start <= data.length - WORD) {\n            final ZipShort headerId = new ZipShort(data, start);\n            final int length = new ZipShort(data, start + 2).getValue();\n            if (start + WORD + length > data.length) {\n                switch(onUnparseableData.getKey()) {\n                case UnparseableExtraField.THROW_KEY:\n                    throw new ZipException(\"bad extra field starting at \"\n                                           + start + \".  Block length of \"\n                                           + length + \" bytes exceeds remaining\"\n                                           + \" data of \"\n                                           + (data.length - start - WORD)\n                                           + \" bytes.\");\n                case UnparseableExtraField.READ_KEY:\n                    final UnparseableExtraFieldData field =\n                        new UnparseableExtraFieldData();\n                    if (local) {\n                        field.parseFromLocalFileData(data, start,\n                                                     data.length - start);\n                    } else {\n                        field.parseFromCentralDirectoryData(data, start,\n                                                            data.length - start);\n                    }\n                    v.add(field);\n                    //$FALL-THROUGH$\n                case UnparseableExtraField.SKIP_KEY:\n                    // since we cannot parse the data we must assume\n                    // the extra field consumes the whole rest of the\n                    // available data\n                    break LOOP;\n                default:\n                    throw new ZipException(\"unknown UnparseableExtraField key: \"\n                                           + onUnparseableData.getKey());\n                }\n            }\n            try {\n                final ZipExtraField ze = createExtraField(headerId);\n                if (local) {\n                    ze.parseFromLocalFileData(data, start + WORD, length);\n                } else {\n                    ze.parseFromCentralDirectoryData(data, start + WORD,\n                                                     length);\n                }\n                v.add(ze);\n            } catch (final InstantiationException | IllegalAccessException ie) {\n                throw (ZipException) new ZipException(ie.getMessage()).initCause(ie);\n            }\n            start += length + WORD;\n        }\n\n        final ZipExtraField[] result = new ZipExtraField[v.size()];\n        return v.toArray(result);\n    }\n\n    /**\n     * Merges the local file data fields of the given ZipExtraFields.\n     * @param data an array of ExtraFiles\n     * @return an array of bytes\n     */\n    public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Merges the central directory fields of the given ZipExtraFields.\n     * @param data an array of ExtraFields\n     * @return an array of bytes\n     */\n    public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data) {", "metadata": {"defects4j_task_id": "d7ec20017e914e414a2c1fb96ab3b64e4843ca1bbe3762a1dee0d2834616b0f0", "task_id": "apache_commons-compress/177", "ground_truth": "\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getCentralDirectoryData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getCentralDirectoryData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    ", "fpath_tuple": ["apache_commons-compress", "commons-compress", "src", "main", "java", "org", "apache", "commons", "compress", "archivers", "zip", "ExtraFieldUtils.java"], "context_start_lineno": 0, "function_name": "mergeCentralDirectoryData", "left_context": "class ExtraFieldUtils {\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data as local file data, throwing an exception if the\n     * data cannot be parsed.\n     * @param data an array of bytes as it appears in local file data\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     */\n    public static ZipExtraField[] parse(final byte[] data) throws ZipException {\n        return parse(data, true, UnparseableExtraField.THROW);\n    }\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data, throwing an exception if the data cannot be parsed.\n     * @param data an array of bytes\n     * @param local whether data originates from the local file data\n     * or the central directory\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     */\n    public static ZipExtraField[] parse(final byte[] data, final boolean local)\n        throws ZipException {\n        return parse(data, local, UnparseableExtraField.THROW);\n    }\n\n    /**\n     * Split the array into ExtraFields and populate them with the\n     * given data.\n     * @param data an array of bytes\n     * @param local whether data originates from the local file data\n     * or the central directory\n     * @param onUnparseableData what to do if the extra field data\n     * cannot be parsed.\n     * @return an array of ExtraFields\n     * @throws ZipException on error\n     *\n     * @since 1.1\n     */\n    public static ZipExtraField[] parse(final byte[] data, final boolean local,\n                                        final UnparseableExtraField onUnparseableData)\n        throws ZipException {\n        final List<ZipExtraField> v = new ArrayList<>();\n        int start = 0;\n        LOOP:\n        while (start <= data.length - WORD) {\n            final ZipShort headerId = new ZipShort(data, start);\n            final int length = new ZipShort(data, start + 2).getValue();\n            if (start + WORD + length > data.length) {\n                switch(onUnparseableData.getKey()) {\n                case UnparseableExtraField.THROW_KEY:\n                    throw new ZipException(\"bad extra field starting at \"\n                                           + start + \".  Block length of \"\n                                           + length + \" bytes exceeds remaining\"\n                                           + \" data of \"\n                                           + (data.length - start - WORD)\n                                           + \" bytes.\");\n                case UnparseableExtraField.READ_KEY:\n                    final UnparseableExtraFieldData field =\n                        new UnparseableExtraFieldData();\n                    if (local) {\n                        field.parseFromLocalFileData(data, start,\n                                                     data.length - start);\n                    } else {\n                        field.parseFromCentralDirectoryData(data, start,\n                                                            data.length - start);\n                    }\n                    v.add(field);\n                    //$FALL-THROUGH$\n                case UnparseableExtraField.SKIP_KEY:\n                    // since we cannot parse the data we must assume\n                    // the extra field consumes the whole rest of the\n                    // available data\n                    break LOOP;\n                default:\n                    throw new ZipException(\"unknown UnparseableExtraField key: \"\n                                           + onUnparseableData.getKey());\n                }\n            }\n            try {\n                final ZipExtraField ze = createExtraField(headerId);\n                if (local) {\n                    ze.parseFromLocalFileData(data, start + WORD, length);\n                } else {\n                    ze.parseFromCentralDirectoryData(data, start + WORD,\n                                                     length);\n                }\n                v.add(ze);\n            } catch (final InstantiationException | IllegalAccessException ie) {\n                throw (ZipException) new ZipException(ie.getMessage()).initCause(ie);\n            }\n            start += length + WORD;\n        }\n\n        final ZipExtraField[] result = new ZipExtraField[v.size()];\n        return v.toArray(result);\n    }\n\n    /**\n     * Merges the local file data fields of the given ZipExtraFields.\n     * @param data an array of ExtraFiles\n     * @return an array of bytes\n     */\n    public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Merges the central directory fields of the given ZipExtraFields.\n     * @param data an array of ExtraFields\n     * @return an array of bytes\n     */\n    public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data) {", "right_context": "}\n}", "class_name": "ExtraFieldUtils", "return_type": "byte[]", "parameters": [{"type": "ZipExtraField[]", "name": "data"}]}}
{"prompt": "class ZipEightByteInteger implements Serializable {\n    private static final int BYTE_1 = 1;\n    private static final int BYTE_1_MASK = 0xFF00;\n    private static final int BYTE_1_SHIFT = 8;\n\n    private static final int BYTE_2 = 2;\n    private static final int BYTE_2_MASK = 0xFF0000;\n    private static final int BYTE_2_SHIFT = 16;\n\n    private static final int BYTE_3 = 3;\n    private static final long BYTE_3_MASK = 0xFF000000L;\n    private static final int BYTE_3_SHIFT = 24;\n\n    private static final int BYTE_4 = 4;\n    private static final long BYTE_4_MASK = 0xFF00000000L;\n    private static final int BYTE_4_SHIFT = 32;\n\n    private static final int BYTE_5 = 5;\n    private static final long BYTE_5_MASK = 0xFF0000000000L;\n    private static final int BYTE_5_SHIFT = 40;\n\n    private static final int BYTE_6 = 6;\n    private static final long BYTE_6_MASK = 0xFF000000000000L;\n    private static final int BYTE_6_SHIFT = 48;\n\n    private static final int BYTE_7 = 7;\n    private static final long BYTE_7_MASK = 0x7F00000000000000L;\n    private static final int BYTE_7_SHIFT = 56;\n\n    private static final int LEFTMOST_BIT_SHIFT = 63;\n    private static final byte LEFTMOST_BIT = (byte) 0x80;\n\n    private final BigInteger value;\n\n    public static final ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\n\n    /**\n     * Create instance from a number.\n     * @param value the long to store as a ZipEightByteInteger\n     */\n    public ZipEightByteInteger(final long value) {\n        this(BigInteger.valueOf(value));\n    }\n\n    /**\n     * Create instance from a number.\n     * @param value the BigInteger to store as a ZipEightByteInteger\n     */\n    public ZipEightByteInteger(final BigInteger value) {\n        this.value = value;\n    }\n\n    /**\n     * Create instance from bytes.\n     * @param bytes the bytes to store as a ZipEightByteInteger\n     */\n    public ZipEightByteInteger (final byte[] bytes) {\n        this(bytes, 0);\n    }\n\n    /**\n     * Create instance from the eight bytes starting at offset.\n     * @param bytes the bytes to store as a ZipEightByteInteger\n     * @param offset the offset to start\n     */\n    public ZipEightByteInteger (final byte[] bytes, final int offset) {\n        value = ZipEightByteInteger.getValue(bytes, offset);\n    }\n\n    /**\n     * Get value as eight bytes in big endian byte order.\n     * @return value as eight bytes in big endian order\n     */\n    public byte[] getBytes() {\n        return ZipEightByteInteger.getBytes(value);\n    }\n\n    /**\n     * Get value as Java long.\n     * @return value as a long\n     */\n    public long getLongValue() {\n        return value.longValue();\n    }\n\n    /**\n     * Get value as Java long.\n     * @return value as a long\n     */\n    public BigInteger getValue() {\n        return value;\n    }\n\n    /**\n     * Get value as eight bytes in big endian byte order.\n     * @param value the value to convert\n     * @return value as eight bytes in big endian byte order\n     */\n    public static byte[] getBytes(final long value) {\n        return getBytes(BigInteger.valueOf(value));\n    }\n\n    /**\n     * Get value as eight bytes in big endian byte order.\n     * @param value the value to convert\n     * @return value as eight bytes in big endian byte order\n     */\n    public static byte[] getBytes(final BigInteger value) {", "metadata": {"defects4j_task_id": "18e62d6d17544c534f318615eded30de454b81de393db017e16b92ddb98da154", "task_id": "apache_commons-compress/26", "ground_truth": "\n        final byte[] result = new byte[8];\n        final long val = value.longValue();\n        result[0] = (byte) ((val & BYTE_MASK));\n        result[BYTE_1] = (byte) ((val & BYTE_1_MASK) >> BYTE_1_SHIFT);\n        result[BYTE_2] = (byte) ((val & BYTE_2_MASK) >> BYTE_2_SHIFT);\n        result[BYTE_3] = (byte) ((val & BYTE_3_MASK) >> BYTE_3_SHIFT);\n        result[BYTE_4] = (byte) ((val & BYTE_4_MASK) >> BYTE_4_SHIFT);\n        result[BYTE_5] = (byte) ((val & BYTE_5_MASK) >> BYTE_5_SHIFT);\n        result[BYTE_6] = (byte) ((val & BYTE_6_MASK) >> BYTE_6_SHIFT);\n        result[BYTE_7] = (byte) ((val & BYTE_7_MASK) >> BYTE_7_SHIFT);\n        if (value.testBit(LEFTMOST_BIT_SHIFT)) {\n            result[BYTE_7] |= LEFTMOST_BIT;\n        }\n        return result;\n    ", "fpath_tuple": ["apache_commons-compress", "commons-compress", "src", "main", "java", "org", "apache", "commons", "compress", "archivers", "zip", "ZipEightByteInteger.java"], "context_start_lineno": 0, "function_name": "getBytes", "left_context": "class ZipEightByteInteger implements Serializable {\n    private static final int BYTE_1 = 1;\n    private static final int BYTE_1_MASK = 0xFF00;\n    private static final int BYTE_1_SHIFT = 8;\n\n    private static final int BYTE_2 = 2;\n    private static final int BYTE_2_MASK = 0xFF0000;\n    private static final int BYTE_2_SHIFT = 16;\n\n    private static final int BYTE_3 = 3;\n    private static final long BYTE_3_MASK = 0xFF000000L;\n    private static final int BYTE_3_SHIFT = 24;\n\n    private static final int BYTE_4 = 4;\n    private static final long BYTE_4_MASK = 0xFF00000000L;\n    private static final int BYTE_4_SHIFT = 32;\n\n    private static final int BYTE_5 = 5;\n    private static final long BYTE_5_MASK = 0xFF0000000000L;\n    private static final int BYTE_5_SHIFT = 40;\n\n    private static final int BYTE_6 = 6;\n    private static final long BYTE_6_MASK = 0xFF000000000000L;\n    private static final int BYTE_6_SHIFT = 48;\n\n    private static final int BYTE_7 = 7;\n    private static final long BYTE_7_MASK = 0x7F00000000000000L;\n    private static final int BYTE_7_SHIFT = 56;\n\n    private static final int LEFTMOST_BIT_SHIFT = 63;\n    private static final byte LEFTMOST_BIT = (byte) 0x80;\n\n    private final BigInteger value;\n\n    public static final ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\n\n    /**\n     * Create instance from a number.\n     * @param value the long to store as a ZipEightByteInteger\n     */\n    public ZipEightByteInteger(final long value) {\n        this(BigInteger.valueOf(value));\n    }\n\n    /**\n     * Create instance from a number.\n     * @param value the BigInteger to store as a ZipEightByteInteger\n     */\n    public ZipEightByteInteger(final BigInteger value) {\n        this.value = value;\n    }\n\n    /**\n     * Create instance from bytes.\n     * @param bytes the bytes to store as a ZipEightByteInteger\n     */\n    public ZipEightByteInteger (final byte[] bytes) {\n        this(bytes, 0);\n    }\n\n    /**\n     * Create instance from the eight bytes starting at offset.\n     * @param bytes the bytes to store as a ZipEightByteInteger\n     * @param offset the offset to start\n     */\n    public ZipEightByteInteger (final byte[] bytes, final int offset) {\n        value = ZipEightByteInteger.getValue(bytes, offset);\n    }\n\n    /**\n     * Get value as eight bytes in big endian byte order.\n     * @return value as eight bytes in big endian order\n     */\n    public byte[] getBytes() {\n        return ZipEightByteInteger.getBytes(value);\n    }\n\n    /**\n     * Get value as Java long.\n     * @return value as a long\n     */\n    public long getLongValue() {\n        return value.longValue();\n    }\n\n    /**\n     * Get value as Java long.\n     * @return value as a long\n     */\n    public BigInteger getValue() {\n        return value;\n    }\n\n    /**\n     * Get value as eight bytes in big endian byte order.\n     * @param value the value to convert\n     * @return value as eight bytes in big endian byte order\n     */\n    public static byte[] getBytes(final long value) {\n        return getBytes(BigInteger.valueOf(value));\n    }\n\n    /**\n     * Get value as eight bytes in big endian byte order.\n     * @param value the value to convert\n     * @return value as eight bytes in big endian byte order\n     */\n    public static byte[] getBytes(final BigInteger value) {", "right_context": "}\n}", "class_name": "ZipEightByteInteger", "return_type": "byte[]", "parameters": [{"type": "BigInteger", "name": "value"}]}}
{"prompt": "class ZipArchiveInputStream extends ArchiveInputStream {\n\n    @Override\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                in.close();\n            } finally {\n                inf.end();\n            }\n        }\n    }\n\n    /**\n     * Skips over and discards value bytes of data from this input\n     * stream.\n     *\n     * <p>This implementation may end up skipping over some smaller\n     * number of bytes, possibly 0, if and only if it reaches the end\n     * of the underlying stream.</p>\n     *\n     * <p>The actual number of bytes skipped is returned.</p>\n     *\n     * @param value the number of bytes to be skipped.\n     * @return the actual number of bytes skipped.\n     * @throws IOException - if an I/O error occurs.\n     * @throws IllegalArgumentException - if value is negative.\n     */\n    @Override\n    public long skip(final long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /**\n     * Checks if the signature matches what is expected for a zip file.\n     * Does not currently handle self-extracting zips which may have arbitrary\n     * leading content.\n     *\n     * @param signature the bytes to check\n     * @param length    the number of bytes to check\n     * @return true, if this stream is a zip archive stream, false otherwise\n     */\n    public static boolean matches(final byte[] signature, final int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) // empty zip\n            || checksig(signature, ZipArchiveOutputStream.DD_SIG) // split zip\n            || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n    }\n\n    private static boolean checksig(final byte[] signature, final byte[] expected) {\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Closes the current ZIP archive entry and positions the underlying\n     * stream to the beginning of the next entry. All per-entry variables\n     * and data structures are cleared.\n     * <p>\n     * If the compressed size of this entry is included in the entry header,\n     * then any outstanding bytes are simply skipped from the underlying\n     * stream without uncompressing them. This allows an entry to be safely\n     * closed even if the compression method is unsupported.\n     * <p>\n     * In case we don't know the compressed size of this entry or have\n     * already buffered too much data from the underlying stream to support\n     * uncompression, then the uncompression process is completed and the\n     * end position of the stream is adjusted based on the result of that\n     * process.\n     *\n     * @throws IOException if an error occurs\n     */\n    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n\n        // Ensure all entry bytes are read\n        if (currentEntryHasOutstandingBytes()) {\n            drainCurrentEntryData();\n        } else {\n            // this is guaranteed to exhaust the stream\n            skip(Long.MAX_VALUE); //NOSONAR\n\n            final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                       ? getBytesInflated() : current.bytesRead;\n\n            // this is at most a single read() operation and can't\n            // exceed the range of int\n            final int diff = (int) (current.bytesReadFromStream - inB);\n\n            // Pushback any required bytes\n            if (diff > 0) {\n                pushback(buf.array(), buf.limit() - diff, diff);\n                current.bytesReadFromStream -= diff;\n            }\n\n            // Drain remainder of entry if not all data bytes were required\n            if (currentEntryHasOutstandingBytes()) {\n                drainCurrentEntryData();\n            }\n        }\n\n        if (lastStoredEntry == null && current.hasDataDescriptor) {\n            readDataDescriptor();\n        }\n\n        inf.reset();\n        buf.clear().flip();\n        current = null;\n        lastStoredEntry = null;\n    }\n\n    /**\n     * If the compressed size of the current entry is included in the entry header\n     * and there are any outstanding bytes in the underlying stream, then\n     * this returns true.\n     *\n     * @return true, if current entry is determined to have outstanding bytes, false otherwise\n     */\n    private boolean currentEntryHasOutstandingBytes() {\n        return current.bytesReadFromStream <= current.entry.getCompressedSize()\n                && !current.hasDataDescriptor;\n    }\n\n    /**\n     * Read all data of the current entry from the underlying stream\n     * that hasn't been read, yet.\n     */\n    private void drainCurrentEntryData() throws IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n            final long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n            if (n < 0) {\n                throw new EOFException(\"Truncated ZIP entry: \"\n                                       + ArchiveUtils.sanitize(current.entry.getName()));\n            }\n            count(n);\n            remaining -= n;\n        }\n    }\n\n    /**\n     * Get the number of bytes Inflater has actually processed.\n     *\n     * <p>for Java &lt; Java7 the getBytes* methods in\n     * Inflater/Deflater seem to return unsigned ints rather than\n     * longs that start over with 0 at 2^32.</p>\n     *\n     * <p>The stream knows how many bytes it has read, but not how\n     * many the Inflater actually consumed - it should be between the\n     * total number of bytes read for the entry and the total number\n     * minus the last read operation.  Here we just try to make the\n     * value close enough to the bytes we've read by assuming the\n     * number of bytes consumed must be smaller than (or equal to) the\n     * number of bytes read but not smaller by more than 2^32.</p>\n     */\n    private long getBytesInflated() {", "metadata": {"defects4j_task_id": "6470af74ff00ece11fb1f8cd2a577a6079acd380812737324225afe3b3717a14", "task_id": "apache_commons-compress/86", "ground_truth": "\n        long inB = inf.getBytesRead();\n        if (current.bytesReadFromStream >= TWO_EXP_32) {\n            while (inB + TWO_EXP_32 <= current.bytesReadFromStream) {\n                inB += TWO_EXP_32;\n            }\n        }\n        return inB;\n    ", "fpath_tuple": ["apache_commons-compress", "commons-compress", "src", "main", "java", "org", "apache", "commons", "compress", "archivers", "zip", "ZipArchiveInputStream.java"], "context_start_lineno": 0, "function_name": "getBytesInflated", "left_context": "class ZipArchiveInputStream extends ArchiveInputStream {\n\n    @Override\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                in.close();\n            } finally {\n                inf.end();\n            }\n        }\n    }\n\n    /**\n     * Skips over and discards value bytes of data from this input\n     * stream.\n     *\n     * <p>This implementation may end up skipping over some smaller\n     * number of bytes, possibly 0, if and only if it reaches the end\n     * of the underlying stream.</p>\n     *\n     * <p>The actual number of bytes skipped is returned.</p>\n     *\n     * @param value the number of bytes to be skipped.\n     * @return the actual number of bytes skipped.\n     * @throws IOException - if an I/O error occurs.\n     * @throws IllegalArgumentException - if value is negative.\n     */\n    @Override\n    public long skip(final long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /**\n     * Checks if the signature matches what is expected for a zip file.\n     * Does not currently handle self-extracting zips which may have arbitrary\n     * leading content.\n     *\n     * @param signature the bytes to check\n     * @param length    the number of bytes to check\n     * @return true, if this stream is a zip archive stream, false otherwise\n     */\n    public static boolean matches(final byte[] signature, final int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) // empty zip\n            || checksig(signature, ZipArchiveOutputStream.DD_SIG) // split zip\n            || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n    }\n\n    private static boolean checksig(final byte[] signature, final byte[] expected) {\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Closes the current ZIP archive entry and positions the underlying\n     * stream to the beginning of the next entry. All per-entry variables\n     * and data structures are cleared.\n     * <p>\n     * If the compressed size of this entry is included in the entry header,\n     * then any outstanding bytes are simply skipped from the underlying\n     * stream without uncompressing them. This allows an entry to be safely\n     * closed even if the compression method is unsupported.\n     * <p>\n     * In case we don't know the compressed size of this entry or have\n     * already buffered too much data from the underlying stream to support\n     * uncompression, then the uncompression process is completed and the\n     * end position of the stream is adjusted based on the result of that\n     * process.\n     *\n     * @throws IOException if an error occurs\n     */\n    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n\n        // Ensure all entry bytes are read\n        if (currentEntryHasOutstandingBytes()) {\n            drainCurrentEntryData();\n        } else {\n            // this is guaranteed to exhaust the stream\n            skip(Long.MAX_VALUE); //NOSONAR\n\n            final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                       ? getBytesInflated() : current.bytesRead;\n\n            // this is at most a single read() operation and can't\n            // exceed the range of int\n            final int diff = (int) (current.bytesReadFromStream - inB);\n\n            // Pushback any required bytes\n            if (diff > 0) {\n                pushback(buf.array(), buf.limit() - diff, diff);\n                current.bytesReadFromStream -= diff;\n            }\n\n            // Drain remainder of entry if not all data bytes were required\n            if (currentEntryHasOutstandingBytes()) {\n                drainCurrentEntryData();\n            }\n        }\n\n        if (lastStoredEntry == null && current.hasDataDescriptor) {\n            readDataDescriptor();\n        }\n\n        inf.reset();\n        buf.clear().flip();\n        current = null;\n        lastStoredEntry = null;\n    }\n\n    /**\n     * If the compressed size of the current entry is included in the entry header\n     * and there are any outstanding bytes in the underlying stream, then\n     * this returns true.\n     *\n     * @return true, if current entry is determined to have outstanding bytes, false otherwise\n     */\n    private boolean currentEntryHasOutstandingBytes() {\n        return current.bytesReadFromStream <= current.entry.getCompressedSize()\n                && !current.hasDataDescriptor;\n    }\n\n    /**\n     * Read all data of the current entry from the underlying stream\n     * that hasn't been read, yet.\n     */\n    private void drainCurrentEntryData() throws IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n            final long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n            if (n < 0) {\n                throw new EOFException(\"Truncated ZIP entry: \"\n                                       + ArchiveUtils.sanitize(current.entry.getName()));\n            }\n            count(n);\n            remaining -= n;\n        }\n    }\n\n    /**\n     * Get the number of bytes Inflater has actually processed.\n     *\n     * <p>for Java &lt; Java7 the getBytes* methods in\n     * Inflater/Deflater seem to return unsigned ints rather than\n     * longs that start over with 0 at 2^32.</p>\n     *\n     * <p>The stream knows how many bytes it has read, but not how\n     * many the Inflater actually consumed - it should be between the\n     * total number of bytes read for the entry and the total number\n     * minus the last read operation.  Here we just try to make the\n     * value close enough to the bytes we've read by assuming the\n     * number of bytes consumed must be smaller than (or equal to) the\n     * number of bytes read but not smaller by more than 2^32.</p>\n     */\n    private long getBytesInflated() {", "right_context": "}\n}", "class_name": "ZipArchiveInputStream", "return_type": "long", "parameters": []}}
{"prompt": "class ZipArchiveInputStream extends ArchiveInputStream {\n\n    private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\n    private static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\n    private static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n    /**\n     * Checks whether the current buffer contains the signature of a\n     * &quot;data descriptor&quot;, &quot;local file header&quot; or\n     * &quot;central directory entry&quot;.\n     *\n     * <p>If it contains such a signature, reads the data descriptor\n     * and positions the stream right after the data descriptor.</p>\n     */\n    private boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen)\n            throws IOException {\n\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; !done && i < lastRead - 4; i++) {\n            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                    // found a LFH or CFH:\n                    readTooMuch = offset + lastRead - i - expectedDDLen;\n                    done = true;\n                }\n                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                    // found DD:\n                    readTooMuch = offset + lastRead - i;\n                    done = true;\n                }\n                if (done) {\n                    // * push back bytes read in excess as well as the data\n                    //   descriptor\n                    // * copy the remaining bytes to cache\n                    // * read data descriptor\n                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n                    bos.write(buf.array(), 0, i);\n                    readDataDescriptor();\n                }\n            }\n        }\n        return done;\n    }\n\n    /**\n     * If the last read bytes could hold a data descriptor and an\n     * incomplete signature then save the last bytes to the front of\n     * the buffer and cache everything in front of the potential data\n     * descriptor into the given ByteArrayOutputStream.\n     *\n     * <p>Data descriptor plus incomplete signature (3 bytes in the\n     * worst case) can be 20 bytes max.</p>\n     */\n    private int cacheBytesRead(final ByteArrayOutputStream bos, int offset, final int lastRead, final int expecteDDLen) {\n        final int cacheable = offset + lastRead - expecteDDLen - 3;\n        if (cacheable > 0) {\n            bos.write(buf.array(), 0, cacheable);\n            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n            offset = expecteDDLen + 3;\n        } else {\n            offset += lastRead;\n        }\n        return offset;\n    }\n\n    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n        ((PushbackInputStream) in).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }\n\n    // End of Central Directory Record\n    //   end of central dir signature    WORD\n    //   number of this disk             SHORT\n    //   number of the disk with the\n    //   start of the central directory  SHORT\n    //   total number of entries in the\n    //   central directory on this disk  SHORT\n    //   total number of entries in\n    //   the central directory           SHORT\n    //   size of the central directory   WORD\n    //   offset of start of central\n    //   directory with respect to\n    //   the starting disk number        WORD\n    //   .ZIP file comment length        SHORT\n    //   .ZIP file comment               up to 64KB\n    //\n\n    /**\n     * Reads the stream until it find the \"End of central directory\n     * record\" and consumes it as well.\n     */\n    private void skipRemainderOfArchive() throws IOException {\n        // skip over central directory. One LFH has been read too much\n        // already.  The calculation discounts file names and extra\n        // data so it will be too short.\n        realSkip((long) entriesRead * CFH_LEN - LFH_LEN);\n        findEocdRecord();\n        realSkip((long) ZipFile.MIN_EOCD_SIZE - WORD /* signature */ - SHORT /* comment len */);\n        readFully(shortBuf);\n        // file comment\n        realSkip(ZipShort.getValue(shortBuf));\n    }\n\n    /**\n     * Reads forward until the signature of the &quot;End of central\n     * directory&quot; record is found.\n     */\n    private void findEocdRecord() throws IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte == -1\n                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n                break;\n            }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        }\n    }\n\n    /**\n     * Skips bytes by reading from the underlying stream rather than\n     * the (potentially inflating) archive stream - which {@link\n     * #skip} would do.\n     *\n     * Also updates bytes-read counter.\n     */\n    private void realSkip(final long value) throws IOException {", "metadata": {"defects4j_task_id": "b995b47040a1058fe82df683e15e0b96996637d8f985cb8d8d366da1dd02d580", "task_id": "apache_commons-compress/156", "ground_truth": "\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                if (x == -1) {\n                    return;\n                }\n                count(x);\n                skipped += x;\n            }\n            return;\n        }\n        throw new IllegalArgumentException();\n    ", "fpath_tuple": ["apache_commons-compress", "commons-compress", "src", "main", "java", "org", "apache", "commons", "compress", "archivers", "zip", "ZipArchiveInputStream.java"], "context_start_lineno": 0, "function_name": "realSkip", "left_context": "class ZipArchiveInputStream extends ArchiveInputStream {\n\n    private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\n    private static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\n    private static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n    /**\n     * Checks whether the current buffer contains the signature of a\n     * &quot;data descriptor&quot;, &quot;local file header&quot; or\n     * &quot;central directory entry&quot;.\n     *\n     * <p>If it contains such a signature, reads the data descriptor\n     * and positions the stream right after the data descriptor.</p>\n     */\n    private boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen)\n            throws IOException {\n\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; !done && i < lastRead - 4; i++) {\n            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                    // found a LFH or CFH:\n                    readTooMuch = offset + lastRead - i - expectedDDLen;\n                    done = true;\n                }\n                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                    // found DD:\n                    readTooMuch = offset + lastRead - i;\n                    done = true;\n                }\n                if (done) {\n                    // * push back bytes read in excess as well as the data\n                    //   descriptor\n                    // * copy the remaining bytes to cache\n                    // * read data descriptor\n                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n                    bos.write(buf.array(), 0, i);\n                    readDataDescriptor();\n                }\n            }\n        }\n        return done;\n    }\n\n    /**\n     * If the last read bytes could hold a data descriptor and an\n     * incomplete signature then save the last bytes to the front of\n     * the buffer and cache everything in front of the potential data\n     * descriptor into the given ByteArrayOutputStream.\n     *\n     * <p>Data descriptor plus incomplete signature (3 bytes in the\n     * worst case) can be 20 bytes max.</p>\n     */\n    private int cacheBytesRead(final ByteArrayOutputStream bos, int offset, final int lastRead, final int expecteDDLen) {\n        final int cacheable = offset + lastRead - expecteDDLen - 3;\n        if (cacheable > 0) {\n            bos.write(buf.array(), 0, cacheable);\n            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n            offset = expecteDDLen + 3;\n        } else {\n            offset += lastRead;\n        }\n        return offset;\n    }\n\n    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n        ((PushbackInputStream) in).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }\n\n    // End of Central Directory Record\n    //   end of central dir signature    WORD\n    //   number of this disk             SHORT\n    //   number of the disk with the\n    //   start of the central directory  SHORT\n    //   total number of entries in the\n    //   central directory on this disk  SHORT\n    //   total number of entries in\n    //   the central directory           SHORT\n    //   size of the central directory   WORD\n    //   offset of start of central\n    //   directory with respect to\n    //   the starting disk number        WORD\n    //   .ZIP file comment length        SHORT\n    //   .ZIP file comment               up to 64KB\n    //\n\n    /**\n     * Reads the stream until it find the \"End of central directory\n     * record\" and consumes it as well.\n     */\n    private void skipRemainderOfArchive() throws IOException {\n        // skip over central directory. One LFH has been read too much\n        // already.  The calculation discounts file names and extra\n        // data so it will be too short.\n        realSkip((long) entriesRead * CFH_LEN - LFH_LEN);\n        findEocdRecord();\n        realSkip((long) ZipFile.MIN_EOCD_SIZE - WORD /* signature */ - SHORT /* comment len */);\n        readFully(shortBuf);\n        // file comment\n        realSkip(ZipShort.getValue(shortBuf));\n    }\n\n    /**\n     * Reads forward until the signature of the &quot;End of central\n     * directory&quot; record is found.\n     */\n    private void findEocdRecord() throws IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte == -1\n                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n                break;\n            }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        }\n    }\n\n    /**\n     * Skips bytes by reading from the underlying stream rather than\n     * the (potentially inflating) archive stream - which {@link\n     * #skip} would do.\n     *\n     * Also updates bytes-read counter.\n     */\n    private void realSkip(final long value) throws IOException {", "right_context": "}\n}", "class_name": "ZipArchiveInputStream", "return_type": "void", "parameters": [{"type": "long", "name": "value"}]}}
{"prompt": "class ZipFile implements Closeable {\n    private final byte[] shortBuf = new byte[SHORT];\n    private final ByteBuffer dwordBbuf = ByteBuffer.wrap(dwordBuf);\n    private final ByteBuffer wordBbuf = ByteBuffer.wrap(wordBuf);\n    private final ByteBuffer cfhBbuf = ByteBuffer.wrap(cfhBuf);\n\n    /**\n     * Opens the given file for reading, assuming \"UTF8\" for file names.\n     *\n     * @param f the archive.\n     *\n     * @throws IOException if an error occurs while reading the file.\n     */\n    public ZipFile(final File f) throws IOException {\n        this(f, ZipEncodingHelper.UTF8);\n    }\n\n    /**\n     * Opens the given file for reading, assuming \"UTF8\".\n     *\n     * @param name name of the archive.\n     *\n     * @throws IOException if an error occurs while reading the file.\n     */\n    public ZipFile(final String name) throws IOException {\n        this(new File(name), ZipEncodingHelper.UTF8);\n    }\n\n    /**\n     * Opens the given file for reading, assuming the specified\n     * encoding for file names, scanning unicode extra fields.\n     *\n     * @param name name of the archive.\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     *\n     * @throws IOException if an error occurs while reading the file.\n     */\n    public ZipFile(final String name, final String encoding) throws IOException {\n        this(new File(name), encoding, true);\n    }\n\n    /**\n     * Opens the given file for reading, assuming the specified\n     * encoding for file names and scanning for unicode extra fields.\n     *\n     * @param f the archive.\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     *\n     * @throws IOException if an error occurs while reading the file.\n     */\n    public ZipFile(final File f, final String encoding) throws IOException {\n        this(f, encoding, true);\n    }\n\n    /**\n     * Opens the given file for reading, assuming the specified\n     * encoding for file names.\n     *\n     * @param f the archive.\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     *\n     * @throws IOException if an error occurs while reading the file.\n     */\n    public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\n        throws IOException {\n        this(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),\n             f.getAbsolutePath(), encoding, useUnicodeExtraFields, true);\n    }\n\n    /**\n     * Opens the given channel for reading, assuming \"UTF8\" for file names.\n     *\n     * <p>{@link\n     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n     * allows you to read from an in-memory archive.</p>\n     *\n     * @param channel the archive.\n     *\n     * @throws IOException if an error occurs while reading the file.\n     * @since 1.13\n     */\n    public ZipFile(final SeekableByteChannel channel)\n            throws IOException {\n        this(channel, \"unknown archive\", ZipEncodingHelper.UTF8, true);\n    }\n\n    /**\n     * Opens the given channel for reading, assuming the specified\n     * encoding for file names.\n     *\n     * <p>{@link\n     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n     * allows you to read from an in-memory archive.</p>\n     *\n     * @param channel the archive.\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     *\n     * @throws IOException if an error occurs while reading the file.\n     * @since 1.13\n     */\n    public ZipFile(final SeekableByteChannel channel, final String encoding)\n        throws IOException {\n        this(channel, \"unknown archive\", encoding, true);\n    }\n\n    /**\n     * Opens the given channel for reading, assuming the specified\n     * encoding for file names.\n     *\n     * <p>{@link\n     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n     * allows you to read from an in-memory archive.</p>\n     *\n     * @param channel the archive.\n     * @param archiveName name of the archive, used for error messages only.\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     *\n     * @throws IOException if an error occurs while reading the file.\n     * @since 1.13\n     */\n    public ZipFile(final SeekableByteChannel channel, final String archiveName,\n                   final String encoding, final boolean useUnicodeExtraFields)\n        throws IOException {\n        this(channel, archiveName, encoding, useUnicodeExtraFields, false);\n    }\n\n    private ZipFile(final SeekableByteChannel channel, final String archiveName,\n                    final String encoding, final boolean useUnicodeExtraFields,\n                    final boolean closeOnError)\n        throws IOException {\n        this.archiveName = archiveName;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        archive = channel;\n        boolean success = false;\n        try {\n            final Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\n                populateFromCentralDirectory();\n            resolveLocalFileHeaderData(entriesWithoutUTF8Flag);\n            success = true;\n        } finally {\n            closed = !success;\n            if (!success && closeOnError) {\n                IOUtils.closeQuietly(archive);\n            }\n        }\n    }\n\n    /**\n     * The encoding to use for filenames and the file comment.\n     *\n     * @return null if using the platform's default character encoding.\n     */\n    public String getEncoding() {\n        return encoding;\n    }\n\n    /**\n     * Closes the archive.\n     * @throws IOException if an error occurs closing the archive.\n     */\n    @Override\n    public void close() throws IOException {\n        // this flag is only written here and read in finalize() which\n        // can never be run in parallel.\n        // no synchronization needed.\n        closed = true;\n\n        archive.close();\n    }\n\n    /**\n     * close a zipfile quietly; throw no io fault, do nothing\n     * on a null parameter\n     * @param zipfile file to close, can be null\n     */\n    public static void closeQuietly(final ZipFile zipfile) {\n        IOUtils.closeQuietly(zipfile);\n    }\n\n    /**\n     * Returns all entries.\n     *\n     * <p>Entries will be returned in the same order they appear\n     * within the archive's central directory.</p>\n     *\n     * @return all entries as {@link ZipArchiveEntry} instances\n     */\n    public Enumeration<ZipArchiveEntry> getEntries() {\n        return Collections.enumeration(entries);\n    }\n\n    /**\n     * Returns all entries in physical order.\n     *\n     * <p>Entries will be returned in the same order their contents\n     * appear within the archive.</p>\n     *\n     * @return all entries as {@link ZipArchiveEntry} instances\n     *\n     * @since 1.1\n     */\n    public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {", "metadata": {"defects4j_task_id": "6f890d2a8803a60029ce3bc7f8cdb37b3efa223be58ccea1429d0b7f76e9971c", "task_id": "apache_commons-compress/94", "ground_truth": "\n        final ZipArchiveEntry[] allEntries = entries.toArray(new ZipArchiveEntry[entries.size()]);\n        Arrays.sort(allEntries, offsetComparator);\n        return Collections.enumeration(Arrays.asList(allEntries));\n    ", "fpath_tuple": ["apache_commons-compress", "commons-compress", "src", "main", "java", "org", "apache", "commons", "compress", "archivers", "zip", "ZipFile.java"], "context_start_lineno": 0, "function_name": "getEntriesInPhysicalOrder", "left_context": "class ZipFile implements Closeable {\n    private final byte[] shortBuf = new byte[SHORT];\n    private final ByteBuffer dwordBbuf = ByteBuffer.wrap(dwordBuf);\n    private final ByteBuffer wordBbuf = ByteBuffer.wrap(wordBuf);\n    private final ByteBuffer cfhBbuf = ByteBuffer.wrap(cfhBuf);\n\n    /**\n     * Opens the given file for reading, assuming \"UTF8\" for file names.\n     *\n     * @param f the archive.\n     *\n     * @throws IOException if an error occurs while reading the file.\n     */\n    public ZipFile(final File f) throws IOException {\n        this(f, ZipEncodingHelper.UTF8);\n    }\n\n    /**\n     * Opens the given file for reading, assuming \"UTF8\".\n     *\n     * @param name name of the archive.\n     *\n     * @throws IOException if an error occurs while reading the file.\n     */\n    public ZipFile(final String name) throws IOException {\n        this(new File(name), ZipEncodingHelper.UTF8);\n    }\n\n    /**\n     * Opens the given file for reading, assuming the specified\n     * encoding for file names, scanning unicode extra fields.\n     *\n     * @param name name of the archive.\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     *\n     * @throws IOException if an error occurs while reading the file.\n     */\n    public ZipFile(final String name, final String encoding) throws IOException {\n        this(new File(name), encoding, true);\n    }\n\n    /**\n     * Opens the given file for reading, assuming the specified\n     * encoding for file names and scanning for unicode extra fields.\n     *\n     * @param f the archive.\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     *\n     * @throws IOException if an error occurs while reading the file.\n     */\n    public ZipFile(final File f, final String encoding) throws IOException {\n        this(f, encoding, true);\n    }\n\n    /**\n     * Opens the given file for reading, assuming the specified\n     * encoding for file names.\n     *\n     * @param f the archive.\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     *\n     * @throws IOException if an error occurs while reading the file.\n     */\n    public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\n        throws IOException {\n        this(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),\n             f.getAbsolutePath(), encoding, useUnicodeExtraFields, true);\n    }\n\n    /**\n     * Opens the given channel for reading, assuming \"UTF8\" for file names.\n     *\n     * <p>{@link\n     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n     * allows you to read from an in-memory archive.</p>\n     *\n     * @param channel the archive.\n     *\n     * @throws IOException if an error occurs while reading the file.\n     * @since 1.13\n     */\n    public ZipFile(final SeekableByteChannel channel)\n            throws IOException {\n        this(channel, \"unknown archive\", ZipEncodingHelper.UTF8, true);\n    }\n\n    /**\n     * Opens the given channel for reading, assuming the specified\n     * encoding for file names.\n     *\n     * <p>{@link\n     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n     * allows you to read from an in-memory archive.</p>\n     *\n     * @param channel the archive.\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     *\n     * @throws IOException if an error occurs while reading the file.\n     * @since 1.13\n     */\n    public ZipFile(final SeekableByteChannel channel, final String encoding)\n        throws IOException {\n        this(channel, \"unknown archive\", encoding, true);\n    }\n\n    /**\n     * Opens the given channel for reading, assuming the specified\n     * encoding for file names.\n     *\n     * <p>{@link\n     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n     * allows you to read from an in-memory archive.</p>\n     *\n     * @param channel the archive.\n     * @param archiveName name of the archive, used for error messages only.\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     *\n     * @throws IOException if an error occurs while reading the file.\n     * @since 1.13\n     */\n    public ZipFile(final SeekableByteChannel channel, final String archiveName,\n                   final String encoding, final boolean useUnicodeExtraFields)\n        throws IOException {\n        this(channel, archiveName, encoding, useUnicodeExtraFields, false);\n    }\n\n    private ZipFile(final SeekableByteChannel channel, final String archiveName,\n                    final String encoding, final boolean useUnicodeExtraFields,\n                    final boolean closeOnError)\n        throws IOException {\n        this.archiveName = archiveName;\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        archive = channel;\n        boolean success = false;\n        try {\n            final Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\n                populateFromCentralDirectory();\n            resolveLocalFileHeaderData(entriesWithoutUTF8Flag);\n            success = true;\n        } finally {\n            closed = !success;\n            if (!success && closeOnError) {\n                IOUtils.closeQuietly(archive);\n            }\n        }\n    }\n\n    /**\n     * The encoding to use for filenames and the file comment.\n     *\n     * @return null if using the platform's default character encoding.\n     */\n    public String getEncoding() {\n        return encoding;\n    }\n\n    /**\n     * Closes the archive.\n     * @throws IOException if an error occurs closing the archive.\n     */\n    @Override\n    public void close() throws IOException {\n        // this flag is only written here and read in finalize() which\n        // can never be run in parallel.\n        // no synchronization needed.\n        closed = true;\n\n        archive.close();\n    }\n\n    /**\n     * close a zipfile quietly; throw no io fault, do nothing\n     * on a null parameter\n     * @param zipfile file to close, can be null\n     */\n    public static void closeQuietly(final ZipFile zipfile) {\n        IOUtils.closeQuietly(zipfile);\n    }\n\n    /**\n     * Returns all entries.\n     *\n     * <p>Entries will be returned in the same order they appear\n     * within the archive's central directory.</p>\n     *\n     * @return all entries as {@link ZipArchiveEntry} instances\n     */\n    public Enumeration<ZipArchiveEntry> getEntries() {\n        return Collections.enumeration(entries);\n    }\n\n    /**\n     * Returns all entries in physical order.\n     *\n     * <p>Entries will be returned in the same order their contents\n     * appear within the archive.</p>\n     *\n     * @return all entries as {@link ZipArchiveEntry} instances\n     *\n     * @since 1.1\n     */\n    public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {", "right_context": "}\n}", "class_name": "ZipFile", "return_type": "Enumeration<ZipArchiveEntry>", "parameters": []}}
{"prompt": "class ZipFile implements Closeable {\n    /**\n     * Length of the \"Zip64 end of central directory locator\" - which\n     * should be right in front of the \"end of central directory\n     * record\" if one is present at all.\n     */\n    private static final int ZIP64_EOCDL_LENGTH =\n        /* zip64 end of central dir locator sig */ WORD\n        /* number of the disk with the start    */\n        /* start of the zip64 end of            */\n        /* central directory                    */ + WORD\n        /* relative offset of the zip64         */\n        /* end of central directory record      */ + DWORD\n        /* total number of disks                */ + WORD;\n\n    /**\n     * Offset of the field that holds the location of the \"Zip64 end\n     * of central directory record\" inside the \"Zip64 end of central\n     * directory locator\" relative to the start of the \"Zip64 end of\n     * central directory locator\".\n     */\n    private static final int ZIP64_EOCDL_LOCATOR_OFFSET =\n        /* zip64 end of central dir locator sig */ WORD\n        /* number of the disk with the start    */\n        /* start of the zip64 end of            */\n        /* central directory                    */ + WORD;\n\n    /**\n     * Offset of the field that holds the location of the first\n     * central directory entry inside the \"Zip64 end of central\n     * directory record\" relative to the start of the \"Zip64 end of\n     * central directory record\".\n     */\n    private static final int ZIP64_EOCD_CFD_LOCATOR_OFFSET =\n        /* zip64 end of central dir        */\n        /* signature                       */ WORD\n        /* size of zip64 end of central    */\n        /* directory record                */ + DWORD\n        /* version made by                 */ + SHORT\n        /* version needed to extract       */ + SHORT\n        /* number of this disk             */ + WORD\n        /* number of the disk with the     */\n        /* start of the central directory  */ + WORD\n        /* total number of entries in the  */\n        /* central directory on this disk  */ + DWORD\n        /* total number of entries in the  */\n        /* central directory               */ + DWORD\n        /* size of the central directory   */ + DWORD;\n\n    /**\n     * Searches for either the &quot;Zip64 end of central directory\n     * locator&quot; or the &quot;End of central dir record&quot;, parses\n     * it and positions the stream at the first central directory\n     * record.\n     */\n    private void positionAtCentralDirectory()\n        throws IOException {\n        positionAtEndOfCentralDirectoryRecord();\n        boolean found = false;\n        final boolean searchedForZip64EOCD =\n            archive.position() > ZIP64_EOCDL_LENGTH;\n        if (searchedForZip64EOCD) {\n            archive.position(archive.position() - ZIP64_EOCDL_LENGTH);\n            wordBbuf.rewind();\n            IOUtils.readFully(archive, wordBbuf);\n            found = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\n                                  wordBuf);\n        }\n        if (!found) {\n            // not a ZIP64 archive\n            if (searchedForZip64EOCD) {\n                skipBytes(ZIP64_EOCDL_LENGTH - WORD);\n            }\n            positionAtCentralDirectory32();\n        } else {\n            positionAtCentralDirectory64();\n        }\n    }\n\n    /**\n     * Parses the &quot;Zip64 end of central directory locator&quot;,\n     * finds the &quot;Zip64 end of central directory record&quot; using the\n     * parsed information, parses that and positions the stream at the\n     * first central directory record.\n     *\n     * Expects stream to be positioned right behind the &quot;Zip64\n     * end of central directory locator&quot;'s signature.\n     */\n    private void positionAtCentralDirectory64()\n        throws IOException {\n        skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET\n                  - WORD /* signature has already been read */);\n        dwordBbuf.rewind();\n        IOUtils.readFully(archive, dwordBbuf);\n        archive.position(ZipEightByteInteger.getLongValue(dwordBuf));\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (!Arrays.equals(wordBuf, ZipArchiveOutputStream.ZIP64_EOCD_SIG)) {\n            throw new ZipException(\"archive's ZIP64 end of central \"\n                                   + \"directory locator is corrupt.\");\n        }\n        skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n                  - WORD /* signature has already been read */);\n        dwordBbuf.rewind();\n        IOUtils.readFully(archive, dwordBbuf);\n        archive.position(ZipEightByteInteger.getLongValue(dwordBuf));\n    }\n\n    /**\n     * Parses the &quot;End of central dir record&quot; and positions\n     * the stream at the first central directory record.\n     *\n     * Expects stream to be positioned at the beginning of the\n     * &quot;End of central dir record&quot;.\n     */\n    private void positionAtCentralDirectory32()\n        throws IOException {\n        skipBytes(CFD_LOCATOR_OFFSET);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        archive.position(ZipLong.getValue(wordBuf));\n    }\n\n    /**\n     * Searches for the and positions the stream at the start of the\n     * &quot;End of central dir record&quot;.\n     */\n    private void positionAtEndOfCentralDirectoryRecord()\n        throws IOException {\n        final boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\n                                             ZipArchiveOutputStream.EOCD_SIG);\n        if (!found) {\n            throw new ZipException(\"archive is not a ZIP archive\");\n        }\n    }\n\n    /**\n     * Searches the archive backwards from minDistance to maxDistance\n     * for the given signature, positions the RandomaccessFile right\n     * at the signature if it has been found.\n     */\n    private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException {", "metadata": {"defects4j_task_id": "c4467bf08d4eec31a94b22aea76f7279745a070599f5b2413cf8fed37c3f9929", "task_id": "apache_commons-compress/159", "ground_truth": "\n        boolean found = false;\n        long off = archive.size() - minDistanceFromEnd;\n        final long stopSearching =\n            Math.max(0L, archive.size() - maxDistanceFromEnd);\n        if (off >= 0) {\n            for (; off >= stopSearching; off--) {\n                archive.position(off);\n                try {\n                    wordBbuf.rewind();\n                    IOUtils.readFully(archive, wordBbuf);\n                    wordBbuf.flip();\n                } catch (EOFException ex) {\n                    break;\n                }\n                int curr = wordBbuf.get();\n                if (curr == sig[POS_0]) {\n                    curr = wordBbuf.get();\n                    if (curr == sig[POS_1]) {\n                        curr = wordBbuf.get();\n                        if (curr == sig[POS_2]) {\n                            curr = wordBbuf.get();\n                            if (curr == sig[POS_3]) {\n                                found = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (found) {\n            archive.position(off);\n        }\n        return found;\n    ", "fpath_tuple": ["apache_commons-compress", "commons-compress", "src", "main", "java", "org", "apache", "commons", "compress", "archivers", "zip", "ZipFile.java"], "context_start_lineno": 0, "function_name": "tryToLocateSignature", "left_context": "class ZipFile implements Closeable {\n    /**\n     * Length of the \"Zip64 end of central directory locator\" - which\n     * should be right in front of the \"end of central directory\n     * record\" if one is present at all.\n     */\n    private static final int ZIP64_EOCDL_LENGTH =\n        /* zip64 end of central dir locator sig */ WORD\n        /* number of the disk with the start    */\n        /* start of the zip64 end of            */\n        /* central directory                    */ + WORD\n        /* relative offset of the zip64         */\n        /* end of central directory record      */ + DWORD\n        /* total number of disks                */ + WORD;\n\n    /**\n     * Offset of the field that holds the location of the \"Zip64 end\n     * of central directory record\" inside the \"Zip64 end of central\n     * directory locator\" relative to the start of the \"Zip64 end of\n     * central directory locator\".\n     */\n    private static final int ZIP64_EOCDL_LOCATOR_OFFSET =\n        /* zip64 end of central dir locator sig */ WORD\n        /* number of the disk with the start    */\n        /* start of the zip64 end of            */\n        /* central directory                    */ + WORD;\n\n    /**\n     * Offset of the field that holds the location of the first\n     * central directory entry inside the \"Zip64 end of central\n     * directory record\" relative to the start of the \"Zip64 end of\n     * central directory record\".\n     */\n    private static final int ZIP64_EOCD_CFD_LOCATOR_OFFSET =\n        /* zip64 end of central dir        */\n        /* signature                       */ WORD\n        /* size of zip64 end of central    */\n        /* directory record                */ + DWORD\n        /* version made by                 */ + SHORT\n        /* version needed to extract       */ + SHORT\n        /* number of this disk             */ + WORD\n        /* number of the disk with the     */\n        /* start of the central directory  */ + WORD\n        /* total number of entries in the  */\n        /* central directory on this disk  */ + DWORD\n        /* total number of entries in the  */\n        /* central directory               */ + DWORD\n        /* size of the central directory   */ + DWORD;\n\n    /**\n     * Searches for either the &quot;Zip64 end of central directory\n     * locator&quot; or the &quot;End of central dir record&quot;, parses\n     * it and positions the stream at the first central directory\n     * record.\n     */\n    private void positionAtCentralDirectory()\n        throws IOException {\n        positionAtEndOfCentralDirectoryRecord();\n        boolean found = false;\n        final boolean searchedForZip64EOCD =\n            archive.position() > ZIP64_EOCDL_LENGTH;\n        if (searchedForZip64EOCD) {\n            archive.position(archive.position() - ZIP64_EOCDL_LENGTH);\n            wordBbuf.rewind();\n            IOUtils.readFully(archive, wordBbuf);\n            found = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\n                                  wordBuf);\n        }\n        if (!found) {\n            // not a ZIP64 archive\n            if (searchedForZip64EOCD) {\n                skipBytes(ZIP64_EOCDL_LENGTH - WORD);\n            }\n            positionAtCentralDirectory32();\n        } else {\n            positionAtCentralDirectory64();\n        }\n    }\n\n    /**\n     * Parses the &quot;Zip64 end of central directory locator&quot;,\n     * finds the &quot;Zip64 end of central directory record&quot; using the\n     * parsed information, parses that and positions the stream at the\n     * first central directory record.\n     *\n     * Expects stream to be positioned right behind the &quot;Zip64\n     * end of central directory locator&quot;'s signature.\n     */\n    private void positionAtCentralDirectory64()\n        throws IOException {\n        skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET\n                  - WORD /* signature has already been read */);\n        dwordBbuf.rewind();\n        IOUtils.readFully(archive, dwordBbuf);\n        archive.position(ZipEightByteInteger.getLongValue(dwordBuf));\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (!Arrays.equals(wordBuf, ZipArchiveOutputStream.ZIP64_EOCD_SIG)) {\n            throw new ZipException(\"archive's ZIP64 end of central \"\n                                   + \"directory locator is corrupt.\");\n        }\n        skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n                  - WORD /* signature has already been read */);\n        dwordBbuf.rewind();\n        IOUtils.readFully(archive, dwordBbuf);\n        archive.position(ZipEightByteInteger.getLongValue(dwordBuf));\n    }\n\n    /**\n     * Parses the &quot;End of central dir record&quot; and positions\n     * the stream at the first central directory record.\n     *\n     * Expects stream to be positioned at the beginning of the\n     * &quot;End of central dir record&quot;.\n     */\n    private void positionAtCentralDirectory32()\n        throws IOException {\n        skipBytes(CFD_LOCATOR_OFFSET);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        archive.position(ZipLong.getValue(wordBuf));\n    }\n\n    /**\n     * Searches for the and positions the stream at the start of the\n     * &quot;End of central dir record&quot;.\n     */\n    private void positionAtEndOfCentralDirectoryRecord()\n        throws IOException {\n        final boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\n                                             ZipArchiveOutputStream.EOCD_SIG);\n        if (!found) {\n            throw new ZipException(\"archive is not a ZIP archive\");\n        }\n    }\n\n    /**\n     * Searches the archive backwards from minDistance to maxDistance\n     * for the given signature, positions the RandomaccessFile right\n     * at the signature if it has been found.\n     */\n    private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException {", "right_context": "}\n}", "class_name": "ZipFile", "return_type": "boolean", "parameters": [{"type": "long", "name": "minDistanceFromEnd"}, {"type": "long", "name": "maxDistanceFromEnd"}, {"type": "byte[]", "name": "sig"}]}}
{"prompt": "class JsonWriter implements Closeable, Flushable {\n\n  /*\n   * From RFC 7159, \"All Unicode characters may be placed within the\n   * quotation marks except for the characters that must be escaped:\n   * quotation mark, reverse solidus, and the control characters\n   * (U+0000 through U+001F).\"\n   *\n   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\n   * newline characters. This prevents eval() from failing with a syntax\n   * error. http://code.google.com/p/google-gson/issues/detail?id=341\n   */\n  /**\n   * A string containing a full set of spaces for a single level of\n   * indentation, or null for no pretty printing.\n   */\n  private String indent;\n\n  /**\n   * The name/value separator; either \":\" or \": \".\n   */\n  private String separator = \":\";\n\n  private boolean lenient;\n\n  private boolean htmlSafe;\n\n  private String deferredName;\n\n  private boolean serializeNulls = true;\n\n  /**\n   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n   * For best performance, ensure {@link Writer} is buffered; wrapping in\n   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n   */\n  public JsonWriter(Writer out) {\n    if (out == null) {\n      throw new NullPointerException(\"out == null\");\n    }\n    this.out = out;\n  }\n\n  /**\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   */\n  public final void setIndent(String indent) {\n    if (indent.length() == 0) {\n      this.indent = null;\n      this.separator = \":\";\n    } else {\n      this.indent = indent;\n      this.separator = \": \";\n    }\n  }\n\n  /**\n   * Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Top-level values of any type. With strict writing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this writer has relaxed syntax rules.\n   */\n  public boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Configure this writer to emit JSON that's safe for direct inclusion in HTML\n   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n   * {@code &} and {@code =} before writing them to the stream. Without this\n   * setting, your XML/HTML encoder should replace these characters with the\n   * corresponding escape sequences.\n   */\n  public final void setHtmlSafe(boolean htmlSafe) {\n    this.htmlSafe = htmlSafe;\n  }\n\n  /**\n   * Returns true if this writer writes JSON that's safe for inclusion in HTML\n   * and XML documents.\n   */\n  public final boolean isHtmlSafe() {\n    return htmlSafe;\n  }\n\n  /**\n   * Sets whether object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final void setSerializeNulls(boolean serializeNulls) {\n    this.serializeNulls = serializeNulls;\n  }\n\n  /**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }\n\n  /**\n   * Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginArray() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_ARRAY, \"[\");\n  }\n\n  /**\n   * Ends encoding the current array.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endArray() throws IOException {\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n  }\n\n  /**\n   * Begins encoding a new object. Each call to this method must be paired\n   * with a call to {@link #endObject}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginObject() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_OBJECT, \"{\");\n  }\n\n  /**\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endObject() throws IOException {\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n  }\n\n  /**\n   * Enters a new scope by appending any necessary whitespace and the given\n   * bracket.\n   */\n  private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue();\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }\n\n  /**\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   */\n  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context == nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      stack = newStack;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns the value on the top of the stack.\n   */\n  private int peek() {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    return stack[stackSize - 1];\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(int topOfStack) {\n    stack[stackSize - 1] = topOfStack;\n  }\n\n  /**\n   * Encodes the property name.\n   *\n   * @param name the name of the forthcoming value. May not be null.\n   * @return this writer.\n   */\n  public JsonWriter name(String name) throws IOException {", "metadata": {"defects4j_task_id": "27208dbee52dd2e5e6693b132dc78cdb6e0ecbea5271340c1647d2300560c1a3", "task_id": "google_gson/35", "ground_truth": "\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n  ", "fpath_tuple": ["google_gson", "gson", "gson", "src", "main", "java", "com", "google", "gson", "stream", "JsonWriter.java"], "context_start_lineno": 0, "function_name": "name", "left_context": "class JsonWriter implements Closeable, Flushable {\n\n  /*\n   * From RFC 7159, \"All Unicode characters may be placed within the\n   * quotation marks except for the characters that must be escaped:\n   * quotation mark, reverse solidus, and the control characters\n   * (U+0000 through U+001F).\"\n   *\n   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\n   * newline characters. This prevents eval() from failing with a syntax\n   * error. http://code.google.com/p/google-gson/issues/detail?id=341\n   */\n  /**\n   * A string containing a full set of spaces for a single level of\n   * indentation, or null for no pretty printing.\n   */\n  private String indent;\n\n  /**\n   * The name/value separator; either \":\" or \": \".\n   */\n  private String separator = \":\";\n\n  private boolean lenient;\n\n  private boolean htmlSafe;\n\n  private String deferredName;\n\n  private boolean serializeNulls = true;\n\n  /**\n   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n   * For best performance, ensure {@link Writer} is buffered; wrapping in\n   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n   */\n  public JsonWriter(Writer out) {\n    if (out == null) {\n      throw new NullPointerException(\"out == null\");\n    }\n    this.out = out;\n  }\n\n  /**\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   */\n  public final void setIndent(String indent) {\n    if (indent.length() == 0) {\n      this.indent = null;\n      this.separator = \":\";\n    } else {\n      this.indent = indent;\n      this.separator = \": \";\n    }\n  }\n\n  /**\n   * Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Top-level values of any type. With strict writing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this writer has relaxed syntax rules.\n   */\n  public boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Configure this writer to emit JSON that's safe for direct inclusion in HTML\n   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n   * {@code &} and {@code =} before writing them to the stream. Without this\n   * setting, your XML/HTML encoder should replace these characters with the\n   * corresponding escape sequences.\n   */\n  public final void setHtmlSafe(boolean htmlSafe) {\n    this.htmlSafe = htmlSafe;\n  }\n\n  /**\n   * Returns true if this writer writes JSON that's safe for inclusion in HTML\n   * and XML documents.\n   */\n  public final boolean isHtmlSafe() {\n    return htmlSafe;\n  }\n\n  /**\n   * Sets whether object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final void setSerializeNulls(boolean serializeNulls) {\n    this.serializeNulls = serializeNulls;\n  }\n\n  /**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }\n\n  /**\n   * Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginArray() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_ARRAY, \"[\");\n  }\n\n  /**\n   * Ends encoding the current array.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endArray() throws IOException {\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n  }\n\n  /**\n   * Begins encoding a new object. Each call to this method must be paired\n   * with a call to {@link #endObject}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginObject() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_OBJECT, \"{\");\n  }\n\n  /**\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endObject() throws IOException {\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n  }\n\n  /**\n   * Enters a new scope by appending any necessary whitespace and the given\n   * bracket.\n   */\n  private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue();\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }\n\n  /**\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   */\n  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context == nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      stack = newStack;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns the value on the top of the stack.\n   */\n  private int peek() {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    return stack[stackSize - 1];\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(int topOfStack) {\n    stack[stackSize - 1] = topOfStack;\n  }\n\n  /**\n   * Encodes the property name.\n   *\n   * @param name the name of the forthcoming value. May not be null.\n   * @return this writer.\n   */\n  public JsonWriter name(String name) throws IOException {", "right_context": "}\n}", "class_name": "JsonWriter", "return_type": "JsonWriter", "parameters": [{"type": "String", "name": "name"}]}}
{"prompt": "class JsonReader implements Closeable {\n  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {", "metadata": {"defects4j_task_id": "f626eb1ad88c484d9c12706a361ab97514804f46e2cbdf010c7bce4d926a931a", "task_id": "google_gson/201", "ground_truth": "\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  ", "fpath_tuple": ["google_gson", "gson", "gson", "src", "main", "java", "com", "google", "gson", "stream", "JsonReader.java"], "context_start_lineno": 0, "function_name": "nextName", "left_context": "class JsonReader implements Closeable {\n  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {", "right_context": "}\n\n  static {\n    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\n              \"Expected a name but was \" + reader.peek() + reader.locationString());\n        }\n      }\n    };\n  }\n}", "class_name": "JsonReader", "return_type": "String", "parameters": []}}
{"prompt": "class JsonReader implements Closeable {\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {", "metadata": {"defects4j_task_id": "cf2b525993915d5f4e04cdb23add4f6526bcb362468e602b2c5c8e180e1339ba", "task_id": "google_gson/169", "ground_truth": "\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  ", "fpath_tuple": ["google_gson", "gson", "gson", "src", "main", "java", "com", "google", "gson", "stream", "JsonReader.java"], "context_start_lineno": 0, "function_name": "nextString", "left_context": "class JsonReader implements Closeable {\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {", "right_context": "}\n\n  static {\n    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\n              \"Expected a name but was \" + reader.peek() + reader.locationString());\n        }\n      }\n    };\n  }\n}", "class_name": "JsonReader", "return_type": "String", "parameters": []}}
{"prompt": "class JsonReader implements Closeable {\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {", "metadata": {"defects4j_task_id": "740e573f452923d860eec625b12da9e77b48577a175c44f8b2ac1cede8d9bd00", "task_id": "google_gson/97", "ground_truth": "\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  ", "fpath_tuple": ["google_gson", "gson", "gson", "src", "main", "java", "com", "google", "gson", "stream", "JsonReader.java"], "context_start_lineno": 0, "function_name": "nextBoolean", "left_context": "class JsonReader implements Closeable {\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {", "right_context": "}\n\n  static {\n    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\n              \"Expected a name but was \" + reader.peek() + reader.locationString());\n        }\n      }\n    };\n  }\n}", "class_name": "JsonReader", "return_type": "boolean", "parameters": []}}
{"prompt": "class TypeToken<T> {\n  final Type type;\n  final int hashCode;\n\n  /**\n   * Constructs a new type literal. Derives represented class from type\n   * parameter.\n   *\n   * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n   * parameter in the anonymous class's type hierarchy so we can reconstitute it\n   * at runtime despite erasure.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected TypeToken() {\n    this.type = getSuperclassTypeParameter(getClass());\n    this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\n    this.hashCode = type.hashCode();\n  }\n\n  /**\n   * Unsafe. Constructs a type literal manually.\n   */\n  @SuppressWarnings(\"unchecked\")\n  TypeToken(Type type) {\n    this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\n    this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\n    this.hashCode = this.type.hashCode();\n  }\n\n  /**\n   * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize\n   * canonical form}.\n   */\n  static Type getSuperclassTypeParameter(Class<?> subclass) {\n    Type superclass = subclass.getGenericSuperclass();\n    if (superclass instanceof Class) {\n      throw new RuntimeException(\"Missing type parameter.\");\n    }\n    ParameterizedType parameterized = (ParameterizedType) superclass;\n    return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n  }\n\n  /**\n   * Returns the raw (non-generic) type for this type.\n   */\n  public final Class<? super T> getRawType() {\n    return rawType;\n  }\n\n  /**\n   * Gets underlying {@code Type} instance.\n   */\n  public final Type getType() {\n    return type;\n  }\n\n  /**\n   * Check if this type is assignable from the given class object.\n   *\n   * @deprecated this implementation may be inconsistent with javac for types\n   *     with wildcards.\n   */\n  @Deprecated\n  public boolean isAssignableFrom(Class<?> cls) {\n    return isAssignableFrom((Type) cls);\n  }\n\n  /**\n   * Check if this type is assignable from the given Type.\n   *\n   * @deprecated this implementation may be inconsistent with javac for types\n   *     with wildcards.\n   */\n  @Deprecated\n  public boolean isAssignableFrom(Type from) {\n    if (from == null) {\n      return false;\n    }\n\n    if (type.equals(from)) {\n      return true;\n    }\n\n    if (type instanceof Class<?>) {\n      return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n    } else if (type instanceof ParameterizedType) {\n      return isAssignableFrom(from, (ParameterizedType) type,\n          new HashMap<String, Type>());\n    } else if (type instanceof GenericArrayType) {\n      return rawType.isAssignableFrom($Gson$Types.getRawType(from))\n          && isAssignableFrom(from, (GenericArrayType) type);\n    } else {\n      throw buildUnexpectedTypeError(\n          type, Class.class, ParameterizedType.class, GenericArrayType.class);\n    }\n  }\n\n  /**\n   * Check if this type is assignable from the given type token.\n   *\n   * @deprecated this implementation may be inconsistent with javac for types\n   *     with wildcards.\n   */\n  @Deprecated\n  public boolean isAssignableFrom(TypeToken<?> token) {\n    return isAssignableFrom(token.getType());\n  }\n\n  /**\n   * Private helper function that performs some assignability checks for\n   * the provided GenericArrayType.\n   */\n  private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n    Type toGenericComponentType = to.getGenericComponentType();\n    if (toGenericComponentType instanceof ParameterizedType) {\n      Type t = from;\n      if (from instanceof GenericArrayType) {\n        t = ((GenericArrayType) from).getGenericComponentType();\n      } else if (from instanceof Class<?>) {\n        Class<?> classType = (Class<?>) from;\n        while (classType.isArray()) {\n          classType = classType.getComponentType();\n        }\n        t = classType;\n      }\n      return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n          new HashMap<String, Type>());\n    }\n    // No generic defined on \"to\"; therefore, return true and let other\n    // checks determine assignability\n    return true;\n  }\n\n  /**\n   * Private recursive helper function to actually do the type-safe checking\n   * of assignability.\n   */\n  private static boolean isAssignableFrom(Type from, ParameterizedType to,\n      Map<String, Type> typeVarMap) {\n\n    if (from == null) {\n      return false;\n    }\n\n    if (to.equals(from)) {\n      return true;\n    }\n\n    // First figure out the class and any type information.\n    Class<?> clazz = $Gson$Types.getRawType(from);\n    ParameterizedType ptype = null;\n    if (from instanceof ParameterizedType) {\n      ptype = (ParameterizedType) from;\n    }\n\n    // Load up parameterized variable info if it was parameterized.\n    if (ptype != null) {\n      Type[] tArgs = ptype.getActualTypeArguments();\n      TypeVariable<?>[] tParams = clazz.getTypeParameters();\n      for (int i = 0; i < tArgs.length; i++) {\n        Type arg = tArgs[i];\n        TypeVariable<?> var = tParams[i];\n        while (arg instanceof TypeVariable<?>) {\n          TypeVariable<?> v = (TypeVariable<?>) arg;\n          arg = typeVarMap.get(v.getName());\n        }\n        typeVarMap.put(var.getName(), arg);\n      }\n\n      // check if they are equivalent under our current mapping.\n      if (typeEquals(ptype, to, typeVarMap)) {\n        return true;\n      }\n    }\n\n    for (Type itype : clazz.getGenericInterfaces()) {\n      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n        return true;\n      }\n    }\n\n    // Interfaces didn't work, try the superclass.\n    Type sType = clazz.getGenericSuperclass();\n    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n  }\n\n  /**\n   * Checks if two parameterized types are exactly equal, under the variable\n   * replacement described in the typeVarMap.\n   */\n  private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap) {", "metadata": {"defects4j_task_id": "a9b940302be89baa98bf1b2352fbc69fd296f74deb1b13d9e8bda1442e1a7f41", "task_id": "google_gson/143", "ground_truth": "\n    if (from.getRawType().equals(to.getRawType())) {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      for (int i = 0; i < fromArgs.length; i++) {\n        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  ", "fpath_tuple": ["google_gson", "gson", "gson", "src", "main", "java", "com", "google", "gson", "reflect", "TypeToken.java"], "context_start_lineno": 0, "function_name": "typeEquals", "left_context": "class TypeToken<T> {\n  final Type type;\n  final int hashCode;\n\n  /**\n   * Constructs a new type literal. Derives represented class from type\n   * parameter.\n   *\n   * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n   * parameter in the anonymous class's type hierarchy so we can reconstitute it\n   * at runtime despite erasure.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected TypeToken() {\n    this.type = getSuperclassTypeParameter(getClass());\n    this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\n    this.hashCode = type.hashCode();\n  }\n\n  /**\n   * Unsafe. Constructs a type literal manually.\n   */\n  @SuppressWarnings(\"unchecked\")\n  TypeToken(Type type) {\n    this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\n    this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\n    this.hashCode = this.type.hashCode();\n  }\n\n  /**\n   * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize\n   * canonical form}.\n   */\n  static Type getSuperclassTypeParameter(Class<?> subclass) {\n    Type superclass = subclass.getGenericSuperclass();\n    if (superclass instanceof Class) {\n      throw new RuntimeException(\"Missing type parameter.\");\n    }\n    ParameterizedType parameterized = (ParameterizedType) superclass;\n    return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n  }\n\n  /**\n   * Returns the raw (non-generic) type for this type.\n   */\n  public final Class<? super T> getRawType() {\n    return rawType;\n  }\n\n  /**\n   * Gets underlying {@code Type} instance.\n   */\n  public final Type getType() {\n    return type;\n  }\n\n  /**\n   * Check if this type is assignable from the given class object.\n   *\n   * @deprecated this implementation may be inconsistent with javac for types\n   *     with wildcards.\n   */\n  @Deprecated\n  public boolean isAssignableFrom(Class<?> cls) {\n    return isAssignableFrom((Type) cls);\n  }\n\n  /**\n   * Check if this type is assignable from the given Type.\n   *\n   * @deprecated this implementation may be inconsistent with javac for types\n   *     with wildcards.\n   */\n  @Deprecated\n  public boolean isAssignableFrom(Type from) {\n    if (from == null) {\n      return false;\n    }\n\n    if (type.equals(from)) {\n      return true;\n    }\n\n    if (type instanceof Class<?>) {\n      return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n    } else if (type instanceof ParameterizedType) {\n      return isAssignableFrom(from, (ParameterizedType) type,\n          new HashMap<String, Type>());\n    } else if (type instanceof GenericArrayType) {\n      return rawType.isAssignableFrom($Gson$Types.getRawType(from))\n          && isAssignableFrom(from, (GenericArrayType) type);\n    } else {\n      throw buildUnexpectedTypeError(\n          type, Class.class, ParameterizedType.class, GenericArrayType.class);\n    }\n  }\n\n  /**\n   * Check if this type is assignable from the given type token.\n   *\n   * @deprecated this implementation may be inconsistent with javac for types\n   *     with wildcards.\n   */\n  @Deprecated\n  public boolean isAssignableFrom(TypeToken<?> token) {\n    return isAssignableFrom(token.getType());\n  }\n\n  /**\n   * Private helper function that performs some assignability checks for\n   * the provided GenericArrayType.\n   */\n  private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n    Type toGenericComponentType = to.getGenericComponentType();\n    if (toGenericComponentType instanceof ParameterizedType) {\n      Type t = from;\n      if (from instanceof GenericArrayType) {\n        t = ((GenericArrayType) from).getGenericComponentType();\n      } else if (from instanceof Class<?>) {\n        Class<?> classType = (Class<?>) from;\n        while (classType.isArray()) {\n          classType = classType.getComponentType();\n        }\n        t = classType;\n      }\n      return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n          new HashMap<String, Type>());\n    }\n    // No generic defined on \"to\"; therefore, return true and let other\n    // checks determine assignability\n    return true;\n  }\n\n  /**\n   * Private recursive helper function to actually do the type-safe checking\n   * of assignability.\n   */\n  private static boolean isAssignableFrom(Type from, ParameterizedType to,\n      Map<String, Type> typeVarMap) {\n\n    if (from == null) {\n      return false;\n    }\n\n    if (to.equals(from)) {\n      return true;\n    }\n\n    // First figure out the class and any type information.\n    Class<?> clazz = $Gson$Types.getRawType(from);\n    ParameterizedType ptype = null;\n    if (from instanceof ParameterizedType) {\n      ptype = (ParameterizedType) from;\n    }\n\n    // Load up parameterized variable info if it was parameterized.\n    if (ptype != null) {\n      Type[] tArgs = ptype.getActualTypeArguments();\n      TypeVariable<?>[] tParams = clazz.getTypeParameters();\n      for (int i = 0; i < tArgs.length; i++) {\n        Type arg = tArgs[i];\n        TypeVariable<?> var = tParams[i];\n        while (arg instanceof TypeVariable<?>) {\n          TypeVariable<?> v = (TypeVariable<?>) arg;\n          arg = typeVarMap.get(v.getName());\n        }\n        typeVarMap.put(var.getName(), arg);\n      }\n\n      // check if they are equivalent under our current mapping.\n      if (typeEquals(ptype, to, typeVarMap)) {\n        return true;\n      }\n    }\n\n    for (Type itype : clazz.getGenericInterfaces()) {\n      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n        return true;\n      }\n    }\n\n    // Interfaces didn't work, try the superclass.\n    Type sType = clazz.getGenericSuperclass();\n    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n  }\n\n  /**\n   * Checks if two parameterized types are exactly equal, under the variable\n   * replacement described in the typeVarMap.\n   */\n  private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap) {", "right_context": "}\n}", "class_name": "TypeToken", "return_type": "boolean", "parameters": [{"type": "ParameterizedType", "name": "from"}, {"type": "ParameterizedType", "name": "to"}, {"type": "Map<String,Type>", "name": "typeVarMap"}]}}
{"prompt": "class SimplePathInterpreter {\n\n    // Because of the complexity caused by the variety of situations\n    // that need to be addressed by this class, we attempt to break up\n    // the class into individual methods addressing those situations\n    // individually.  The names of the methods are supposed to\n    // give brief descriptions of those situations.\n\n    /**\n     * We have a step that starts with a property owner (bean, map, etc) and has\n     * no predicates.  The name test of the step may map to a scalar property\n     * or to a collection.  If it is a collection, we should apply the tail of\n     * the path to each element until we find a match. If we don't find\n     * a perfect match, we should return the \"best quality\" pointer, which\n     * has the longest chain of steps mapping to existing nodes and the shortes\n     * tail of Null* pointers.\n     * @param context evaluation context\n     * @param parentPointer property owner pointer\n     * @param steps path steps\n     * @param currentStep step number\n     * @return NodePointer\n     */\n    private static NodePointer doStepNoPredicatesPropertyOwner(\n                EvalContext context, PropertyOwnerPointer parentPointer,\n                Step[] steps, int currentStep) {\n        Step step = steps[currentStep];\n        NodePointer childPointer =\n            createChildPointerForStep(parentPointer, step);\n\n        if (childPointer == null) {\n            return null;\n        }\n        if (!childPointer.isActual()) {\n            // The property does not exist - create a null pointer.\n            return createNullPointer(\n                context,\n                parentPointer,\n                steps,\n                currentStep);\n        }\n        if (currentStep == steps.length - 1) {\n            // If this is the last step - we are done, we found it\n            return childPointer;\n        }\n        if (childPointer.isCollection()) {\n            // Iterate over all values and\n            // execute remaining steps for each node,\n            // looking for the best quality match\n            int bestQuality = 0;\n            childPointer = (NodePointer) childPointer.clone();\n            NodePointer bestMatch = null;\n            int count = childPointer.getLength();\n            for (int i = 0; i < count; i++) {\n                childPointer.setIndex(i);\n                NodePointer pointer =\n                    doStep(context, childPointer, steps, currentStep + 1);\n                int quality = computeQuality(pointer);\n                if (quality == PERFECT_MATCH) {\n                    return pointer;\n                }\n                else if (quality > bestQuality) {\n                    bestQuality = quality;\n                    bestMatch = (NodePointer) pointer.clone();\n                }\n            }\n            if (bestMatch != null) {\n                return bestMatch;\n            }\n            // This step did not find anything - return a null pointer\n            return createNullPointer(context, childPointer, steps, currentStep);\n        }\n        // Evaluate subsequent steps\n        return doStep(context, childPointer, steps, currentStep + 1);\n    }\n\n    /**\n     * A path that starts with a standard InfoSet node (e.g. DOM Node) and\n     * has no predicates.  Get a child iterator and apply the tail of\n     * the path to each element until we find a match. If we don't find\n     * a perfect match, we should return the \"best quality\" pointer, which\n     * has the longest chain of steps mapping to existing nodes and the shortes\n     * tail of Null* pointers.\n     * @param context evaluation context\n     * @param parentPointer parent pointer\n     * @param steps path steps\n     * @param currentStep step number\n     * @return NodePointer\n     */\n    private static NodePointer doStepNoPredicatesStandard(\n                EvalContext context, NodePointer parentPointer,\n                Step[] steps, int currentStep) {\n        Step step = steps[currentStep];\n\n        if (step.getAxis() == Compiler.AXIS_SELF) {\n            return doStep(context, parentPointer, steps, currentStep + 1);\n        }\n\n        int bestQuality = 0;\n        NodePointer bestMatch = null;\n        NodeIterator it = getNodeIterator(context, parentPointer, step);\n        if (it != null) {\n            for (int i = 1; it.setPosition(i); i++) {\n                NodePointer childPointer = it.getNodePointer();\n                if (steps.length == currentStep + 1) {\n                    // If this is the last step - we are done, we found it\n                    return childPointer;\n                }\n                NodePointer pointer = doStep(\n                        context, childPointer, steps, currentStep + 1);\n                int quality = computeQuality(pointer);\n                if (quality == PERFECT_MATCH) {\n                    return pointer;\n                }\n                if (quality > bestQuality) {\n                    bestQuality = quality;\n                    bestMatch = (NodePointer) pointer.clone();\n                }\n            }\n        }\n        return bestMatch != null ? bestMatch\n                : createNullPointer(context, parentPointer, steps, currentStep);\n    }\n\n    /**\n     * A path that starts with a property owner. The method evaluates\n     * the first predicate in a special way and then forwards to\n     * a general predicate processing method.\n     * @param context evaluation context\n     * @param parentPointer parent pointer\n     * @param steps path steps\n     * @param currentStep step number\n     * @return NodePointer\n     */\n    private static NodePointer doStepPredicatesPropertyOwner(\n            EvalContext context, PropertyOwnerPointer parentPointer,\n            Step[] steps, int currentStep) {\n        Step step = steps[currentStep];\n        Expression[] predicates = step.getPredicates();\n\n        NodePointer childPointer =\n            createChildPointerForStep(parentPointer, step);\n        if (!childPointer.isActual()) {\n            // Property does not exist - return a null pointer\n            return createNullPointer(\n                context,\n                parentPointer,\n                steps,\n                currentStep);\n        }\n\n        // Evaluate predicates\n        return doPredicate(\n            context,\n            childPointer,\n            steps,\n            currentStep,\n            predicates,\n            0);\n    }\n\n    /**\n     * Create the child pointer for a given step.\n     * @param parentPointer parent pointer\n     * @param step associated step\n     * @return NodePointer\n     */\n    private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step) {", "metadata": {"defects4j_task_id": "4c89b33db0966a39ba47b31d4e480f0389cd3065fdefb93cbb94192d08f150a3", "task_id": "apache_commons-jxpath/69", "ground_truth": "\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {\n            QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n            if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) {\n                return new LangAttributePointer(parentPointer);\n            }\n            if (parentPointer.isValidProperty(name)) {\n                NodePointer childPointer = parentPointer.getPropertyPointer();\n                ((PropertyPointer) childPointer).setPropertyName(\n                        name.toString());\n                childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);\n                return childPointer;\n            }\n            //invalid property gets nothing, not even a NullPointer\n            return null;\n        }\n        return parentPointer;\n    ", "fpath_tuple": ["apache_commons-jxpath", "commons-jxpath", "src", "java", "org", "apache", "commons", "jxpath", "ri", "axes", "SimplePathInterpreter.java"], "context_start_lineno": 0, "function_name": "createChildPointerForStep", "left_context": "class SimplePathInterpreter {\n\n    // Because of the complexity caused by the variety of situations\n    // that need to be addressed by this class, we attempt to break up\n    // the class into individual methods addressing those situations\n    // individually.  The names of the methods are supposed to\n    // give brief descriptions of those situations.\n\n    /**\n     * We have a step that starts with a property owner (bean, map, etc) and has\n     * no predicates.  The name test of the step may map to a scalar property\n     * or to a collection.  If it is a collection, we should apply the tail of\n     * the path to each element until we find a match. If we don't find\n     * a perfect match, we should return the \"best quality\" pointer, which\n     * has the longest chain of steps mapping to existing nodes and the shortes\n     * tail of Null* pointers.\n     * @param context evaluation context\n     * @param parentPointer property owner pointer\n     * @param steps path steps\n     * @param currentStep step number\n     * @return NodePointer\n     */\n    private static NodePointer doStepNoPredicatesPropertyOwner(\n                EvalContext context, PropertyOwnerPointer parentPointer,\n                Step[] steps, int currentStep) {\n        Step step = steps[currentStep];\n        NodePointer childPointer =\n            createChildPointerForStep(parentPointer, step);\n\n        if (childPointer == null) {\n            return null;\n        }\n        if (!childPointer.isActual()) {\n            // The property does not exist - create a null pointer.\n            return createNullPointer(\n                context,\n                parentPointer,\n                steps,\n                currentStep);\n        }\n        if (currentStep == steps.length - 1) {\n            // If this is the last step - we are done, we found it\n            return childPointer;\n        }\n        if (childPointer.isCollection()) {\n            // Iterate over all values and\n            // execute remaining steps for each node,\n            // looking for the best quality match\n            int bestQuality = 0;\n            childPointer = (NodePointer) childPointer.clone();\n            NodePointer bestMatch = null;\n            int count = childPointer.getLength();\n            for (int i = 0; i < count; i++) {\n                childPointer.setIndex(i);\n                NodePointer pointer =\n                    doStep(context, childPointer, steps, currentStep + 1);\n                int quality = computeQuality(pointer);\n                if (quality == PERFECT_MATCH) {\n                    return pointer;\n                }\n                else if (quality > bestQuality) {\n                    bestQuality = quality;\n                    bestMatch = (NodePointer) pointer.clone();\n                }\n            }\n            if (bestMatch != null) {\n                return bestMatch;\n            }\n            // This step did not find anything - return a null pointer\n            return createNullPointer(context, childPointer, steps, currentStep);\n        }\n        // Evaluate subsequent steps\n        return doStep(context, childPointer, steps, currentStep + 1);\n    }\n\n    /**\n     * A path that starts with a standard InfoSet node (e.g. DOM Node) and\n     * has no predicates.  Get a child iterator and apply the tail of\n     * the path to each element until we find a match. If we don't find\n     * a perfect match, we should return the \"best quality\" pointer, which\n     * has the longest chain of steps mapping to existing nodes and the shortes\n     * tail of Null* pointers.\n     * @param context evaluation context\n     * @param parentPointer parent pointer\n     * @param steps path steps\n     * @param currentStep step number\n     * @return NodePointer\n     */\n    private static NodePointer doStepNoPredicatesStandard(\n                EvalContext context, NodePointer parentPointer,\n                Step[] steps, int currentStep) {\n        Step step = steps[currentStep];\n\n        if (step.getAxis() == Compiler.AXIS_SELF) {\n            return doStep(context, parentPointer, steps, currentStep + 1);\n        }\n\n        int bestQuality = 0;\n        NodePointer bestMatch = null;\n        NodeIterator it = getNodeIterator(context, parentPointer, step);\n        if (it != null) {\n            for (int i = 1; it.setPosition(i); i++) {\n                NodePointer childPointer = it.getNodePointer();\n                if (steps.length == currentStep + 1) {\n                    // If this is the last step - we are done, we found it\n                    return childPointer;\n                }\n                NodePointer pointer = doStep(\n                        context, childPointer, steps, currentStep + 1);\n                int quality = computeQuality(pointer);\n                if (quality == PERFECT_MATCH) {\n                    return pointer;\n                }\n                if (quality > bestQuality) {\n                    bestQuality = quality;\n                    bestMatch = (NodePointer) pointer.clone();\n                }\n            }\n        }\n        return bestMatch != null ? bestMatch\n                : createNullPointer(context, parentPointer, steps, currentStep);\n    }\n\n    /**\n     * A path that starts with a property owner. The method evaluates\n     * the first predicate in a special way and then forwards to\n     * a general predicate processing method.\n     * @param context evaluation context\n     * @param parentPointer parent pointer\n     * @param steps path steps\n     * @param currentStep step number\n     * @return NodePointer\n     */\n    private static NodePointer doStepPredicatesPropertyOwner(\n            EvalContext context, PropertyOwnerPointer parentPointer,\n            Step[] steps, int currentStep) {\n        Step step = steps[currentStep];\n        Expression[] predicates = step.getPredicates();\n\n        NodePointer childPointer =\n            createChildPointerForStep(parentPointer, step);\n        if (!childPointer.isActual()) {\n            // Property does not exist - return a null pointer\n            return createNullPointer(\n                context,\n                parentPointer,\n                steps,\n                currentStep);\n        }\n\n        // Evaluate predicates\n        return doPredicate(\n            context,\n            childPointer,\n            steps,\n            currentStep,\n            predicates,\n            0);\n    }\n\n    /**\n     * Create the child pointer for a given step.\n     * @param parentPointer parent pointer\n     * @param step associated step\n     * @return NodePointer\n     */\n    private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step) {", "right_context": "}\n}", "class_name": "SimplePathInterpreter", "return_type": "NodePointer", "parameters": [{"type": "PropertyOwnerPointer", "name": "parentPointer"}, {"type": "Step", "name": "step"}]}}
{"prompt": "class Lexer implements Closeable {\n\n    private static final String LF_STRING = Character.toString(Constants.LF);\n\n    /**\n     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char delimiter;\n    private final char escape;\n    private final char quoteChar;\n    private final char commentStart;\n\n    private final boolean ignoreSurroundingSpaces;\n    private final boolean ignoreEmptyLines;\n\n    /** The input stream */\n    private final ExtendedBufferedReader reader;\n    private String firstEol;\n\n    String getFirstEol(){\n        return firstEol;\n    }\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n        this.reader = reader;\n        this.delimiter = format.getDelimiter();\n        this.escape = mapNullToDisabled(format.getEscapeCharacter());\n        this.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\n        this.commentStart = mapNullToDisabled(format.getCommentMarker());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n    }\n\n    /**\n     * Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token\n     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n     * @return the next token found\n     * @throws java.io.IOException\n     *             on stream access error\n     */\n    Token nextToken(final Token token) throws IOException {\n\n        // get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n\n        // read the next char and set eol\n        int c = reader.read();\n        /*\n         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n         * - they are equivalent here.\n         */\n        boolean eol = readEndOfLine(c);\n\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol && isStartOfLine(lastChar)) {\n                // go on char ahead ...\n                lastChar = c;\n                c = reader.read();\n                eol = readEndOfLine(c);\n                // reached end of file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type = EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // did we reach eof during the last iteration already ? EOF\n        if (isEndOfFile(lastChar) || !isDelimiter(lastChar) && isEndOfFile(c)) {\n            token.type = EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n            final String line = reader.readLine();\n            if (line == null) {\n                token.type = EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n            final String comment = line.trim();\n            token.content.append(comment);\n            token.type = COMMENT;\n            return token;\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n\n    /**\n     * Parses a simple token.\n     * <p/>\n     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>end of line has been reached (EORECORD)</li>\n     * <li>end of stream has been reached (EOF)</li>\n     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token\n     *            the current token\n     * @param ch\n     *            the current character\n     * @return the filled token\n     * @throws IOException\n     *             on stream access error\n     */\n    private Token parseSimpleToken(final Token token, int ch) throws IOException {", "metadata": {"defects4j_task_id": "7dad4cd9ee0d3fb88dee0dabe36be516c9a3158a869f27ed05ae2f3885a1f616", "task_id": "apache_commons-csv/104", "ground_truth": "\n        // Faster to use while(true)+break than while(token.type == INVALID)\n        while (true) {\n            if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                break;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                break;\n            } else if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n                ch = reader.read(); // continue\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read(); // continue\n            }\n        }\n\n        if (ignoreSurroundingSpaces) {\n            trimTrailingSpaces(token.content);\n        }\n\n        return token;\n    ", "fpath_tuple": ["apache_commons-csv", "commons-csv", "src", "main", "java", "org", "apache", "commons", "csv", "Lexer.java"], "context_start_lineno": 0, "function_name": "parseSimpleToken", "left_context": "class Lexer implements Closeable {\n\n    private static final String LF_STRING = Character.toString(Constants.LF);\n\n    /**\n     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char delimiter;\n    private final char escape;\n    private final char quoteChar;\n    private final char commentStart;\n\n    private final boolean ignoreSurroundingSpaces;\n    private final boolean ignoreEmptyLines;\n\n    /** The input stream */\n    private final ExtendedBufferedReader reader;\n    private String firstEol;\n\n    String getFirstEol(){\n        return firstEol;\n    }\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n        this.reader = reader;\n        this.delimiter = format.getDelimiter();\n        this.escape = mapNullToDisabled(format.getEscapeCharacter());\n        this.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\n        this.commentStart = mapNullToDisabled(format.getCommentMarker());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n    }\n\n    /**\n     * Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token\n     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n     * @return the next token found\n     * @throws java.io.IOException\n     *             on stream access error\n     */\n    Token nextToken(final Token token) throws IOException {\n\n        // get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n\n        // read the next char and set eol\n        int c = reader.read();\n        /*\n         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n         * - they are equivalent here.\n         */\n        boolean eol = readEndOfLine(c);\n\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol && isStartOfLine(lastChar)) {\n                // go on char ahead ...\n                lastChar = c;\n                c = reader.read();\n                eol = readEndOfLine(c);\n                // reached end of file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type = EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // did we reach eof during the last iteration already ? EOF\n        if (isEndOfFile(lastChar) || !isDelimiter(lastChar) && isEndOfFile(c)) {\n            token.type = EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n            final String line = reader.readLine();\n            if (line == null) {\n                token.type = EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n            final String comment = line.trim();\n            token.content.append(comment);\n            token.type = COMMENT;\n            return token;\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n\n    /**\n     * Parses a simple token.\n     * <p/>\n     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>end of line has been reached (EORECORD)</li>\n     * <li>end of stream has been reached (EOF)</li>\n     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token\n     *            the current token\n     * @param ch\n     *            the current character\n     * @return the filled token\n     * @throws IOException\n     *             on stream access error\n     */\n    private Token parseSimpleToken(final Token token, int ch) throws IOException {", "right_context": "}\n}", "class_name": "Lexer", "return_type": "Token", "parameters": [{"type": "Token", "name": "token"}, {"type": "int", "name": "ch"}]}}
